#define DYN_MULTINSTANCE 1 
#include "dsmodel_fmu.h" 
#include "dsutil.h" 
#if defined(FMU_SOURCE_CODE_EXPORT)
#define DYMOSIM_RT_IMP
#endif
#ifdef DYMOSIM_RT_IMP
/*
 * Copyright (C) 1997-2001 Dynasim AB.
 * All rights reserved.
 *
 */

#if defined(DYMOLA_DSPACE)
/* Realtime compilation. DB 1998-10-05 */
#define NO_FILE
#include <dsdefs.h>
#else
#include <stdio.h>
#endif
#include "assumption.h"

#include <stdlib.h>
#include <errno.h> 
#include <string.h>
#include <ctype.h>
#include <math.h>
#include "f2c.h"
#include "amat.h"
#include "float.h"
#if !defined(MOTIF)
#include "sprwat.h"
#endif
#include "localeless.h"

#if defined(DYMOLAB) || defined(OPENGL)
extern int maxRows();
#else
static integer maxRows() {return 0;}
#endif
#if !defined(NO_FILE) && !defined(DYMOLAB) && !defined(DYMOSIM) && !defined(FMU_SOURCE_CODE_EXPORT) && !defined(Matlab5) && !defined(Matlab51) && !defined(Matlab4)
#include "supportunicodefiles.h"
#endif

#define ALLOW_REOPEN
#ifndef LIBDS_DLL
#define NAMATERROR 1500
DYMOLA_STATIC char amatError[NAMATERROR] = { "No message." };
DYMOLA_STATIC char* amatErrorFunction() {
	return amatError;
}
                                  /* utility storage on which a message     */
                                  /* may be placed                          */
#endif


#if !defined(NO_FILE) || defined(DYM2CCUR)

#define RET_MZERO 1
#define RET_REQ   2
#define RET_EOF   3
#define RET_ERR   4

static int amatGetCHeader (AmatGetFile *file, Amatrix *matrix, Amatrix matrixReq);

static int amatGetFHeader (AmatGetFile *file, Amatrix *matrix, char name[], integer lname);
static int amatGetFMatrix (AmatGetFile *file, Amatrix *matrix);
static int amatGetFNMatrix(AmatGetFile *file, Amatrix *matrix);
static int amatGetFText   (AmatGetFile *file, Amatrix *matrix);

static int amatGetBHeader (AmatGetFile *file, Amatrix *matrix, char name[], integer lname, int *prec);
static int amatGetBMatrix (AmatGetFile *file, Amatrix *matrix, AmatType typeOnFile, int prec,int removeSpace);
static int amatGetBIMatrix(AmatGetFile *file, Amatrix *matrix);
static int amatGetBRMatrix(AmatGetFile *file, Amatrix *matrix);
static int amatGetBDMatrix(AmatGetFile *file, Amatrix *matrix);
static int amatGetBText   (AmatGetFile *file, Amatrix *matrix, int prec,int removeSpace);

DYMOLA_STATIC int (*amatStopRequest)(void)=0;
static int amatGetSkip    (AmatGetFile *file);


/* Error messages */
   static const char *const amatg_table[] = {
      /* 0 */   "Error reading matrix header from file \"%.400s\":\n%.400s\n"
      /* 1 */  ,"Wrong row dimension (= %d) of matrix \"%.400s\" on file \"%.400s\".\n"
                "Dimension must be >= 0.\n"
      /* 2 */  ,"Wrong column dimension (= %d) of matrix \"%.400s\" on file \"%.400s\".\n" 
                "Dimension must be >= 0.\n"
      /* 3 */  ,"Wrong precision flag (= %d) of numeric matrix \"%.400s\" on file \"%.400s\"\n"
                "Flag must be 0 (= 64-bit) or 1 (32-bit).\n"
      /* 4 */  ,"Wrong type flag (= %d) of matrix \"%.400s\" on file \"%.400s\".\n"
                "The type flag must be 0 (= numeric matrix) or 1 (= character matrix).\n"
      /* 5 */  ,"Error when reading numeric matrix \"%.400s(%d,%d)\" from file\n"
                "\"%.400s\", since it is not possible to allocate storage for\n"
                "%d numeric elements.\n"
      /* 6 */  ,"Error when reading numeric data of matrix \"%.400s(%d,%d)\" from file\n"
                "\"%.400s\"\n"
      /* 7 */  ,"Not possible to open file \"%.400s\": %.400s\n"
      /* 8 */  ,"Wrong precision flag (= %d) of character matrix \"%.400s(%d,%d)\"\n"
                "on file \"%.400s\".\n"
                "Flag must be 0 (= 64-bit) or 5 (= 8-bit unsigned integer).\n"
     /*  9 */  ,"Error reading first character from file \"%.400s\":\n%.400s\n"
     /* 10 */  ,"Error should never occur when reading file \"%.400s\"\n"
                "(FileFormat = %d).\n"
     /* 11 */  ,"Error should never occur when reading file \"%.400s\"\n"
                "(matrix.type = %d).\n"
     /* 12 */  ,"Wrong error number\n"
     /* 13 */  ,"Error when reading text matrix \"%.400s(%d,%d)\" from file \"%.400s\",\n"
                "since it is not possible to allocate storage for\n"
                "%d characters.\n"
     /* 14 */  ,"Error reading data of text matrix \"%.40s(%d,%d)\" from file \"%.400s\":\n"
                "%.400s\n"
     /* 15 */  ,"Not possible to allocate enough storage in order to open\n"
                "file \"%.400s\" for reading of matrices:\n%.400s\n"
     /* 16 */  ,"Not possible to read matrices from file \"%.400s\",\n"
                "because the version number  (= \"%.400s\") does not correspond to\n"
                "the required version number (= \"%.400s\").\n"
                "Note, that the version number is stored in the second row\n"
                "of the first matrix \"Aclass\" on file.\n"
     /* 17 */  ,"Not possible to read matrices from file \"%.400s\",\n"
                "because matrix \"Aclass\" has less than 3 rows.\n"
                "(in the first row the class-name, in the second row\n"
                "the version-number and in the third row the description text\n"
                "must be stored)\n"
     /* 18 */  ,"Error when reading matrix from file \"%.400s\",\n"
                "because it is not possible to allocate storage for\n"
                "the matrix name (length = %d)\n:%.400s\n"
     /* 19 */  ,"Not possible to read matrices from file \"%.400s\",\n"
                "because the class name (= \"%.400s\") does not correspond to\n"
                "the required class name (= \"%.400s\").\n"
                "Note, that the class name is stored in the first row\n"
                "of the first matrix \"Aclass\" on file.\n"
     /* 20 */  ,"Cannot read matrix from file \"%.400s\".\n"
	            "The file has incorrect format (note that binary files must be saved with '-v4' in MATLAB).\n"
     /* 21 */  ,"Error reading format and version information in first line of \n"
                "file \"%.400s\": \"#%.400s\" expected, but \"#%c\" found.\n"
     /* 22 */  ,"Error scanning the following declaration on file \"%.400s\":\n"
                "%.400s"
                "Expected is: <type> <name> (<row_dimension>, <column_dimension>)\n"
                "where <type> is \"integer\", \"real\", \"double\" or \"char\" and\n"
                "<name> is the name of the matrix.\n"
     /* 23 */  ,"Not possible to allocate enough storage in order to read\n"
                "matrix from file \"%.400s\":\n%.400s\n"
     /* 24 */  ,"Error scanning the following declaration on file \"%.400s\":\n"
                "%.400s"
                "Name of matrix is wrong, should be \"%.400s\".\n"
     /* 25 */  ,"Error when reading matrix \"%.400s(%d,%d)\" from file \"%.400s\",\n"
                "because matrix should be of type \"integer\", \"real\" or \"double\"\n"
                "and not of type \"%.400s\".\n"
     /* 26 */  ,"Error when reading matrix \"%.400s(%d,%d)\" from file \"%.400s\",\n"
                "because matrix should be of type \"char\" and not of type \"%.400s\".\n"
     /* 27 */  ,"Error when reading matrix \"%.400s(%d,%d)\" from file \"%.400s\",\n"
                "because row dimension = %d required.\n"
     /* 28 */  ,"Error when reading matrix \"%.400s(%d,%d)\" from file \"%.400s\",\n"
                "because column dimension = %d required.\n"
     /* 29 */  ,"Error when reading matrix \"%.400s(%d,%d)\" from file \"%.400s\",\n"
                "because number of matrix elements is zero.\n"
     /* 30 */  ,"Error should never occur when reading matrix \"%.400s(%d,%d)\"\n"
                "from file \"%.400s\" (matrix->type = %d)\n"
     /* 31 */  ,"Error when reading matrix \"%.400s\" from file \"%.400s\",\n"
                "because matrix-name = \"%.400s\" required.\n"
     /* 32 */  ,"Programming error when reading matrix \"%.400s(%d,%d)\" from file \"%.400s\".\n"
                "Function amatGetMatrix is called with storage supplied for the\n"
                "matrix data (matrix.data != NULL), but row dimension, column dimension\n"
                "and matrix type are not all predefined\n"
                "(matrix.nrow = %d, matrix.ncol = %d, matrix.type = %.400s)\n"
     /* 33 */  ,"Programming error detected when reading file \"%.400s\":\n"
                "Function amatReadAll is called, without providing storage for\n"
                "array \"%.400s\", (although %d number of elements required).\n"
     /* 34 */  ,"Matrix \"%.400s\" is not expected on file \"%.400s\".\n"
     /* 35 */  ,"Programming error detected when reading file \"%.400s\":\n"
                "Function amatReadAll is called with m[%d].matrix.nrow = %d (!= 0),\n"
                "although m[%d].rowDim > 0. This is not allowed.\n"
     /* 36 */  ,"Programming error detected when reading file \"%.400s\":\n"
                "Function amatReadAll is called with m[%d].matrix.ncol = %d (!= 0),\n"
                "although m[%d].colDim > 0. This is not allowed.\n"
     /* 37 */  ,"Error when reading matrix \"%.400s(%d,%d)\" from file \"%.400s\",\n"
                "because matrix \"%.400s\" is not stored in this file (which is required)\n"
     /* 38 */  ,"Error when reading matrix \"%.100s(%d,%d)\" from file \"%.400s\",\n"
                "because %.100s dimension does not agree with %.100s dimension of\n"
                "matrix \"%.100s(%d,%d)\".\n"
     /* 39 */  ,"Error when reading matrix \"%.400s(%d,%d)\" from file \"%.400s\",\n"
                "because row dimension <= %d required.\n"
     /* 40 */  ,"Error when reading matrix \"%.400s(%d,%d)\" from file \"%.400s\",\n"
                "because column dimension <= %d required.\n"
     /* 41 */  ,"Matrix \"%.400s\" has to be present on file \"%.400s\"\n"
                "which is not the case.\n"
     /* 42 */  ,"Programming error detected when reading file \"%.400s\":\n"
                "Index rowIndex/colIndex (= %d) stored in %d-th matrix \"%.400s\"\n"
                "is not in the required range 0 <= Index < %d.\n"
     /* 43 */  ,"Not possible to read matrices from file \"%.400s\",\n"
                "because the first matrix on file (=\"%.400s\")\n"
                "has not the name \"class\" or \"Aclass\".\n"
	 /* 44 */  ,"Reading of file \"%.400s\" stopped by user.\n"
   };



int amatRead (const char *fileName, Amatrix *matrix){ 

   /* Read single matrix from a file. */
      AmatGetFile  file;

      if ( amatGetOpen(fileName, "NoClass", "0.0", &file ) != 0 ) return 1;
      if ( amatGetMatrix(&file, matrix) != 0 ) {
         amatGetClose(&file);
         return 2;
      }
      amatGetClose(&file);
      return 0;
}



int amatReadAll (const char *fileName, const char *classReq, const char *versionReq, 
                 AclassRead c[], integer dim_c) {

   /* Read all matrices from file. */

   /* Declarations */
      AmatGetFile  file;
      int          err;

   /* Open file and check class name and version number */
      if ( (err=amatGetOpen(fileName, classReq, versionReq, &file)) != 0 ) return err;

   /* Read all matrices from file */
      err=amatReadAll2(&file, c, dim_c);
      return err;
}


static void amatUnexpectedNull(void) {
	sprintfC(amatError,"Unexpected null-pointer");
}
int amatReadAll2 (AmatGetFile *file, AclassRead c[], integer dim_c) {

   /* Read all matrices from file. */

   /* Declarations */
      char        *name=NULL, *str1, *str2;
      integer      i, j, ndim, found;
      int          err, eof;
      const char        *fileName;
	  if (!file) {amatUnexpectedNull();return RET_ERR;}
	  fileName = file->name;

   /* Check that storage is provided for all fixed dimensioned matrices */
      for (i=0; i<dim_c; i++) {
         ndim = Dymola_abs(c[i].matrix->nrow) * Dymola_abs(c[i].matrix->ncol);
         if ( ndim > 0 && c[i].matrix->data.v == NULL ) {
            if ( c[i].matrix->name != NULL ) {
               name = c[i].matrix->name;
            } else {
               name = "????";
            }
            goto error33;
         }

         if ( c[i].rowDim > 0 && c[i].matrix->nrow != 0 ) {j=i; goto error35;}
         if ( c[i].colDim > 0 && c[i].matrix->ncol != 0 ) {j=i; goto error36;} 

         c[i].onFile = FALSE_;
      }

   /* Read all matrices from file */
      while ( (name=amatGetName(file,&eof)) != NULL ) {
         /* Find matrix name */
            found = FALSE_;
            for (i=0; i<dim_c; i++) {
               if ( strcmp(c[i].matrix->name,name) == 0) {
                  found = TRUE_;
                  j     = i;
                  break;
               }
            }
            if ( !found ) goto error34;

         /* Read matrix j from file */
            if( (err = amatGetMatrix(file, c[j].matrix)) > 1 ) {
                if ( err==3 ) err=4; else err=5;
                goto errorExit;
            }
            c[j].onFile = TRUE_;

         /* Free allocated storage */
            free(name);
            name = NULL;  

      } /* End of  while */

      if ( !eof ) {err=4; goto errorExit;}


   /* Check additional semantic requirements */
      for (i=0; i<dim_c; i++) {
         if ( c[i].matrix->nrow == 0  ||  c[i].matrix->ncol == 0 ) c[i].onFile = FALSE_;
         if ( c[i].onFile ) {
            /* matrix i was read from file */
               if ( c[i].rowDim > 0 ) {
                  /* row dimension of matrix i must be equal to other dimension */
                     j = c[i].rowIndex;
                     if ( j < 0 || j >= dim_c ) goto error42;
                     if ( !c[j].onFile ) goto error37;
                     if ( c[i].rowDim==1 && c[i].matrix->nrow!=c[j].matrix->nrow ) {
                        str1 = "row"; str2 = "row"; goto error38;
                     }
                     if ( c[i].rowDim==2 && c[i].matrix->nrow!=c[j].matrix->ncol ) {
                        str1 = "row"; str2 = "column"; goto error38;
                     }
               }
               if ( c[i].colDim > 0 ) {
                  /* column dimension of matrix i must be equal to other dimension */
                     j = c[i].colIndex;
                     if ( j < 0 || j >= dim_c ) goto error42;
                     if ( !c[j].onFile ) goto error37;
                     if ( c[i].colDim==1 && c[i].matrix->ncol!=c[j].matrix->nrow ) {
                        str1 = "column"; str2 = "row"; goto error38;
                     }
                     if ( c[i].colDim==2 && c[i].matrix->ncol!=c[j].matrix->ncol ) {
                        str1 = "column"; str2 = "column"; goto error38;
                     }
               }
         } else if ( c[i].req ) {
            /* matrix i not on file as required */
               goto error41;
         }
      }


   /* Close reading of file */
      amatGetClose(file);
      return 0;


   /* Error handling */
      error33   : sprintfC(amatError, amatg_table[33], fileName, name, (int) ndim);
                  goto errorClose;

      error34   : sprintfC(amatError, amatg_table[34], name, fileName);
                  goto errorClose;

      error35   : sprintfC(amatError, amatg_table[35], fileName, (int) j, 
                          (int) c[j].matrix->nrow, (int) j);
                  goto errorClose;

      error36   : sprintfC(amatError, amatg_table[36], fileName, (int) j, 
                          (int) c[j].matrix->ncol, (int) j);
                  goto errorClose;

      error37   : sprintfC(amatError, amatg_table[37], c[i].matrix->name,
                          c[i].matrix->nrow, c[i].matrix->ncol, fileName, c[j].matrix->name);
                  goto errorClose;

      error38   : sprintfC(amatError, amatg_table[38], c[i].matrix->name,
                          c[i].matrix->nrow, c[i].matrix->ncol, fileName, str1, str2,
                          c[j].matrix->name, c[j].matrix->nrow, c[j].matrix->ncol);
                  goto errorClose;

      error41   : sprintfC(amatError, amatg_table[41], c[i].matrix->name, fileName);
                  goto errorClose;

      error42   : sprintfC(amatError, amatg_table[42], fileName, (int) j, (int) i, 
                          c[i].matrix->name, (int) dim_c);
                  goto errorClose;
      
      errorClose: err = 5;
      errorExit : amatGetClose(file);
                  free(name);
                  return err;
}



int amatGetOpen (const char *fileName, const char *classReq, const char *versionReq, AmatGetFile *file) {

   /* Open file for reading of matrices */

   /* Declarations */
      FILE        *fp;
      int          c_first;
      size_t       len;
      const char        *vers = "1";
      int          ic;
      Amatrix     *classInfo;
      int          err, i1, i2;
      const char        *str;

   /* Initialize file */
	  if (!file || !fileName)  {amatUnexpectedNull(); return RET_ERR;}
      file->name    = NULL;
      file->fp      = NULL;
      file->format  = amatASCII;
      file->bstruct = binNormal;
      file->header  = FALSE_;
      file->prec    = 0;
      classInfo = &(file->classInfo);
	  if (!classInfo) {amatUnexpectedNull(); return 13;}
      amatInit(classInfo);

   /* Open file, from which input data must be read */ 
	  if ( (fp = fopen(fileName, "r")) == NULL ) goto error7;
      file->fp = fp;

   /* Read first character */
      if ( (c_first = getc(fp)) == EOF ) goto error9;

   /* Determine file format (formatted or binary) */
	  if (c_first == 0xEF) {
		  /* Likely a byte-order mark, skip that */
		  int unicode = 0;
		  ic = getc(fp);
		  if (ic == 0xBB) {
			  ic = getc(fp);
			  if (ic == 0xBF) {
				  unicode = 1;
				  if ((c_first = getc(fp)) == EOF) goto error9;
			  }
		  }
		  if (!unicode) {
			  /* Restart reading otherwise */
			  fclose(fp);
			  if ((fp = fopen(fileName, "r")) == NULL) goto error7;
			  file->fp = fp;
			  if ((c_first = getc(fp)) == EOF) goto error9;
		  }
	  }
      if ( c_first == '#' ) {
         file->format = amatASCII;
         /* read next character and check version number */
            ic = getc(fp);
            if ( ic == EOF ) goto error0;
            if ( ic != vers[0] ) goto error21;
      } else { 
         file->format = amatBinary;
#ifndef UNIX
         /* binary file must be opened in "binary modus" */
            fclose(fp);
            if ( (fp = fopen(fileName, "rb")) == NULL ) goto error7;
            file->fp = fp;
#else
         ungetc(c_first, fp);
#endif
      }

   /* Allocate storage for file-name and store it in "file" */
      len = strlen(fileName) + 1;
      file->name = (char *) malloc( len*sizeof(char) );
      if ( file->name == NULL ) goto error15;
      strcpy( file->name, fileName );

   /* If no class description should be read, terminate function */
      if ( classReq != NULL && strcmp(classReq,"NoClass") == 0 ) return 0;

   /* Read class information (= matrix "classInfo") */

   /* Note: the classInfo->name is 0 and will therefore be allocated in amatGetMatrix */
      classInfo->name = NULL;
      classInfo->type = charMatrix;
      if ( (err=amatGetMatrix(file, classInfo)) != 0 ) {
		 if (classInfo->name) free(classInfo->name);
         amatGetClose(file);
         if (err == RET_MZERO)  return 1;
         if (err == RET_REQ  )  return 1;
         if (err == RET_EOF  )  return 4;
         return 5;
      }

   /* Check that name of matrix is "class" or "Aclass" */
      i1 = strcmp(classInfo->name, "class");
      i2 = strcmp(classInfo->name, "Aclass");
      if ( i1 != 0  &&  i2 != 0 ) goto error43;

	  /* De allocate classInfo and replace with static data; consistent with amatGetClose */
	  free(classInfo->name);
	  if (i1==0) classInfo->name="class";
	  else if (i2==0) classInfo->name="Aclass";
	  else classInfo->name="";

   /* Check class name */
      if ( classInfo->nrow < 3 ) goto error17;
      if ( classReq != NULL ) {
         if ( strcmp(classInfo->data.c[0],classReq) != 0 ) {str=classReq; goto error19;}
      } else {
         str = "";
         goto error19;
      }

   /* Check version number */
      if ( versionReq != NULL ) {
         if ( strcmp(classInfo->data.c[1],versionReq) != 0 ) goto error16;
      }

   /* Inquire bstruct flag if available */
      if ( classInfo->nrow >= 4 ) {
         if ( strcmp(classInfo->data.c[3],"binTrans") == 0 ) {
            file->bstruct = binTrans;
         }
      }
                        
   return 0;


   /* Error handling */
      error0 : if ( feof(fp) ) {
                  sprintfC(amatError, amatg_table[0], fileName, "End-Of-File reached."); 
                  amatGetClose(file);
                  return 4;
               } else { 
                  sprintfC(amatError, amatg_table[0], fileName, strerror(errno));
                  amatGetClose(file);
                  return 5;
               }

      error7 : sprintfC(amatError, amatg_table[7], fileName, strerror(errno));
               return 5;

      error9 : if ( feof(fp) ) {
                  sprintfC(amatError, amatg_table[9], fileName, "End-Of-File reached."); 
               } else { 
                  sprintfC(amatError, amatg_table[9], fileName, strerror(errno));
               }
               amatGetClose(file);
               return 5;

      error15: sprintfC(amatError, amatg_table[15], fileName, strerror(errno));
               fclose(fp);
               return 5;

      error16: if (!classInfo) {amatUnexpectedNull(); return 13;}
               sprintfC(amatError, amatg_table[16], fileName, classInfo->data.c[1], versionReq);
               if ( classInfo->data.c != NULL ) {
                   amatTextDel(classInfo->data.c, classInfo->nrow);
                   classInfo->data.c = NULL;
			   }
               amatGetClose(file);
               return 3;

      error17: if (!classInfo) {amatUnexpectedNull(); return 13;}
               sprintfC(amatError, amatg_table[17], fileName);
               if ( classInfo->data.c != NULL ) {
                  amatTextDel(classInfo->data.c, classInfo->nrow);
                  classInfo->data.c = NULL;
               }
               goto END;

      error19: if (!classInfo) {amatUnexpectedNull(); return 13;}
               sprintfC(amatError, amatg_table[19], fileName, classInfo->data.c[0], str);
               if ( classInfo->data.c != NULL ) {
                  amatTextDel(classInfo->data.c, classInfo->nrow);
                  classInfo->data.c = NULL;
               }
               amatGetClose(file);
               return 2;

      error21: sprintfC(amatError, amatg_table[21], fileName, vers, ic);
               goto END;

      error43: if (!classInfo) {amatUnexpectedNull(); return 13;}
               sprintfC(amatError, amatg_table[43], fileName, classInfo->name);
               amatGetClose(file);
               return 2;

      END    : amatGetClose(file);
               return 5;

} /* End of  amatGetOpen */





void amatGetClose (AmatGetFile *file) {

   /* Close file */
      Amatrix *mat;

      if ( file && file->fp != NULL ) {
		 fclose (file->fp);   
         free   (file->name);
         /* file->classInfo.name is a static string, must not be freed */
            mat = &(file->classInfo);
            amatTextDel(mat->data.c, mat->nrow);
            amatInit(mat);
         file->fp   = NULL;
         file->name = NULL;
      }

} /* End of  amatGetClose */



char *amatGetClass (AmatGetFile *file) {
   
   /* Get class name from file */
      char    *p;
	  if (!file)  {amatUnexpectedNull(); return 0;}
      p = file->classInfo.data.c[0];
      file->classInfo.data.c[0] = NULL;
      return p;
}



char *amatGetDescr (AmatGetFile *file) {
   
   /* Get description string from file */
      char    *p;
	  if (!file)  {amatUnexpectedNull(); return 0;}
      p = file->classInfo.data.c[2];
      file->classInfo.data.c[2] = NULL;
      return p;
}




char *amatGetVersion (AmatGetFile *file) {
   
   /* Get version string from file */
      char *p;
	  if (!file)  {amatUnexpectedNull(); return 0;}
      p = file->classInfo.data.c[1];
      file->classInfo.data.c[1] = NULL;
      return p;
}




#define LINE_LEN 200
#define NAME_LEN 100
#define TYPE_LEN  10 


int amatGetMatrix (AmatGetFile *file, Amatrix *matrixReq) {

   return amatGetMatrixP (file, matrixReq, voidMatrix);

} /* End of  amatGetMatrix */


int amatGetMatrixP3 (AmatGetFile *file, Amatrix *matrixReq, AmatType typeReq, const fpos_t*dataCont,int removeSpace) {

   /* Read numeric or text matrix from file.
      File may be in binary or formatted form */

   /* Declaration */
      Amatrix *matrix;                  /* matrix read from file */
      AmatType typeOnFile;
      char     name[NAME_LEN+1];
      int      err=0, prec;
      size_t   len;
	  integer  nRowPositive;
      integer  lname = NAME_LEN;
      char     *ch;

	  if (!file || !matrixReq)  {amatUnexpectedNull(); return RET_ERR;}
   /* Read matrix declaration */
      matrix = &file->matrix;
      if ( file->header ) {
         /* Matrix declaration already read from file */
            file->header = FALSE_;
            matrix->name = matrixReq->name;
            matrix->data = matrixReq->data;
            prec         = file->prec;

      } else { 
         /* Initialize utility matrix */
             matrix->name = matrixReq->name;
             matrix->nrow = 0;
             matrix->ncol = 0;
             matrix->type = voidMatrix;
             matrix->data = matrixReq->data;

         /* Read header from file */
             switch ( file->format ) {
                case amatASCII : if ( (err=amatGetFHeader(file, matrix, name, lname)) != 0 ) goto END;
                                 break;
                case amatBinary: if ( (err=amatGetBHeader(file, matrix, name, lname, &prec)) != 0 ) goto END;
                                 break;
                default        : goto error10;
             }
      }
     

   /* Check header */
      if (dataCont==0) {
		  if ( (err=amatGetCHeader(file, matrix, *matrixReq)) > 1 ) goto END;
	  }


   /* Set actual matrix type */
      typeOnFile = matrix->type;
      switch ( matrixReq->type ) {
         case voidMatrix   :  if ( typeOnFile == realMatrix || typeOnFile == doubleMatrix ) {
                                 if ( typeReq == realMatrix ) {
                                    matrix->type = realMatrix;
                                 } else if ( typeReq == doubleMatrix ) {
                                    matrix->type = doubleMatrix;
                                 }
                              }
                              break;
         case integerMatrix:  matrix->type = integerMatrix; break;
         case realMatrix   :  matrix->type = realMatrix   ; break;
		 case doubleMatrix :
			 if (typeOnFile == realMatrix) {
				 /* reduce according to type on file */ 
				 matrix->type = realMatrix;
			 } else {
				 matrix->type = doubleMatrix;
			 }
			 break;
         case charMatrix   :  matrix->type = charMatrix   ; break;
		 case realRowMatrix : matrix->type = realRowMatrix; break;
		 case doubleRowMatrix : 
			 if (typeOnFile == realMatrix) {
				 /* reduce according to type on file */ 
				 matrix->type = realRowMatrix;
			 } else {
				 matrix->type = doubleRowMatrix;
			 }
			 break;
         default           :  matrix->type = matrixReq->type; goto error30;
      }
      if ( err > 1 ) goto END; else err=0;  /* "err" value from call to amatGetCHeader */
	  
   /* Allocate storage for data */
      if ( matrix->data.v == NULL ) {
		 nRowPositive =matrix->nrow; 		 /* Guard against null-size allocation, also for charMatrix */
		 if (nRowPositive==0) nRowPositive=1;
         len = (size_t) (  nRowPositive* matrix->ncol );
         switch ( matrix->type ) {
            case integerMatrix: matrix->data.i = (integer    *) malloc( len*sizeof(integer   ) ); break;
            case realMatrix   : matrix->data.r = (real       *) malloc( len*sizeof(real      ) ); break;
            case doubleMatrix : matrix->data.d = (doublereal *) malloc( len*sizeof(doublereal) ); break;
			case charMatrix   : matrix->data.c = (char      **) malloc( nRowPositive*sizeof(char *) );	matrix->nrowread = 0; break;
			case realRowMatrix: /* Fall thru */
			case doubleRowMatrix:
				{
					int stopped=0;
					if (maxRows()>0) {
						/* This case is only on a special flag. */
						matrix->nrowallocated = -matrix->nrow-1; /* Actual number of rows */
						if (matrix->nrow>maxRows())
							matrix->nrow=maxRows(); /* Useful number of rows */
					} else {
						if (matrix->nrow<=10) 
							matrix->nrowallocated = 10; /* allocate some more */
						else 
							matrix->nrowallocated = matrix->nrow; /* Since we always allocate at least 10 no need for guard */
					}

					if (matrix->type == realRowMatrix) {
						if (matrix->nrowallocated<0)
							matrix->data.rrow = (real**) malloc(matrix->nrow*sizeof(real*));
						else
							matrix->data.rrow = (real **) malloc(matrix->nrowallocated*sizeof(real*));
						matrix->nrowread = 0;
						if (matrix->data.rrow!=0) {
							int i;
							for(i=0;i<matrix->nrow;i++) {
								if (amatStopRequest!=0 && (*amatStopRequest)()) {
									matrix->data.rrow[i] = 0;
									stopped=1;
								} else
									matrix->data.rrow[i] = (real*) malloc(matrix->ncol*sizeof(real));
								if (matrix->data.rrow[i]==0) {
									for(;i>=0;i--) free(matrix->data.rrow[i]);
									free(matrix->data.rrow);
									matrix->data.rrow=0;
									break;
								}
							}
						}
					} else {
						/* doubleRowMatrix */
						if (matrix->nrowallocated<0)
							matrix->data.drow = (doublereal**) malloc(matrix->nrow*sizeof(double*));
						else
							matrix->data.drow = (doublereal **) malloc(matrix->nrowallocated*sizeof(double*));
						matrix->nrowread = 0;
						if (matrix->data.drow!=0) {
							int i;
							for(i=0;i<matrix->nrow;i++) {
								if (amatStopRequest!=0 && (*amatStopRequest)()) {
									matrix->data.drow[i] = 0;
									stopped=1;
								} else
									matrix->data.drow[i] = (doublereal*) malloc(matrix->ncol*sizeof(double));
								if (matrix->data.drow[i]==0) {
									for(;i>=0;i--) free(matrix->data.drow[i]);
									free(matrix->data.drow);
									matrix->data.drow=0;
									break;
								}
							}
						}
					}
					if (stopped) goto error44;
					break;
				}
            default           : goto error30;
         }
         if ( matrix->data.v == NULL ) goto error5;

      } else if (dataCont) {
		  int realRow = (matrixReq->type == realRowMatrix && matrix->type == realRowMatrix);
		  if (realRow || (matrixReq->type == doubleRowMatrix && matrix->type == doubleRowMatrix)) {
 			  len = matrix->nrow;
			  if (matrixReq->nrowallocated<0) {
				  /* Do not update nrowallocated yet */
				  integer deltaShift=matrix->nrow-(matrixReq->nrowread-matrixReq->nrow);
				  matrix->nrowallocated = -matrix->nrow-1;
				  if (maxRows()>0 && matrix->nrow>maxRows())
					  matrix->nrow=maxRows();
				  deltaShift-=matrix->nrow;
				  if (realRow) {
					  for(;deltaShift>0;--deltaShift) {
						  integer i;
						  real*d2=matrixReq->data.rrow[0];
						  for(i=1;i<matrixReq->nrow;++i) matrixReq->data.rrow[i-1]=matrixReq->data.rrow[i];
						  matrixReq->data.rrow[matrixReq->nrow-1]=d2;
					  }
					  if (matrix->nrow>matrixReq->nrow) {
						  matrixReq->data.rrow = (real**)realloc(matrixReq->data.rrow,matrix->nrow*sizeof(real*));
						  /* Note: Should only be able to shrink since matrix->nrow will decrease if greater than maxRows but not increase */
					  }
				  } else {
					  /* doubleRowMatrix */
					  for(;deltaShift>0;--deltaShift) {
						  integer i;
						  double*d2=matrixReq->data.drow[0];
						  for(i=1;i<matrixReq->nrow;++i) matrixReq->data.drow[i-1]=matrixReq->data.drow[i];
						  matrixReq->data.drow[matrixReq->nrow-1]=d2;
					  }
					  if (matrix->nrow>matrixReq->nrow) {
						  matrixReq->data.drow = (doublereal**)realloc(matrixReq->data.drow,matrix->nrow*sizeof(double*));
						  /* Note: Should only be able to shrink since matrix->nrow will decrease if greater than maxRows but not increase */
					  }
				  }
			  } else {
				  if (matrix->nrow > matrixReq->nrowallocated) {
					  integer toAllocate=Dymola_max(matrix->nrow,matrixReq->nrowallocated*2);
					  if (realRow) {
						  real**rr=0;
						  rr = (real**)realloc(matrixReq->data.rrow, toAllocate*sizeof(real*));
						  if (rr) {
							  matrixReq->data.rrow = rr;
							  matrixReq->nrowallocated = matrix->nrowallocated = toAllocate;
						  } else {
							  /* Cannot grow. Do nothing more. */
							  goto error5;
						  }
					  } else {
						  /* doubleRowMatrix */
						  doublereal**dd=0;
						  dd = (doublereal**)realloc(matrixReq->data.drow, toAllocate*sizeof(double*));
						  if (dd) {
							  matrixReq->data.drow = dd;
							  matrixReq->nrowallocated = matrix->nrowallocated = toAllocate;
						  } else {
							  /* Cannot grow. Do nothing more. */
							  goto error5;
						  }
					  }
				  } else {
					  matrix->nrowallocated = matrixReq->nrowallocated;
				  }
			  }
			  if (realRow) {
				  matrix->data.rrow = matrixReq->data.rrow;
				  matrix->nrowread = matrixReq->nrowread;
				  if (matrix->nrow > matrixReq->nrow && matrix->data.rrow) {
					  int i;
					  for(i=matrixReq->nrow;i<matrix->nrow;++i) {
						  matrix->data.rrow[i] = (real*) malloc(matrix->ncol*sizeof(real));
						  if (matrix->data.rrow[i]==0) {
							  for(;i>=matrixReq->nrow;i--) 
								  free(matrix->data.rrow[i]);
							  matrix->nrow=matrixReq->nrow; /* Has not grown */
							  goto error5;
						  }
					  }
				  }
			  } else {
				  /* doubleRowMatrix */
				  matrix->data.drow = matrixReq->data.drow;
				  matrix->nrowread = matrixReq->nrowread;
				  if (matrix->nrow > matrixReq->nrow && matrix->data.drow) {
					  int i;
					  for(i=matrixReq->nrow;i<matrix->nrow;++i) {
						  matrix->data.drow[i] = (doublereal*) malloc(matrix->ncol*sizeof(double));
						  if (matrix->data.drow[i]==0) {
							  for(;i>=matrixReq->nrow;i--) 
								  free(matrix->data.drow[i]);
							  matrix->nrow=matrixReq->nrow; /* Has not grown */
							  goto error5;
						  }
					  }
				  }
			  }
			  if (matrix->data.v == NULL) goto error5;
			  if (fsetpos(file->fp, dataCont)) goto error5; /* Or somewhere else?*/
		  } else {
         /* Check, whether nrow, ncol and type are user-defined */
            if ( (matrixReq->nrow == 0) || (matrixReq->ncol == 0 && matrixReq->type != charMatrix) 
              || (matrixReq->type == voidMatrix) ) goto error32;
		  }
	  }


   /* switch according to file format */
      switch ( file->format ) {
         case amatASCII : err = amatGetFMatrix(file, matrix);
                          break;
         case amatBinary: err = amatGetBMatrix(file, matrix, typeOnFile, prec,removeSpace);
                          break;
         default        : goto error10;
      }


   /* Copy matrix from file into output argument */
   END:
      switch ( err ) {
         case 0 : /* No error occured */
                     if ( matrixReq->name == NULL ) matrixReq->name = matrix->name;
                     matrixReq->nrow = matrix->nrow;
                     matrixReq->ncol = matrix->ncol;
                     matrixReq->type = matrix->type;
					 matrixReq->nrowread = matrix->nrowread;
					 matrixReq->nrowallocated = matrix->nrowallocated;
                     if ( matrixReq->data.v == NULL ) matrixReq->data = matrix->data;
                     return 0;

         case 1 : /* Matrix has zero elements */
                     if ( matrixReq->name == NULL ) matrixReq->name = matrix->name;
                     matrixReq->nrow = 0;
                     matrixReq->ncol = 0;
					 matrixReq->nrowread = matrix->nrowread;
					 matrixReq->nrowallocated = matrix->nrowallocated;
                     matrixReq->type = matrix->type;
                     return RET_MZERO;

         default: /* Error, remove allocated storage */
                     if ( matrixReq->name   == NULL ) free(matrix->name);
                     if ( matrixReq->data.v == NULL ) free(matrix->data.v);
                     if ( err == RET_REQ ) return RET_REQ;
                     if ( err == RET_EOF ) return RET_EOF;
                     return RET_ERR;
      }


   /* Error handling */
      error5 : sprintfC(amatError, amatg_table[5], matrix->name, (int) matrix->nrow, 
                       (int) matrix->ncol, file->name, (int) len);
               err = RET_ERR;
               goto END;

      error10: sprintfC(amatError, amatg_table[10], file->name, (int) file->format);
               err = RET_ERR;
               goto END;

      error30: sprintfC(amatError, amatg_table[30], matrix->name, (int) matrix->nrow, 
                       (int) matrix->ncol, file->name, (int) matrix->type);
               err = RET_ERR;
               goto END;
 
      error32: switch (matrixReq->type) {
                  case voidMatrix   : ch = "voidMatrix"   ; break;
                  case integerMatrix: ch = "integerMatrix"; break;
                  case realMatrix   : ch = "realMatrix"   ; break;
                  case doubleMatrix : ch = "doubleMatrix" ; break;
                  case charMatrix   : ch = "charMatrix"   ; break;
				  case realRowMatrix : ch ="realRowMatrix"; break;
				  case doubleRowMatrix : ch ="doubleRowMatrix"; break;
                  default           : ch = "unknown"      ; break;
               }
               sprintfC(amatError, amatg_table[32], matrix->name, (int) matrix->nrow, 
                       (int) matrix->ncol, file->name, (int) matrixReq->nrow,
                       (int) matrixReq->ncol, ch);
               err = RET_ERR;
			   goto END;
      error44:
			   sprintfC(amatError, amatg_table[44], file->name);
			   err = RET_ERR;
               goto END;
 
} /* End of  amatGetMatrix */
int amatGetMatrixP  (AmatGetFile *file, Amatrix *matrixReq, AmatType typeReq) {
	return amatGetMatrixP3(file,matrixReq,typeReq,0,1);
}
int amatGetMatrixP2  (AmatGetFile *file, Amatrix *matrixReq, AmatType typeReq,const fpos_t*dataCont) {
	return amatGetMatrixP3(file,matrixReq,typeReq,dataCont,1);
}


char *amatGetName (AmatGetFile *file, int *eof) {

   /* Get name of next matrix from file.
      File may be in binary or formatted form */

   /* Declaration */
      Amatrix *matrix;                  /* matrix read from file */
      char     name[NAME_LEN+1];
      int      err, prec=0;
      integer  lname = NAME_LEN;

   /* Initialize utility matrix */
	  if (!file || !eof)  {amatUnexpectedNull(); return 0;}
      *eof = FALSE_;
      file->header   = FALSE_;
      matrix         = &file->matrix;
      matrix->name   = NULL;
      matrix->nrow   = 0;
      matrix->ncol   = 0;
      matrix->type   = voidMatrix;
      matrix->data.v = NULL;

   /* Read header from file */
      switch ( file->format ) {
         case amatASCII : if ( (err=amatGetFHeader(file, matrix, name, lname)) != 0 ) {
                             if ( err == RET_EOF ) *eof = TRUE_;
                             return NULL;
                          }
                          break;
         case amatBinary: if ( (err=amatGetBHeader(file, matrix, name, lname, &prec)) != 0 ) {
                             if ( err == RET_EOF ) *eof = TRUE_;
                             return NULL;
                          }
                          break;
         default        : sprintfC(amatError, amatg_table[10], file->name, (int) file->format);
                          return NULL;
      }

   /* Return matrix name */
      file->header = TRUE_;
      file->prec   = prec;
      return matrix->name;

} /* End of  amatGetName */



static int amatGetFMatrix (AmatGetFile *file, Amatrix *matrix) {

   /* Read numeric or text matrix in formatted format from file */

   /* Read data */
	if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
      switch ( matrix->type ) {
	     case realRowMatrix:
	     case doubleRowMatrix:
         case integerMatrix:
         case realMatrix   : 
         case doubleMatrix : return amatGetFNMatrix (file, matrix);
         case charMatrix   : return amatGetFText    (file, matrix);
      }

   /* Error handling */
      sprintfC(amatError, amatg_table[11], file->name, (int) matrix->type);
      return RET_ERR;

} /* End of  amatGetFMatrix */


static int amatGetFHeader (AmatGetFile *file, Amatrix *matrix, char name[], integer lname){

   /* Read matrix header from file in formatted format and 
      check matrix attributes
      <- RETURN: = 0: No error occured.
                 = 1: The matrix on file has zero dimensions (nrow*ncol=0). 
                 = 2: The matrix on file does not have the required attributes.
                 = 3: End-of-File reached (file was already at EOF when calling this
                      function).
                 = 4: Another error occured.
   */
    
   /* Declarations */
      FILE    *fp;
      char     line[LINE_LEN], type[TYPE_LEN+1];
      char     fmt[50];
      size_t   len;
      int      err;
	  	
	  if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}

   /* Build sscanf format string */
      sprintfC(fmt, "%%%ds %%%d[^( 	](%%d,%%d)",(int) TYPE_LEN, (int) lname);
	  /* Gives: % <TYPE_LEN> s % <lname> [^( ....](%d, %d) */

   /* Read next input line and scan declaration */
      fp = file->fp;
      if ( (err=amatGetSkip(file)) != 0 ) return err;
      if ( fgets(line,LINE_LEN,fp) == NULL ) goto error0;
      if ( sscanfCtext_ssdd(line, fmt, type, name, &matrix->nrow, &matrix->ncol) != 4 ) goto error22;

   /* Determine matrix type */
      if ( strcmp(type, "int") == 0 ) {
         matrix->type = integerMatrix;
      } else if ( strcmp(type, "float") == 0 ) {
         matrix->type = realMatrix;
      } else if ( strcmp(type, "double") == 0 ) {
         matrix->type = doubleMatrix;
      } else if ( strcmp(type, "char") == 0 ) {
         matrix->type = charMatrix;
      } else {
         goto error22;
      }

   /* Check matrix name */
      if ( matrix->name != NULL ) {
         if ( strcmp(matrix->name, name) != 0 ) goto error24;

      } else {
         len = strlen(name);
         if ( len > 0ul ) {
            len += 1;
            matrix->name = (char *) malloc( len*sizeof(char) );
            if ( matrix->name == NULL ) goto error18;
            strcpy(matrix->name, name);
         } else {
           goto error22;
         }
      }

   return 0;

   /* Error handling */
               
      error0 : if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               if ( feof(fp) ) {
                  sprintfC(amatError, amatg_table[0], file->name, "End-Of-File reached.");
                  return RET_EOF;
               } else { 
                  sprintfC(amatError, amatg_table[0], file->name, strerror(errno));
                  return RET_ERR;
               }

      error18: if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[18], file->name, (int) len);
               return RET_ERR;

      error22: if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[22], file->name, line);
               return RET_ERR;

      error24: if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[24], file->name, line, matrix->name);
               return RET_REQ;

} /* End of  amatGetFHeader */



static int amatGetCHeader (AmatGetFile *file, Amatrix *matrix, Amatrix matrixReq) {

   /* Check header of matrix 
      -> file      : File identificator.
      -> matrixReq : Required matrix attributes.
      <- matrix    : Actual matrix attributes.
      <- RETURN    : = 0: no error.
                     = 1: header fully checked; number of matrix elements on  
                          file is zero.
                     = 3: error.
   */

   /* Declarations */
      char    *ch;

      if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
   /* Check matrix type */
      switch ( matrixReq.type ) {
	     case realRowMatrix:
	     case doubleRowMatrix :
         case integerMatrix:
         case realMatrix   :  
         case doubleMatrix : if ( (matrix->type != integerMatrix) &&
                                  (matrix->type != realMatrix   ) &&
                                  (matrix->type != doubleMatrix )    ) goto error25;
                             break;
         case charMatrix   : if ( matrix->type != charMatrix ) goto error26;
                             break;
         default           : break;   /* do nothing */
      }

   /* Check row and column dimensions */
      if ( matrix->nrow < 0 ) goto error1;
      if ( matrix->ncol < 0 ) goto error2;
      if ( (matrix->nrow)*(matrix->ncol) == 0 ) goto error29;
      if ( matrixReq.nrow > 0 && matrix->nrow != matrixReq.nrow )     goto error27;
      if ( matrixReq.ncol > 0 && matrix->ncol != matrixReq.ncol )     goto error28;
      if ( matrixReq.nrow < 0 && matrix->nrow > Dymola_abs(matrixReq.nrow) ) goto error39;
      if ( matrixReq.ncol < 0 && matrix->ncol > Dymola_abs(matrixReq.ncol) ) goto error40;

   return 0;


   /* Error handling */
      error1 : if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[1], (int) matrix->nrow, matrix->name, file->name);
               return RET_ERR;

      error2 : if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[2], (int) matrix->ncol, matrix->name, file->name);
               return RET_ERR;

      error25: if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               switch ( matrix->type ) {
                  case charMatrix: ch = "char";
                                   break;
                  default        : ch = "unknown";
               }
               sprintfC(amatError, amatg_table[25], matrix->name, (int) matrix->nrow,
                       (int) matrix->ncol, file->name, ch); 
               return RET_REQ;

      error26: if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               switch ( matrix->type ) {
                  case integerMatrix: ch = "integer"; break;
                  case realRowMatrix: /* Fall thru */
                  case realMatrix   : ch = "real";    break;
				  case doubleRowMatrix: /* Fall thru */
                  case doubleMatrix : ch = "double";  break;
                  default           : ch = "unknown";
               }
               sprintfC(amatError, amatg_table[26], matrix->name, (int) matrix->nrow,
                       (int) matrix->ncol, file->name, ch); 
               return RET_REQ;

      error27: if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[27], matrix->name, (int) matrix->nrow,
                       (int) matrix->ncol, file->name, (int) matrixReq.nrow);
               return RET_REQ;

      error28: if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[28], matrix->name, (int) matrix->nrow,
                       (int) matrix->ncol, file->name, (int) matrixReq.ncol);
               return RET_REQ;

      error29: if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[29], matrix->name, (int) matrix->nrow,
                       (int) matrix->ncol, file->name);
               return RET_MZERO;

      error39: 
               if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatg_table[39], matrix->name, (int) matrix->nrow,
                       (int) matrix->ncol, file->name, (int) Dymola_abs(matrixReq.nrow));
               return RET_REQ;

      error40: 
               if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[40], matrix->name, (int) matrix->nrow,
                       (int) matrix->ncol, file->name, (int) Dymola_abs(matrixReq.ncol));
               return RET_REQ;

} /* End of  amatGetCHeader */



static int amatGetFNMatrix (AmatGetFile *file, Amatrix *matrix) {

   /* Read formatted matrix-data from file */

   /* Declarations */
      FILE       *fp;
      integer     i, j;
      integer    *ip1, *ip2;
      real       *rp1, *rp2;
      doublereal *dp1, *dp2, dp;

   /* Read numeric data of matrix from file */
	  if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}

      fp  = file->fp;
      if ( matrix->type == integerMatrix ) {
         ip1 = matrix->data.i;
         ip2 = ip1;
         for ( i=0; i<matrix->nrow; i++) {
            for ( j=0; j<matrix->ncol; j++ ) {
               if ( amatGetSkip(file) != 0 ) return RET_ERR;
               if ( fscanfClf(fp,&dp) != 1 ) goto error6;
               *ip2 = (integer) dp;
               ip2 += matrix->nrow;
            }
            ip1++;
            ip2 = ip1;
         }

      } else if ( matrix->type == realMatrix ) {
         rp1 = matrix->data.r;
         rp2 = rp1;
         for ( i=0; i<matrix->nrow; i++) {
            for ( j=0; j<matrix->ncol; j++ ) {
               if ( amatGetSkip(file) != 0 ) return RET_ERR;
               if ( fscanfCg(fp,rp2) != 1 ) goto error6;
               rp2 += matrix->nrow;
            }
            rp1++;
            rp2 = rp1;
         }
	  } else if ( matrix->type == realRowMatrix ||matrix->type == doubleRowMatrix ) {
		integer readto=matrix->nrow;
		integer offset=0;
		if (matrix->nrowallocated<0) {
			readto=-matrix->nrowallocated-1;
			offset=readto-matrix->nrow;
		}
        for ( i=matrix->nrowread; i<readto; i++) {
			integer index=i-offset;if (index<0) index=0;
			if (matrix->type == realRowMatrix) {
				for ( j=0; j<matrix->ncol; j++ ) {
					double dp;
					if ( amatGetSkip(file) != 0 ) return RET_ERR;
					if ( fscanfClf(fp,&dp) != 1 ) goto error6;
					matrix->data.rrow[index][j] = (real) dp;
				}
			} else {
				/* doubleRowMatrix */
				for ( j=0; j<matrix->ncol; j++ ) {
					if ( amatGetSkip(file) != 0 ) return RET_ERR;
					if ( fscanfClf(fp,&(matrix->data.drow[index][j])) != 1 ) goto error6;
				}
			}
		}
		matrix->nrowread = i;
      } else {
         dp1 = matrix->data.d;
         dp2 = dp1;
         for ( i=0; i<matrix->nrow; i++) {
            for ( j=0; j<matrix->ncol; j++ ) {
               if ( amatGetSkip(file) != 0 ) return RET_ERR;
               if ( fscanfClf(fp,dp2) != 1 ) goto error6;
               dp2 += matrix->nrow;
            }
            dp1++;
            dp2 = dp1;
         }
      }

      return 0;


   /* Error handling */
      error6 : if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               if ( feof(fp) ) {
                  sprintfC(amatError, amatg_table[6], matrix->name, (int) matrix->nrow, 
                          (int) matrix->ncol, file->name, ": End-Of-File reached."); 
                  return RET_EOF;
               } else { 
                  sprintfC(amatError, amatg_table[6], matrix->name, (int) matrix->nrow, 
                          (int) matrix->ncol, file->name, " ");
                  return RET_ERR;
               }

} /* End of  amatGetFNMatrix */


static void fixQuotes(char*s) {
	int i=0,j=0;
	for(;;) {
		if (s[i]=='\\' && s[i+1]=='n') {s[j]='\n';i+=2;j++;}
		else if (s[i]=='\\' && s[i+1]=='\\') {s[j]='\\';i+=2;j++;}
		else {s[j]=s[i];if (!s[j]) break;i++;j++;}
	}
}
static int amatGetFText (AmatGetFile *file, Amatrix *matrix) {

   /* Read text matrix in formatted form from file */

   /* Declarations */
      FILE       *fp;
      integer     nrow, ncol;
      size_t      lenStr, len, lenmax;
      integer     i, ii;
      char      **textVec, *str, *p;
      int         c;

	  if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}

   /* Initialize output data */
      textVec = matrix->data.c;
      nrow    = matrix->nrow;
      ncol    = matrix->ncol;
      fp      = file->fp;

   /* Allocate storage for string with maximum length*2 + 2 ('\n\0') */
      lenStr = (size_t) ( ncol*2 + 2 );
      str    = (char *) malloc( lenStr*sizeof(char) );
      if ( str == NULL ) {len=lenStr; goto error13;}
 
   /* Initialize text pointer vector with NULL */
      for (i=0; i<nrow; i++) textVec[i] = NULL;

   /* Read text */
      lenmax = 0;
      for ( i=0; i<nrow; i++) {
         /* Read next string into temporary storage "str" */
            if ( fgets(str,(int)lenStr,fp) == NULL ) goto error14;

			fixQuotes(str);
         /* Determine length of string */
            len = strlen(str);
            if ( str[len-1] == '\n' ) {
               str[len-1] = '\0';
               len--;
            } else {
               /* read upto End-of-Line */ 
                  c = getc(fp);
                  while( c != '\n' && c != EOF ) c = getc(fp);
            }

         /* Allocate storage for string and copy string into storage */
            p = (char *) malloc( (size_t) (len+1)*sizeof(char) );
            if ( p == NULL ) {
               for (ii=0; ii<nrow; ii++) free(textVec[ii]);
               free(str);
               len = len+1;
               goto error13;
            }
            textVec[i] = strcpy(p, str);
            lenmax = Dymola_max(len,lenmax);
      }      

      free(str);
      matrix->ncol = (integer) lenmax;

   return 0;


   /* Error handling */
      error13 : if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
                sprintfC(amatError, amatg_table[13], matrix->name, (int) matrix->nrow, 
                        (int) matrix->ncol, file->name, (int) len);
                return RET_ERR;

      error14 : if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
                if ( feof(fp) ) {
                   sprintfC(amatError, amatg_table[14], matrix->name, (int) matrix->nrow, 
                           (int) matrix->ncol,  file->name, "End-Of-File reached."); 
                } else { 
                   sprintfC(amatError, amatg_table[14], matrix->name, (int) matrix->nrow, 
                           (int) matrix->ncol, file->name, strerror(errno));
                }
                for (i=0; i<nrow; i++) free(textVec[i]);
                free(str);
                return RET_ERR;

} /* End of  amatGetFText */



static int amatGetBMatrix (AmatGetFile *file, Amatrix *matrix, AmatType typeOnFile, int prec,int removeSpace){

   /* Read numeric or text matrix in binary format from file */
	if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
   /* Read data */
      switch ( typeOnFile ) {
         case integerMatrix: return amatGetBIMatrix (file, matrix);
         case realMatrix   : return amatGetBRMatrix (file, matrix);
         case doubleMatrix : return amatGetBDMatrix (file, matrix);
         case charMatrix   : return amatGetBText    (file, matrix, prec, removeSpace);
      }

   /* Error handling */
      sprintfC(amatError, amatg_table[11], file->name, (int) typeOnFile);
      return RET_ERR;

} /* End of  amatGetBMatrix */



static int amatGetBHeader (AmatGetFile *file, Amatrix *matrix,
                           char *name, integer lname, int *prec) {

   /* Read matrix header from file in amatBinary format */

   /* Declarations */
      FILE    *fp;
      Fmatrix  x;
      size_t   one=1, len, len2;
      int      type, i;
      int     mach, machReq;
      integer  ii;

	  if (!file||!matrix||!name)  {amatUnexpectedNull(); return RET_ERR;}
   /* Read struct and determine length of name */
      fp = file->fp;
      if ( fread(&x, sizeof(Fmatrix), one, fp) != one ) goto error0a;

     /* Determine data type of matrix */
	  /* Before actually checking name, since it detects incorrectly formatted files */
      machReq = MATTYPE/1000L;
      mach    = x.type / 1000L;
      if ( mach != machReq ) goto error20;  /* machine type   */

   /* Read and check name */
      if ( matrix->name == NULL ) {
         /* Allocate storage and read name into storage */
            len  = (size_t) x.namlen;
            len2 = Dymola_max(1,len);
            matrix->name = (char *) malloc( len2*sizeof(char) ); 
            if ( matrix->name == NULL ) goto error18;
            if ( len > 0 ) {
               if ( fread(matrix->name, sizeof(char), len, fp) != len ) goto error0;
            } else {
               matrix->name[0] = '\0';
            }

      } else {
         /* Read name into "name" storage. If name on file is too long, truncate it */
            if ( x.namlen > 0 ) {
               if ( x.namlen <= lname+1 ) {
                  if ( fread(name, sizeof(char), x.namlen, fp) != (size_t) x.namlen ) goto error0;
               } else {
                  if ( fread(name, sizeof(char), lname, fp) != (size_t) lname ) goto error0;
                  name[lname] = '\0';
                  for (ii=0; ii<x.namlen-lname; ii++) {if ( fgetc(fp) == EOF ) goto error0;}
               }
            } else {
              name[0] = '\0';
            }
         
         /* Compare name with required name */
            if ( strcmp(matrix->name, name) != 0 ) goto error31;
      }

      i       = (int) ((x.type % 1000L) % 100L);
      *prec   = i / 10;
      type    = i % 10;
     if ( type == 0 ) {                    /* numeric matrix */
         if ( *prec == 0 ) {
            matrix->type = doubleMatrix;
         } else if ( *prec == 1 ) {
            matrix->type = realMatrix;
         } else if ( *prec == 2 ) {
            matrix->type = integerMatrix;
         } else {
            goto error3;
         }
      } else if ( type == 1 ) {             /* character matrix */
         matrix->type = charMatrix;
      } else {
         goto error4;
      }

   /* store row and column dimension */
      if ( file->bstruct == binNormal ) {
         matrix->nrow = x.mrows;
         matrix->ncol = x.ncols;
      } else {
         matrix->nrow = x.ncols;
         matrix->ncol = x.mrows;
      }

   return 0;


   /* Error handling */
      error0a: if (!file||!matrix||!name)  {amatUnexpectedNull(); return RET_ERR;}
               if ( feof(fp) ) {
                  sprintfC(amatError, amatg_table[0], file->name, "End-Of-File reached."); 
                  return RET_EOF;
               } else { 
                  sprintfC(amatError, amatg_table[0], file->name, strerror(errno));
                  return RET_ERR;
               }

      error0 : if (!file||!matrix||!name)  {amatUnexpectedNull(); return RET_ERR;}
               if ( feof(fp) ) {
                  sprintfC(amatError, amatg_table[0], file->name, "End-Of-File reached."); 
               } else { 
                  sprintfC(amatError, amatg_table[0], file->name, strerror(errno));
               }
               return RET_ERR;

      error3 : if (!file||!matrix||!name)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[3], *prec, matrix->name, file->name);
               return RET_ERR;

      error4 : if (!file||!matrix||!name)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[4], type, matrix->name, file->name);
               return RET_ERR;

      error18: if (!file||!matrix||!name)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[18], file->name, (int) len2, strerror(errno));
               return RET_ERR;

      error20: if (!file||!matrix||!name)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[20], file->name);
               return RET_ERR;

      error31: if (!file||!matrix||!name)  {amatUnexpectedNull(); return RET_ERR;}
               sprintfC(amatError, amatg_table[31], name, file->name, matrix->name);
               return RET_REQ;

} /* End of  amatGetBHeader */



static int amatGetBIMatrix (AmatGetFile *file, Amatrix *matrix) {

   /* Read matrix-data from file. The data is stored as integer matrix
      in Matlab binary format */

   /* Declarations */
      FILE       *fp;
      size_t      one=1, ii;
      integer     i, j;
      doublereal *dp1, *dp2;
      real       *rp1, *rp2;
      integer    *ip1, *ip2, ip;
      size_t      len;

	  if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
 
   /* Read numeric data of matrix from file */
      fp  = file->fp;
      len = (size_t) matrix->nrow * matrix->ncol;

      if ( file->bstruct == binNormal ) {  /* normal matrix structure */
         if ( matrix->type == integerMatrix ) {
            /* get integer matrix in column dense format as integer matrix */
               if ( fread(matrix->data.i, sizeof(integer), len, fp) != len ) goto error6;

         } else if ( matrix->type == realMatrix ) {
            /* get integer matrix in column dense format as real matrix */
               rp1 = matrix->data.r;
               for ( ii=0; ii<len; ii++ ) {
                     if ( fread(&ip, sizeof(integer), one, fp) != one ) goto error6;
                     *rp1++ = (real) ip;
               }
		 } else if ( matrix->type == realRowMatrix ) {
			 for (j=0;j<matrix->ncol;j++) {
				 for(i=0;i<matrix->nrow;i++) {
                    if ( fread(&ip, sizeof(integer), one, fp) != one ) goto error6;
					matrix->data.rrow[i][j]= (real) ip;
				 }
			 }
		 } else if ( matrix->type == doubleRowMatrix ) {
			 for (j=0;j<matrix->ncol;j++) {
				 for(i=0;i<matrix->nrow;i++) {
                    if ( fread(&ip, sizeof(integer), one, fp) != one ) goto error6;
					matrix->data.drow[i][j]= (doublereal) ip;
				 }
			 }
         } else {
            /* get integer matrix in column dense format as doublereal matrix */
               dp1 = matrix->data.d;
               for ( ii=0; ii<len; ii++ ) {
                     if ( fread(&ip, sizeof(integer), one, fp) != one ) goto error6;
                     *dp1++ = (doublereal) ip;
               }
         }

      } else {    /* matrix has to be transposed */
         if ( matrix->type == integerMatrix ) {
            /* get integer matrix in row dense format as integer matrix */
               ip1 = matrix->data.i;
               ip2 = ip1;
               for ( i=0; i<matrix->nrow; i++) {
                  for ( j=0; j<matrix->ncol; j++ ) {
                     if ( fread(ip2, sizeof(integer), one, fp) != one ) goto error6;
                     ip2 += matrix->nrow;
                  }
                  ip1++;
                  ip2 = ip1;
               }

		 } else if ( matrix->type == realRowMatrix || matrix->type == doubleRowMatrix) {
			 int readto=matrix->nrow;
			 int offset=0;
			 if (matrix->nrowallocated<0) {
				 readto=-matrix->nrowallocated-1;
				 offset=readto-matrix->nrow;
			 }
			 if ( matrix->type == realRowMatrix ) {
				 for(i=matrix->nrowread;i<readto;i++) {
					 int index=i-offset;if(index<0) index=0;
					 for (j=0;j<matrix->ncol;j++) {
						 if ( fread(&ip, sizeof(integer), one, fp) != one ) goto error6;
						 matrix->data.rrow[index][j]= (real) ip;
					 }
				 }
			 } else {
				 /* doubleRowMatrix */
				 for(i=matrix->nrowread;i<readto;i++) {
					 int index=i-offset;if(index<0) index=0;
					 for (j=0;j<matrix->ncol;j++) {
						 if ( fread(&ip, sizeof(integer), one, fp) != one ) goto error6;
						 matrix->data.drow[index][j]= (doublereal) ip;
					 }
				 }
			 }
			 matrix->nrowread = i;
         } else if ( matrix->type == realMatrix ) {
            /* get integer matrix in row dense format as real matrix */
               rp1 = matrix->data.r;
               rp2 = rp1;
               for ( i=0; i<matrix->nrow; i++) {
                  for ( j=0; j<matrix->ncol; j++ ) {
                     if ( fread(&ip, sizeof(integer), one, fp) != one ) goto error6;
                     *rp2 =  (real) ip;
                      rp2 += matrix->nrow;
                  }
                  rp1++;
                  rp2 = rp1;
               }

         } else {
            /* get integer matrix in row dense format as doublereal matrix */
               dp1 = matrix->data.d;
               dp2 = dp1;
               for ( i=0; i<matrix->nrow; i++) {
                  for ( j=0; j<matrix->ncol; j++ ) {
                     if ( fread(&ip, sizeof(integer), one, fp) != one ) goto error6;
                     *dp2 =  (doublereal) ip;
                      dp2 += matrix->nrow;
                  }
                  dp1++;
                  dp2 = dp1;
               }
         }
      }

      return 0;


   /* Error handling */
      error6 : if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               if ( feof(fp) ) {
                  sprintfC(amatError, amatg_table[6], matrix->name, (int) matrix->nrow, 
                          (int) matrix->ncol, file->name, "End-Of-File reached."); 
               } else { 
                  sprintfC(amatError, amatg_table[6], matrix->name, (int) matrix->nrow, 
                          (int) matrix->ncol, file->name, strerror(errno));
               }
               return RET_ERR;

} /* End of  amatGetBIMatrix */



static int amatGetBRMatrix (AmatGetFile *file, Amatrix *matrix) {

   /* Read matrix-data from file. The data is stored as real matrix
      in Matlab binary format */

   /* Declarations */
      FILE       *fp;
      size_t      one=1, ii;
      integer     i, j;
      doublereal *dp1, *dp2;
      real       *rp1, *rp2, rp;
      integer    *ip1, *ip2;
      size_t      len;
 
	  if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
   /* Read numeric data of matrix from file */
      fp  = file->fp;
      len = (size_t) matrix->nrow * matrix->ncol;

      if ( file->bstruct == binNormal ) {  /* normal matrix structure */
         if ( matrix->type == realMatrix ) {
            /* get real matrix in column dense format as real matrix */
               if ( fread(matrix->data.r, sizeof(real), len, fp) != len ) goto error6;

         } else if ( matrix->type == integerMatrix ) {
            /* get real matrix in column dense format as integer matrix */
               ip1 = matrix->data.i;
               for ( ii=0; ii<len; ii++ ) {
                     if ( fread(&rp, sizeof(real), one, fp) != one ) goto error6;
                     *ip1++ = (integer) rp;
               }
		 } else if ( matrix->type == realRowMatrix) {
           /* get real matrix in column dense format as real row-stored matrix */
 			 for(j=0;j<matrix->ncol;j++) {
				 for(i=0;i<matrix->nrow;i++) {
					 if (fread(&rp,sizeof(real),one,fp) != one) goto error6;
					 matrix->data.rrow[i][j] = rp;
				 }
			 }
		 } else if ( matrix->type == doubleRowMatrix) {
           /* get real matrix in column dense format as doublereal row-stored matrix */
 			 for(j=0;j<matrix->ncol;j++) {
				 for(i=0;i<matrix->nrow;i++) {
					 if (fread(&rp,sizeof(real),one,fp) != one) goto error6;
					 matrix->data.drow[i][j] = rp;
				 }
			 }
         } else {
            /* get real matrix in column dense format as doublereal matrix */
               dp1 = matrix->data.d;
               for ( ii=0; ii<len; ii++ ) {
                     if ( fread(&rp, sizeof(real), one, fp) != one ) goto error6;
                     *dp1++ = (doublereal) rp;
               }
         }

      } else {    /* matrix has to be transposed */
         if ( matrix->type == realMatrix ) {
            /* get real matrix in row dense format as real matrix */
               rp1 = matrix->data.r;
               rp2 = rp1;
               for ( i=0; i<matrix->nrow; i++) {
                  for ( j=0; j<matrix->ncol; j++ ) {
                     if ( fread(rp2, sizeof(real), one, fp) != one ) goto error6;
                     rp2 += matrix->nrow;
                  }
                  rp1++;
                  rp2 = rp1;
               }

         } else if ( matrix->type == integerMatrix ) {
            /* get real matrix in row dense format as integer matrix */
               ip1 = matrix->data.i;
               ip2 = ip1;
               for ( i=0; i<matrix->nrow; i++) {
                  for ( j=0; j<matrix->ncol; j++ ) {
                     if ( fread(&rp, sizeof(real), one, fp) != one ) goto error6;
                     *ip2 =  (integer) rp;
                      ip2 += matrix->nrow;
                  }
                  ip1++;
                  ip2 = ip1;
               }
		 } else if (matrix->type == realRowMatrix || matrix->type == doubleRowMatrix) {
           /* get real matrix in row dense format as doublereal row-stored matrix */
			   real buffer[20];
			   real *mbuff;
			   integer readto=matrix->nrow;
			   integer offset=0;
			   if (matrix->nrowallocated<0) {
				   readto=-matrix->nrowallocated-1;
				   offset=readto-matrix->nrow;
			   }
			   for(i=matrix->nrowread;i<readto;i++) {
				  integer index=i-offset;if(index<0) index=0;
				  if (amatStopRequest!=0 && (*amatStopRequest)()) {
					goto error44;
				  }
				  if (matrix->type == realRowMatrix) {
					  for ( j=0; j<matrix->ncol; ) {
						  size_t todo = Dymola_min(matrix->ncol-j,sizeof(buffer)/sizeof(*buffer));
						  if ( fread(&buffer[0], sizeof(real), todo, fp) != todo ) goto error6;
						  for(mbuff=buffer;mbuff<buffer+todo;j++,mbuff++) {
							  matrix->data.rrow[index][j] = *mbuff;
						  }
					  }
				  } else {
					  /* doubleRowMatrix */
					  for ( j=0; j<matrix->ncol; ) {
						  size_t todo = Dymola_min(matrix->ncol-j,sizeof(buffer)/sizeof(*buffer));
						  if ( fread(&buffer[0], sizeof(real), todo, fp) != todo ) goto error6;
						  for(mbuff=buffer;mbuff<buffer+todo;j++,mbuff++) {
							  matrix->data.drow[index][j] = (doublereal) *mbuff;
						  }
					  }
				  }
               }
			   matrix->nrowread = i;
         } else {
            /* get real matrix in row dense format as doublereal matrix */
			   real buffer[20];
			   real *mbuff;
               dp1 = matrix->data.d;

               for ( i=0; i<matrix->nrow; i++) {
				  dp2 = dp1;
                  for ( j=0; j<matrix->ncol; ) {
					 size_t todo = Dymola_min(matrix->ncol-j,sizeof(buffer)/sizeof(*buffer));
                     if ( fread(&buffer[0], sizeof(real), todo, fp) != todo ) goto error6;
					 for(mbuff=buffer;mbuff<buffer+todo;j++,mbuff++) {
						*dp2 =  (doublereal) *mbuff;
						dp2 += matrix->nrow;
					 }
                  }
                  dp1++;
               }
         }
      }

      return 0;


   /* Error handling */
      error6 : 
               if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
               if ( feof(fp) ) {
                  sprintfC(amatError, amatg_table[6], matrix->name, (int) matrix->nrow, 
                          (int) matrix->ncol, file->name, "End-Of-File reached."); 
               } else { 
                  sprintfC(amatError, amatg_table[6], matrix->name, (int) matrix->nrow, 
                          (int) matrix->ncol, file->name, strerror(errno));
               }
               return RET_ERR;
	error44:
			   if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatg_table[44], file->name);
			   return RET_ERR;

} /* End of  amatGetBRMatrix */



static int amatGetBDMatrix (AmatGetFile *file, Amatrix *matrix){

   /* Read matrix-data from file. The data is stored as doublereal matrix
      in Matlab binary format */

   /* Declarations */
      FILE       *fp;
      size_t      one=1, ii;
      integer     i, j;
      doublereal *dp1, *dp2, dp;
      real       *rp1, *rp2;
      integer    *ip1, *ip2;
      size_t      len;

	  if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}

   /* Read numeric data of matrix from file */
      fp  = file->fp;
      len = (size_t) matrix->nrow * matrix->ncol;

      if ( file->bstruct == binNormal ) {  /* normal matrix structure */
         if ( matrix->type == doubleMatrix ) {
            /* get doublereal matrix in column dense format as doublereal matrix */
               if ( fread(matrix->data.d, sizeof(doublereal), len, fp) != len ) goto error6;

		 } else if (matrix->type == realRowMatrix) {
			 /* get a doublereal matrix in column dense format as a real row-stored matrix */
			 for(j=0;j<matrix->ncol;j++) {
				 for(i=0;i<matrix->nrow;i++) {
					 if (fread(&dp,sizeof(doublereal),one,fp) != one) goto error6;
					 matrix->data.rrow[i][j] = (real) dp;
				 }
			 }
		 } else if (matrix->type == doubleRowMatrix) {
			 /* get a doublereal matrix in column dense format as a doublereal row-stored matrix */
			 for(j=0;j<matrix->ncol;j++) {
				 for(i=0;i<matrix->nrow;i++) {
					 if (fread(&(matrix->data.drow[i][j]),sizeof(doublereal),one,fp) != one) goto error6;
				 }
			 }
         } else if ( matrix->type == realMatrix ) {
            /* get doublereal matrix in column dense format as real matrix */
               rp1 = matrix->data.r;
               for ( ii=0; ii<len; ii++ ) {
                     if ( fread(&dp, sizeof(doublereal), one, fp) != one ) goto error6;
                     *rp1++ = (real) dp;
               }

         } else {
            /* get doublereal matrix in column dense format as integer matrix */
               ip1 = matrix->data.i;
               for ( ii=0; ii<len; ii++ ) {
                     if ( fread(&dp, sizeof(doublereal), one, fp) != one ) goto error6;
                     *ip1++ = (integer) dp;
               }
         }

      } else {    /* matrix has to be transposed */
         if ( matrix->type == doubleMatrix ) {
            /* get doublereal matrix in row dense format as doublereal matrix */
			   doublereal buffer[20];
			   doublereal *mbuff;
               dp1 = matrix->data.d;

               for ( i=0; i<matrix->nrow; i++) {
				  dp2 = dp1;
                  for ( j=0; j<matrix->ncol;) {
					 size_t todo = Dymola_min(matrix->ncol-j,sizeof(buffer)/sizeof(*buffer));
                     if ( fread(&buffer[0], sizeof(doublereal), todo, fp) != todo ) goto error6;
					 for(mbuff=buffer;mbuff<buffer+todo;mbuff++,j++) {
						 *dp2 = *mbuff;
                         dp2 += matrix->nrow;
					 }
                  }
                  dp1++;
               }
         } else if ( matrix->type == realRowMatrix || matrix->type == doubleRowMatrix ) {
			 /* get a doublereal matrix in row dense format as a doublereal row-stored matrix */
			 /* no need to transpose */
			 integer readto=matrix->nrow;
			 integer offset=0;
			 if (matrix->nrowallocated<0) {
				 readto=-matrix->nrowallocated-1;
				 offset=readto-matrix->nrow;
			 }
			 if (matrix->type == realRowMatrix) {
				 for(i=matrix->nrowread;i<readto;i++) {
					 integer index=i-offset;if(index<0) index=0;
					 for (j=0;j<matrix->ncol;j++) {
						 if (fread(&dp,sizeof(doublereal), one, fp) != one ) goto error6;
						 matrix->data.drow[index][j] = (real) dp;
					 }
				 }
			 } else {
				 /* doubleRowMatrix */ 
				 for(i=matrix->nrowread;i<readto;i++) {
					 integer index=i-offset;if(index<0) index=0;
					 if (fread(matrix->data.drow[index],sizeof(doublereal), matrix->ncol, fp) != (size_t)(matrix->ncol) ) goto error6;
				 }
			 }
			 matrix->nrowread = i;
         } else if ( matrix->type == realMatrix ) {
            /* get doublereal matrix in row dense format as real matrix */
               rp1 = matrix->data.r;
               rp2 = rp1;
               for ( i=0; i<matrix->nrow; i++) {
                  for ( j=0; j<matrix->ncol; j++ ) {
                     if ( fread(&dp, sizeof(doublereal), one, fp) != one ) goto error6;
                     *rp2 =  (real) dp;
                      rp2 += matrix->nrow;
                  }
                  rp1++;
                  rp2 = rp1;
               }
         } else {
            /* get doublereal matrix in row dense format as integer matrix */
               ip1 = matrix->data.i;
               ip2 = ip1;
               for ( i=0; i<matrix->nrow; i++) {
                  for ( j=0; j<matrix->ncol; j++ ) {
                     if ( fread(&dp, sizeof(doublereal), one, fp) != one ) goto error6;
                     *ip2 =  (integer) dp;
                      ip2 += matrix->nrow;
                  }
                  ip1++;
                  ip2 = ip1;
               }
         }
      }

      return 0;


   /* Error handling */
      error6 : 
               if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
			   if ( feof(fp) ) {
                  sprintfC(amatError, amatg_table[6], matrix->name, (int) matrix->nrow, 
                          (int) matrix->ncol, file->name, "End-Of-File reached."); 
               } else { 
                  sprintfC(amatError, amatg_table[6], matrix->name, (int) matrix->nrow, 
                          (int) matrix->ncol, file->name, strerror(errno));
               }
               return RET_ERR;

} /* End of  BamatGetBDMatrix */



static int amatGetBText (AmatGetFile *file, Amatrix *matrix, int prec,int removeSpace){

   /* Read text matrix (Matlab binary format) from file */

   /* Declarations */
      FILE       *fp;
      size_t      one=1, lenTemp, lenTempByte, lenVec;
      size_t      lenStr, lenStrByte, len, lenmax, nrow, ncol;
      integer     i, j, ii;
      char       *textTemp, **textVec, *str;
      char       *p, **pVec, *pTemp, *pStr;
      doublereal  dp;

	  if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
   /* Check for type of text matrix */
      if ( !(prec==0 || prec==5) ) goto error8;

   /* Initialize output data */
      textTemp = NULL;
      textVec  = matrix->data.c;
      lenVec   = (size_t) matrix->nrow;
      nrow     = (size_t) matrix->nrow;
      ncol     = (size_t) matrix->ncol;
      fp       = file->fp;

   /* Read matrix from file */
      if ( file->bstruct == binNormal ) {  /* normal matrix structure */
         /* Read full matrix temporarily */

         /* Allocate storage for temporary text matrix */
            lenTemp     = (size_t) nrow * ncol;
            lenTempByte = lenTemp * sizeof( char );
			textTemp    = (char *) malloc( lenTempByte?lenTempByte:1 ); /* Avoid null-size */
            if ( textTemp == NULL ) {len = lenTemp; goto error13;}

         /* Read text matrix from file */
            if ( prec == 5 ) {
               /* text stored as character */
                  if ( fread(textTemp, one, lenTempByte, fp) != lenTempByte ) {
                     free(textTemp);
                     goto error14;
                  }
            } else {
               /* text stored as doublereal */
                  p = textTemp; 
                  for (i=0; i<(integer) lenTemp; i++) {
                     if ( fread(&dp, sizeof(doublereal), one, fp) != one ) {
                        free(textTemp);
                        goto error14;
                     }
                     *p++ = (char) dp;
                  }
            }
      }

      /* Allocate storage for string with maximum length + 1 */
         lenStr     = (size_t) ( ncol + 1 );
         lenStrByte = lenStr * sizeof( char );
         str        = (char *) malloc( lenStrByte );
         if ( str == NULL ) {
            free(textTemp);
            len = lenStr;
            goto error13;
         }
 
      /* Initialize text pointer vector with NULL */
         for (i=0; i<(integer) lenVec; i++) textVec[i] = NULL;

      /* Read text */
         pVec   = textVec;
         pTemp  = textTemp;
         lenmax = 0;
         for ( i=0; i<(integer) nrow; i++) {
            /* Read next string into temporary storage "str" */
               if ( file->bstruct == binNormal ) {
                  pStr = str;
                  p    = pTemp;
                  for ( j=0; j<(integer) ncol; j++ ) {
                      *pStr++ = *p;
                       p += nrow;
                  }
                  pTemp++;

               } else {
                  if ( prec == 5 ) {
                     /* text stored as character */
                        if ( fread(str, sizeof(char), ncol, fp) != ncol ) {
                           for (ii=0; ii<(integer) lenVec; ii++) free(textVec[ii]);
                           free(textTemp);
                           free(str);
                           goto error14;
                        }
                  } else {
                     /* text stored as doublereal */
                        p = str;
                        for (j=0; j<(integer) ncol; j++) {
                           if ( fread(&dp, sizeof(doublereal), one, fp) != one ) {
                              for (ii=0; ii<(integer) lenVec; ii++) free(textVec[ii]);
                              free(textTemp);
                              free(str);
                              goto error14;
                           }
                           *p++ = (char) dp;
                        }
                  }
               }
         
            /* Remove trailing blanks and determine length of string */
               len = 0;
               for ( j=ncol-1; j>=0; j--) {
				  if ( removeSpace ? (isspaceC(((unsigned char*)str)[j]) == 0) : (str[j]!='\0') ) {
                     len = j + 1;               /* length of string without '\0' */
                     break;
                  }
               }

            /* Allocate storage for string and copy string into storage */
              if ( len > 0ul ) {
                  p = (char *) malloc( (size_t) (len+1)*sizeof(char) );
                  if ( p == NULL ) {
                     for (ii=0; ii<(integer) lenVec; ii++) free(textVec[ii]);
                     free(textTemp);
                     free(str);
                     len = len+1;
                     goto error13;
                  }
                  str[len] = '\0';
                  *pVec = strcpy(p, str);
               }
               pVec++;
               lenmax = Dymola_max(len,lenmax);
         }      

         free(str);
         free(textTemp);
         matrix->ncol = (integer) lenmax;

      return 0;


   /* Error handling */
      error8  : 
                if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
				sprintfC(amatError, amatg_table[8], prec, matrix->name, 
                        (int) matrix->nrow, (int) matrix->ncol, file->name);
                return RET_ERR;

      error13 : 
                if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
				sprintfC(amatError, amatg_table[13], matrix->name, (int) matrix->nrow, 
                        (int) matrix->ncol, file->name, (int) len);
                return RET_ERR;

      error14 : 
                if (!file||!matrix)  {amatUnexpectedNull(); return RET_ERR;}
				if ( feof(fp) ) {
                   sprintfC(amatError, amatg_table[14], matrix->name, (int) matrix->nrow, 
                           (int) matrix->ncol,  file->name, "End-Of-File reached."); 
                } else { 
                   sprintfC(amatError, amatg_table[14], matrix->name, (int) matrix->nrow, 
                           (int) matrix->ncol, file->name, strerror(errno));
                }
                return RET_ERR;

} /* End of  amatGetBText */



static int amatGetSkip(AmatGetFile *file) {

   /* Skip blanks, tabs and comments
      <- RETURN: = 0: no error occured.
                 = 3: EOF occured.
                 = 4: other error occured.
   */

      FILE *fp;
      int   ch;
	  if (!file)  {amatUnexpectedNull(); return RET_ERR;}
      fp = file->fp;
      while(1) {
         /* Read next character */
            if ( (ch = getc(fp)) == EOF ) goto error0;

         /* If character = blank, tab, newline then read next character */
            if ( isspaceC(ch) ) continue;

         /* If character = '#' then skip characters upto newline,
            otherwise break loop */
            if ( ch == '#' ) {
               do {
                  if ( (ch = getc(fp)) == EOF ) goto error0;
               } while ( ch != '\n' );
            } else {
               if ( ungetc(ch, fp) == EOF ) goto error0;
               break;
            }
      }
      return 0;

   /* Error handling */
      error0 : 
               if (!file)  {amatUnexpectedNull(); return RET_ERR;}
			   if ( feof(fp) != 0 ) { 
                  sprintfC(amatError, amatg_table[0], file->name, "End-of-File reached");
                  return RET_EOF;
               } else {
                  sprintfC(amatError, amatg_table[0], file->name, strerror(errno));
                  return RET_ERR;
               }

} /* End of  amatGetSkip */







static int amatPutFImatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const integer     data[], const char *matDescr, const char *const elemDescr[], int nblank);
static int amatPutFRmatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const real        data[], const char *matDescr, const char *const elemDescr[], int nblank);
static int amatPutFRmatrix2(AmatPutFile *file, const char *name, integer nrow, integer ncol, const Amatrix     matrix, const char *matDescr, const char *const elemDescr[], int nblank);
static int amatPutFDmatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const doublereal  data[], const char *matDescr, const char *const elemDescr[], int nblank);
static int amatPutFDmatrix2(AmatPutFile *file, const char *name, integer nrow, integer ncol, const Amatrix     matrix, const char *matDescr, const char *const elemDescr[], int nblank);
static int amatPutFCmatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const char       *const data[], const char *matDescr);
static int amatPutFRinit   (AmatPutFile *file);
static int amatPutFRclose  (AmatPutFile *file);
static int amatPutFRreal   (AmatPutFile *file, const real row[]);
static int amatPutFRdouble (AmatPutFile *file, const doublereal row[]);

static int amatPutBImatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const integer     data[]);
static int amatPutBRmatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const real        data[]);
static int amatPutBRmatrix2(AmatPutFile *file, const char *name, integer nrow, integer ncol, Amatrix     matrix);
static int amatPutBDmatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const doublereal  data[]);
static int amatPutBDmatrix2(AmatPutFile *file, const char *name, integer nrow, integer ncol, Amatrix     matrix);
static int amatPutBCmatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const char       *const data[], char padUsing);
static int amatPutBRinit   (AmatPutFile *file);
static int amatPutBRclose  (AmatPutFile *file);


/* Error messages */
   static const char *const amatp_table[] = {
      /* 0 */   "Error opening file \"%.400s\": %.400s, please make sure it is a valid file name and the running process have write access to the current working directory\n"
      /* 1 */  ,"Error writing class description of class \"%.400s\" to\n"
                "file \"%.400s\":\n%.400s\n"
      /* 2 */  ,"Error should never occur when writing matrix \"%.400s(%d,%d)\" to\n"
                "file \"%.400s\" (matrix.type = %d)\n"
      /* 3 */  ,"Error when writing matrix \"%.400s(%d,%d)\" to file \"%.400s\":\n%.400s\n"
      /* 4 */  ,"Error should never occur when writing matrix \"%.400s\" to\n"
                "file \"%.400s\" (file.format = %d)\n"
      /* 5 */  ,"Not possible to allocate enough storage in order to open\n"
                "file \"%.400s\" for writing of matrices:\n%.400s\n"
      /* 6 */  ,"Not possible to allocate enough storage in order to open\n"
                "file \"%.400s\" for writing of matrix \"%.400s\":\n%.400s\n"
      /* 7 */  ,"Wrong argument \"type\" (= %d) in function amatPutRinit,\n"
                "when initializing writing of matrix \"%.400s\" to file \"%.400s\".\n"
                "(type = realMatrix or doubleMatrix required).\n"
      /* 8 */  ,"Error when writing matrix \"%.400s\" row-wise to file \"%.400s\":\n%.400s\n"
      /* 9 */  ,"In order to write matrix \"%.400s\" row-wise to file \"%.400s\",\n"
                "the file has to be opened with \"bstruct = binTrans\" and not\n"
                "with \"bstruct = binNormal\" (function amatPutOpen).\n"
     /* 10 */  ,"Error when writing row %d of matrix \"%.400s\" row-wise\n"
                "to file \"%.400s\": %.400s\n"
     /* 11 */  ,"Error when writing matrix \"%.400s(%d,%d)\" to file \"%.400s\":\n"
                "The datatype of the matrix is not specified (matrix.type = voidMatrix).\n"
     /* 12 */  ,"Not possible to use functions amatPutRxxx, in order to write\n"
               ,"matrix \"%.400s\" row-wise, because output stream is no file, but stdout.\n"
	 /* 13 */  ,"%s is not of type double{Row}matrix"
   };



int amatWrite (char *fileName, AmatFileType ftype, Amatrix matrix) {
 
   /* Write matrix to file */
      AmatPutFile file;
      if ( amatPutOpen   (fileName, ftype, binNormal, "", "", "", &file) != 0 ) return 1;
      if ( amatPutMatrix (&file, matrix) != 0 ) { amatPutClose(&file); return 1; }
      amatPutClose(&file);
      return 0;

} /* End of  amatWrite */




int amatWriteAll (const char *fileName, AmatFileType ftype, char *className,
                  char *version, char *descr, AclassWrite c[], integer dim_c) {

   /* Declarations */
      AmatPutFile file;
      integer     i;

   /* Open file */
      if ( amatPutOpen(fileName, ftype, binNormal, className, version, descr, &file) != 0 ) return 1;

   /* Write matrices to file */
      for (i=0; i<dim_c; i++) {
         if ( amatPutMatrixD(&file, *(c[i].matrix), c[i].matDescr, c[i].elemDescr, c[i].nblank) != 0 ) {
            /* Error */
               amatPutClose(&file);
               return 1;
         }
      }

   /* Close file */
      amatPutClose(&file);
      return 0;

} /* End of  amatWriteAll */


static const fpos_t null_fpos;
/* Needed for initialization.*/

int amatPutOpen (const char *fileName, AmatFileType format, AmatBinStruct bstruct,
				 char *className,  char *version, char *descr, AmatPutFile *file){
   
   /* Open file for writing of matrices */
   
   /* Declarations */
      FILE      *fp;
      const char      *mode;
      Amatrix    classmat;
      char      * classdata[4];
      size_t     len;

	  if (!file)  {amatUnexpectedNull(); return RET_ERR;}

   /* Initialize file */
      file->fp      = NULL;
      file->format  = format;
      file->bstruct = binNormal;
      file->matName = NULL;
      file->posHead = null_fpos;
	  file->posEndTime = null_fpos;
	  file->updateEnd = 0;
      file->type    = voidMatrix;
      file->ncol    = 0;
      file->nrowAct = 0;
      file->noRow   = 0;

   /* Determine file mode */
      if ( format == amatBinary ) mode = "wb";
      else                        mode = "w";

   /* Open file */
      if ( fileName == NULL || fileName[0] == '\0' ) {
         /* use stdout */
            fp = stdout;
      } else {
         if ( (fp = fopen(fileName, mode)) == NULL ) goto error0;
         file->noRow = 1;
      }
      file->fp = fp;    

   /* Allocate storage for file-name and store it in "file" */
      if ( fp != stdout ) {
         len = strlen(fileName) + 1;
         file->name = (char *) malloc( len*sizeof(char) );
         if ( file->name == NULL ) goto error5;
         strcpy( file->name, fileName );
      } else {
         file->name = NULL;
      }

   /* Define class */

   /* Write file version number to file, in case of ASCII file format */
      if ( format == amatASCII ) {
         if ( fprintfC(fp,"#1\n") < 0 ) goto error1;
      }

   /* Write class description to file (always with bstruct=binNormal) */
      if ( className != NULL && className[0] != '\0' ) {
         classmat.name   = "Aclass";
         classmat.nrow   = (format == amatASCII) ? 3 : 4;
         classmat.ncol   = 0;
         classmat.type   = charMatrix;
         classmat.data.c = classdata;
         classdata[0]    = className;
         classdata[1]    = version ? version : " ";
         classdata[2]    = descr   ? descr   : " ";
         classdata[3]    = (bstruct == binNormal) ? "binNormal" : "binTrans";
         if ( amatPutMatrix(file, classmat) != 0 ) goto error1;
      }

   /* Set bstruct for next writing of matrices */
      file->bstruct = bstruct;
   
   return 0;

   /* Error handling */ 
      error0: sprintfC(amatError, amatp_table[0], fileName, strerror(errno));
              return 1;

      error1: sprintfC(amatError, amatp_table[1], className, fileName, strerror(errno));
              amatPutClose(file);
              return 1;

      error5: sprintfC(amatError, amatp_table[5], fileName, strerror(errno));
              fclose(fp);
              return 1;

} /* End of  amatPutOpen */



void amatPutClose (AmatPutFile *file) {

   /* Close file */

   if (file && file->fp != NULL ) {
      fclose(file->fp);
      free(file->name);
      free(file->matName);
      file->fp      = NULL;
      file->name    = NULL;
      file->matName = NULL;
   }
}


void amatPutConnect(FILE *fp, char *fileName, AmatPutFile *file) {
	if (!file)  {amatUnexpectedNull(); return;}
   /* Connect AmatPut stream to an open ASCII file stream */
      file->name    = fileName;
      file->fp      = fp;
      file->format  = amatASCII;
      file->bstruct = binNormal;
      file->noRow   = 0;
      file->matName = NULL;
}



static int amatPutMatrixD2(AmatPutFile* file, Amatrix matrix, const char*matDescr, const char*const elemDescr[],int nblank,char padUsing) {
   /* Write matrix on file "file" including a description text */
	  if (!file)  {amatUnexpectedNull(); return RET_ERR;}

      if ( file->format == amatASCII ) {
         /* Write matrix in ASCII format */ 
            switch ( matrix.type ) {
               case voidMatrix   : goto error11;
               case integerMatrix:  return amatPutFImatrix (file, matrix.name, matrix.nrow, matrix.ncol, matrix.data.i, matDescr, elemDescr, nblank);
               case realMatrix   :  return amatPutFRmatrix (file, matrix.name, matrix.nrow, matrix.ncol, matrix.data.r, matDescr, elemDescr, nblank);
               case doubleMatrix :  return amatPutFDmatrix (file, matrix.name, matrix.nrow, matrix.ncol, matrix.data.d, matDescr, elemDescr, nblank);
               case charMatrix   :  return amatPutFCmatrix (file, matrix.name, matrix.nrow, matrix.ncol, (const char   *const*)(matrix.data.c), matDescr); /* cast-away? */
			   case realRowMatrix:  return amatPutFRmatrix2(file, matrix.name, matrix.nrow, matrix.ncol, matrix,matDescr,elemDescr,nblank);
			   case doubleRowMatrix:return amatPutFDmatrix2(file, matrix.name, matrix.nrow, matrix.ncol, matrix,matDescr,elemDescr,nblank);
               default           : goto error2;
            }

      } else {
         /* Write matrix in binary format */
            switch ( matrix.type ) {
               case voidMatrix   : goto error11;
               case integerMatrix:  return amatPutBImatrix (file, matrix.name, matrix.nrow, matrix.ncol, matrix.data.i);
               case realMatrix   :  return amatPutBRmatrix (file, matrix.name, matrix.nrow, matrix.ncol, matrix.data.r);
               case doubleMatrix :  return amatPutBDmatrix (file, matrix.name, matrix.nrow, matrix.ncol, matrix.data.d);
               case charMatrix   :  return amatPutBCmatrix (file, matrix.name, matrix.nrow, matrix.ncol, (const char   *const*)(matrix.data.c),padUsing); /* cast-away? */
			   case realRowMatrix:  return amatPutBRmatrix2(file, matrix.name, matrix.nrow, matrix.ncol, matrix);
			   case doubleRowMatrix:return amatPutBDmatrix2(file, matrix.name, matrix.nrow, matrix.ncol, matrix);
               default           : goto error2;
            }
      } 

   /* Error handling */ 
      error2:  
               if (!file)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[2], matrix.name, (int) matrix.nrow,
                       (int) matrix.ncol, file->name, (int) matrix.type);
               return 1;

      error11: 
               if (!file)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[11], matrix.name, (int) matrix.nrow,
                       (int) matrix.ncol, file->name);
               return 1;

} /* End of  amatPutMatrixD2 */

int amatPutMatrixD (AmatPutFile *file, Amatrix matrix, const char *matDescr, const char *const elemDescr[], int nblank) {
	return amatPutMatrixD2(file,matrix,matDescr,elemDescr,nblank,' ');
}




int amatPutMatrix (AmatPutFile *file, Amatrix matrix) {

   /* Write matrix to file */
      char *s1;
      const char *const*s2;
      s1 = NULL;
      s2 = NULL;
      return amatPutMatrixD (file, matrix, s1, s2, 0);
}

int amatPutMatrixPadding (AmatPutFile *file, Amatrix matrix,char padForText) {

   /* Write matrix to file */
      char *s1;
      const char *const*s2;
      s1 = NULL;
      s2 = NULL;
      return amatPutMatrixD2 (file, matrix, s1, s2, 0, padForText);
}



int amatPutRinit (AmatPutFile *file, const char *name, integer ncol, AmatType type) {
   
   /* Initialize writing of numeric matrix row-wise to file */

   /* Declarations */
      size_t len;

	  if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
   /* Check arguments */
      if ( file->noRow == 0 ) goto error12;
      assumption(ncol > 0);
	  /* Should not store as RowMatrix*/
	  if (type == realRowMatrix) {
		  type = realMatrix;
	  } else if (type == doubleRowMatrix) {
		  type = doubleMatrix;
	  } 
      if ( type != realMatrix && type != doubleMatrix) goto error7;
      if ( file->bstruct != binTrans ) goto error9;

   /* Store matrix name in "file" (for error messages) */
      len = strlen(name) + 1;
      file->matName = (char *) malloc( len*sizeof(char) );
      if ( file->matName == NULL ) goto error6;
      strcpy( file->matName, name );

   /* Initialize common data */
      file->type    = type;
      file->ncol    = ncol;
      file->nrowAct = 0;

   /* Initialize header and write header to file */
      switch ( file->format ) {
         case amatASCII : return amatPutFRinit (file);
         case amatBinary: return amatPutBRinit (file);
         default        : goto error4;
      }

   /* Error handling */
      error4:  
               if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[4], name, file->name, (int) file->format);
               return 1;

      error6:  
               if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[6], file->name, name, strerror(errno));
               return 1;

      error7:  
               if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[7], type, name, file->name);
               return 1;

      error9:  
               if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[9], name, file->name);
               return 1;

      error12: 
               if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[12], name);
               return 1;

} /* End of  amatPutRinit */



int amatPutRclose (AmatPutFile *file) {

   /* Close row-wise writing of matrix */
	  if (!file)  {return 0;}
      if ( !file->fp ) return 0;

      switch ( file->format ) {
         case amatASCII : if ( putc('\n', file->fp) == EOF ) goto error8;
                          free(file->matName);
                          file->matName = NULL;
                          return amatPutFRclose(file);
         case amatBinary: free(file->matName);
                          file->matName = NULL;
                          return amatPutBRclose(file);
         default        : goto error4;
      }

   /* Error handling */
      error4: if (file) sprintfC(amatError, amatp_table[4], file->matName, file->name, (int) file->format);
              return 1;

      error8: if (file) sprintfC(amatError, amatp_table[8], file->matName, file->name,
                      strerror(errno));
              return 1;

} /* End of  amatPutRclose */


#define ALLOW_READING_OF_DATA_DURING_SIMULATION 1
int amatPutRreal (AmatPutFile *file, const real row[]) {

   /* Write row of real matrix to file */
      size_t nrow;
	  
	  if (!file)  {amatUnexpectedNull(); return RET_ERR;}

      switch ( file->format ) {
	     case amatASCII : {
							int res=amatPutFRreal(file, row);
							if (res==0) {
#if ALLOW_READING_OF_DATA_DURING_SIMULATION
								amatPutFRclose(file);
								fflush(file->fp);
#endif
							}
							return res;
						  }
         case amatBinary: nrow = file->x.mrows;
                          if ( fwrite(row, sizeof(real), nrow, file->fp) != nrow ) goto error10;
                          file->x.ncols++;
#if ALLOW_READING_OF_DATA_DURING_SIMULATION
						  amatPutBRclose(file);
						  fflush(file->fp);
#endif
                          return 0;
         default        : goto error4;
      }

   /* Error handling */
      error4 : 
               if (!file)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[4], file->matName, file->name, (int) file->format);
               return 1;

      error10: 
               if (!file)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[10], file->x.ncols+1, file->matName, file->name,
                       strerror(errno));
               return 1;

} /* End of  matPutRreal */



int amatPutRdouble (AmatPutFile *file, const doublereal row[]) {

   /* Write row of doublereal matrix to file */
      size_t nrow;

	  if (!file)  {amatUnexpectedNull(); return RET_ERR;}

      switch ( file->format ) {
	     case amatASCII : {
							int res=amatPutFRdouble(file, row);
							if (res==0)  {
#if ALLOW_READING_OF_DATA_DURING_SIMULATION
								amatPutFRclose(file);
								fflush(file->fp);
#endif
							}
							return res;
						  }
         case amatBinary: nrow = file->x.mrows;
                          if ( fwrite(row, sizeof(doublereal), nrow, file->fp) != nrow ) goto error10;
                          file->x.ncols++;
#if ALLOW_READING_OF_DATA_DURING_SIMULATION
						  amatPutBRclose(file);
						  fflush(file->fp);
#endif
                          return 0;
         default        : goto error4;
      }

   /* Error handling */
      error4 : 
               if (!file)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[4], file->matName, file->name, (int) file->format);
               return 1;

      error10: 
               if (!file)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[10], file->x.ncols+1, file->matName, file->name,
                       strerror(errno));
               return 1;

} /* End of  matPutRdouble */



/* Procedures for formatted output ..........................................*/

static int writeStringAndPossiblyEndl(FILE*fp,const char*s,int endLine,int quoteIfNeeded) {
	/* Return <0 if error */
	int anyQuoteNeeded=0;
	int i;
	if (quoteIfNeeded) for(i=0;s[i];++i) {
		if (s[i]=='\\' || s[i]=='\n') anyQuoteNeeded=1;
	}
	if (anyQuoteNeeded) {
		for(i=0;s[i];++i) {
			switch(s[i]) {
			case '\\':fprintf(fp,"\\\\");break;
			case '\n':fprintf(fp,"\\n");break;
			default:fprintf(fp,"%c",s[i]);break;
			}
		}
		if (endLine) return fprintf(fp,"\n");
		return 1;
	}
	return fprintfC(fp,endLine?"%s\n":"%s",s);
}

static int amatPutFImatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const integer data[],
                            const char *matDescr, const char *const elemDescr[], int nblank) {

   /* Write integer matrix in formatted form on file */

   /* Declarations */
      FILE    *fp;
      const integer *p, *prow;
      integer  i, j, nb;
      integer  imax;
      int      sign, digits, k;
      char     fmt[20];

	  if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}

   /* Assertions */
      assumption(nrow >= 0);
      assumption(ncol >= 0);

   /* Write matrix type, name and dimensions to file */
      fp = file->fp;
      if ( matDescr!=NULL && matDescr[0]!='\0' ) { if ( fprintfC(fp, "%s\n", matDescr) < 0 ) goto error3; }
      if ( fprintfC(fp,"int %s(%d,%d)\n", name, (int) nrow, (int) ncol) < 0 ) goto error3;

   /* Determine biggest element of matrix */
      imax = 0;
      sign = 0;
      for (i=0; i<nrow*ncol; i++) {
         if ( Dymola_abs(data[i]) > imax ) imax = Dymola_abs(data[i]);
         if ( data[i] < 0 ) sign = 1;
      }

   /* Determine number of digits of maximal element (+ optionally sign) */
      digits = 1 + sign;
      while( imax > 9) {
         imax = imax/10;
         digits++;
      }

   /* Build format */
      sprintfC(fmt," %%%dd", digits);

   /* Write matrix data to file */
      p    = data;
      prow = data;
      for (i=0; i<nrow; i++) {
         k = 1;
         for (j=0; j<ncol; j++) {
             if ( fprintfC(fp, fmt, (int) *p) < 0 ) goto error3;
             p += nrow;
             k++;
             /* insert a new-line after a certain amount of numbers */
                if ( (k > 7) && (j < ncol-1) ) {
                   k = 1;
                   if ( fprintfC(fp,"\n    ") < 0 ) goto error3;
                }
         }
         if ( elemDescr != NULL ) { 
            if ( nblank > 0 ) {
               nb = nblank;
               while( --nb ) {if ( putc(' ', fp) == EOF ) goto error3;}
               if ( fputs("# ", fp) == EOF ) goto error3; 
            }
            if ( writeStringAndPossiblyEndl(fp, elemDescr[i],0,nblank>0) <0) goto error3;
         }
         if ( fprintfC(fp,"\n") < 0 ) goto error3;
         prow++;
         p = prow;
      }

   if ( putc('\n',fp) == EOF ) goto error3;
   return 0;

   /* Error handling */
      error3: 
              if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) ncol,
                      file->name, strerror(errno));
              return 1;

} /* End of  amatPutFImatrix */



static int amatPutFRmatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const real data[],
                            const char *matDescr, const char *const elemDescr[], int nblank) {

   /* Write real matrix in formatted form on file */

   /* Declarations */
      FILE    *fp;
      const real    *p, *prow;
	  real pr;
      integer  i, j, nb;
      double   pg;
      int      k;

	  if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
   /* Assertions */
      assumption(nrow >= 0);
      assumption(ncol >= 0);

   /* Write matrix type, name and dimensions to file */
      fp = file->fp;
      if ( matDescr!=NULL && matDescr[0]!='\0' ) { if ( fprintfC(fp, "%s\n", matDescr) < 0 ) goto error3; }
      if ( fprintfC(fp,"float %s(%d,%d)\n", name, (int) nrow, (int) ncol) < 0 ) goto error3;

   /* Write matrix data to file */
      p    = data;
      prow = data;
      for (i=0; i<nrow; i++) {
         k = 1;
         for (j=0; j<ncol; j++) {
             /* Check whether number is an integer number and in the range -100 000 ...100 000 */
			    double x=*p;
			    if (x>=FLT_MAX) {
					x=FLT_MAX;
				} else if (x<=-FLT_MAX) {
					x=-FLT_MAX;
				}
                pr = (real) modf((double) x, &pg);
	            if ( pr == 0.0 && pg >=-100000.0 && pg <= 100000.0) {
                   if ( fprintfC(fp," %7d       ", (int) x) < 0 ) goto error3;
                } else {
                   if ( fprintfC(fp," %14.7E", (double) x) < 0 ) goto error3;
                }
             p += nrow;
             k++;
             /* insert a new-line after a certain amount of numbers */
                if ( (k > 5) && (j < ncol-1) ) {
                   k = 1;
                   if ( fprintfC(fp,"\n    ") < 0 ) goto error3;
                }
         }
         if ( elemDescr != NULL ) { 
            if ( nblank > 0 ) {
               nb = nblank;
               while( --nb ) {if ( putc(' ', fp) == EOF ) goto error3;}
               if ( fputs("# ", fp) == EOF ) goto error3; 
            }
            if ( writeStringAndPossiblyEndl(fp, elemDescr[i],0,nblank>0) < 0 ) goto error3;
         }
         if ( fprintfC(fp,"\n") < 0 ) goto error3;
         prow++;
         p = prow;
      }

   if ( putc('\n',fp) == EOF ) goto error3;
   return 0;

   /* Error handling */
      error3: 
              if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) ncol,
                      file->name, strerror(errno));
              return 1;

} /* End of  amatPutFRmatrix */

static int amatPutFRmatrix2 (AmatPutFile *file, const char *name, integer nrow, integer ncol, const Amatrix matrix,
                            const char *matDescr, const char *const elemDescr[], int nblank) {

   /* Write real matrix in formatted form on file */

   /* Declarations */
      FILE    *fp;
	  real pr;
      integer  i, j, nb;
	  int      isRowFormat = (matrix.type == realRowMatrix);
      double   pg;
      int      k;

	  if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
   /* Assertions */
      assumption(nrow >= 0);
      assumption(ncol >= 0);

   /* Write matrix type, name and dimensions to file */
      fp = file->fp;
      if ( matDescr!=NULL && matDescr[0]!='\0' ) { if ( fprintfC(fp, "%s\n", matDescr) < 0 ) goto error3; }
      if ( fprintfC(fp,"float %s(%d,%d)\n", name, (int) nrow, (int) ncol) < 0 ) goto error3;

   /* Write matrix data to file */
      for (i=0; i<nrow; i++) {
         k = 1;
         for (j=0; j<ncol; j++) {
			 double x;
             /* Check whether number is an integer number and in the range -100 000 ...100 000 */
			 if (isRowFormat) {
				 x = matrix.data.rrow[i][j];
			 } else {
				 x = matrix.data.r[j*nrow+i];
			 }
			 if (x>=FLT_MAX) {
				 x=FLT_MAX;
			 } else if (x<=-FLT_MAX) {
				 x=-FLT_MAX;
			 }
			 pr = (real) modf(x, &pg);
			 if ( pr == 0.0 && pg >=-100000.0 && pg <= 100000.0) {
				 if ( fprintfC(fp," %7d       ", (int) x) < 0 ) goto error3;
			 } else {
				 if ( fprintfC(fp," %14.7E", x) < 0 ) goto error3;
			 }
			 k++;
			 /* insert a new-line after a certain amount of numbers */
			 if ( (k > 5) && (j < ncol-1) ) {
				 k = 1;
				 if ( fprintfC(fp,"\n    ") < 0 ) goto error3;
			 }
		 }
         if ( elemDescr != NULL ) { 
            if ( nblank > 0 ) {
               nb = nblank;
               while( --nb ) {if ( putc(' ', fp) == EOF ) goto error3;}
               if ( fputs("# ", fp) == EOF ) goto error3; 
            }
            if ( writeStringAndPossiblyEndl(fp, elemDescr[i],0,nblank>0) < 0 ) goto error3;
         }
         if ( fprintfC(fp,"\n") < 0 ) goto error3;
      }

   if ( putc('\n',fp) == EOF ) goto error3;
   return 0;

   /* Error handling */
      error3: 
              if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) ncol,
                      file->name, strerror(errno));
              return 1;

} /* End of  amatPutFRmatrix2 */


static int amatPutFDmatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const doublereal data[],
							 const char *matDescr, const char *const elemDescr[], int nblank) {

   /* Write doublereal matrix in formatted form on file */

   /* Declarations */
      FILE      *fp;
      const doublereal *p, *prow;
      integer     i, j, nb, ndigit, nnum;
      doublereal  pr;
      double      pg;
      int         k;
      int        *type=NULL;
      char        str[10];

	  if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}

   /* Assertions */
      assumption(nrow >= 0);
      assumption(ncol >= 0);

   /* Write matrix type, name and dimensions to file */
      fp = file->fp;
      if ( matDescr!=NULL && matDescr[0]!='\0' ) { if ( fprintfC(fp, "%s\n", matDescr) < 0 ) goto error3; }
      if ( fprintfC(fp,"double %s(%d,%d)\n", name, (int) nrow, (int) ncol) < 0 ) goto error3;

   /* Allocate storage for an integer vector with ncol elements and
      initialize vector with 0 (= column of double numbers).
      This vector is used to produce nicer output.
   */
      type = (int *) calloc( (size_t) ncol, sizeof(int) );
      if ( type == NULL ) goto error3b;

   /* Determine, whether a column of the matrix contains only integer
      numbers and if this is the case, store the number of digits
      in the type vector
   */
      for (j=0; j<ncol; j++) {
         p = data + j*nrow;
         for (i=0; i<nrow; i++) {
            pr = modf(*p, &pg); 
            if ( pr != 0.0 ) {
               /* number is a double number */
                  type[j] = 0;
                  break;
            } else {
               /* number is an integer number */
                  pg     = fabs(pg);
                  ndigit =  1;
                  nnum   = 10;
                  for (k=0; k<8; k++) {
                     if ( pg < nnum ) {
                        type[j] = type[j] > ndigit ? type[j] : ndigit;
                        break;
                     }
                     ndigit++;
                     nnum *= 10;
                  }
                  if ( ndigit >= 8 ) {
                     type[j] = 0;
                     break;
                  }
            }
            p++;
         }
      }
   
   /* Write matrix data to file */
      p    = data;
      prow = data;
      for (i=0; i<nrow; i++) {
         k = 0;
         for (j=0; j<ncol; j++) {
			 double x=*p;
			 if (x>=DBL_MAX) {
				x=DBL_MAX;
			} else if (x<=-DBL_MAX) {
				x= -DBL_MAX;
			}
             /* If column contains only integers, write an integer */
                if ( type[j] > 0 ) {
                   /* write maximum number of digits of column in string */
                      sprintfC(str," %%%dd", type[j]+1);
                   if ( fprintfC(fp, str, (int) x) < 0 ) goto error3;
                   k = k+type[j]+2;
                } else {
                   /* check, whether number is an integer number */
                      pr = modf(x, &pg);
                      if ( pr == 0.0 && pg >=-100000.0 && pg <= 100000.0) {
                         if ( fprintfC(fp," %7d                ", (int) x) < 0 ) goto error3;
                      } else { 
                         if ( fprintfC(fp," %23.16E", (double) x) < 0 ) goto error3;
                      }
                      k = k+24;
                }
             p += nrow;
             /* insert a new-line after a certain amount of numbers */
                if ( (k > 70) && (j < ncol-1) ) {
                   k = 0;
                   if ( fprintfC(fp,"\n") < 0 ) goto error3;
                }
         }
         if ( elemDescr != NULL ) { 
            if ( nblank > 0 ) {
               nb = nblank;
               while( --nb ) {if ( putc(' ', fp) == EOF ) goto error3;}
               if ( fputs("# ", fp) == EOF ) goto error3; 
            }
            if ( writeStringAndPossiblyEndl(fp, elemDescr[i],0,nblank>0) < 0 ) goto error3;
         }
         if ( fprintfC(fp,"\n") < 0 ) goto error3;
         prow++;
         p = prow;
      }

   if ( putc('\n',fp) == EOF ) goto error3;
   free(type);
   return 0;

   /* Error handling */
      error3 : 
               if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) ncol,
                       file->name, strerror(errno));
               free(type);
               return 1;

      error3b: 
               if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) ncol,
                       file->name, "not enough memory\n");
               return 1;

} /* End of  amatPutFDmatrix */

static int amatPutFDmatrix2 (AmatPutFile *file, const char *name, integer nrow, integer ncol, const Amatrix matrix, 
                            const char *matDescr, const char *const elemDescr[], int nblank) {

   /* Write doublereal matrix in formatted form on file */

   /* Declarations */
      FILE      *fp;
	  double pstar;
      integer     i, j, nb, ndigit, nnum;
      doublereal  pr;
	  int         isRowFormat = (matrix.type == doubleRowMatrix);
      double      pg;
      int         k;
      int        *type=NULL;
      char        str[10];

	  if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}

   /* Assertions */
      assumption(nrow >= 0);
      assumption(ncol >= 0);

	  if (matrix.type != doubleMatrix && matrix.type != doubleRowMatrix) {
		  goto error13;
	  }

   /* Write matrix type, name and dimensions to file */
      fp = file->fp;
      if ( matDescr!=NULL && matDescr[0]!='\0' ) { if ( fprintfC(fp, "%s\n", matDescr) < 0 ) goto error3; }
      if ( fprintfC(fp,"double %s(%d,%d)\n", name, (int) nrow, (int) ncol) < 0 ) goto error3;

   /* Allocate storage for an integer vector with ncol elements and
      initialize vector with 0 (= column of double numbers).
      This vector is used to produce nicer output.
   */
      type = (int *) calloc( (size_t) ncol, sizeof(int) );
      if ( type == NULL ) goto error3b;

   /* Determine, whether a column of the matrix contains only integer
      numbers and if this is the case, store the number of digits
      in the type vector
   */
      for (j=0; j<ncol; j++) {
         for (i=0; i<nrow; i++) {
			if (isRowFormat) 
				pstar = matrix.data.drow[i][j];
			else
				pstar = matrix.data.d[j*nrow+i];
            pr = modf(pstar, &pg); 
            if ( pr != 0.0 ) {
               /* number is a double number */
                  type[j] = 0;
                  break;
            } else {
               /* number is an integer number */
                  pg     = fabs(pg);
                  ndigit =  1;
                  nnum   = 10;
                  for (k=0; k<8; k++) {
                     if ( pg < nnum ) {
                        type[j] = type[j] > ndigit ? type[j] : ndigit;
                        break;
                     }
                     ndigit++;
                     nnum *= 10;
                  }
                  if ( ndigit >= 8 ) {
                     type[j] = 0;
                     break;
                  }
            }
         }
      }
   
   /* Write matrix data to file */
      for (i=0; i<nrow; i++) {
         k = 0;
         for (j=0; j<ncol; j++) {
			 if (isRowFormat) 
				pstar = matrix.data.drow[i][j];
			else
				pstar = matrix.data.d[j*nrow+i];
             /* If column contains only integers, write an integer */
                if ( type[j] > 0 ) {
                   /* write maximum number of digits of column in string */
                      sprintfC(str," %%%dd", type[j]+1);
                   if ( fprintfC(fp, str, (int) pstar) < 0 ) goto error3;
                   k = k+type[j]+2;
                } else {
                   /* check, whether number is an integer number */
                      pr = modf(pstar, &pg);
                      if ( pr == 0.0 && pg >=-100000.0 && pg <= 100000.0) {
                         if ( fprintfC(fp," %7d                ", (int) pstar) < 0 ) goto error3;
                      } else { 
                         if ( fprintfC(fp," %23.16E", (double) pstar) < 0 ) goto error3;
                      }
                      k = k+24;
                }
             /* insert a new-line after a certain amount of numbers */
                if ( (k > 70) && (j < ncol-1) ) {
                   k = 0;
                   if ( fprintfC(fp,"\n") < 0 ) goto error3;
                }
         }
         if ( elemDescr != NULL ) { 
            if ( nblank > 0 ) {
               nb = nblank;
               while( --nb ) {if ( putc(' ', fp) == EOF ) goto error3;}
               if ( fputs("# ", fp) == EOF ) goto error3; 
            }
            if ( writeStringAndPossiblyEndl(fp, elemDescr[i],0,nblank>0)) goto error3;
         }
         if ( fprintfC(fp,"\n") < 0 ) goto error3;
      }

   if ( putc('\n',fp) == EOF ) goto error3;
   free(type);
   return 0;

   /* Error handling */
      error3 : 
               if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) ncol,
                       file->name, strerror(errno));
               free(type);
               return 1;

      error3b: 
               if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) ncol,
                       file->name, "not enough memory\n");
               return 1;

      error13: 
               if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[13], matrix.name);
			   return 1;

} /* End of  amatPutFDmatrix2 */



static int amatPutFCmatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const char *const data[],
                            const char *matDescr){
                          
   /* Write char matrix in formatted form on file */

   /* Declarations */
      FILE     *fp;
      integer   i, maxdim, idum;
      const char     *s;

	  if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}

   /* Assertions */
      assumption(nrow >= 0);
      assumption(ncol >= 0);
      if ( nrow == 0 ) ncol = 0;

   /* Determine maximum length of the strings, if necessary */
      if ( ncol == 0 ) {
         maxdim = (integer) 0;
         for (i=0; i<nrow; i++) {
            if ( (idum=strlen(data[i])) > maxdim ) maxdim = idum;
         }
      } else {
         maxdim = ncol;
      }

   /* Write matrix name and dimensions to file */
      fp = file->fp;
      if ( matDescr!=NULL && matDescr[0]!='\0' ) { if ( fprintfC(fp, "%s\n", matDescr) < 0 ) goto error3; }
      if ( fprintfC(fp,"char %s(%d,%d)\n", name, (int) nrow, (int) maxdim) < 0 ) goto error3;
  
   /* Write vector of strings onto file */
      if ( data != NULL ) {
         for (i=0; i<nrow; i++) {
              s = data[i];
              if ( s == NULL ) {
                 if ( fprintfC(fp,"\n") < 0 )     goto error3;
              } else {
				 if ( writeStringAndPossiblyEndl(fp,s,1,1) < 0 ) goto error3;
              }
         }
      } 

   if ( putc('\n',fp) == EOF ) goto error3;
   return 0;

   /* Error handling */
      error3: 
              if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) maxdim,
                      file->name, strerror(errno));
              return 1;

} /* End of  amatPutFCmatrix */

                           

static int amatPutFRinit (AmatPutFile *file) {

   /* Initialize row-wise writing of numeric matrix to ASCII file */

   /* Declarations */
      FILE *fp;
	  if (!file)  {amatUnexpectedNull(); return RET_ERR;}
   /* Write matrix type and matrix name to file */
      fp = file->fp;
      if ( file->type == doubleMatrix ) {
         if ( fprintfC(fp,"double ") < 0 ) goto error8;
      } else {
         if ( fprintfC(fp,"float ") < 0 ) goto error8;
      }
      if ( fprintfC(fp,"%s",file->matName) < 0 ) goto error8;

   /* Inquire position of stream */
      if ( fgetpos(fp, &(file->posHead)) != 0 ) goto error8;

   /* Write initial dimensions and enough blanks for actual ones
      (supply an additional blank before '(', because there is a bug
      on MSDOS/gcc with fgetpos/fsetpos). 
   */
      if ( fprintfC(fp," (0,%d)                             \n",
                      (int) file->ncol) < 0 ) goto error8;

   return 0;
   
   /* Error handling */
      error8: 
              if (!file)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[8], file->matName, file->name, strerror(errno));
              return 1;

} /* End of  amatPutFRinit */



static int amatPutFRclose (AmatPutFile *file) {

   /* Close row-wise writing of matrix to ASCII file */

   /* Declarations */
      FILE    *fp;
      fpos_t   PosEnd;

	  if (!file)  {amatUnexpectedNull(); return RET_ERR;}
   /* Inquire actual position of file */
      fp = file->fp;
      if ( fgetpos(fp, &PosEnd) != 0 ) goto error8;
    
   /* Position file to start of header */
      if ( fsetpos(fp, &file->posHead) != 0 ) goto error8;

   /* Write actual dimensions */
      if ( fprintfC(fp,"(%d,%d) ", (int) file->nrowAct,
                                    (int) file->ncol) < 0 ) goto error8;

   /* Position file to previous position */
      if ( fsetpos(fp, &PosEnd) != 0 ) goto error8;

   return 0;
   
   /* Error handling */
      error8: 
              if (!file)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[8], file->matName, file->name, strerror(errno));
              return 1;

} /* End of  amatPutFRclose */



static int amatPutFRreal (AmatPutFile *file, const real row[]) {

   /* Write row of real matrix to ASCII file */

   /* Declarations */
      FILE       *fp;
      integer     i;
      int         k;

	  if (!file)  {amatUnexpectedNull(); return RET_ERR;}
   /* Store vector */
      fp = file->fp;
      k  = 1;
      for (i=0; i<file->ncol; i++) {
         if ( fprintfC(fp," %14.7E", (double) row[i]) < 0 ) goto error10;
         k++;
         /* insert a new-line after a certain amount of numbers */
            if ( (k > 5) && (i < file->ncol-1) ) {
               k = 1;
               if ( fprintfC(fp,"\n    ") < 0 ) goto error10;
            }
      }
      if ( fprintfC(fp,"\n") < 0 ) goto error10;

      (file->nrowAct)++;

      return 0;
   
   /* Error handling */
      error10: 
               if (!file)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[10], file->nrowAct+1, file->matName, 
                       file->name, strerror(errno));
               return 1;
 
} /* End of  amatPutFRreal */



static int amatPutFRdouble (AmatPutFile *file, const doublereal row[]) {

   /* Write row of doublereal matrix to ASCII file */

   /* Declarations */
      FILE       *fp;
      integer     i;
      int         k;

	  if (!file)  {amatUnexpectedNull(); return RET_ERR;}
   /* Store vector */
      fp = file->fp;
      k  = 1;
      for (i=0; i<file->ncol; i++) {
         if ( fprintfC(fp," %23.16E", row[i]) < 0 ) goto error10;
         k++;
         /* insert a new-line after a certain amount of numbers */
            if ( (k > 3) && (i < file->ncol-1) ) {
               k = 1;
               if ( fprintfC(fp,"\n    ") < 0 ) goto error10;
            }
      }
      if ( fprintfC(fp,"\n") < 0 ) goto error10;

      (file->nrowAct)++;

      return 0;
   
   /* Error handling */
      error10: 
               if (!file)  {amatUnexpectedNull(); return RET_ERR;}
			   sprintfC(amatError, amatp_table[10], file->nrowAct+1, file->matName, 
                       file->name, strerror(errno));
               return 1;
 
} /* End of  amatPutFRdouble */

            

/* Procedures for Matlab binary output ......................................*/

static int amatPutBImatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const integer mat[]) {

   /* Write integer matrix in Matlab binary format to file */

   /* Declarations */
      FILE    *fp;
      Fmatrix *x;
      size_t   len, one=1;
      integer  i, j;
      const integer *p1, *p2;

	  if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
   /* Assertions */
      assumption(nrow >= 0);
      assumption(ncol >= 0);

   /* Define struct Fmatrix */
      x = &file->x;
      x->type   = MATTYPE + 20;
      x->imagf  = 0L;
      len       = strlen(name) + 1;
      x->namlen = (int) len;
      if ( file->bstruct == binNormal ) {
         x->mrows  = (int) nrow;
         x->ncols  = (int) ncol;
      } else {                         /* Write transposed matrix */
         x->mrows  = (int) ncol;
         x->ncols  = (int) nrow;
      }

   /* Write header to file */
      fp = file->fp;
      if ( fwrite(x, sizeof(Fmatrix), one, fp) != one ) goto error3;
      if ( fwrite(name, sizeof(char), len, fp) != len ) goto error3;

   /* Write data to file */
      if ( file->bstruct == binNormal ) {
         /* Write column-wise */
            len = nrow*ncol;
            if ( len > 0ul ) {
               if ( fwrite(mat, sizeof(integer), len, fp) != len ) goto error3;
            }
      } else {
         /* Write row-wise */
            p1 = mat;
            p2 = mat;
            for (i=0; i<nrow; i++) {
               for (j=0; j<ncol; j++) {
                  if ( fwrite(p1, sizeof(integer), one, fp) != one ) goto error3;
                  p1 += nrow;
               }
               p2++;
               p1 = p2;
            }

      }
      return 0;

   /* Error handling */
      error3: 
              if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) ncol,
                      file->name, strerror(errno));
              return 1;

} /* End of  amatPutBImatrix */



static int amatPutBRmatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const real mat[]) {

   /* Write real matrix in Matlab binary format to file */

   /* Declarations */
      FILE    *fp;
      Fmatrix *x;
      size_t   len, one=1;
      integer  i, j;
      const real    *p1, *p2;

	  if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
   /* Assertions */
      assumption(nrow >= 0);
      assumption(ncol >= 0);

   /* Define struct Fmatrix */
      x = &file->x;
      x->type   = MATTYPE + 10;
      x->imagf  = 0L;
      len       = strlen(name) + 1;
      x->namlen = (int) len;
      if ( file->bstruct == binNormal ) {
         x->mrows  = (int) nrow;
         x->ncols  = (int) ncol;
      } else {                         /* Write transposed matrix */
         x->mrows  = (int) ncol;
         x->ncols  = (int) nrow;
      }

   /* Write header to file */
      fp = file->fp;
      if ( fwrite(x, sizeof(Fmatrix), one, fp) != one ) goto error3;
      if ( fwrite(name, sizeof(char), len, fp) != len ) goto error3;

   /* Write data to file */
      if ( file->bstruct == binNormal ) {
         /* Write column-wise */
            len = nrow*ncol;
            if ( len > 0ul ) {
				if (1==file->updateEnd && nrow==2 && ncol>=1) {
					if ( fwrite(mat, sizeof(real), 1, fp) != len ) goto error3;
					if (0!=fgetpos(fp, &(file->posEndTime))) file->posEndTime=null_fpos;
					else {
						file->endTimeType=realRowMatrix;
						file->updateEnd=2;
					}
					if ( fwrite(mat+1, sizeof(real), len-1, fp) != len ) goto error3;
					
				} else {
					if ( fwrite(mat, sizeof(real), len, fp) != len ) goto error3;
				}
            }
      } else {
         /* Write row-wise */
            p1 = mat;
            p2 = mat;
            for (i=0; i<nrow; i++) {
			   if (1==file->updateEnd && nrow==2 && i==1) {
				  if (0!=fgetpos(fp, &(file->posEndTime))) file->posEndTime=null_fpos;
				  else {
						file->endTimeType=realRowMatrix;
						file->updateEnd=2;
					}
			   }
               for (j=0; j<ncol; j++) {
                  if ( fwrite(p1, sizeof(real), one, fp) != one ) goto error3;
                  p1 += nrow;
               }
               p2++;
               p1 = p2;
            }
      }
      return 0;

   /* Error handling */
      error3: 
              if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) ncol,
                      file->name, strerror(errno));
              return 1;

} /* End of  amatPutBRmatrix */


static int amatPutBRmatrix2(AmatPutFile *file, const char *name, integer nrow, integer ncol, Amatrix matrix) {

   /* Write real matrix in Matlab binary format to file */

   /* Declarations */
      FILE       *fp;
      Fmatrix    *x;
      size_t      len, one=1;
      integer     i, j;
      int         isRowMatrix = (matrix.type == realRowMatrix);

	  if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}

   /* Assertions */
      assumption(nrow >= 0);
      assumption(ncol >= 0);

   /* Define struct Fmatrix */
      x = &file->x;
      x->type   = MATTYPE + 10;
      x->imagf  = 0L;
      len       = strlen(name) + 1;
      x->namlen = (int) len;
      if ( file->bstruct == binNormal ) {
         x->mrows  = (int) nrow;
         x->ncols  = (int) ncol;
      } else {                         /* Write transposed matrix */
         x->mrows  = (int) ncol;
         x->ncols  = (int) nrow;
      }

   /* Write header to file */
      fp = file->fp;
      if ( fwrite(x, sizeof(Fmatrix), one, fp) != one ) goto error3;
      if ( fwrite(name, sizeof(char), len, fp) != len ) goto error3;

   /* Write data to file */
      if ( file->bstruct == binNormal ) {
         /* Write column-wise */
            len = nrow*ncol;
            if ( len > 0ul ) { 
				if (isRowMatrix) {
					for(j=0; j<ncol; j++) {
						for(i=0; i<nrow; i++) {
							if (fwrite(&(matrix.data.rrow[i][j]), sizeof(real), one, fp)!=one) goto error3;
						}
					}
				} else {
				   if ( fwrite(matrix.data.r, sizeof(real), len, fp) != len ) goto error3;
				}
            }
      } else {
         /* Write row-wise */
            for (i=0; i<nrow; i++) {
				if (isRowMatrix) {
					if (fwrite(matrix.data.rrow[i],sizeof(real), ncol, fp ) != (size_t)(ncol)) goto error3;
				} else {
					real*p1 = matrix.data.r+i;
					for (j=0; j<ncol; j++) {
						if ( fwrite(p1, sizeof(real), one, fp) != one ) goto error3;
						p1 += nrow;
					}
				}
            }
      }
      return 0;

   /* Error handling */
      error3: 
              if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) ncol,
                      file->name, strerror(errno));
              return 1;

} /* End of  amatPutBRmatrix2 */


static int amatPutBDmatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const doublereal mat[]) {

   /* Write doublereal matrix in Matlab binary format to file */

   /* Declarations */
      FILE       *fp;
      Fmatrix    *x;
      size_t      len, one=1;
      integer     i, j;
      const doublereal *p1, *p2;

   /* Assertions */
      assumption(nrow >= 0);
      assumption(ncol >= 0);

	  if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}

   /* Define struct Fmatrix */
      x = &file->x;
      x->type   = MATTYPE;
      x->imagf  = 0L;
      len       = strlen(name) + 1;
      x->namlen = (int) len;
      if ( file->bstruct == binNormal ) {
         x->mrows  = (int) nrow;
         x->ncols  = (int) ncol;
      } else {                         /* Write transposed matrix */
         x->mrows  = (int) ncol;
         x->ncols  = (int) nrow;
      }

   /* Write header to file */
      fp = file->fp;
      if ( fwrite(x, sizeof(Fmatrix), one, fp) != one ) goto error3;
      if ( fwrite(name, sizeof(char), len, fp) != len ) goto error3;

   /* Write data to file */
      if ( file->bstruct == binNormal ) {
         /* Write column-wise */
            len = nrow*ncol;
            if ( len > 0ul ) { 
				if (1==file->updateEnd && nrow==2 && ncol>=1) {
					if ( fwrite(mat, sizeof(doublereal), 1, fp) != len ) goto error3;
					if (0!=fgetpos(fp, &(file->posEndTime))) file->posEndTime=null_fpos;
					else {
						file->endTimeType=doubleRowMatrix;
						file->updateEnd=2;
					}
					if ( fwrite(mat+1, sizeof(doublereal), len-1, fp) != len ) goto error3;
				} else {
                    if ( fwrite(mat, sizeof(doublereal), len, fp) != len ) goto error3;
				}
            }
      } else {
         /* Write row-wise */
            p1 = mat;
            p2 = mat;
            for (i=0; i<nrow; i++) {
			   if (1==file->updateEnd && nrow==2 && i==1) {
				  if (0!=fgetpos(fp, &(file->posEndTime))) file->posEndTime=null_fpos;
				  else {
						file->endTimeType=doubleRowMatrix;
						file->updateEnd=2;
					}
			   }
               for (j=0; j<ncol; j++) {
                  if ( fwrite(p1, sizeof(doublereal), one, fp) != one ) goto error3;
                  p1 += nrow;
               }
               p2++;
               p1 = p2;
            }
      }
      return 0;

   /* Error handling */
      error3: 
              if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) ncol,
                      file->name, strerror(errno));
              return 1;

} /* End of  amatPutBDmatrix */

static int amatPutBDmatrix2(AmatPutFile *file, const char *name, integer nrow, integer ncol, Amatrix matrix) {

   /* Write doublereal matrix in Matlab binary format to file */

   /* Declarations */
      FILE       *fp;
      Fmatrix    *x;
      size_t      len, one=1;
      integer     i, j;
      int         isRowMatrix = (matrix.type == doubleRowMatrix);

   /* Assertions */
	  if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}

      assumption(nrow >= 0);
      assumption(ncol >= 0);

	  if (matrix.type != doubleMatrix && matrix.type != doubleRowMatrix) {
		  goto error13;
	  }

   /* Define struct Fmatrix */
      x = &file->x;
      x->type   = MATTYPE;
      x->imagf  = 0L;
      len       = strlen(name) + 1;
      x->namlen = (int) len;
      if ( file->bstruct == binNormal ) {
         x->mrows  = (int) nrow;
         x->ncols  = (int) ncol;
      } else {                         /* Write transposed matrix */
         x->mrows  = (int) ncol;
         x->ncols  = (int) nrow;
      }

   /* Write header to file */
      fp = file->fp;
      if ( fwrite(x, sizeof(Fmatrix), one, fp) != one ) goto error3;
      if ( fwrite(name, sizeof(char), len, fp) != len ) goto error3;

   /* Write data to file */
      if ( file->bstruct == binNormal ) {
         /* Write column-wise */
            len = nrow*ncol;
            if ( len > 0ul ) { 
				if (isRowMatrix) {
					for(j=0; j<ncol; j++) {
						for(i=0; i<nrow; i++) {
							if (fwrite(&(matrix.data.drow[i][j]), sizeof(doublereal), one, fp)!=one) goto error3;
						}
					}
				} else {
				   if ( fwrite(matrix.data.d, sizeof(doublereal), len, fp) != len ) goto error3;
				}
            }
      } else {
         /* Write row-wise */
            for (i=0; i<nrow; i++) {
				if (isRowMatrix) {
					if (fwrite(matrix.data.drow[i],sizeof(doublereal), ncol, fp ) != (size_t)(ncol)) goto error3;
				} else {
					doublereal*p1 = matrix.data.d+i;
					for (j=0; j<ncol; j++) {
						if ( fwrite(p1, sizeof(doublereal), one, fp) != one ) goto error3;
						p1 += nrow;
					}
				}
            }
      }
      return 0;

   /* Error handling */
      error3: 
              if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) ncol,
                      file->name, strerror(errno));
              return 1;

      error13: 
              if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[13], matrix.name);
			  return 1;

} /* End of  amatPutBDmatrix2 */


static int amatPutBCmatrix (AmatPutFile *file, const char *name, integer nrow, integer ncol, const char *const mat[], char padUsing) {

   /* Write char matrix in Matlab binary format to file */

   /* Declarations */
      FILE    *fp;
      Fmatrix *x;
      integer  maxdim, idum, i, j, jmax;
      size_t   len, one=1;
      const char    *p;
	  char c;

	  if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}

   /* Assertions */
      assumption(nrow >= 0);
      assumption(ncol >= 0);
      if ( nrow == 0 ) ncol = 0;

   /* Determine maximum length of the strings */
      maxdim = (integer) 0;
      for (i=0; i<nrow; i++) {
		  if ( (idum=mat[i] ? strlen(mat[i]) : 0) > maxdim ) maxdim = idum;
      } 

   /* Define struct Fmatrix */
      x = &file->x;
      x->type   = MATTYPE + 51;
      x->imagf  = 0L;
      len       = strlen(name) + 1;
      x->namlen = (int) len;
      if ( file->bstruct == binNormal ) {
         x->mrows  = (int) nrow;
         x->ncols  = (int) maxdim;
      } else {                         /* Write transposed matrix */
         x->mrows  = (int) maxdim;
         x->ncols  = (int) nrow;
      }

   /* Write header to file */
      fp = file->fp;
      if ( fwrite(x, sizeof(Fmatrix), one, fp) != one ) goto error3;
      if ( fwrite(name, sizeof(char), len, fp) != len ) goto error3;

   /* Write data to file */
      if ( file->bstruct == binNormal ) {
         /* Write column-wise */
            for (j=0; j<maxdim; j++) {
		  	  for (i=0; i<nrow;i++) {
			    p = mat[i];
				if (p==0) {
				  p="";
				}
                if ( j <= (integer) strlen( p ) ) {
                  c = p[j];
                  if ( putc(c,fp) == EOF ) goto error3;
                } else {
                  if ( putc(padUsing,fp) == EOF ) goto error3;
                }
              }
            }

      } else {
         /* Write row-wise */
            for (i=0;i<nrow;i++) {
               /* Write string */
				  p = mat[i];
				  if (p==0) p="";
                  if ( fputs(p,fp) == EOF ) goto error3;

               /* Write trailing blanks */
                  jmax = maxdim - strlen(p);
                  for (j=0;j<jmax;j++) {
                    if ( putc(padUsing,fp) == EOF ) goto error3;
                  }
            }
      }
      return 0;

   /* Error handling */
      error3: 
              if (!file||!name)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[3], name, (int) nrow, (int) ncol,
                      file->name, strerror(errno));
              return 1;
 
} /* End of  amatPutBCmatrix */ 



static int amatPutBRinit (AmatPutFile *file) {

   /* Initialize row-wise writing of numeric matrix to ASCII file */

   /* Declarations */
      FILE    *fp;
      Fmatrix *x;
      size_t   len, one=1;

	  if (!file)  {amatUnexpectedNull(); return RET_ERR;}

   /* Inquire position of stream */
      fp = file->fp;
      if ( fgetpos(fp, &(file->posHead)) != 0 ) goto error8;

   /* Define struct Fmatrix */
      x = &file->x;
      x->type   = ( file->type == doubleMatrix) ? MATTYPE : MATTYPE + 10;
      x->mrows  = (int) file->ncol;
      x->ncols  = 0L;
      x->imagf  = 0L;
      len       = strlen(file->matName) + 1;
      x->namlen = (int) len;

   /* Write header to file */
      if ( fwrite(x, sizeof(Fmatrix), one, fp) != one ) goto error8;
      if ( fwrite(file->matName, sizeof(char), len, fp) != len ) goto error8;

   return 0;
   
   /* Error handling */
      error8: 
              if (!file)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[8], file->matName, file->name, strerror(errno));
              return 1;

} /* End of  amatPutBRinit */



static int amatPutBRclose (AmatPutFile *file) {

   /* Close row-wise writing of matrix to Matlab binary file */

   /* Declarations */
      FILE    *fp;
      Fmatrix *x;
      fpos_t   PosEnd;
      size_t   one=1;

	  if (!file)  {amatUnexpectedNull(); return RET_ERR;}

   /* Inquire actual position of file */
      fp = file->fp;
      if ( fgetpos(fp, &PosEnd) != 0 ) goto error8;

	  if (3==file->updateEnd) {
		  file->updateEnd=0;
		  if (fsetpos(fp, &file->posEndTime)!=0)  goto error8;
		  if (doubleRowMatrix==file->endTimeType) {
			  fwrite(&file->endTime, sizeof(double), 1, fp);
		  } else {
			  real rTime=file->endTime;
			  fwrite(&rTime, sizeof(real), 1, fp);
		  }
	  }
    
   /* Position file to start of header */
      if ( fsetpos(fp, &file->posHead) != 0 ) goto error8;

   /* Write actual header */
      x = &file->x;
      if ( fwrite(x, sizeof(Fmatrix), one, fp) != one ) goto error8;

   /* Position file to previous position */
      if ( fsetpos(fp, &PosEnd) != 0 ) goto error8;

   return 0;
   
   /* Error handling */
      error8: 
              if (!file)  {amatUnexpectedNull(); return RET_ERR;}
			  sprintfC(amatError, amatp_table[8], file->matName, file->name, strerror(errno));
              return 1;

} /* End of  amatPutBRclose */

#endif


/* Error messages */
   static const char *const amatu_table[] = {
     /* 0 */    "Not possible to allocate storage for %d character pointers\n"
                "in order to generate a default text matrix.\n"
     /* 1 */   ,"Not possible to resize text matrix from %d rows to %d rows.\n"
     /* 2 */   ,"Error should never occur when generating default text matrix\n"
                "with procedure amatTextGenElem (number of written characters = %d,"
                "should be %d).\n"
     /* 3 */   ,"Not possible to allocate storage for %d characters, in\n"
                "order to generate a default name for text matrix element %d.\n"
     /* 4 */   ,"Not possible to allocate storage for a matrix.\n"
     /* 5 */   ,"Not possible to allocate storage for %d integer pointers.\n"
     /* 6 */   ,"Name \"%.400s\" in matrix \"%.400s\" is unknown.\n"
   };


DYMOLA_STATIC Amatrix *amatNew(void) {
   /* Allocate storage for a new matrix and initialize it */

   /* Declarations */
      Amatrix *matrix;

   /* Allocate storage */
      matrix = (Amatrix *) malloc( sizeof(Amatrix) );
      if ( matrix == NULL ) goto error4;

   /* Initialize storage */
      amatInit(matrix);
      return matrix;

   /* Error handling */
      error4: sprintfC(amatError, amatu_table[4]);
              return NULL;
}



DYMOLA_STATIC void amatInit(Amatrix *mat) {
   /* Initialize an Amatrix object */
	  if (!mat) return;
      mat->name   = NULL;
      mat->nrow   = 0;
      mat->ncol   = 0;
      mat->type   = voidMatrix;
	  mat->nrowallocated =0;
	  mat->nrowread = 0;
      mat->data.v = NULL;
}


DYMOLA_STATIC void amatInitValue(char *name, integer nrow, integer ncol,
                   AmatType type, AmatData data, Amatrix *mat) {
    /* Initialize an Amatrix object with the specified values. 
       is overwritten. */
	   if (!mat) return;
       mat->name   = name;
       mat->nrow   = nrow;
       mat->ncol   = ncol;
       mat->type   = type;
	   mat->nrowallocated =0;
	   mat->nrowread = 0;
       mat->data.v = data.v;
}


DYMOLA_STATIC void amatDel (Amatrix *mat) {
   
   /* Delete matrix */ 
      if ( mat == NULL ) return;
      free(mat->name);
      if ( mat->type == charMatrix ) {
         amatTextDel(mat->data.c, mat->nrow);
      } else {
		 if ((mat->type == realRowMatrix || mat->type == doubleRowMatrix) && mat->data.v) {
			 int i;
			 if (mat->type == realRowMatrix) {
				 for(i=0;i<mat->nrow;++i) {
					 free(mat->data.rrow[i]);
					 mat->data.rrow[i]=0;
				 }
			 } else {
				 for(i=0;i<mat->nrow;++i) {
					 free(mat->data.drow[i]);
					 mat->data.drow[i]=0;
				 }
			 }
		 }
         free(mat->data.v);
      }
      amatInit(mat);

} /* End of  amatDel */

static char **amatTextGenElem (char *text[], char *name, integer nbeg, integer nend);


DYMOLA_STATIC void amatTextDel (char *text[], integer nrow) {

   /* Delete text matrix */
      integer  i;

      if ( text == NULL ) return;
      for (i=0; i<nrow; i++) {
          free( text[i] );
		  text[i]=NULL;
      }
      free (text);
	  text=NULL;

} /* End of  amatTextDel */



DYMOLA_STATIC char **amatTextGen (char *name, integer nrow) {

   /* Generate default text */

   /* Declarations */
      char **text;

   /* Check nrow */
      assumption(nrow > 0);

   /* Allocate storage for pointer text */
      text = (char **) malloc( (size_t) nrow*sizeof(char *) );
      if ( text == NULL ) goto error0;

   /* Generate default text */
      return amatTextGenElem(text, name, (integer) 0, nrow);

   /* Error handling */
      error0: sprintfC(amatError, amatu_table[0], (int) nrow);
              return NULL;

} /* End of  amatTextGen */



DYMOLA_STATIC char **amatTextResize (char *text[], integer nrowIn, integer nrowOut, char *name) {

   /* Resize text */

   /* Declarations */
      integer   i, iend;
      char    **vec;

   /* Resize text */
      if ( nrowIn == nrowOut ) {
         /* do nothing */
            vec = text;

      } else if ( nrowIn >  nrowOut ) {
         /* remove last rows */
            for (i=nrowOut; i<nrowIn; i++) free( text[i] );
            vec = (char **) realloc( (void *)text, (size_t) nrowOut*sizeof(char *) );
            if ( vec == NULL ) {iend=nrowOut; goto error1;}

      } else {
         /* add additional rows */
            vec = (char **) realloc( (void *)text, (size_t) nrowOut*sizeof(char *) );
            if ( vec == NULL ) {iend=nrowIn; goto error1;}
            vec = amatTextGenElem(vec, name, nrowIn, nrowOut);
      }
      return vec;

   /* Error handling */
      error1: sprintfC(amatError, amatu_table[1], (int) nrowIn, (int) nrowOut);
              for (i=0; i<iend; i++) free( vec[i] );
              free( vec );
              return NULL;

} /* End of  amatTextResize */



static char **amatTextGenElem (char *text[], char *name, integer nbeg, integer nend) {

   /* Generate default text from [nbeg] ... [nend-1]. If an error occurs, 
      free complete text */

   /* Declarations */
      size_t    lenName;
      char     *str;
      integer   i, j, len;
      int       digits, digitLimit;

   /* Check arguments */
      assumption(nbeg >= 0) ;
      assumption(nbeg <= nend);
 
   /* Determine length of name */
      lenName = strlen(name);

   /* Determine starting number of digits of nbeg+1 */
      j = nbeg+1;
      digits     = 0;
      digitLimit = 1;
      while (j > 0) {
         j = j/10;
         digits++; 
         digitLimit *= 10;
      }

   /* Generate default names */
      for (i=nbeg; i<nend; i++) {
         /* determine number of digits of i+1 */
            if ( i+1 >= digitLimit ) {
               digits++;
               digitLimit *= 10;
            }

         /* allocate storage for element name */
            len = (integer) (lenName + digits + 1);
            str = (char *) malloc( (size_t) len );
            if ( str == NULL ) {        /* release allocated storage */
               for (j=0; j<i; j++) free( text[j] );
               free( text );
			   text = NULL;
               goto error3;
            }
            text[i] = str;

         /* store default element name */
            if ( (j=(integer) sprintfC(str, "%s%d", name, (int) i+1)) != (len-1) ) {
               for (j=0; j<=i; j++) free( text[j] );
               free( text );
			   text = NULL;
               goto error2;
            }
      }

   return text;

   /* Error handling */
      error2: sprintfC(amatError, amatu_table[2], (int) j, (int) len); 
              return NULL;

      error3: sprintfC(amatError, amatu_table[3], (int) len, (int) i);
              return NULL;

} /* End of  amatTextGenElem */


DYMOLA_STATIC int amatTextFind (Amatrix tmat, const char *str) {

   /* Find C-index of string "str" within text field of "tmat". */
      char *str2;
      int   i;
      int   info = -1;
	  int last =tmat.nrowread;

   /* Initialize */
      if ( str == NULL ) return -1;

   /* Search from last position upto end */
      if ( last < 0   ) last = 0;
      for (i=last; i<tmat.nrow; i++) {
         str2 = tmat.data.c[i];
         if ( (str2 != NULL)  &&  strcmp(str2, str) == 0) goto found;
      }

   /* Search from first position upto last position */
      if ( last >= tmat.nrow ) last = tmat.nrow;
      for (i=0; i<last; i++) {
         str2 = tmat.data.c[i];
         if ( (str2 != NULL)  &&  strcmp(str2, str) == 0) goto found;
      }

   /* No comparision found */
      return info;

   /* Comparision found */
      found: tmat.nrowread=i;
			 info = i;
             return info;
}

DYMOLA_STATIC integer *amatTextIndex(Amatrix tmat1, Amatrix tmat2, int message) {

   /* Build index from two text objects. */
      integer *index = NULL;
      integer  i, j, ii, jbeg;

   /* Allocate storage for index */
      index = (integer *) malloc( tmat2.nrow*sizeof(integer) );
      if ( index == NULL ) goto error5;

   /* Build index */
      jbeg = 0;
      for (i=0; i<tmat2.nrow; i++) {
         /* search from last position upto end */
            for (j=jbeg; j<tmat1.nrow; j++) {
               if ( strcmp(tmat1.data.c[j], tmat2.data.c[i]) == 0) {
                  index[i] = j;
                  jbeg = j+1;
                  if ( jbeg >= tmat1.nrow ) jbeg = 0;
                  goto next;
               }
            }

         /* search from first position upto last position */
            for (j=0; j<jbeg-1; j++) {
               if ( strcmp(tmat1.data.c[j], tmat2.data.c[i]) == 0) {
                  index[i] = j;
                  jbeg = j+1;
                  if ( jbeg >= tmat1.nrow ) jbeg = 0;
                  goto next;
               }
            }

         /* no comparision found */
            if ( message ) {
               ii = i;
               goto error6;
            } else {
               index[i] = -1;
            }

         /* comparison successful */
            next: ;
      }
      return index;

   /* Error handling */
      error5: sprintfC(amatError, amatu_table[5], (int) tmat2.nrow*sizeof(integer *));
              return NULL;

      error6: free(index);
              sprintfC(amatError, amatu_table[6], tmat2.data.c[ii], tmat2.name);
              return NULL;

} /* End of  amatTextIndex */


/* usertab.c

   User-defined function to define Dymola interpolation tables.
   The data for the user-defined tables are provided via 
   include-file "usertab.h".

   USUALLY, THIS FILE (usertab.c) NEED NOT TO BE CHANGED.

   Author : Martin Otter, DLR.
   Version: 1.0, 1997-09-30: implemented.
*/
/*
 * Copyright (C) 1997-2001 Dynasim AB.
 * All rights reserved.
 *
 */

#include "usertab.h"
#include "sprwat.h"

static int userTabFindName(UsertabTableElement tableDef[], int ntable, char *name);

DYMOLA_STATIC int usertab(char *tableName, int nipo, int dim[], int *colWise,
            double **table) {

   /* Define a table by statically storing the table in function usertab.
      This function can be adapted by the user to his/her needs.
      A 1D-table is defined as a matrix where
        - the first column is the abszissa data
        - the other columns are the ordinate data to
          be interpolated with respect to the first column.
      A 2D-table is defined as a matrix where
        - the first column (without first element), i.e., table(2:,1),
          is the first abscissa (u(1)),
        - the first row (without first element), i.e., table(1,2:),
          is the second abscissa (u(2)),
        - the other elements, i.e., table(i,j) with i>=2,j>=2,
          are the corresponding ordinate values.

      -> tableName  : Name of table.
      -> nipo       : = 0: time-table required (time interpolation).
                      = 1: 1D-table required.
                      = 2: 2D-table required.
      <- dim        : Actual values of dimensions.
      <- colWise    : = 0: table stored row-wise    (row_1, row_2, ..., row_n).
                    : = 1: table stored column-wise (column_1, column_2, ...).
      <- table      : Pointer to value vector.
      <- RETURN: = 0: No error.
                 = 1: An error occured. An error message is printed
                      from "usertab" with function "DymosimError".
   */

      char mess[500];
      int  ID;

   /* Search names */
      ID = userTabFindName(tableDef, N_TABLEDEF, tableName);
      if ( ID < 0 ) return 1;

   /* Check interpolation type */
      if ( nipo != tableDef[ID].nipo ) {
         sprintf(mess,"%dD-interpolation required for %dD-table \"%s\"\n",
                      nipo, tableDef[ID].nipo, tableName);
         DymosimError(mess);
         return 1;
      }

   /* Return desired values */
      *table   = tableDef[ID].value;
      *colWise = 0;
      dim[0] = tableDef[ID].dim[0];         
      dim[1] = tableDef[ID].dim[1];         

      return 0;
}


static int userTabFindName(UsertabTableElement tableDef[], int ntable, char *name) {

   /* Find table element with the given name. Return the index
      with respect to the found element or -1, in case it is
      not found
   */
      int  i;
      char mess[500];

      for (i=0; i<ntable; i++) {
         if ( strcmp(tableDef[i].name, name) == 0 ) return i;
      }

   /* Error */
      sprintf(mess, "The table matrix \"%s\" was not found in the user\n"
                    "supplied function \"usertab\" on file \"usertab.c\".\n",
                    name);
      DymosimError(mess);
      return (-1);              
}

/*
 * Copyright (C) 1997-2001 Dynasim AB.
 * All rights reserved.
 *
 */
/* dymc.c

   Include all relevant C-Files, in order that the number of
   files is reduced (problems with batch-files under
   Windows'95 and Windows 3.11).

   Author : Martin Otter, DLR.
   Release: 1997-11-26: implemented and tested
            1998-10-05: modified for realtime
            1999-01-20: Uses DYMOLA_DSPACE
*/

#if defined(DYMOLA_DSPACE)
/* Realtime system */
#define NO_FILE
#include <dsdefs.h>
#else
#include <stdio.h>
#endif
#include "sprwat.h"

#include "matutil.c"
#include "delay.c"
#include "dymtable.c"
#include "dymf2c.c"
#include "matrixop.c"

/* Start MSL Table Wrappers */

DYMOLA_STATIC int ModelicaTables_CombiTimeTable_init(const char* tableName, const char* fileName, 
                                        double const *table, size_t nRow, size_t nColumn,
                                        double startTime, int smoothness,
                                        int extrapolation) {
  int tableID = (int) dymTableTimeIni2(0.0, startTime, smoothness-1, extrapolation-1, 
                                       tableName, fileName, table, nRow, nColumn, 0.0);
  return tableID;
}

DYMOLA_STATIC void ModelicaTables_CombiTimeTable_close(int tableID) {
  ;
};

DYMOLA_STATIC double ModelicaTables_CombiTimeTable_interpolate(int tableID, int icol, double u) {
  return dymTableTimeIpo2(tableID, icol, u);
}

DYMOLA_STATIC double ModelicaTables_CombiTimeTable_minimumTime(int tableID) {
  int tableID2 = (int) tableID;
  return dymTableTimeTmin(tableID2);
}

DYMOLA_STATIC double ModelicaTables_CombiTimeTable_maximumTime(int tableID) {
  return dymTableTimeTmax(tableID);
}

DYMOLA_STATIC int ModelicaTables_CombiTable1D_init(const char* tableName, const char* fileName, 
                                       double const *table, size_t nRow, size_t nColumn, 
                                       int smoothness) {
  int tableID = (int) dymTableInit(1.0, smoothness-1, tableName, fileName, table, nRow, nColumn, 0.0);
  return tableID;
}

DYMOLA_STATIC void ModelicaTables_CombiTable1D_close(int tableID) {
  ;
};

DYMOLA_STATIC double ModelicaTables_CombiTable1D_interpolate(int tableID, int icol, double u) {
  return dymTableIpo1((double) tableID, icol, u);
}

DYMOLA_STATIC int ModelicaTables_CombiTable2D_init(const char* tableName, const char* fileName,
                                       double const *table, size_t nRow, size_t nColumn, 
                                       int smoothness) {
  int tableID = (int) dymTableInit(2.0, smoothness-1, tableName, fileName, table, nRow, nColumn, 0.0);
  return tableID;
}

DYMOLA_STATIC void ModelicaTables_CombiTable2D_close(int tableID) {
  ;
};

DYMOLA_STATIC double ModelicaTables_CombiTable2D_interpolate(int tableID, double u1, double u2) {
  return dymTableIpo2((double) tableID, u1, u2);
}

/* End MSL Table Wrappers */


/* MSL 3.2.1 Tables */

#if defined(NO_FILE) && !defined(NO_FILE_SYSTEM)
#define NO_FILE_SYSTEM 1
#endif

#if !defined(NO_FILE_SYSTEM)
#include "ModelicaMatIO.c"
#include "ModelicaIO.c"
#include "ModelicaFFT.c"
#endif
#include "ModelicaStandardTables.c"
#include "ModelicaRandom.c"

#if defined(NO_FILE_SYSTEM)
#undef NO_FILE_SYSTEM
#endif

/* End MSL 3.2.1 Tables */

/* dymf.f -- translated by f2c (version 19961209).
   You must link the resulting object file with the libraries:
	-lf2c -lm   (in that order)
*/

/*
 * Copyright (C) 1993-2008 Dynasim AB.
 * All rights reserved.
 *
 * Parts of the code is copyrighted Minpack.
 *
 * Minpack Copyright Notice (1999) University of Chicago.  All rights reserved
 *  
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the
 * following conditions are met:
 *  
 * 1. Redistributions of source code must retain the above
 * copyright notice, this list of conditions and the following
 * disclaimer.
 *  
 * 2. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *  
 * 3. The end-user documentation included with the
 * redistribution, if any, must include the following
 * acknowledgment:
 *  
 *    "This product includes software developed by the
 *    University of Chicago, as Operator of Argonne National
 *    Laboratory.
 *  
 * Alternately, this acknowledgment may appear in the software
 * itself, if and wherever such third-party acknowledgments
 * normally appear.
 *  
 * 4. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS"
 * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 * BE CORRECTED.
 *  
 * 5. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 * POSSIBILITY OF SUCH LOSS OR DAMAGES.
 */

#include <math.h>
#include "f2c.h"
#if defined(DYMOLAB) || defined(OPENGL)
#define DEBUG_NL 0
void DymosimMessageDouble(const char*c,double d) {
}
#else
#define DEBUG_NL 0
#endif /*  defined(DYMOLAB) || defined(OPENGL) */

#if defined(DYMOLA_DSPACE) || defined(NO_FILE)
#include <dsdefs.h>
#else
#include <stdio.h>
#endif /*  defined(DYMOLA_DSPACE) || defined(NO_FILE) */

#ifdef DEBUG_NL
static double LocalTime;
#endif /* DEBUG_NL */

#include "libdssetup.h"
#include "localeless.h"

LIBDS_API int dymlqr_(const integer *fact,doublereal *a, integer*lda, integer*n,doublereal *b,const doublereal *tol, integer *itype,doublereal *work,integer *iwork,integer *info);
LIBDS_API int dymli1_(integer *sysnr,const integer *fact,doublereal *a,integer*lda,integer*n,doublereal * b,doublereal *time, integer *event, integer *printpriority,doublereal *dwork,integer *iwork,integer *ierr);
LIBDS_API int dymli2_(integer *sysnr,integer *fact,doublereal *a,integer*lda, integer*n,doublereal *b, doublereal *time,integer *event, integer *printpriority,doublereal *dwork, integer *iwork,integer *factor,integer *ierr);
LIBDS_API int dymli3_(integer *sysnr,integer *fact,doublereal *a,integer*lda,integer*n,doublereal *b,doublereal *time,integer *event,integer *printpriority,doublereal *dwork, integer *iwork,integer *factor,const char*const*varnames,integer *ierr);
LIBDS_API int dymli4_(integer *sysnr,integer *fact,doublereal *a,integer*lda,integer*n,doublereal *b,doublereal *time,
					  integer *event,integer *printpriority,doublereal *dwork,integer *iwork,integer *factor,const char*const*varnames,integer *ierr,int*fEvent);
LIBDS_API int dymli5_(integer *sysnr,integer *fact,doublereal *a,integer*lda,integer*n,doublereal *b,const doublereal*x0,doublereal *time,
					  integer *event,integer *PrintEvent,doublereal *dwork,integer *iwork,integer *factor,const char*const*varnames,integer *ierr,int*fEvent,doublereal*intTol);
#if !defined(RT)
#include <time.h>
#ifdef UNIX
#include <sys/time.h>
#endif /* UNIX */

LIBDS_API double myclock(void) {
	static clock_t oldValue=0;
	static double extra=0;

#ifndef UNIX
	clock_t t=clock();
	if (t<oldValue) {
		/* Assume that times are represented by integer type, and that they work */
		/* using mod 2^32 and not mod 2^31 */
		if (t==-1) return 0; /* No timer*/
		extra+=pow(256.0,sizeof(clock_t));
	}
	oldValue=t;
#else /* UNIX */
  double t;
  struct timeval time;
  if (gettimeofday(&time, NULL)){
    return 0; /* No timer*/
  }
  t = (time.tv_sec + 1e-6 * time.tv_usec) * CLOCKS_PER_SEC;
#endif /* UNIX */
	return extra+t;
}
#endif /* !defined(RT) */

#include <float.h>
/* Constants used to implement dlamch_(). DB 1998-10-05. */

#define __dj_ENFORCE_FUNCTION_CALLS
/* The define guards missing files for djgpp */
#include <ctype.h>
#undef  __dj_ENFORCE_FUNCTION_CALLS
#define lsame_(ca,cb,nca,ncb) ((*ca==*cb)||(toupperC(*(const unsigned char*)ca)==toupperC(*(const unsigned char*)cb)))

typedef logical (*L_fp)();

/* Table of constant values */

static integer c__0 = 0;
static integer c__1 = 1;
static integer c__2 = 2;
static integer c__3 = 3;
static integer c__4 = 4;
static integer c__5 = 5;
static integer c__6 = 6;
static integer c__8 = 8;
static integer c__12 = 12;
static integer c__13 = 13;
static integer c__14 = 14;
static integer c__15 = 15;
static integer c__16 = 16;
static integer c__49 = 49;
static integer c__65 = 65;

static doublereal c_b3 = 2.;
static doublereal c_b4 = 1.;
static doublereal c_b4_dlahr2 = -1.;
static doublereal c_b5 = 1.;
static doublereal c_b5_dlarf = 0.;
static doublereal c_b5_dtgex2 = 0.;
static doublereal c_b7 = -1.;
static doublereal c_b7_dlaqr5 = 0.;
static doublereal c_b7_dlarft = 1.;
static doublereal c_b8 = 1.;
static doublereal c_b8_dgetf2 = -1.;
static doublereal c_b9 = -1.;
static doublereal c_b10 = 0.;
static doublereal c_b10_gdetc2 = -1.;
static doublereal c_b10_dpotf2 = -1.;
static doublereal c_b11 = 1.;
static doublereal c_b11_dhseqr = 0.;
static doublereal c_b12 = 1.;
static doublereal c_b12_dhgeqz = 0.;
static doublereal c_b12_dlaqr2 = 0.;
static doublereal c_b13 = 1.;
static doublereal c_b13_dgelsx = 0.;
static doublereal c_b13_dpotrf = -1.;
static doublereal c_b14 = 1.;
static doublereal c_b14_dtgsyl = 0.;
static doublereal c_b16 = 1.;
static doublereal c_b17 = 0.;
static doublereal c_b18 = -1.;
static doublereal c_b18_dtrtri = 1.;
static doublereal c_b18_dlaqr3 = 1.;
static doublereal c_b19 = -1.;
static doublereal c_b19_dtgsna = 1.;
static doublereal c_b20 = -1.;
static doublereal c_b21 = 1.;
static doublereal c_b21_dtgsna = 0.;
static doublereal c_b22 = 1.;
static doublereal c_b22_dtrtri = -1.;
static doublereal c_b23 = 1.;
static doublereal c_b25 = -1.;
static doublereal c_b25_dtrevc = 0.;
static doublereal c_b25_dlaqtr = 0.;
static doublereal c_b26 = 1.;
static doublereal c_b27 = 1.;
static doublereal c_b27_dtgsy2 = -1.;
static doublereal c_b30 = 0.;
static doublereal c_b31 = 1.;
static doublereal c_b31_dgglse = -1.;
static doublereal c_b32 = 0.;
static doublereal c_b33 = 0.;
static doublereal c_b33_dggsle = 1.;
static doublereal c_b34 = 1.;
static doublereal c_b35 = 10.;
static doublereal c_b36 = .5;
static doublereal c_b36_dtgevc = 0.;
static doublereal c_b36_dgelsx = 1.;
static doublereal c_b36_dggev = 0.;
static doublereal c_b37 = 1.;
static doublereal c_b37_dlatdf = -1.;
static doublereal c_b38 = 0.;
static doublereal c_b42 = 1.;
static doublereal c_b48 = -1.;
static doublereal c_b51 = -1.;
static doublereal c_b52 = 1.;
static doublereal c_b56 = 0.;
static doublereal c_b57 = 0.;
static doublereal c_b59 = 0.;
static doublereal c_b60 = 1.;
static doublereal c_b71 = .5;
static doublereal c_b79 = 1.;
static real c_b163 = 0.f;
static real c_b164 = 1.f;
static doublereal c_b227 = 0.;
static doublereal c_b248 = 1.;
static doublereal c_b263 = 1.;
static doublereal c_b362 = 0.;

static integer c_n1 = -1;

static logical c_false = FALSE_;
static logical c_true = TRUE_;

static int dgbsv_(const integer *n, const integer *kl, const integer *ku, const integer *nrhs, doublereal *ab, const integer *ldab, integer *ipiv, doublereal *b, const integer *ldb, integer *info);
static int dgbtf2_(integer *m, integer *n, integer *kl, integer *ku, doublereal *ab, integer *ldab, integer *ipiv, integer *info);
static int dgbtrf_(integer *m, integer *n, integer *kl, integer *ku, doublereal *ab, integer *ldab, integer *ipiv, integer *info);
static int dgbtrs_(char *trans, integer *n, integer *kl, integer *ku, integer *nrhs, doublereal *ab, integer *ldab, integer *ipiv, doublereal *b, integer *ldb, integer *info);

/* start: functions merely for Modelica.Math.Matrices.LAPACK functions */

/* avoid lenghty compilations for libds and godess */

#ifndef DYMOSIM

/* added for dgeev_ */
static int dgeev_(const char *jobvl, const char *jobvr, integer *n, doublereal *a, integer *lda, doublereal *wr, doublereal *wi, doublereal *vl, const integer *ldvl, doublereal *vr, integer *ldvr, doublereal *work, const integer *lwork, integer *info);
static int dhseqr_(const char *job, const char *compz, integer *n, integer *ilo, integer *ihi, doublereal *h__, integer *ldh, doublereal *wr, doublereal *wi, doublereal *z__, integer *ldz, doublereal *work, integer *lwork, integer *info);
static int dlascl_(char *type__, integer *kl, integer *ku, doublereal *cfrom, doublereal *cto, integer *m, integer *n, doublereal *a, integer *lda, integer *info);
static int dgebal_(char *job, integer *n, doublereal *a, integer *lda, integer *ilo, integer *ihi, doublereal *scale, integer *info);
static int dgehrd_(integer *n, const integer *ilo, const integer *ihi, doublereal *a, integer *lda, doublereal *tau, doublereal *work, integer *lwork, integer *info);
static int dlacpy_(char *uplo, integer *m, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb);
static int dorghr_(integer *n, const integer *ilo, const integer *ihi, doublereal *a, integer *lda, const doublereal *tau, doublereal *work, integer *lwork, integer *info);
static int dtrevc_(const char *side, const char *howmny, logical *select, integer *n, const doublereal *t, integer *ldt, doublereal *vl, integer *ldvl, doublereal *vr, integer *ldvr, integer *mm, integer *m, doublereal *work, integer *info);
static int dgebak_(char *job, char *side, integer *n, integer *ilo, integer *ihi, doublereal *scale, integer *m, doublereal *v, integer *ldv, integer *info);
static int dlartg_(doublereal *f, doublereal *g, doublereal *cs, doublereal *sn, doublereal *r__);
static int drot_(integer *n, doublereal *dx, integer *incx, doublereal *dy, integer *incy, doublereal *c__, doublereal *s);
static int dlaqr0_(logical *wantt, logical *wantz, integer *n, integer *ilo, integer *ihi, doublereal *h__, integer *ldh, doublereal *wr, doublereal *wi, integer *iloz, integer *ihiz, doublereal *z__, integer *ldz, doublereal *work, integer *lwork, integer *info);
static int dlaset_(char *uplo, integer *m, integer *n, doublereal *alpha, doublereal *beta, doublereal *a, integer *lda);
static int dlahqr_(logical *wantt, logical *wantz, integer *n, integer *ilo, integer *ihi, doublereal *h__, integer *ldh, doublereal *wr, doublereal *wi, integer *iloz, integer *ihiz, doublereal *z__, integer *ldz, integer *info);
static int dlahr2_(integer *n, integer *k, integer *nb, doublereal *a, integer *lda, doublereal *tau, doublereal *t, integer *ldt, doublereal *y, integer *ldy);
static int dtrmm_(char *side, char *uplo, char *transa, char *diag, integer *m, integer *n, doublereal *alpha, doublereal *a, integer *lda, doublereal *b, integer *ldb);
static int dlarfb_(char *side, char *trans, char *direct, char *storev, integer *m, integer *n, integer *k, doublereal *v, integer *ldv, doublereal *t, integer *ldt, doublereal *c__, integer *ldc, doublereal *work, integer *ldwork);
static int dgehd2_(integer *n, integer *ilo, integer *ihi, doublereal *a, integer *lda, doublereal *tau, doublereal *work, integer *info);
static int dorgqr_(const integer *m, const integer *n, const integer *k, doublereal *a, integer *lda, const doublereal *tau, doublereal *work, integer *lwork, integer *info);
static int dlaln2_(logical *ltrans, integer *na, integer *nw, doublereal *smin, doublereal *ca, doublereal *a, integer *lda, doublereal *d1, doublereal *d2, doublereal *b, integer *ldb, doublereal *wr, doublereal *wi, doublereal *x, integer *ldx, doublereal *scale, doublereal *xnorm, integer *info);
static int dlaqr3_(logical *wantt, logical *wantz, integer *n, integer *ktop, integer *kbot, integer *nw, doublereal *h__, integer *ldh, integer *iloz, integer *ihiz, doublereal *z__, integer *ldz, integer *ns, integer *nd, doublereal *sr, doublereal *si, doublereal *v, integer *ldv, integer *nh, doublereal *t, integer *ldt, integer *nv, doublereal *wv, integer *ldwv, doublereal *work, integer *lwork);
static int dlaqr4_(logical *wantt, logical *wantz, integer *n, integer *ilo, integer *ihi, doublereal *h__, integer *ldh, doublereal *wr, doublereal *wi, integer *iloz, integer *ihiz, doublereal *z__, integer *ldz, doublereal *work, integer *lwork, integer *info);
static int dlaqr5_(logical *wantt, logical *wantz, integer *kacc22, integer *n, integer *ktop, integer *kbot, integer *nshfts, doublereal *sr, doublereal *si, doublereal *h__, integer *ldh, integer *iloz, integer *ihiz, doublereal *z__, integer *ldz, doublereal *v, integer *ldv, doublereal *u, integer *ldu, integer *nv, doublereal *wv, integer *ldwv, integer *nh, doublereal *wh, integer *ldwh);
static int dlanv2_(doublereal *a, doublereal *b, doublereal *c__, doublereal *d__, doublereal *rt1r, doublereal *rt1i, doublereal *rt2r, doublereal *rt2i, doublereal *cs, doublereal *sn);
static int dtrmv_(char *uplo, char *trans, char *diag, integer *n, doublereal *a, integer *lda, doublereal *x, integer *incx);
static int dorg2r_(integer *m, integer *n, integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *work, integer *info);
static int dlarft_(char *direct, char *storev, integer *n, integer *k, doublereal *v, integer *ldv, doublereal *tau, doublereal *t, integer *ldt);
static int dladiv_(doublereal *a, doublereal *b, doublereal *c__, doublereal *d__, doublereal *p, doublereal *q);
static int dladiv1_(doublereal *a, doublereal *b, doublereal *c__, doublereal *d__, doublereal *p, doublereal *q);
static doublereal dladiv2_(doublereal *a, doublereal *b, doublereal *c__, doublereal *d__, doublereal *r__, doublereal *t);
static int dormhr_(const char *side, const char *trans, integer *m, integer *n, const integer *ilo, const integer *ihi, const doublereal *a, integer *lda, const doublereal *tau, doublereal *c__, integer *ldc, doublereal *work, integer *lwork, integer *info);
static int dtrexc_(char *compq, integer *n, doublereal *t, integer *ldt, doublereal *q, integer *ldq, integer *ifst, integer *ilst, doublereal *work, integer *info);
static int dlaqr1_(integer *n, doublereal *h__, integer *ldh, doublereal *sr1, doublereal *si1, doublereal *sr2, doublereal *si2, doublereal *v);
static int dlaqr2_(logical *wantt, logical *wantz, integer *n, integer *ktop, integer *kbot, integer *nw, doublereal *h__, integer *ldh, integer *iloz, integer *ihiz, doublereal *z__, integer *ldz, integer *ns, integer *nd, doublereal *sr, doublereal *si, doublereal *v, integer *ldv, integer *nh, doublereal *t, integer *ldt, integer *	nv, doublereal *wv, integer *ldwv, doublereal *work, integer *lwork);
static int dormqr_(const char *side, const char *trans, integer *m, integer *n, integer *k, const doublereal *a, integer *lda, const doublereal *tau, doublereal *c__, integer *ldc, doublereal *work, integer *lwork, integer *info);
static int dlaexc_(logical *wantq, integer *n, doublereal *t, integer *ldt, doublereal *q, integer *ldq, integer *j1, integer *n1, integer *n2, doublereal *work, integer *info);
static int dlasy2_(logical *ltranl, logical *ltranr, integer *isgn, integer *n1, integer *n2, doublereal *tl, integer *ldtl, doublereal *tr, integer *ldtr, doublereal *b, integer *ldb, doublereal *scale, doublereal *x, integer *ldx, doublereal *xnorm, integer *info);
/* Subroutine */ static int dlarfx_(char *side, integer *m, integer *n, doublereal *v, doublereal *tau, doublereal *c__, integer *ldc, doublereal *work);

/* added for dgegv */
static int dgegv_(const char *jobvl, const char *jobvr, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *alphar, doublereal *alphai, doublereal *beta, doublereal *vl, const integer *ldvl, doublereal *vr, const integer *ldvr, doublereal *work, const integer *lwork, integer *info);
static int dggbal_(char *job, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, integer *ilo, integer *ihi, doublereal *lscale, doublereal *rscale, doublereal *work, integer *info);
static int dgeqrf_(integer *m, integer *n, doublereal *a, integer * lda, doublereal *tau, doublereal *work, integer *lwork, integer *info);
static int dgghrd_(char *compq, char *compz, integer *n, integer *ilo, integer *ihi, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *q, integer *ldq, doublereal *z__, integer *ldz, integer *info);
static int dhgeqz_(const char *job, const char *compq, const char *compz, integer *n, integer *ilo, integer *ihi, doublereal *h__, integer *ldh, doublereal *t, integer *ldt, doublereal *alphar, doublereal *alphai, doublereal *beta, doublereal *q, const integer *ldq, doublereal *z__, const integer *ldz, doublereal *work, integer *lwork, integer *info);
static int dtgevc_(char *side, char *howmny, logical *select, integer *n, doublereal *s, integer *lds, doublereal *p, integer *ldp, doublereal *vl, integer *ldvl, doublereal *vr, integer *ldvr, integer *mm, integer *m, doublereal *work, integer *info);
static int dggbak_(char *job, char *side, integer *n, integer *ilo, integer *ihi, doublereal *lscale, doublereal *rscale, integer *m, doublereal *v, integer *ldv, integer *info);
static doublereal dlanhs_(char *norm, integer *n, doublereal *a, integer *lda, doublereal *work);
static int dlag2_(doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *safmin, doublereal *scale1, doublereal *scale2, doublereal *wr1, doublereal *wr2, doublereal *wi);
static int dlasv2_(doublereal *f, doublereal *g, doublereal *h__, doublereal *ssmin, doublereal *ssmax, doublereal *snr, doublereal *csr, doublereal *snl, doublereal *csl);
static doublereal dlapy3_(doublereal *x, doublereal *y, doublereal *z__);

/* added for dgelsx */
static int dgelsx_(integer *m, integer *n, integer *nrhs, doublereal *a, integer *lda, doublereal *b, integer *ldb, integer *jpvt, const doublereal *rcond, integer *rank, doublereal *work, integer *info);

/* added for dgels_vec */
static int dgels_(const char *trans, integer *m, integer *n, const integer *nrhs, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *work, integer *lwork, integer *info);
static int dtrtrs_(char *uplo, char *trans, char *diag, integer *n, integer *nrhs, doublereal *a, integer *lda, doublereal *b, integer *ldb, integer *info);
static int dgelqf_(integer *m, integer *n, doublereal *a, integer *lda, doublereal *tau, doublereal *work, integer *lwork, integer *info);
static int dormlq_(char *side, char *trans, integer *m, integer *n, integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *c__, integer *ldc, doublereal *work, integer *lwork, integer *info);
static int dgelq2_(integer *m, integer *n, doublereal *a, integer *lda, doublereal *tau, doublereal *work, integer *info);
static int dorml2_(char *side, char *trans, integer *m, integer *n, integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *c__, integer *ldc, doublereal *work, integer *info);

/* added for dgglse_vec */
static int dgglse_(integer *m, integer *n, integer *p, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *c__, doublereal *d__, doublereal *x, doublereal *work, integer *lwork, integer *info);
static int dggrqf_(integer *m, integer *p, integer *n, doublereal *a, integer *lda, doublereal *taua, doublereal *b, integer *ldb, doublereal *taub, doublereal *work, integer *lwork, integer *info);
static int dormrq_(char *side, char *trans, integer *m, integer *n, integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *c__, integer *ldc, doublereal *work, integer *lwork, integer *info);
static int dgerqf_(integer *m, integer *n, doublereal *a, integer *lda, doublereal *tau, doublereal *work, integer *lwork, integer *info);
static int dormr2_(char *side, char *trans, integer *m, integer *n, integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *c__, integer *ldc, doublereal *work, integer *info);
/* Subroutine */ static int dgerq2_(integer *m, integer *n, doublereal *a, integer *lda, doublereal *tau, doublereal *work, integer *info);


/* added for dgtsv */
static int dgtsv_(const integer *n, const integer *nrhs, doublereal *dl, doublereal *d__, doublereal *du, doublereal *b, const integer *ldb, integer *info);


/* added for dgetri */
static int dgetri_(const integer *n, doublereal *a, integer *lda, const integer *ipiv, doublereal *work, integer *lwork, integer *info);
static int dtrtri_(char *uplo, char *diag, integer *n, doublereal *a, integer *lda, integer *info);
static int dtrti2_(char *uplo, char *diag, integer *n, doublereal *a, integer *lda, integer *info);

/* added for dtrsen */
static int dtrsen_(const char *job, const char *compq, const logical *select, integer *n, doublereal *t, integer *ldt, doublereal *q, integer *ldq, doublereal *wr, doublereal *wi, integer *m, doublereal *s, doublereal *sep, doublereal *work, integer *lwork, integer *iwork, integer *liwork, integer *info);
static int dtrsyl_(const char *trana, const char *tranb, const integer *isgn, integer *m, integer *n, const doublereal *a, integer *lda, const doublereal *b, integer *ldb, doublereal *c__, integer *ldc, doublereal *scale, integer *info);

/* added for dgeevx */
static int dgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, integer *n, doublereal *a, integer *lda, doublereal *wr, doublereal *wi, doublereal *vl, integer *ldvl, doublereal *vr, integer *ldvr, integer *ilo, integer *ihi, doublereal *scale, doublereal *abnrm, doublereal *rconde, doublereal *rcondv, doublereal *work, integer *lwork, integer *iwork, integer *info);
static int dtrsna_(char *job, char *howmny, logical *select, integer *n, doublereal *t, integer *ldt, doublereal *vl, integer *ldvl, doublereal *vr, integer *ldvr, doublereal *s, doublereal *sep, integer *mm, integer *m, doublereal *work, integer *ldwork, integer *iwork, integer *info);
static int dlaqtr_(logical *ltran, logical *lreal, integer *n, doublereal *t, integer *ldt, doublereal *b, doublereal *w, doublereal *scale, doublereal *x, doublereal *work, integer *info);

/* added for dggev */
static int dggev_(const char *jobvl, const char *jobvr, const integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *alphar, doublereal *alphai, doublereal *beta, doublereal *vl, integer *ldvl, doublereal *vr, integer *ldvr, doublereal *work, integer *lwork, integer *info);

/* added for dggevx */
static int dggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, integer *n, const doublereal *a, integer *lda, const doublereal *b, integer *ldb, doublereal *alphar, doublereal *alphai, doublereal *beta, doublereal *vl, integer *ldvl, doublereal *vr, integer *ldvr, integer *ilo, integer *ihi, doublereal *lscale, doublereal *rscale, doublereal *abnrm, doublereal *bbnrm, doublereal *rconde, doublereal *rcondv, doublereal *work, integer *lwork, integer *iwork, logical *bwork, integer *info);
static int dtgsna_(char *job, char *howmny, logical *select, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *vl, integer *ldvl, doublereal *vr, integer *ldvr, doublereal *s, doublereal *dif, integer *mm, integer *m, doublereal *work, integer *lwork, integer *iwork, integer *info);
static int dtgexc_(logical *wantq, logical *wantz, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *q, integer *ldq, doublereal *z__, integer *ldz, integer *ifst, integer *ilst, doublereal *work, integer *lwork, integer *info);
static int dtgsyl_(char *trans, integer *ijob, integer *m, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *c__, integer *ldc, doublereal *d__, integer *ldd, doublereal *e, integer *lde, doublereal *f, integer *ldf, doublereal *scale, doublereal *dif, doublereal *work, integer *lwork, integer *iwork, integer *info);
static int dtgex2_(logical *wantq, logical *wantz, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *q, integer *ldq, doublereal *z__, integer *ldz, integer *j1, integer *n1, integer *n2, doublereal *work, integer *lwork, integer *info);
static int dtgsy2_(char *trans, integer *ijob, integer *m, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *c__, integer *ldc, doublereal *d__, integer *ldd, doublereal *e, integer *lde, doublereal *f, integer *ldf, doublereal *scale, doublereal *rdsum, doublereal *rdscal, integer *iwork, integer *pq, integer *info);
static int dorgr2_(integer *m, integer *n, integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *work, integer *info);
static int dlagv2_(doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *alphar, doublereal *alphai, doublereal *beta, doublereal *csl, doublereal *snl, doublereal *csr, doublereal *snr);
static int dgetc2_(integer *n, doublereal *a, integer *lda, integer *ipiv, integer *jpiv, integer *info);
static int dgesc2_(integer *n, doublereal *a, integer *lda, doublereal *rhs, integer *ipiv, integer *jpiv, doublereal *scale);
static int dlatdf_(integer *ijob, integer *n, doublereal *z__, integer *ldz, doublereal *rhs, doublereal *rdsum, doublereal *rdscal, integer *ipiv, integer *jpiv);

/* added for dpotrf */
static int dpotrf_(const char *uplo, integer *n, doublereal *a, integer *lda, integer *info);
static int dpotf2_(char *uplo, integer *n, doublereal *a, integer *lda, integer *info);
static int dsyrk_(char *uplo, char *trans, integer *n, integer *k, doublereal *alpha, doublereal *a, integer *lda, doublereal *beta, doublereal *c__, integer *ldc);

/* added for dgees */
static int dgees_(char *jobvs, char *sort, L_fp select, integer *n, doublereal *a, integer *lda, integer *sdim, doublereal *wr, doublereal *wi, doublereal *vs, integer *ldvs, doublereal *work, integer *lwork, logical *bwork, integer *info);

#endif /* DYMOSIM */

/* end: functions merely for Modelica.Math.Matrices.LAPACK functions */

static int dgesv_(const integer *n, const integer *nrhs, doublereal *a, integer *lda, integer *ipiv, doublereal *b, integer *ldb, integer *info);
static int dlacn2_(integer *n, doublereal *v, doublereal *x, integer *isgn, doublereal *est, integer *kase, integer *isave);
static logical disnan_(doublereal *din);
static logical dlaisnan_(doublereal *din1, doublereal *din2);
static int dtbsv_(char *uplo, char *trans, char *diag, integer *n, integer *k, doublereal *a, integer *lda, doublereal *x, integer *incx);
#ifndef GODESS
static doublereal dlamch_(char *cmach);
#endif
static int dlamc1_(integer *beta, integer *t, logical *rnd, logical *ieee1);
static int dlamc2_(integer *beta, integer *t, logical *rnd, doublereal *eps, integer *emin, doublereal *rmin, integer *emax, doublereal *rmax);
static doublereal dlamc3_(doublereal *a, doublereal *b);
static int dlamc4_(integer *emin, doublereal *start, integer *base);
static int dlamc5_(integer *beta, integer *p, integer *emin, logical *ieee, integer *emax, doublereal *rmax);
static integer ieeeck_(integer *ispec, real *zero, real *one);
static integer iladlc_(integer *m, integer *n, doublereal *a, integer *lda);
static integer iladlr_(integer *m, integer *n, doublereal *a, integer *lda);
static integer iparmq_(integer *ispec, char *name__, char *opts, integer *n, integer *ilo, integer *ihi, integer *lwork);

DYMOLA_STATIC void dymnl2_Fast(const integer m, const integer n, doublereal* a, const integer lda, const doublereal* v, const doublereal* w);
DYMOLA_STATIC void dymnl3_Fast(const integer m, const integer n, doublereal*s, const integer ls, const doublereal*u, doublereal*v, doublereal*w, logical*sing,
				 const integer*ipivots);
DYMOLA_STATIC void dymnl4_Fast(const integer n, const doublereal* r__, const integer lr, const doublereal*diag, const doublereal*qtb, 
				 const doublereal delta, doublereal*x, doublereal*wa1, doublereal*wa2,
				 const integer*ipivots,int inJacobian);
DYMOLA_STATIC void dymnl7_Fast(const integer m, const integer n, doublereal* a, const integer lda, 
				 const logical pivot, 
			 integer*ipvt, const integer lipvt, doublereal*sigma, doublereal*acnorm, 
	doublereal*wa,const char*const*varnames,doublereal*x,int printEvent);
DYMOLA_STATIC doublereal dnrm2_(const integer *n, doublereal *x, const integer *incx);
DYMOLA_STATIC doublereal dnrm2_Fast(const integer np, const doublereal *x, const integer incxp);
DYMOLA_STATIC doublereal dnrm2_Fast1(const integer np, const doublereal *x);
DYMOLA_STATIC void dymnl6_Fast(const integer m, const integer n, doublereal* q, const integer ldq, doublereal*wa);
DYMOLA_STATIC void dymnl5_Fast(integer*irev, const integer n, const integer n2, doublereal*x, doublereal*fvec, doublereal*fvec2, doublereal*fjac, 
			const integer ldfjac, const integer ml, const integer mu, const doublereal*nominalx, 
	doublereal*wa1, doublereal*wa2, doublereal*dsave, integer*isave,logical useCentral,logical printDetails,
	const char*const*varnames,int check);
DYMOLA_STATIC void dymnl1_Fast(integer*infrev, const integer iopt, const integer n, doublereal*x, 
			 doublereal*fvec, doublereal*fjac, const integer ldfjac, doublereal*fjac2, doublereal*qres2,const integer ldfjac2, const doublereal xtol,
			 const doublereal xtoldesired, const integer maxfev, const integer ml, 
			 const integer mu, const doublereal*nominalx, doublereal*diag, doublereal *diag2,
			 const doublereal factor, integer*info, integer*nfev, integer*njev, 
			 doublereal *r__, const integer lr,doublereal* qtf, 
			 doublereal * wa1, doublereal*wa2, doublereal*wa3, doublereal*wa4, 
			 const integer jopt, doublereal*dsave, integer*isave,const char*const*varnames,
                               integer*ipivots,int printEvent,int inJacobian);
DYMOLA_STATIC void dymnlinf2_(integer n,const doublereal*sol,const char*const*varnames,unsigned indent);
DYMOLA_STATIC void dymnlinf1_(const integer*sysnr, const integer*n, const doublereal*sol, const doublereal*res, 
				const integer*nfunc, const integer*njac, const integer*nmax,const char*const*varnames);
DYMOLA_STATIC void dymnlerr_(const doublereal*time, const integer*sysnr, const integer*info, const integer*n, 
			   const integer*iopt, const doublereal*tol, const doublereal*sol, const doublereal*res, 
	const integer*nfunc, const integer*njac, const integer*nmax,const char*const*varnames,const double*wa1,const char*tag,int idemand,int printevent,int*const advicePrinted);
/* --- */
LIBDS_API int dgemv_(char *trans, integer *m, integer *n, doublereal *alpha, doublereal *a, integer *lda, doublereal *x, integer *incx, doublereal *beta, doublereal *y, integer *incy);
DYMOLA_STATIC int dgetf2Dummy_(const integer*m, const integer*n, doublereal*a, const integer*lda,integer*ipiv,integer*hysteresis,integer*info);
DYMOLA_STATIC int xerbla_(char*srname,integer*info);
DYMOLA_STATIC int dswap_(const integer *n, doublereal *dx, const integer *incx, doublereal *dy, const integer *incy);
DYMOLA_STATIC int dscal_(const integer*n, const doublereal*da, doublereal*dx, const integer*incx);
DYMOLA_STATIC int dger_(const integer*m,const integer*n,const doublereal*alpha,doublereal*x,const integer*incx,doublereal*y,const integer*incy, doublereal*a,const integer*lda);
DYMOLA_STATIC int dgetrfDummy_(const integer*m,const integer*n,doublereal *a,const integer*lda,integer * ipiv,integer * hysteresis,integer * info);
DYMOLA_STATIC integer ilaenv_(const integer *ispec,const char *name__,const char *opts,const integer*n1,const integer*n2,const integer*n3,const integer*n4);
DYMOLA_STATIC int dtrsm_(const char *side, const char *uplo, const char *transa, const char *diag, integer *m, integer *n, const doublereal *alpha, const doublereal *a, integer *lda, doublereal *b, integer *ldb);
DYMOLA_STATIC int dgemm_(const char*transa,const char*transb,const integer*m,const integer*n,const integer * k,const doublereal*alpha,doublereal * a,const integer*lda,doublereal * b,const integer*ldb, const doublereal*beta,doublereal * c__, const integer*ldc);
DYMOLA_STATIC doublereal dasum_(integer*n, doublereal * dx,integer*incx);
LIBDS_API int daxpy_(const integer*n,doublereal * da,doublereal *dx, const integer*incx,doublereal * dy,const integer*incy);
static void daxpy1_(const integer*np,doublereal * dap,doublereal * dx,doublereal * dy);
DYMOLA_STATIC int dgeequ_(integer *m, integer *n, doublereal *a, integer *lda, doublereal *r__, doublereal *c__, doublereal *rowcnd, doublereal *colcnd, doublereal *amax, integer *info);
DYMOLA_STATIC int dlaqge_(integer *m, integer *n, doublereal *a, integer *lda, doublereal *r__, doublereal *c__, doublereal *rowcnd, doublereal *colcnd, doublereal *amax, char *equed);
DYMOLA_STATIC int dcopy_(const integer *n, const doublereal *dx, const integer*incx, doublereal *dy, const integer*incy);
static doublereal ddot1_(const integer*np, doublereal *dx,doublereal * dy);
DYMOLA_STATIC doublereal ddot_(const integer*n,doublereal *dx,const integer*incx,doublereal *dy,const integer*incy);
DYMOLA_STATIC int dtrsv_(char *uplo, char *trans, char *diag, integer *n,doublereal *a, integer *lda, doublereal *x, integer *incx);
DYMOLA_STATIC integer idamax_(integer*n, doublereal*dx, integer*incx);
DYMOLA_STATIC int dgecon_(const char *norm, integer *n, const doublereal *a, integer *lda, const doublereal *anorm, doublereal *rcond, doublereal *work, integer *iwork, integer *info);

struct dlacon_clean_struct {
	integer i__,j,iter;
	doublereal temp;
	integer jump;
	integer jlast;
	doublereal altsgn,estold;
};
DYMOLA_STATIC int dlacon_(integer *n, doublereal *v, doublereal *x, integer *isgn, doublereal *est, integer *kase);
DYMOLA_STATIC int dlacon_clean(integer*n,doublereal * v,doublereal * x,integer*isgn,doublereal *est,integer*kase,struct dlacon_clean_struct *staticarea);
DYMOLA_STATIC int dlatrs_(char *uplo, char *trans, char *diag, char *normin, integer *n, doublereal *a, integer *lda, doublereal *x, doublereal *scale, doublereal *cnorm, integer *info);
DYMOLA_STATIC int drscl_(integer*n, doublereal*sa, doublereal*sx, integer*incx);
DYMOLA_STATIC int dgeqpf_(const integer *m, integer *n, doublereal *a, integer *lda, integer *jpvt, doublereal *tau, doublereal *work, integer *info);
DYMOLA_STATIC int dgeqr2_(integer *m, integer *n, doublereal *a, integer *lda, doublereal *tau, doublereal *work, integer *info);
DYMOLA_STATIC int dorm2r_(char *side, char *trans, integer *m, integer *n, integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *c__, integer *ldc, doublereal *work, integer *info);
DYMOLA_STATIC int dlarf_(char *side, integer *m, integer *n, doublereal *v, integer *incv, doublereal *tau, doublereal *c__, integer *ldc, doublereal *work);
DYMOLA_STATIC int dlarfg_(integer*n, doublereal*alpha, doublereal * x, integer*incx, doublereal *tau);
DYMOLA_STATIC int dgetrf_(const integer *m, const integer *n, doublereal *a, integer *lda, integer *ipiv, integer *info);
DYMOLA_STATIC int dgetf2_(integer *m, integer *n, doublereal *a, integer *lda, integer *ipiv, integer *info);
DYMOLA_STATIC int dgetrs_(const char *trans, const integer *n, const integer *nrhs, doublereal *a, integer *lda, const integer *ipiv, doublereal *b, integer *ldb, integer *info);
DYMOLA_STATIC int dlabad_(doublereal *small,doublereal *large);
DYMOLA_STATIC int dlaic1_(integer *job, integer *j, doublereal *x, doublereal *sest, doublereal *w, doublereal *gamma, doublereal *sestpr, doublereal *s, doublereal *c__);
DYMOLA_STATIC doublereal dlange_(const char *norm, integer *m, integer *n, const doublereal *a, integer *lda, doublereal *work);
DYMOLA_STATIC int  dlassq_(integer *n, doublereal *x, integer *incx, doublereal *scale, doublereal *sumsq);
DYMOLA_STATIC int dlaswp_(const integer*n,doublereal*a,const integer*lda,const integer *k1,const integer * k2,const integer * ipiv,const integer*incx);
DYMOLA_STATIC doublereal dlapy2_(doublereal *x,doublereal * y);
DYMOLA_STATIC int dlatzm_(char *side, integer *m, integer *n, doublereal *v, integer *incv, doublereal *tau, doublereal *c1, doublereal *c2, integer *ldc, doublereal *work);
DYMOLA_STATIC int dtzrqf_(integer*m, integer*n, doublereal *a, integer*lda, doublereal *tau, integer *info);
DYMOLA_STATIC logical (lsame_)(const char*ca,const char*cb,ftnlen ca_len,ftnlen cb_len);
DYMOLA_STATIC int dgbfa_(doublereal *abd,const integer*lda,const integer*n,const integer*ml,const integer*mu,integer *ipvt,integer *info);
DYMOLA_STATIC int dgbsl_(doublereal *abd,const integer*lda,const integer*n,const integer*ml,const integer*mu,integer *ipvt,doublereal *b,const integer *job);
DYMOLA_STATIC int dgeco_(doublereal *a, integer*lda, integer*n,integer *ipvt,doublereal * rcond,doublereal *z__);
DYMOLA_STATIC int dgefa_(doublereal *a,const integer*lda,const integer*n,integer *ipvt,integer *info);
DYMOLA_STATIC int dgesl_(doublereal *a,const integer*lda,const integer*n,const integer *ipvt,doublereal *b,const integer *job);
DYMOLA_STATIC int dymres_(doublereal *a,const integer*lda,const integer*n,doublereal *b,integer *ierr);
DYMOLA_STATIC int dymsol_(doublereal *a,integer*lda,integer*n,doublereal *b,doublereal *dwork,integer *iwork,integer *ierr);
DYMOLA_STATIC int dymlin_(integer *infrev, integer*n,doublereal *sol,doublereal *res,doublereal *jac, integer *ljac,doublereal *dwork,integer *iwork,doublereal *time, integer *event,integer *printpriority,integer *sysnr,integer *ierr);
DYMOLA_STATIC int dymnl_(integer *infrev,integer *iopt,const integer*n,doublereal *x,doublereal *fvec,doublereal *fjac,const doublereal *tol,
		   const doublereal *toldesired,integer *info,doublereal *dum,integer*ldum,integer *idum,const doublereal *epsfcn);
DYMOLA_STATIC int dymnon_(integer *infrev,integer *qiopt,integer *qnnl,doublereal *qsol,doublereal *qres,doublereal *qjac,
			doublereal *qtol, 
	integer *qinfo,doublereal*qd,integer *qi,integer *printevent,integer *qnlnr,doublereal *time,integer *qnlfunc,integer *qnljac,
	integer *qnlmax,integer *ierr___);
DYMOLA_STATIC int dymnon4_(integer *qinfrev,integer *qiopt,integer *qnnl,doublereal *qsol,doublereal *qres,doublereal *qjac,doublereal *qtol,
			 doublereal *qtoldesired,integer *qinfo,doublereal *qd,integer *qi,integer *idum,
			 integer *printevent,integer *qnlnr,doublereal *time,integer *qnlfunc,integer *qnljac,integer *qnlmax,const char*const*varnames,integer*ierr___);
DYMOLA_STATIC int handleevent_(const char *relation,integer*m,doublereal *cp,doublereal *cn,doublereal *c__,integer *init,
				 integer *printevent,doublereal *eps,doublereal *t,logical *anyevent,ftnlen relation_len);
LIBDS_API int booleanchanged_(const char *varname,logical *var,logical *newvar,integer *printevent, 
	logical *anyevent,ftnlen varname_len);

#ifndef GODESS

DYMOLA_STATIC doublereal dasum_(integer *n, doublereal *dx, integer *incx)
{
    /* System generated locals */
    integer i__1, i__2;
    doublereal ret_val, d__1, d__2, d__3, d__4, d__5, d__6;

    /* Local variables */
    integer i__, m, mp1;
    doublereal dtemp;
    integer nincx;


/*  -- Reference BLAS level1 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
    /* Parameter adjustments */
    --dx;

    /* Function Body */
    ret_val = 0.;
    dtemp = 0.;
    if (*n <= 0 || *incx <= 0) {
	return ret_val;
    }
    if (*incx == 1) {
/*        code for increment equal to 1 */


/*        clean-up loop */

	m = *n % 6;
	if (m != 0) {
	    i__1 = m;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		dtemp += (d__1 = dx[i__], Dymola_abs(d__1));
	    }
	    if (*n < 6) {
		ret_val = dtemp;
		return ret_val;
	    }
	}
	mp1 = m + 1;
	i__1 = *n;
	for (i__ = mp1; i__ <= i__1; i__ += 6) {
	    dtemp = dtemp + (d__1 = dx[i__], Dymola_abs(d__1)) + (d__2 = dx[i__ + 1],
		     Dymola_abs(d__2)) + (d__3 = dx[i__ + 2], Dymola_abs(d__3)) + (d__4 = 
		    dx[i__ + 3], Dymola_abs(d__4)) + (d__5 = dx[i__ + 4], Dymola_abs(d__5)) 
		    + (d__6 = dx[i__ + 5], Dymola_abs(d__6));
	}
    } else {

/*        code for increment not equal to 1 */

	nincx = *n * *incx;
	i__1 = nincx;
	i__2 = *incx;
	for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	    dtemp += (d__1 = dx[i__], Dymola_abs(d__1));
	}
    }
    ret_val = dtemp;
    return ret_val;
} /* dasum_ */

/* Subroutine */ 
LIBDS_API int daxpy_(const integer*n,doublereal * da,doublereal *dx, const integer*incx,doublereal * dy,const integer*incy)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    integer i__, m, ix, iy, mp1;


/*  -- Reference BLAS level1 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
    /* Parameter adjustments */
    --dy;
    --dx;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    if (*da == 0.) {
	return 0;
    }
    if (*incx == 1 && *incy == 1) {

/*        code for both increments equal to 1 */


/*        clean-up loop */

	m = *n % 4;
	if (m != 0) {
	    i__1 = m;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		dy[i__] += *da * dx[i__];
	    }
	}
	if (*n < 4) {
	    return 0;
	}
	mp1 = m + 1;
	i__1 = *n;
	for (i__ = mp1; i__ <= i__1; i__ += 4) {
	    dy[i__] += *da * dx[i__];
	    dy[i__ + 1] += *da * dx[i__ + 1];
	    dy[i__ + 2] += *da * dx[i__ + 2];
	    dy[i__ + 3] += *da * dx[i__ + 3];
	}
    } else {

/*        code for unequal increments or equal increments */
/*          not equal to 1 */

	ix = 1;
	iy = 1;
	if (*incx < 0) {
	    ix = (-(*n) + 1) * *incx + 1;
	}
	if (*incy < 0) {
	    iy = (-(*n) + 1) * *incy + 1;
	}
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    dy[iy] += *da * dx[ix];
	    ix += *incx;
	    iy += *incy;
	}
    }
    return 0;
} /* daxpy_ */
#endif /* GODESS */

static
#if defined(_MSC_VER) && _MSC_VER>=1200
__inline
#elif __GNUC__
__inline
#endif /* defined(_MSC_VER) && _MSC_VER>=1200 */
void daxpy1_(np, dap, dx, dy)
const integer*np;
doublereal *dap, *dx, *dy;
{
    const integer  n = *np;
    const doublereal da = *dap;
    integer i;
	
	/* constant times a vector plus a vector. */
	/* special case for increment=1, no loop unrolling. */
	
    if (da == 0.) return;
	
    for (i = 0; i < n; ++i) {
		dy[i] += da * dx[i];
    }
} /* daxpy1_ */

#ifndef GODESS
/* Subroutine */ DYMOLA_STATIC int dcopy_(const integer *n, const doublereal *dx, const integer *incx, doublereal *dy, const integer *incy)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    integer i__, m, ix, iy, mp1;


/*  -- Reference BLAS level1 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
    /* Parameter adjustments */
    --dy;
    --dx;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    if (*incx == 1 && *incy == 1) {

/*        code for both increments equal to 1 */


/*        clean-up loop */

	m = *n % 7;
	if (m != 0) {
	    i__1 = m;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		dy[i__] = dx[i__];
	    }
	    if (*n < 7) {
		return 0;
	    }
	}
	mp1 = m + 1;
	i__1 = *n;
	for (i__ = mp1; i__ <= i__1; i__ += 7) {
	    dy[i__] = dx[i__];
	    dy[i__ + 1] = dx[i__ + 1];
	    dy[i__ + 2] = dx[i__ + 2];
	    dy[i__ + 3] = dx[i__ + 3];
	    dy[i__ + 4] = dx[i__ + 4];
	    dy[i__ + 5] = dx[i__ + 5];
	    dy[i__ + 6] = dx[i__ + 6];
	}
    } else {

/*        code for unequal increments or equal increments */
/*          not equal to 1 */

	ix = 1;
	iy = 1;
	if (*incx < 0) {
	    ix = (-(*n) + 1) * *incx + 1;
	}
	if (*incy < 0) {
	    iy = (-(*n) + 1) * *incy + 1;
	}
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    dy[iy] = dx[ix];
	    ix += *incx;
	    iy += *incy;
	}
    }
    return 0;
} /* dcopy_ */

#endif /* GODESS */

static
#if defined(_MSC_VER) && _MSC_VER>=1200
__inline
#elif __GNUC__
__inline
#endif /* defined(_MSC_VER) && _MSC_VER>=1200 */
doublereal ddot1_(np, dx, dy)
const integer*np;
doublereal *dx;
doublereal *dy;
{
    const integer n = *np;
    doublereal dtemp = 0;
    integer i;
	
	/*     forms the dot product of two vectors. */
	/*     special case for increment=1, no loop unrolling. */
	
    for (i = 0; i < n; ++i) {
		dtemp += dx[i] * dy[i];
    }
    return dtemp;
} /* ddot1_ */

#ifndef GODESS
DYMOLA_STATIC doublereal ddot_(const integer*n,doublereal *dx,const integer*incx,doublereal *dy,const integer*incy)
{
    /* System generated locals */
    integer i__1;
    doublereal ret_val;

    /* Local variables */
    integer i__, m, ix, iy, mp1;
    doublereal dtemp;


/*  -- Reference BLAS level1 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
    /* Parameter adjustments */
    --dy;
    --dx;

    /* Function Body */
    ret_val = 0.;
    dtemp = 0.;
    if (*n <= 0) {
	return ret_val;
    }
    if (*incx == 1 && *incy == 1) {

/*        code for both increments equal to 1 */


/*        clean-up loop */

	m = *n % 5;
	if (m != 0) {
	    i__1 = m;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		dtemp += dx[i__] * dy[i__];
	    }
	    if (*n < 5) {
		ret_val = dtemp;
		return ret_val;
	    }
	}
	mp1 = m + 1;
	i__1 = *n;
	for (i__ = mp1; i__ <= i__1; i__ += 5) {
	    dtemp = dtemp + dx[i__] * dy[i__] + dx[i__ + 1] * dy[i__ + 1] + 
		    dx[i__ + 2] * dy[i__ + 2] + dx[i__ + 3] * dy[i__ + 3] + 
		    dx[i__ + 4] * dy[i__ + 4];
	}
    } else {

/*        code for unequal increments or equal increments */
/*          not equal to 1 */

	ix = 1;
	iy = 1;
	if (*incx < 0) {
	    ix = (-(*n) + 1) * *incx + 1;
	}
	if (*incy < 0) {
	    iy = (-(*n) + 1) * *incy + 1;
	}
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    dtemp += dx[ix] * dy[iy];
	    ix += *incx;
	    iy += *incy;
	}
    }
    ret_val = dtemp;
    return ret_val;
} /* ddot_ */

/* Subroutine */ static int dgbsv_(const integer* n, const integer* kl, const integer* ku, const integer* nrhs, doublereal* ab, const integer* ldab, integer* ipiv, doublereal* b, const integer* ldb, integer* info)
{
    /* System generated locals */
    integer ab_dim1, ab_offset, b_dim1, b_offset, i__1;

/*  -- LAPACK driver routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    ab_dim1 = *ldab;
    ab_offset = 1 + ab_dim1;
    ab -= ab_offset;
    --ipiv;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    *info = 0;
    if (*n < 0) {
	*info = -1;
    } else if (*kl < 0) {
	*info = -2;
    } else if (*ku < 0) {
	*info = -3;
    } else if (*nrhs < 0) {
	*info = -4;
    } else if (*ldab < (*kl << 1) + *ku + 1) {
	*info = -6;
    } else if (*ldb < Dymola_max(*n,1)) {
	*info = -9;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGBSV ", &i__1);
	return 0;
    }

/*     Compute the LU factorization of the band matrix A. */

    dgbtrf_((integer*)n, (integer*)n, (integer*)kl, (integer*)ku, &ab[ab_offset], (integer*)ldab, &ipiv[1], info);
    if (*info == 0) {

/*        Solve the system A*X = B, overwriting B with X. */

      dgbtrs_("No transpose", (integer*)n, (integer*)kl, (integer*)ku, (integer*)nrhs, &ab[ab_offset], (integer*)ldab, &ipiv[1], &b[b_offset], (integer*)ldb, info);
    }
    return 0;

/*     End of DGBSV */

} /* dgbsv_ */

/* Subroutine */ static int dgbtf2_(integer* m, integer* n, integer* kl, integer* ku, doublereal* ab, integer* ldab, integer* ipiv, integer* info)
{
    /* System generated locals */
    integer ab_dim1, ab_offset, i__1, i__2, i__3, i__4;
    doublereal d__1;

    /* Local variables */
    integer i__, j, km, jp, ju, kv;

/*  -- LAPACK routine (version 3.2) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. */
/*     November 2006 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  Purpose */
/*  ======= */

/*  DGBTF2 computes an LU factorization of a real m-by-n band matrix A */
/*  using partial pivoting with row interchanges. */

/*  This is the unblocked version of the algorithm, calling Level 2 BLAS. */

/*  Arguments */
/*  ========= */

/*  M       (input) INTEGER */
/*          The number of rows of the matrix A.  M >= 0. */

/*  N       (input) INTEGER */
/*          The number of columns of the matrix A.  N >= 0. */

/*  KL      (input) INTEGER */
/*          The number of subdiagonals within the band of A.  KL >= 0. */

/*  KU      (input) INTEGER */
/*          The number of superdiagonals within the band of A.  KU >= 0. */

/*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N) */
/*          On entry, the matrix A in band storage, in rows KL+1 to */
/*          2*KL+KU+1; rows 1 to KL of the array need not be set. */
/*          The j-th column of A is stored in the j-th column of the */
/*          array AB as follows: */
/*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl) */

/*          On exit, details of the factorization: U is stored as an */
/*          upper triangular band matrix with KL+KU superdiagonals in */
/*          rows 1 to KL+KU+1, and the multipliers used during the */
/*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1. */
/*          See below for further details. */

/*  LDAB    (input) INTEGER */
/*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1. */

/*  IPIV    (output) INTEGER array, dimension (min(M,N)) */
/*          The pivot indices; for 1 <= i <= min(M,N), row i of the */
/*          matrix was interchanged with row IPIV(i). */

/*  INFO    (output) INTEGER */
/*          = 0: successful exit */
/*          < 0: if INFO = -i, the i-th argument had an illegal value */
/*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization */
/*               has been completed, but the factor U is exactly */
/*               singular, and division by zero will occur if it is used */
/*               to solve a system of equations. */

/*  Further Details */
/*  =============== */

/*  The band storage scheme is illustrated by the following example, when */
/*  M = N = 6, KL = 2, KU = 1: */

/*  On entry:                       On exit: */

/*      *    *    *    +    +    +       *    *    *   u14  u25  u36 */
/*      *    *    +    +    +    +       *    *   u13  u24  u35  u46 */
/*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56 */
/*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66 */
/*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   * */
/*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    * */

/*  Array elements marked * are not used by the routine; elements marked */
/*  + need not be set on entry, but are required by the routine to store */
/*  elements of U, because of fill-in resulting from the row */
/*  interchanges. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     KV is the number of superdiagonals in the factor U, allowing for */
/*     fill-in. */

    /* Parameter adjustments */
    ab_dim1 = *ldab;
    ab_offset = 1 + ab_dim1;
    ab -= ab_offset;
    --ipiv;

    /* Function Body */
    kv = *ku + *kl;

/*     Test the input parameters. */

    *info = 0;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*kl < 0) {
	*info = -3;
    } else if (*ku < 0) {
	*info = -4;
    } else if (*ldab < *kl + kv + 1) {
	*info = -6;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGBTF2", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {
	return 0;
    }

/*     Gaussian elimination with partial pivoting */

/*     Set fill-in elements in columns KU+2 to KV to zero. */

    i__1 = Dymola_min(kv,*n);
    for (j = *ku + 2; j <= i__1; ++j) {
	i__2 = *kl;
	for (i__ = kv - j + 2; i__ <= i__2; ++i__) {
	    ab[i__ + j * ab_dim1] = 0.;
/* L10: */
	}
/* L20: */
    }

/*     JU is the index of the last column affected by the current stage */
/*     of the factorization. */

    ju = 1;

    i__1 = Dymola_min(*m,*n);
    for (j = 1; j <= i__1; ++j) {

/*        Set fill-in elements in column J+KV to zero. */

	if (j + kv <= *n) {
	    i__2 = *kl;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		ab[i__ + (j + kv) * ab_dim1] = 0.;
/* L30: */
	    }
	}

/*        Find pivot and test for singularity. KM is the number of */
/*        subdiagonal elements in the current column. */

/* Computing MIN */
	i__2 = *kl, i__3 = *m - j;
	km = Dymola_min(i__2,i__3);
	i__2 = km + 1;
	jp = idamax_(&i__2, &ab[kv + 1 + j * ab_dim1], &c__1);
	ipiv[j] = jp + j - 1;
	if (ab[kv + jp + j * ab_dim1] != 0.) {
/* Computing MAX */
/* Computing MIN */
	    i__4 = j + *ku + jp - 1;
	    i__2 = ju, i__3 = Dymola_min(i__4,*n);
	    ju = Dymola_max(i__2,i__3);

/*           Apply interchange to columns J to JU. */

	    if (jp != 1) {
		i__2 = ju - j + 1;
		i__3 = *ldab - 1;
		i__4 = *ldab - 1;
		dswap_(&i__2, &ab[kv + jp + j * ab_dim1], &i__3, &ab[kv + 1 + 
			j * ab_dim1], &i__4);
	    }

	    if (km > 0) {

/*              Compute multipliers. */

		d__1 = 1. / ab[kv + 1 + j * ab_dim1];
		dscal_(&km, &d__1, &ab[kv + 2 + j * ab_dim1], &c__1);

/*              Update trailing submatrix within the band. */

		if (ju > j) {
		    i__2 = ju - j;
		    i__3 = *ldab - 1;
		    i__4 = *ldab - 1;
		    dger_(&km, &i__2, &c_b9, &ab[kv + 2 + j * ab_dim1], &c__1, 
			     &ab[kv + (j + 1) * ab_dim1], &i__3, &ab[kv + 1 + 
			    (j + 1) * ab_dim1], &i__4);
		}
	    }
	} else {

/*           If pivot is zero, set INFO to the index of the pivot */
/*           unless a zero pivot has already been found. */

	    if (*info == 0) {
		*info = j;
	    }
	}
/* L40: */
    }
    return 0;

/*     End of DGBTF2 */

} /* dgbtf2_ */



/* Subroutine */ static int dgbtrf_(integer* m, integer* n, integer* kl, integer* ku, doublereal* ab, integer* ldab, integer* ipiv, integer* info)
{
    /* System generated locals */
    integer ab_dim1, ab_offset, i__1, i__2, i__3, i__4, i__5, i__6;
    doublereal d__1;

    /* Local variables */
    integer i__, j, i2, i3, j2, j3, k2, jb, nb, ii, jj, jm, ip, jp, km, ju, 
	    kv, nw;
    doublereal temp;
    doublereal work13[4160]	/* was [65][64] */, work31[4160]	/* 
	    was [65][64] */;

/*  -- LAPACK routine (version 3.2) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. */
/*     November 2006 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  Purpose */
/*  ======= */

/*  DGBTRF computes an LU factorization of a real m-by-n band matrix A */
/*  using partial pivoting with row interchanges. */

/*  This is the blocked version of the algorithm, calling Level 3 BLAS. */

/*  Arguments */
/*  ========= */

/*  M       (input) INTEGER */
/*          The number of rows of the matrix A.  M >= 0. */

/*  N       (input) INTEGER */
/*          The number of columns of the matrix A.  N >= 0. */

/*  KL      (input) INTEGER */
/*          The number of subdiagonals within the band of A.  KL >= 0. */

/*  KU      (input) INTEGER */
/*          The number of superdiagonals within the band of A.  KU >= 0. */

/*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N) */
/*          On entry, the matrix A in band storage, in rows KL+1 to */
/*          2*KL+KU+1; rows 1 to KL of the array need not be set. */
/*          The j-th column of A is stored in the j-th column of the */
/*          array AB as follows: */
/*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl) */

/*          On exit, details of the factorization: U is stored as an */
/*          upper triangular band matrix with KL+KU superdiagonals in */
/*          rows 1 to KL+KU+1, and the multipliers used during the */
/*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1. */
/*          See below for further details. */

/*  LDAB    (input) INTEGER */
/*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1. */

/*  IPIV    (output) INTEGER array, dimension (min(M,N)) */
/*          The pivot indices; for 1 <= i <= min(M,N), row i of the */
/*          matrix was interchanged with row IPIV(i). */

/*  INFO    (output) INTEGER */
/*          = 0: successful exit */
/*          < 0: if INFO = -i, the i-th argument had an illegal value */
/*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization */
/*               has been completed, but the factor U is exactly */
/*               singular, and division by zero will occur if it is used */
/*               to solve a system of equations. */

/*  Further Details */
/*  =============== */

/*  The band storage scheme is illustrated by the following example, when */
/*  M = N = 6, KL = 2, KU = 1: */

/*  On entry:                       On exit: */

/*      *    *    *    +    +    +       *    *    *   u14  u25  u36 */
/*      *    *    +    +    +    +       *    *   u13  u24  u35  u46 */
/*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56 */
/*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66 */
/*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   * */
/*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    * */

/*  Array elements marked * are not used by the routine; elements marked */
/*  + need not be set on entry, but are required by the routine to store */
/*  elements of U because of fill-in resulting from the row interchanges. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     KV is the number of superdiagonals in the factor U, allowing for */
/*     fill-in */

    /* Parameter adjustments */
    ab_dim1 = *ldab;
    ab_offset = 1 + ab_dim1;
    ab -= ab_offset;
    --ipiv;

    /* Function Body */
    kv = *ku + *kl;

/*     Test the input parameters. */

    *info = 0;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*kl < 0) {
	*info = -3;
    } else if (*ku < 0) {
	*info = -4;
    } else if (*ldab < *kl + kv + 1) {
	*info = -6;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGBTRF", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {
	return 0;
    }

/*     Determine the block size for this environment */

    nb = ilaenv_(&c__1, "DGBTRF", " ", m, n, kl, ku);

/*     The block size must not exceed the limit set by the size of the */
/*     local arrays WORK13 and WORK31. */

    nb = Dymola_min(nb,64);

    if (nb <= 1 || nb > *kl) {

/*        Use unblocked code */

	dgbtf2_(m, n, kl, ku, &ab[ab_offset], ldab, &ipiv[1], info);
    } else {

/*        Use blocked code */

/*        Zero the superdiagonal elements of the work array WORK13 */

	i__1 = nb;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = j - 1;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		work13[i__ + j * 65 - 66] = 0.;
/* L10: */
	    }
/* L20: */
	}

/*        Zero the subdiagonal elements of the work array WORK31 */

	i__1 = nb;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = nb;
	    for (i__ = j + 1; i__ <= i__2; ++i__) {
		work31[i__ + j * 65 - 66] = 0.;
/* L30: */
	    }
/* L40: */
	}

/*        Gaussian elimination with partial pivoting */

/*        Set fill-in elements in columns KU+2 to KV to zero */

	i__1 = Dymola_min(kv,*n);
	for (j = *ku + 2; j <= i__1; ++j) {
	    i__2 = *kl;
	    for (i__ = kv - j + 2; i__ <= i__2; ++i__) {
		ab[i__ + j * ab_dim1] = 0.;
/* L50: */
	    }
/* L60: */
	}

/*        JU is the index of the last column affected by the current */
/*        stage of the factorization */

	ju = 1;

	i__1 = Dymola_min(*m,*n);
	i__2 = nb;
	for (j = 1; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {
/* Computing MIN */
	    i__3 = nb, i__4 = Dymola_min(*m,*n) - j + 1;
	    jb = Dymola_min(i__3,i__4);

/*           The active part of the matrix is partitioned */

/*              A11   A12   A13 */
/*              A21   A22   A23 */
/*              A31   A32   A33 */

/*           Here A11, A21 and A31 denote the current block of JB columns */
/*           which is about to be factorized. The number of rows in the */
/*           partitioning are JB, I2, I3 respectively, and the numbers */
/*           of columns are JB, J2, J3. The superdiagonal elements of A13 */
/*           and the subdiagonal elements of A31 lie outside the band. */

/* Computing MIN */
	    i__3 = *kl - jb, i__4 = *m - j - jb + 1;
	    i2 = Dymola_min(i__3,i__4);
/* Computing MIN */
	    i__3 = jb, i__4 = *m - j - *kl + 1;
	    i3 = Dymola_min(i__3,i__4);

/*           J2 and J3 are computed after JU has been updated. */

/*           Factorize the current block of JB columns */

	    i__3 = j + jb - 1;
	    for (jj = j; jj <= i__3; ++jj) {

/*              Set fill-in elements in column JJ+KV to zero */

		if (jj + kv <= *n) {
		    i__4 = *kl;
		    for (i__ = 1; i__ <= i__4; ++i__) {
			ab[i__ + (jj + kv) * ab_dim1] = 0.;
/* L70: */
		    }
		}

/*              Find pivot and test for singularity. KM is the number of */
/*              subdiagonal elements in the current column. */

/* Computing MIN */
		i__4 = *kl, i__5 = *m - jj;
		km = Dymola_min(i__4,i__5);
		i__4 = km + 1;
		jp = idamax_(&i__4, &ab[kv + 1 + jj * ab_dim1], &c__1);
		ipiv[jj] = jp + jj - j;
		if (ab[kv + jp + jj * ab_dim1] != 0.) {
/* Computing MAX */
/* Computing MIN */
		    i__6 = jj + *ku + jp - 1;
		    i__4 = ju, i__5 = Dymola_min(i__6,*n);
		    ju = Dymola_max(i__4,i__5);
		    if (jp != 1) {

/*                    Apply interchange to columns J to J+JB-1 */

			if (jp + jj - 1 < j + *kl) {

			    i__4 = *ldab - 1;
			    i__5 = *ldab - 1;
			    dswap_(&jb, &ab[kv + 1 + jj - j + j * ab_dim1], &
				    i__4, &ab[kv + jp + jj - j + j * ab_dim1], 
				     &i__5);
			} else {

/*                       The interchange affects columns J to JJ-1 of A31 */
/*                       which are stored in the work array WORK31 */

			    i__4 = jj - j;
			    i__5 = *ldab - 1;
			    dswap_(&i__4, &ab[kv + 1 + jj - j + j * ab_dim1], 
				    &i__5, &work31[jp + jj - j - *kl - 1], &
				    c__65);
			    i__4 = j + jb - jj;
			    i__5 = *ldab - 1;
			    i__6 = *ldab - 1;
			    dswap_(&i__4, &ab[kv + 1 + jj * ab_dim1], &i__5, &
				    ab[kv + jp + jj * ab_dim1], &i__6);
			}
		    }

/*                 Compute multipliers */

		    d__1 = 1. / ab[kv + 1 + jj * ab_dim1];
		    dscal_(&km, &d__1, &ab[kv + 2 + jj * ab_dim1], &c__1);

/*                 Update trailing submatrix within the band and within */
/*                 the current block. JM is the index of the last column */
/*                 which needs to be updated. */

/* Computing MIN */
		    i__4 = ju, i__5 = j + jb - 1;
		    jm = Dymola_min(i__4,i__5);
		    if (jm > jj) {
			i__4 = jm - jj;
			i__5 = *ldab - 1;
			i__6 = *ldab - 1;
			dger_(&km, &i__4, &c_b18, &ab[kv + 2 + jj * ab_dim1], 
				&c__1, &ab[kv + (jj + 1) * ab_dim1], &i__5, &
				ab[kv + 1 + (jj + 1) * ab_dim1], &i__6);
		    }
		} else {

/*                 If pivot is zero, set INFO to the index of the pivot */
/*                 unless a zero pivot has already been found. */

		    if (*info == 0) {
			*info = jj;
		    }
		}

/*              Copy current column of A31 into the work array WORK31 */

/* Computing MIN */
		i__4 = jj - j + 1;
		nw = Dymola_min(i__4,i3);
		if (nw > 0) {
		    dcopy_(&nw, &ab[kv + *kl + 1 - jj + j + jj * ab_dim1], &
			    c__1, &work31[(jj - j + 1) * 65 - 65], &c__1);
		}
/* L80: */
	    }
	    if (j + jb <= *n) {

/*              Apply the row interchanges to the other blocks. */

/* Computing MIN */
		i__3 = ju - j + 1;
		j2 = Dymola_min(i__3,kv) - jb;
/* Computing MAX */
		i__3 = 0, i__4 = ju - j - kv + 1;
		j3 = Dymola_max(i__3,i__4);

/*              Use DLASWP to apply the row interchanges to A12, A22, and */
/*              A32. */

		i__3 = *ldab - 1;
		dlaswp_(&j2, &ab[kv + 1 - jb + (j + jb) * ab_dim1], &i__3, &
			c__1, &jb, &ipiv[j], &c__1);

/*              Adjust the pivot indices. */

		i__3 = j + jb - 1;
		for (i__ = j; i__ <= i__3; ++i__) {
		    ipiv[i__] = ipiv[i__] + j - 1;
/* L90: */
		}

/*              Apply the row interchanges to A13, A23, and A33 */
/*              columnwise. */

		k2 = j - 1 + jb + j2;
		i__3 = j3;
		for (i__ = 1; i__ <= i__3; ++i__) {
		    jj = k2 + i__;
		    i__4 = j + jb - 1;
		    for (ii = j + i__ - 1; ii <= i__4; ++ii) {
			ip = ipiv[ii];
			if (ip != ii) {
			    temp = ab[kv + 1 + ii - jj + jj * ab_dim1];
			    ab[kv + 1 + ii - jj + jj * ab_dim1] = ab[kv + 1 + 
				    ip - jj + jj * ab_dim1];
			    ab[kv + 1 + ip - jj + jj * ab_dim1] = temp;
			}
/* L100: */
		    }
/* L110: */
		}

/*              Update the relevant part of the trailing submatrix */

		if (j2 > 0) {

/*                 Update A12 */

		    i__3 = *ldab - 1;
		    i__4 = *ldab - 1;
		    dtrsm_("Left", "Lower", "No transpose", "Unit", &jb, &j2, 
			    &c_b31, &ab[kv + 1 + j * ab_dim1], &i__3, &ab[kv 
			    + 1 - jb + (j + jb) * ab_dim1], &i__4);

		    if (i2 > 0) {

/*                    Update A22 */

			i__3 = *ldab - 1;
			i__4 = *ldab - 1;
			i__5 = *ldab - 1;
			dgemm_("No transpose", "No transpose", &i2, &j2, &jb, 
				&c_b18, &ab[kv + 1 + jb + j * ab_dim1], &i__3, 
				 &ab[kv + 1 - jb + (j + jb) * ab_dim1], &i__4, 
				 &c_b31, &ab[kv + 1 + (j + jb) * ab_dim1], &
				i__5);
		    }

		    if (i3 > 0) {

/*                    Update A32 */

			i__3 = *ldab - 1;
			i__4 = *ldab - 1;
			dgemm_("No transpose", "No transpose", &i3, &j2, &jb, 
				&c_b18, work31, &c__65, &ab[kv + 1 - jb + (j 
				+ jb) * ab_dim1], &i__3, &c_b31, &ab[kv + *kl 
				+ 1 - jb + (j + jb) * ab_dim1], &i__4);
		    }
		}

		if (j3 > 0) {

/*                 Copy the lower triangle of A13 into the work array */
/*                 WORK13 */

		    i__3 = j3;
		    for (jj = 1; jj <= i__3; ++jj) {
			i__4 = jb;
			for (ii = jj; ii <= i__4; ++ii) {
			    work13[ii + jj * 65 - 66] = ab[ii - jj + 1 + (jj 
				    + j + kv - 1) * ab_dim1];
/* L120: */
			}
/* L130: */
		    }

/*                 Update A13 in the work array */

		    i__3 = *ldab - 1;
		    dtrsm_("Left", "Lower", "No transpose", "Unit", &jb, &j3, 
			    &c_b31, &ab[kv + 1 + j * ab_dim1], &i__3, work13, 
			    &c__65);

		    if (i2 > 0) {

/*                    Update A23 */

			i__3 = *ldab - 1;
			i__4 = *ldab - 1;
			dgemm_("No transpose", "No transpose", &i2, &j3, &jb, 
				&c_b18, &ab[kv + 1 + jb + j * ab_dim1], &i__3, 
				 work13, &c__65, &c_b31, &ab[jb + 1 + (j + kv)
				 * ab_dim1], &i__4);
		    }

		    if (i3 > 0) {

/*                    Update A33 */

			i__3 = *ldab - 1;
			dgemm_("No transpose", "No transpose", &i3, &j3, &jb, 
				&c_b18, work31, &c__65, work13, &c__65, &
				c_b31, &ab[*kl + 1 + (j + kv) * ab_dim1], &
				i__3);
		    }

/*                 Copy the lower triangle of A13 back into place */

		    i__3 = j3;
		    for (jj = 1; jj <= i__3; ++jj) {
			i__4 = jb;
			for (ii = jj; ii <= i__4; ++ii) {
			    ab[ii - jj + 1 + (jj + j + kv - 1) * ab_dim1] = 
				    work13[ii + jj * 65 - 66];
/* L140: */
			}
/* L150: */
		    }
		}
	    } else {

/*              Adjust the pivot indices. */

		i__3 = j + jb - 1;
		for (i__ = j; i__ <= i__3; ++i__) {
		    ipiv[i__] = ipiv[i__] + j - 1;
/* L160: */
		}
	    }

/*           Partially undo the interchanges in the current block to */
/*           restore the upper triangular form of A31 and copy the upper */
/*           triangle of A31 back into place */

	    i__3 = j;
	    for (jj = j + jb - 1; jj >= i__3; --jj) {
		jp = ipiv[jj] - jj + 1;
		if (jp != 1) {

/*                 Apply interchange to columns J to JJ-1 */

		    if (jp + jj - 1 < j + *kl) {

/*                    The interchange does not affect A31 */

			i__4 = jj - j;
			i__5 = *ldab - 1;
			i__6 = *ldab - 1;
			dswap_(&i__4, &ab[kv + 1 + jj - j + j * ab_dim1], &
				i__5, &ab[kv + jp + jj - j + j * ab_dim1], &
				i__6);
		    } else {

/*                    The interchange does affect A31 */

			i__4 = jj - j;
			i__5 = *ldab - 1;
			dswap_(&i__4, &ab[kv + 1 + jj - j + j * ab_dim1], &
				i__5, &work31[jp + jj - j - *kl - 1], &c__65);
		    }
		}

/*              Copy the current column of A31 back into place */

/* Computing MIN */
		i__4 = i3, i__5 = jj - j + 1;
		nw = Dymola_min(i__4,i__5);
		if (nw > 0) {
		    dcopy_(&nw, &work31[(jj - j + 1) * 65 - 65], &c__1, &ab[
			    kv + *kl + 1 - jj + j + jj * ab_dim1], &c__1);
		}
/* L170: */
	    }
/* L180: */
	}
    }

    return 0;

/*     End of DGBTRF */

} /* dgbtrf_ */


/* Subroutine */ static int dgbtrs_(char* trans, integer* n, integer* kl, integer* ku, integer* nrhs, doublereal* ab, integer* ldab, integer* ipiv, 
	doublereal* b, integer* ldb, integer* info)
{
    /* System generated locals */
    integer ab_dim1, ab_offset, b_dim1, b_offset, i__1, i__2, i__3;

    /* Local variables */
    integer i__, j, l, kd, lm;
    logical lnoti;
    logical notran;


/*  -- LAPACK routine (version 3.2) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. */
/*     November 2006 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  Purpose */
/*  ======= */

/*  DGBTRS solves a system of linear equations */
/*     A * X = B  or  A' * X = B */
/*  with a general band matrix A using the LU factorization computed */
/*  by DGBTRF. */

/*  Arguments */
/*  ========= */

/*  TRANS   (input) CHARACTER*1 */
/*          Specifies the form of the system of equations. */
/*          = 'N':  A * X = B  (No transpose) */
/*          = 'T':  A'* X = B  (Transpose) */
/*          = 'C':  A'* X = B  (Conjugate transpose = Transpose) */

/*  N       (input) INTEGER */
/*          The order of the matrix A.  N >= 0. */

/*  KL      (input) INTEGER */
/*          The number of subdiagonals within the band of A.  KL >= 0. */

/*  KU      (input) INTEGER */
/*          The number of superdiagonals within the band of A.  KU >= 0. */

/*  NRHS    (input) INTEGER */
/*          The number of right hand sides, i.e., the number of columns */
/*          of the matrix B.  NRHS >= 0. */

/*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N) */
/*          Details of the LU factorization of the band matrix A, as */
/*          computed by DGBTRF.  U is stored as an upper triangular band */
/*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and */
/*          the multipliers used during the factorization are stored in */
/*          rows KL+KU+2 to 2*KL+KU+1. */

/*  LDAB    (input) INTEGER */
/*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1. */

/*  IPIV    (input) INTEGER array, dimension (N) */
/*          The pivot indices; for 1 <= i <= N, row i of the matrix was */
/*          interchanged with row IPIV(i). */

/*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) */
/*          On entry, the right hand side matrix B. */
/*          On exit, the solution matrix X. */

/*  LDB     (input) INTEGER */
/*          The leading dimension of the array B.  LDB >= max(1,N). */

/*  INFO    (output) INTEGER */
/*          = 0:  successful exit */
/*          < 0: if INFO = -i, the i-th argument had an illegal value */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    ab_dim1 = *ldab;
    ab_offset = 1 + ab_dim1;
    ab -= ab_offset;
    --ipiv;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    *info = 0;
    notran = lsame_(trans, "N", 0, 0);
    if (! notran && ! lsame_(trans, "T", 0, 0) && ! lsame_(
                                                           trans, "C", 0, 0)) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*kl < 0) {
	*info = -3;
    } else if (*ku < 0) {
	*info = -4;
    } else if (*nrhs < 0) {
	*info = -5;
    } else if (*ldab < (*kl << 1) + *ku + 1) {
	*info = -7;
    } else if (*ldb < Dymola_max(1,*n)) {
	*info = -10;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGBTRS", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0 || *nrhs == 0) {
	return 0;
    }

    kd = *ku + *kl + 1;
    lnoti = *kl > 0;

    if (notran) {

/*        Solve  A*X = B. */

/*        Solve L*X = B, overwriting B with X. */

/*        L is represented as a product of permutations and unit lower */
/*        triangular matrices L = P(1) * L(1) * ... * P(n-1) * L(n-1), */
/*        where each transformation L(i) is a rank-one modification of */
/*        the identity matrix. */

	if (lnoti) {
	    i__1 = *n - 1;
	    for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
		i__2 = *kl, i__3 = *n - j;
		lm = Dymola_min(i__2,i__3);
		l = ipiv[j];
		if (l != j) {
		    dswap_(nrhs, &b[l + b_dim1], ldb, &b[j + b_dim1], ldb);
		}
		dger_(&lm, nrhs, &c_b7, &ab[kd + 1 + j * ab_dim1], &c__1, &b[
			j + b_dim1], ldb, &b[j + 1 + b_dim1], ldb);
/* L10: */
	    }
	}

	i__1 = *nrhs;
	for (i__ = 1; i__ <= i__1; ++i__) {

/*           Solve U*X = B, overwriting B with X. */

	    i__2 = *kl + *ku;
	    dtbsv_("Upper", "No transpose", "Non-unit", n, &i__2, &ab[
		    ab_offset], ldab, &b[i__ * b_dim1 + 1], &c__1);
/* L20: */
	}

    } else {

/*        Solve A'*X = B. */

	i__1 = *nrhs;
	for (i__ = 1; i__ <= i__1; ++i__) {

/*           Solve U'*X = B, overwriting B with X. */

	    i__2 = *kl + *ku;
	    dtbsv_("Upper", "Transpose", "Non-unit", n, &i__2, &ab[ab_offset], 
		     ldab, &b[i__ * b_dim1 + 1], &c__1);
/* L30: */
	}

/*        Solve L'*X = B, overwriting B with X. */

	if (lnoti) {
	    for (j = *n - 1; j >= 1; --j) {
/* Computing MIN */
		i__1 = *kl, i__2 = *n - j;
		lm = Dymola_min(i__1,i__2);
		dgemv_("Transpose", &lm, nrhs, &c_b7, &b[j + 1 + b_dim1], ldb, 
			 &ab[kd + 1 + j * ab_dim1], &c__1, &c_b23, &b[j + 
			b_dim1], ldb);
		l = ipiv[j];
		if (l != j) {
		    dswap_(nrhs, &b[l + b_dim1], ldb, &b[j + b_dim1], ldb);
		}
/* L40: */
	    }
	}
    }
    return 0;

/*     End of DGBTRS */

} /* dgbtrs_ */

/* start: functions merely for Modelica.Math.Matrices.LAPACK functions */

/* avoid lenghty compilations for libds and godess */

#ifndef DYMOSIM

/* Subroutine */ static int dgeev_(const char* jobvl, const char* jobvr, integer* n, doublereal* a, integer* lda, doublereal* wr, doublereal* wi, doublereal* vl, const integer* ldvl, doublereal* vr, integer* ldvr, doublereal* work, const integer* lwork, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, vl_dim1, vl_offset, vr_dim1, vr_offset, i__1, 
	    i__2, i__3;
    doublereal d__1, d__2;

    /* Local variables */
    integer i__, k;
    doublereal r__, cs, sn;
    integer ihi;
    doublereal scl;
    integer ilo;
    doublereal dum[1], eps;
    integer ibal;
    char side[1];
    doublereal anrm;
    integer ierr, itau;
    integer iwrk, nout;
    logical scalea;
    doublereal cscale;
    logical select[1];
    doublereal bignum;
    integer minwrk, maxwrk;
    logical wantvl;
    doublereal smlnum;
    integer hswork;
    logical lquery, wantvr;


/*  -- LAPACK driver routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --wr;
    --wi;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --work;

    /* Function Body */
    *info = 0;
    lquery = *lwork == -1;
    wantvl = lsame_(jobvl, "V", (ftnlen)1, (ftnlen)1);
    wantvr = lsame_(jobvr, "V", (ftnlen)1, (ftnlen)1);
    if (! wantvl && ! lsame_(jobvl, "N", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! wantvr && ! lsame_(jobvr, "N", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (*n < 0) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -5;
    } else if (*ldvl < 1 || wantvl && *ldvl < *n) {
	*info = -9;
    } else if (*ldvr < 1 || wantvr && *ldvr < *n) {
	*info = -11;
    }

/*     Compute workspace */
/*      (Note: Comments in the code beginning "Workspace:" describe the */
/*       minimal amount of workspace needed at that point in the code, */
/*       as well as the preferred amount for good performance. */
/*       NB refers to the optimal block size for the immediately */
/*       following subroutine, as returned by ILAENV. */
/*       HSWORK refers to the workspace preferred by DHSEQR, as */
/*       calculated below. HSWORK is computed assuming ILO=1 and IHI=N, */
/*       the worst case.) */

    if (*info == 0) {
	if (*n == 0) {
	    minwrk = 1;
	    maxwrk = 1;
	} else {
	    maxwrk = (*n << 1) + *n * ilaenv_(&c__1, "DGEHRD", " ", n, &c__1, 
		    n, &c__0);
	    if (wantvl) {
		minwrk = *n << 2;
/* Computing MAX */
		i__1 = maxwrk, i__2 = (*n << 1) + (*n - 1) * ilaenv_(&c__1, 
			"DORGHR", " ", n, &c__1, n, &c_n1);
		maxwrk = Dymola_max(i__1,i__2);
		dhseqr_("S", "V", n, &c__1, n, &a[a_offset], lda, &wr[1], &wi[1], &vl[vl_offset], (integer*) ldvl, &work[1], &c_n1, info);
		hswork = (integer) work[1];
/* Computing MAX */
		i__1 = maxwrk, i__2 = *n + 1, i__1 = Dymola_max(i__1,i__2), i__2 = *
			n + hswork;
		maxwrk = Dymola_max(i__1,i__2);
/* Computing MAX */
		i__1 = maxwrk, i__2 = *n << 2;
		maxwrk = Dymola_max(i__1,i__2);
	    } else if (wantvr) {
		minwrk = *n << 2;
/* Computing MAX */
		i__1 = maxwrk, i__2 = (*n << 1) + (*n - 1) * ilaenv_(&c__1, 
			"DORGHR", " ", n, &c__1, n, &c_n1);
		maxwrk = Dymola_max(i__1,i__2);
		dhseqr_("S", "V", n, &c__1, n, &a[a_offset], lda, &wr[1], &wi[1], &vr[vr_offset], (integer*) ldvr, &work[1], &c_n1, info);
		hswork = (integer) work[1];
/* Computing MAX */
		i__1 = maxwrk, i__2 = *n + 1, i__1 = Dymola_max(i__1,i__2), i__2 = *
			n + hswork;
		maxwrk = Dymola_max(i__1,i__2);
/* Computing MAX */
		i__1 = maxwrk, i__2 = *n << 2;
		maxwrk = Dymola_max(i__1,i__2);
	    } else {
		minwrk = *n * 3;
		dhseqr_("E", "N", n, &c__1, n, &a[a_offset], lda, &wr[1], &wi[1], &vr[vr_offset], (integer*) ldvr, &work[1], &c_n1, info);
		hswork = (integer) work[1];
/* Computing MAX */
		i__1 = maxwrk, i__2 = *n + 1, i__1 = Dymola_max(i__1,i__2), i__2 = *
			n + hswork;
		maxwrk = Dymola_max(i__1,i__2);
	    }
	    maxwrk = Dymola_max(maxwrk,minwrk);
	}
	work[1] = (doublereal) maxwrk;

	if (*lwork < minwrk && ! lquery) {
	    *info = -13;
	}
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGEEV ", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

/*     Get machine constants */

    eps = dlamch_("P");
    smlnum = dlamch_("S");
    bignum = 1. / smlnum;
    dlabad_(&smlnum, &bignum);
    smlnum = sqrt(smlnum) / eps;
    bignum = 1. / smlnum;

/*     Scale A if max element outside range [SMLNUM,BIGNUM] */

    anrm = dlange_("M", n, n, &a[a_offset], lda, dum);
    scalea = FALSE_;
    if (anrm > 0. && anrm < smlnum) {
	scalea = TRUE_;
	cscale = smlnum;
    } else if (anrm > bignum) {
	scalea = TRUE_;
	cscale = bignum;
    }
    if (scalea) {
	dlascl_("G", &c__0, &c__0, &anrm, &cscale, n, n, &a[a_offset], lda, &
		ierr);
    }

/*     Balance the matrix */
/*     (Workspace: need N) */

    ibal = 1;
    dgebal_("B", n, &a[a_offset], lda, &ilo, &ihi, &work[ibal], &ierr);

/*     Reduce to upper Hessenberg form */
/*     (Workspace: need 3*N, prefer 2*N+N*NB) */

    itau = ibal + *n;
    iwrk = itau + *n;
    i__1 = *lwork - iwrk + 1;
    dgehrd_(n, &ilo, &ihi, &a[a_offset], lda, &work[itau], &work[iwrk], &i__1,
	     &ierr);

    if (wantvl) {

/*        Want left eigenvectors */
/*        Copy Householder vectors to VL */

	*(unsigned char *)side = 'L';
	dlacpy_("L", n, n, &a[a_offset], (integer*) lda, &vl[vl_offset], (integer*) ldvl)
		;

/*        Generate orthogonal matrix in VL */
/*        (Workspace: need 3*N-1, prefer 2*N+(N-1)*NB) */

	i__1 = *lwork - iwrk + 1;
	dorghr_(n, &ilo, &ihi, &vl[vl_offset], (integer*) ldvl, &work[itau], &work[iwrk],
		 &i__1, &ierr);

/*        Perform QR iteration, accumulating Schur vectors in VL */
/*        (Workspace: need N+1, prefer N+HSWORK (see comments) ) */

	iwrk = itau;
	i__1 = *lwork - iwrk + 1;
	dhseqr_("S", "V", n, &ilo, &ihi, &a[a_offset], lda, &wr[1], &wi[1], &vl[vl_offset], (Integer*) ldvl, &work[iwrk], &i__1, info);

	if (wantvr) {

/*           Want left and right eigenvectors */
/*           Copy Schur vectors to VR */

	    *(unsigned char *)side = 'B';
	    dlacpy_("F", n, n, &vl[vl_offset], (integer*) ldvl, &vr[vr_offset], (integer*) ldvr);
	}

    } else if (wantvr) {

/*        Want right eigenvectors */
/*        Copy Householder vectors to VR */

	*(unsigned char *)side = 'R';
	dlacpy_("L", n, n, &a[a_offset], (integer*) lda, &vr[vr_offset], (integer*) ldvr)
		;

/*        Generate orthogonal matrix in VR */
/*        (Workspace: need 3*N-1, prefer 2*N+(N-1)*NB) */

	i__1 = *lwork - iwrk + 1;
	dorghr_(n, &ilo, &ihi, &vr[vr_offset], (integer*) ldvr, &work[itau], &work[iwrk],
		 &i__1, &ierr);

/*        Perform QR iteration, accumulating Schur vectors in VR */
/*        (Workspace: need N+1, prefer N+HSWORK (see comments) ) */

	iwrk = itau;
	i__1 = *lwork - iwrk + 1;
	dhseqr_("S", "V", n, &ilo, &ihi, &a[a_offset], lda, &wr[1], &wi[1], &vr[vr_offset], (integer*) ldvr, &work[iwrk], &i__1, info);

    } else {

/*        Compute eigenvalues only */
/*        (Workspace: need N+1, prefer N+HSWORK (see comments) ) */

	iwrk = itau;
	i__1 = *lwork - iwrk + 1;
	dhseqr_("E", "N", n, &ilo, &ihi, &a[a_offset], lda, &wr[1], &wi[1], &vr[vr_offset], (integer*) ldvr, &work[iwrk], &i__1, info);
    }

/*     If INFO > 0 from DHSEQR, then quit */

    if (*info > 0) {
	goto L50;
    }

    if (wantvl || wantvr) {

/*        Compute left and/or right eigenvectors */
/*        (Workspace: need 4*N) */

      dtrevc_(side, "B", select, n, &a[a_offset], lda, &vl[vl_offset], (integer*) ldvl,
              &vr[vr_offset], ldvr, n, &nout, &work[iwrk], &ierr);
    }

    if (wantvl) {

/*        Undo balancing of left eigenvectors */
/*        (Workspace: need N) */

      dgebak_("B", "L", n, &ilo, &ihi, &work[ibal], n, &vl[vl_offset], (integer*) ldvl, &ierr);

/*        Normalize left eigenvectors and make largest component real */

	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (wi[i__] == 0.) {
		scl = 1. / dnrm2_(n, &vl[i__ * vl_dim1 + 1], &c__1);
		dscal_(n, &scl, &vl[i__ * vl_dim1 + 1], &c__1);
	    } else if (wi[i__] > 0.) {
		d__1 = dnrm2_(n, &vl[i__ * vl_dim1 + 1], &c__1);
		d__2 = dnrm2_(n, &vl[(i__ + 1) * vl_dim1 + 1], &c__1);
		scl = 1. / dlapy2_(&d__1, &d__2);
		dscal_(n, &scl, &vl[i__ * vl_dim1 + 1], &c__1);
		dscal_(n, &scl, &vl[(i__ + 1) * vl_dim1 + 1], &c__1);
		i__2 = *n;
		for (k = 1; k <= i__2; ++k) {
/* Computing 2nd power */
		    d__1 = vl[k + i__ * vl_dim1];
/* Computing 2nd power */
		    d__2 = vl[k + (i__ + 1) * vl_dim1];
		    work[iwrk + k - 1] = d__1 * d__1 + d__2 * d__2;
/* L10: */
		}
		k = idamax_(n, &work[iwrk], &c__1);
		dlartg_(&vl[k + i__ * vl_dim1], &vl[k + (i__ + 1) * vl_dim1], 
			&cs, &sn, &r__);
		drot_(n, &vl[i__ * vl_dim1 + 1], &c__1, &vl[(i__ + 1) * 
			vl_dim1 + 1], &c__1, &cs, &sn);
		vl[k + (i__ + 1) * vl_dim1] = 0.;
	    }
/* L20: */
	}
    }

    if (wantvr) {

/*        Undo balancing of right eigenvectors */
/*        (Workspace: need N) */

      dgebak_("B", "R", n, &ilo, &ihi, &work[ibal], n, &vr[vr_offset], (integer*) ldvr, &ierr);

/*        Normalize right eigenvectors and make largest component real */

	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (wi[i__] == 0.) {
		scl = 1. / dnrm2_(n, &vr[i__ * vr_dim1 + 1], &c__1);
		dscal_(n, &scl, &vr[i__ * vr_dim1 + 1], &c__1);
	    } else if (wi[i__] > 0.) {
		d__1 = dnrm2_(n, &vr[i__ * vr_dim1 + 1], &c__1);
		d__2 = dnrm2_(n, &vr[(i__ + 1) * vr_dim1 + 1], &c__1);
		scl = 1. / dlapy2_(&d__1, &d__2);
		dscal_(n, &scl, &vr[i__ * vr_dim1 + 1], &c__1);
		dscal_(n, &scl, &vr[(i__ + 1) * vr_dim1 + 1], &c__1);
		i__2 = *n;
		for (k = 1; k <= i__2; ++k) {
/* Computing 2nd power */
		    d__1 = vr[k + i__ * vr_dim1];
/* Computing 2nd power */
		    d__2 = vr[k + (i__ + 1) * vr_dim1];
		    work[iwrk + k - 1] = d__1 * d__1 + d__2 * d__2;
/* L30: */
		}
		k = idamax_(n, &work[iwrk], &c__1);
		dlartg_(&vr[k + i__ * vr_dim1], &vr[k + (i__ + 1) * vr_dim1], 
			&cs, &sn, &r__);
		drot_(n, &vr[i__ * vr_dim1 + 1], &c__1, &vr[(i__ + 1) * 
			vr_dim1 + 1], &c__1, &cs, &sn);
		vr[k + (i__ + 1) * vr_dim1] = 0.;
	    }
/* L40: */
	}
    }

/*     Undo scaling if necessary */

L50:
    if (scalea) {
	i__1 = *n - *info;
/* Computing MAX */
	i__3 = *n - *info;
	i__2 = Dymola_max(i__3,1);
	dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wr[*info + 
		1], &i__2, &ierr);
	i__1 = *n - *info;
/* Computing MAX */
	i__3 = *n - *info;
	i__2 = Dymola_max(i__3,1);
	dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wi[*info + 
		1], &i__2, &ierr);
	if (*info > 0) {
	    i__1 = ilo - 1;
	    dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wr[1], 
		    n, &ierr);
	    i__1 = ilo - 1;
	    dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wi[1], 
		    n, &ierr);
	}
    }

    work[1] = (doublereal) maxwrk;
    return 0;

/*     End of DGEEV */

} /* dgeev_ */

/* Subroutine */ static int dhseqr_(const char* job, const char* compz, integer* n, integer* ilo, integer* ihi, doublereal* h__, integer* ldh, doublereal* wr, doublereal* wi, doublereal* z__, integer* ldz, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    address a__1[2];
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2[2], i__3;
    doublereal d__1;
    char ch__1[2];

    /* Builtin functions */

    /* Local variables */
    integer i__;
    doublereal hl[2401]	/* was [49][49] */;
    integer kbot, nmin;
    logical initz;
    doublereal workl[49];
    logical wantt, wantz;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */

/*     ==== Matrices of order NTINY or smaller must be processed by */
/*     .    DLAHQR because of insufficient subdiagonal scratch space. */
/*     .    (This is a hard limit.) ==== */

/*     ==== NL allocates some local workspace to help small matrices */
/*     .    through a rare DLAHQR failure.  NL .GT. NTINY = 11 is */
/*     .    required and NL .LE. NMIN = ILAENV(ISPEC=12,...) is recom- */
/*     .    mended.  (The default value of NMIN is 75.)  Using NL = 49 */
/*     .    allows up to six simultaneous shifts and a 16-by-16 */
/*     .    deflation window.  ==== */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     ==== Decode and check the input parameters. ==== */

    /* Parameter adjustments */
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    --wr;
    --wi;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --work;

    /* Function Body */
    wantt = lsame_(job, "S", (ftnlen)1, (ftnlen)1);
    initz = lsame_(compz, "I", (ftnlen)1, (ftnlen)1);
    wantz = initz || lsame_(compz, "V", (ftnlen)1, (ftnlen)1);
    work[1] = (doublereal) Dymola_max(1,*n);
    lquery = *lwork == -1;

    *info = 0;
    if (! lsame_(job, "E", (ftnlen)1, (ftnlen)1) && ! wantt) {
	*info = -1;
    } else if (! lsame_(compz, "N", (ftnlen)1, (ftnlen)1) && ! wantz) {
	*info = -2;
    } else if (*n < 0) {
	*info = -3;
    } else if (*ilo < 1 || *ilo > Dymola_max(1,*n)) {
	*info = -4;
    } else if (*ihi < Dymola_min(*ilo,*n) || *ihi > *n) {
	*info = -5;
    } else if (*ldh < Dymola_max(1,*n)) {
	*info = -7;
    } else if (*ldz < 1 || wantz && *ldz < Dymola_max(1,*n)) {
	*info = -11;
    } else if (*lwork < Dymola_max(1,*n) && ! lquery) {
	*info = -13;
    }

    if (*info != 0) {

/*        ==== Quick return in case of invalid argument. ==== */

	i__1 = -(*info);
	xerbla_("DHSEQR", &i__1);
	return 0;

    } else if (*n == 0) {

/*        ==== Quick return in case N = 0; nothing to do. ==== */

	return 0;

    } else if (lquery) {

/*        ==== Quick return in case of a workspace query ==== */

	dlaqr0_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], &wi[
		1], ilo, ihi, &z__[z_offset], ldz, &work[1], lwork, info);
/*        ==== Ensure reported workspace size is backward-compatible with */
/*        .    previous LAPACK versions. ==== */
/* Computing MAX */
	d__1 = (doublereal) Dymola_max(1,*n);
	work[1] = Dymola_max(d__1,work[1]);
	return 0;

    } else {

/*        ==== copy eigenvalues isolated by DGEBAL ==== */

	i__1 = *ilo - 1;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    wr[i__] = h__[i__ + i__ * h_dim1];
	    wi[i__] = 0.;
/* L10: */
	}
	i__1 = *n;
	for (i__ = *ihi + 1; i__ <= i__1; ++i__) {
	    wr[i__] = h__[i__ + i__ * h_dim1];
	    wi[i__] = 0.;
/* L20: */
	}

/*        ==== Initialize Z, if requested ==== */

	if (initz) {
	    dlaset_("A", n, n, &c_b11_dhseqr, &c_b12, &z__[z_offset], ldz)
		    ;
	}

/*        ==== Quick return if possible ==== */

	if (*ilo == *ihi) {
	    wr[*ilo] = h__[*ilo + *ilo * h_dim1];
	    wi[*ilo] = 0.;
	    return 0;
	}

/*        ==== DLAHQR/DLAQR0 crossover point ==== */

/* Writing concatenation */
	i__2[0] = 1, a__1[0] = job;
	i__2[1] = 1, a__1[1] = compz;
	s_cat(ch__1, a__1, i__2, &c__2, (ftnlen)2);
	nmin = ilaenv_(&c__12, "DHSEQR", ch__1, n, ilo, ihi, lwork);
	nmin = Dymola_max(11,nmin);

/*        ==== DLAQR0 for big matrices; DLAHQR for small ones ==== */

	if (*n > nmin) {
	    dlaqr0_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], 
		    &wi[1], ilo, ihi, &z__[z_offset], ldz, &work[1], lwork, 
		    info);
	} else {

/*           ==== Small matrix ==== */

	    dlahqr_(&wantt, &wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], 
		    &wi[1], ilo, ihi, &z__[z_offset], ldz, info);

	    if (*info > 0) {

/*              ==== A rare DLAHQR failure!  DLAQR0 sometimes succeeds */
/*              .    when DLAHQR fails. ==== */

		kbot = *info;

		if (*n >= 49) {

/*                 ==== Larger matrices have enough subdiagonal scratch */
/*                 .    space to call DLAQR0 directly. ==== */

		    dlaqr0_(&wantt, &wantz, n, ilo, &kbot, &h__[h_offset], 
			    ldh, &wr[1], &wi[1], ilo, ihi, &z__[z_offset], 
			    ldz, &work[1], lwork, info);

		} else {

/*                 ==== Tiny matrices don't have enough subdiagonal */
/*                 .    scratch space to benefit from DLAQR0.  Hence, */
/*                 .    tiny matrices must be copied into a larger */
/*                 .    array before calling DLAQR0. ==== */

		    dlacpy_("A", n, n, &h__[h_offset], ldh, hl, &c__49);
		    hl[*n + 1 + *n * 49 - 50] = 0.;
		    i__1 = 49 - *n;
		    dlaset_("A", &c__49, &i__1, &c_b11_dhseqr, &c_b11_dhseqr, &hl[(*n + 1) *
			     49 - 49], &c__49);
		    dlaqr0_(&wantt, &wantz, &c__49, ilo, &kbot, hl, &c__49, &
			    wr[1], &wi[1], ilo, ihi, &z__[z_offset], ldz, 
			    workl, &c__49, info);
		    if (wantt || *info != 0) {
			dlacpy_("A", n, n, hl, &c__49, &h__[h_offset], ldh);
		    }
		}
	    }
	}

/*        ==== Clear out the trash, if necessary. ==== */

	if ((wantt || *info != 0) && *n > 2) {
	    i__1 = *n - 2;
	    i__3 = *n - 2;
	    dlaset_("L", &i__1, &i__3, &c_b11_dhseqr, &c_b11_dhseqr, &h__[h_dim1 + 3], ldh);
	}

/*        ==== Ensure reported workspace size is backward-compatible with */
/*        .    previous LAPACK versions. ==== */

/* Computing MAX */
	d__1 = (doublereal) Dymola_max(1,*n);
	work[1] = Dymola_max(d__1,work[1]);
    }

/*     ==== End of DHSEQR ==== */

    return 0;
} /* dhseqr_ */

/* Subroutine */ static int dlascl_(char* type__, integer* kl, integer* ku, doublereal* cfrom, doublereal* cto, integer* m, integer* n, doublereal* a, integer* lda, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;

    /* Local variables */
    integer i__, j, k1, k2, k3, k4;
    doublereal mul, cto1;
    logical done;
    doublereal ctoc;
    integer itype;
    doublereal cfrom1;
    doublereal cfromc;
    doublereal bignum, smlnum;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;

    if (lsame_(type__, "G", (ftnlen)1, (ftnlen)1)) {
	itype = 0;
    } else if (lsame_(type__, "L", (ftnlen)1, (ftnlen)1)) {
	itype = 1;
    } else if (lsame_(type__, "U", (ftnlen)1, (ftnlen)1)) {
	itype = 2;
    } else if (lsame_(type__, "H", (ftnlen)1, (ftnlen)1)) {
	itype = 3;
    } else if (lsame_(type__, "B", (ftnlen)1, (ftnlen)1)) {
	itype = 4;
    } else if (lsame_(type__, "Q", (ftnlen)1, (ftnlen)1)) {
	itype = 5;
    } else if (lsame_(type__, "Z", (ftnlen)1, (ftnlen)1)) {
	itype = 6;
    } else {
	itype = -1;
    }

    if (itype == -1) {
	*info = -1;
    } else if (*cfrom == 0. || disnan_(cfrom)) {
	*info = -4;
    } else if (disnan_(cto)) {
	*info = -5;
    } else if (*m < 0) {
	*info = -6;
    } else if (*n < 0 || itype == 4 && *n != *m || itype == 5 && *n != *m) {
	*info = -7;
    } else if (itype <= 3 && *lda < Dymola_max(1,*m)) {
	*info = -9;
    } else if (itype >= 4) {
/* Computing MAX */
	i__1 = *m - 1;
	if (*kl < 0 || *kl > Dymola_max(i__1,0)) {
	    *info = -2;
	} else /* if(complicated condition) */ {
/* Computing MAX */
	    i__1 = *n - 1;
	    if (*ku < 0 || *ku > Dymola_max(i__1,0) || (itype == 4 || itype == 5) && 
		    *kl != *ku) {
		*info = -3;
	    } else if (itype == 4 && *lda < *kl + 1 || itype == 5 && *lda < *
		    ku + 1 || itype == 6 && *lda < (*kl << 1) + *ku + 1) {
		*info = -9;
	    }
	}
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DLASCL", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0 || *m == 0) {
	return 0;
    }

/*     Get machine parameters */

    smlnum = dlamch_("S");
    bignum = 1. / smlnum;

    cfromc = *cfrom;
    ctoc = *cto;

L10:
    cfrom1 = cfromc * smlnum;
    if (cfrom1 == cfromc) {
/*        CFROMC is an inf.  Multiply by a correctly signed zero for */
/*        finite CTOC, or a NaN if CTOC is infinite. */
	mul = ctoc / cfromc;
	done = TRUE_;
	cto1 = ctoc;
    } else {
	cto1 = ctoc / bignum;
	if (cto1 == ctoc) {
/*           CTOC is either 0 or an inf.  In both cases, CTOC itself */
/*           serves as the correct multiplication factor. */
	    mul = ctoc;
	    done = TRUE_;
	    cfromc = 1.;
	} else if (Dymola_abs(cfrom1) > Dymola_abs(ctoc) && ctoc != 0.) {
	    mul = smlnum;
	    done = FALSE_;
	    cfromc = cfrom1;
	} else if (Dymola_abs(cto1) > Dymola_abs(cfromc)) {
	    mul = bignum;
	    done = FALSE_;
	    ctoc = cto1;
	} else {
	    mul = ctoc / cfromc;
	    done = TRUE_;
	}
    }

    if (itype == 0) {

/*        Full matrix */

	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *m;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		a[i__ + j * a_dim1] *= mul;
/* L20: */
	    }
/* L30: */
	}

    } else if (itype == 1) {

/*        Lower triangular matrix */

	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *m;
	    for (i__ = j; i__ <= i__2; ++i__) {
		a[i__ + j * a_dim1] *= mul;
/* L40: */
	    }
/* L50: */
	}

    } else if (itype == 2) {

/*        Upper triangular matrix */

	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = Dymola_min(j,*m);
	    for (i__ = 1; i__ <= i__2; ++i__) {
		a[i__ + j * a_dim1] *= mul;
/* L60: */
	    }
/* L70: */
	}

    } else if (itype == 3) {

/*        Upper Hessenberg matrix */

	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
	    i__3 = j + 1;
	    i__2 = Dymola_min(i__3,*m);
	    for (i__ = 1; i__ <= i__2; ++i__) {
		a[i__ + j * a_dim1] *= mul;
/* L80: */
	    }
/* L90: */
	}

    } else if (itype == 4) {

/*        Lower half of a symmetric band matrix */

	k3 = *kl + 1;
	k4 = *n + 1;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
	    i__3 = k3, i__4 = k4 - j;
	    i__2 = Dymola_min(i__3,i__4);
	    for (i__ = 1; i__ <= i__2; ++i__) {
		a[i__ + j * a_dim1] *= mul;
/* L100: */
	    }
/* L110: */
	}

    } else if (itype == 5) {

/*        Upper half of a symmetric band matrix */

	k1 = *ku + 2;
	k3 = *ku + 1;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
	    i__2 = k1 - j;
	    i__3 = k3;
	    for (i__ = Dymola_max(i__2,1); i__ <= i__3; ++i__) {
		a[i__ + j * a_dim1] *= mul;
/* L120: */
	    }
/* L130: */
	}

    } else if (itype == 6) {

/*        Band matrix */

	k1 = *kl + *ku + 2;
	k2 = *kl + 1;
	k3 = (*kl << 1) + *ku + 1;
	k4 = *kl + *ku + 1 + *m;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
	    i__3 = k1 - j;
/* Computing MIN */
	    i__4 = k3, i__5 = k4 - j;
	    i__2 = Dymola_min(i__4,i__5);
	    for (i__ = Dymola_max(i__3,k2); i__ <= i__2; ++i__) {
		a[i__ + j * a_dim1] *= mul;
/* L140: */
	    }
/* L150: */
	}

    }

    if (! done) {
	goto L10;
    }

    return 0;

/*     End of DLASCL */

} /* dlascl_ */

/* Subroutine */ static int dgebal_(char* job, integer* n, doublereal* a, integer* lda, integer* ilo, integer* ihi, doublereal* scale, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal d__1, d__2;

    /* Local variables */
    doublereal c__, f, g;
    integer i__, j, k, l, m;
    doublereal r__, s, ca, ra;
    integer ica, ira, iexc;
    doublereal sfmin1, sfmin2, sfmax1, sfmax2;
    logical noconv;


/*  -- LAPACK computational routine (version 3.5.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2013 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --scale;

    /* Function Body */
    *info = 0;
    if (! lsame_(job, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(job, "P", (
	    ftnlen)1, (ftnlen)1) && ! lsame_(job, "S", (ftnlen)1, (ftnlen)1) 
	    && ! lsame_(job, "B", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -4;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGEBAL", &i__1);
	return 0;
    }

    k = 1;
    l = *n;

    if (*n == 0) {
	goto L210;
    }

    if (lsame_(job, "N", (ftnlen)1, (ftnlen)1)) {
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    scale[i__] = 1.;
/* L10: */
	}
	goto L210;
    }

    if (lsame_(job, "S", (ftnlen)1, (ftnlen)1)) {
	goto L120;
    }

/*     Permutation to isolate eigenvalues if possible */

    goto L50;

/*     Row and column exchange. */

L20:
    scale[m] = (doublereal) j;
    if (j == m) {
	goto L30;
    }

    dswap_(&l, &a[j * a_dim1 + 1], &c__1, &a[m * a_dim1 + 1], &c__1);
    i__1 = *n - k + 1;
    dswap_(&i__1, &a[j + k * a_dim1], lda, &a[m + k * a_dim1], lda);

L30:
    switch (iexc) {
	case 1:  goto L40;
	case 2:  goto L80;
    }

/*     Search for rows isolating an eigenvalue and push them down. */

L40:
    if (l == 1) {
	goto L210;
    }
    --l;

L50:
    for (j = l; j >= 1; --j) {

	i__1 = l;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (i__ == j) {
		goto L60;
	    }
	    if (a[j + i__ * a_dim1] != 0.) {
		goto L70;
	    }
L60:
	    ;
	}

	m = l;
	iexc = 1;
	goto L20;
L70:
	;
    }

    goto L90;

/*     Search for columns isolating an eigenvalue and push them left. */

L80:
    ++k;

L90:
    i__1 = l;
    for (j = k; j <= i__1; ++j) {

	i__2 = l;
	for (i__ = k; i__ <= i__2; ++i__) {
	    if (i__ == j) {
		goto L100;
	    }
	    if (a[i__ + j * a_dim1] != 0.) {
		goto L110;
	    }
L100:
	    ;
	}

	m = k;
	iexc = 2;
	goto L20;
L110:
	;
    }

L120:
    i__1 = l;
    for (i__ = k; i__ <= i__1; ++i__) {
	scale[i__] = 1.;
/* L130: */
    }

    if (lsame_(job, "P", (ftnlen)1, (ftnlen)1)) {
	goto L210;
    }

/*     Balance the submatrix in rows K to L. */

/*     Iterative loop for norm reduction */

    sfmin1 = dlamch_("S") / dlamch_("P");
    sfmax1 = 1. / sfmin1;
    sfmin2 = sfmin1 * 2.;
    sfmax2 = 1. / sfmin2;

L140:
    noconv = FALSE_;

    i__1 = l;
    for (i__ = k; i__ <= i__1; ++i__) {

	i__2 = l - k + 1;
	c__ = dnrm2_(&i__2, &a[k + i__ * a_dim1], &c__1);
	i__2 = l - k + 1;
	r__ = dnrm2_(&i__2, &a[i__ + k * a_dim1], lda);
	ica = idamax_(&l, &a[i__ * a_dim1 + 1], &c__1);
	ca = (d__1 = a[ica + i__ * a_dim1], Dymola_abs(d__1));
	i__2 = *n - k + 1;
	ira = idamax_(&i__2, &a[i__ + k * a_dim1], lda);
	ra = (d__1 = a[i__ + (ira + k - 1) * a_dim1], Dymola_abs(d__1));

/*        Guard against zero C or R due to underflow. */

	if (c__ == 0. || r__ == 0.) {
	    goto L200;
	}
	g = r__ / 2.;
	f = 1.;
	s = c__ + r__;
L160:
/* Computing MAX */
	d__1 = Dymola_max(f,c__);
/* Computing MIN */
	d__2 = Dymola_min(r__,g);
	if (c__ >= g || Dymola_max(d__1,ca) >= sfmax2 || Dymola_min(d__2,ra) <= sfmin2) {
	    goto L170;
	}
	d__1 = c__ + f + ca + r__ + g + ra;
	if (disnan_(&d__1)) {

/*           Exit if NaN to avoid infinite loop */

	    *info = -3;
	    i__2 = -(*info);
	    xerbla_("DGEBAL", &i__2);
	    return 0;
	}
	f *= 2.;
	c__ *= 2.;
	ca *= 2.;
	r__ /= 2.;
	g /= 2.;
	ra /= 2.;
	goto L160;

L170:
	g = c__ / 2.;
L180:
/* Computing MIN */
	d__1 = Dymola_min(f,c__), d__1 = Dymola_min(d__1,g);
	if (g < r__ || Dymola_max(r__,ra) >= sfmax2 || Dymola_min(d__1,ca) <= sfmin2) {
	    goto L190;
	}
	f /= 2.;
	c__ /= 2.;
	g /= 2.;
	ca /= 2.;
	r__ *= 2.;
	ra *= 2.;
	goto L180;

/*        Now balance. */

L190:
	if (c__ + r__ >= s * .95) {
	    goto L200;
	}
	if (f < 1. && scale[i__] < 1.) {
	    if (f * scale[i__] <= sfmin1) {
		goto L200;
	    }
	}
	if (f > 1. && scale[i__] > 1.) {
	    if (scale[i__] >= sfmax1 / f) {
		goto L200;
	    }
	}
	g = 1. / f;
	scale[i__] *= f;
	noconv = TRUE_;

	i__2 = *n - k + 1;
	dscal_(&i__2, &g, &a[i__ + k * a_dim1], lda);
	dscal_(&l, &f, &a[i__ * a_dim1 + 1], &c__1);

L200:
	;
    }

    if (noconv) {
	goto L140;
    }

L210:
    *ilo = k;
    *ihi = l;

    return 0;

/*     End of DGEBAL */

} /* dgebal_ */

/* Subroutine */ static int dgehrd_(integer* n, const integer* ilo, const integer* ihi, 
	doublereal* a, integer* lda, doublereal* tau, doublereal* work, 
	integer* lwork, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    integer i__, j;
    doublereal t[4160]	/* was [65][64] */;
    integer ib;
    doublereal ei;
    integer nb, nh, nx, iws;
    integer nbmin, iinfo;
    integer ldwork, lwkopt;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
/* Computing MIN */
    i__1 = 64, i__2 = ilaenv_(&c__1, "DGEHRD", " ", n, ilo, ihi, &c_n1);
    nb = Dymola_min(i__1,i__2);
    lwkopt = *n * nb;
    work[1] = (doublereal) lwkopt;
    lquery = *lwork == -1;
    if (*n < 0) {
	*info = -1;
    } else if (*ilo < 1 || *ilo > Dymola_max(1,*n)) {
	*info = -2;
    } else if (*ihi < Dymola_min(*ilo,*n) || *ihi > *n) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -5;
    } else if (*lwork < Dymola_max(1,*n) && ! lquery) {
	*info = -8;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGEHRD", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Set elements 1:ILO-1 and IHI:N-1 of TAU to zero */

    i__1 = *ilo - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
	tau[i__] = 0.;
/* L10: */
    }
    i__1 = *n - 1;
    for (i__ = Dymola_max(1,*ihi); i__ <= i__1; ++i__) {
	tau[i__] = 0.;
/* L20: */
    }

/*     Quick return if possible */

    nh = *ihi - *ilo + 1;
    if (nh <= 1) {
	work[1] = 1.;
	return 0;
    }

/*     Determine the block size */

/* Computing MIN */
    i__1 = 64, i__2 = ilaenv_(&c__1, "DGEHRD", " ", n, ilo, ihi, &c_n1);
    nb = Dymola_min(i__1,i__2);
    nbmin = 2;
    iws = 1;
    if (nb > 1 && nb < nh) {

/*        Determine when to cross over from blocked to unblocked code */
/*        (last block is always handled by unblocked code) */

/* Computing MAX */
	i__1 = nb, i__2 = ilaenv_(&c__3, "DGEHRD", " ", n, ilo, ihi, &c_n1);
	nx = Dymola_max(i__1,i__2);
	if (nx < nh) {

/*           Determine if workspace is large enough for blocked code */

	    iws = *n * nb;
	    if (*lwork < iws) {

/*              Not enough workspace to use optimal NB:  determine the */
/*              minimum value of NB, and reduce NB or force use of */
/*              unblocked code */

/* Computing MAX */
		i__1 = 2, i__2 = ilaenv_(&c__2, "DGEHRD", " ", n, ilo, ihi, &
			c_n1);
		nbmin = Dymola_max(i__1,i__2);
		if (*lwork >= *n * nbmin) {
		    nb = *lwork / *n;
		} else {
		    nb = 1;
		}
	    }
	}
    }
    ldwork = *n;

    if (nb < nbmin || nb >= nh) {

/*        Use unblocked code below */

	i__ = *ilo;

    } else {

/*        Use blocked code */

	i__1 = *ihi - 1 - nx;
	i__2 = nb;
	for (i__ = *ilo; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
	    i__3 = nb, i__4 = *ihi - i__;
	    ib = Dymola_min(i__3,i__4);

/*           Reduce columns i:i+ib-1 to Hessenberg form, returning the */
/*           matrices V and T of the block reflector H = I - V*T*V**T */
/*           which performs the reduction, and also the matrix Y = A*V*T */

	    dlahr2_((integer*) ihi, &i__, &ib, &a[i__ * a_dim1 + 1], lda, &tau[i__], t, &
		    c__65, &work[1], &ldwork);

/*           Apply the block reflector H to A(1:ihi,i+ib:ihi) from the */
/*           right, computing  A := A - Y * V**T. V(i+ib,ib-1) must be set */
/*           to 1 */

	    ei = a[i__ + ib + (i__ + ib - 1) * a_dim1];
	    a[i__ + ib + (i__ + ib - 1) * a_dim1] = 1.;
	    i__3 = *ihi - i__ - ib + 1;
	    dgemm_("No transpose", "Transpose", ihi, &i__3, &ib, &c_b25, &
		    work[1], &ldwork, &a[i__ + ib + i__ * a_dim1], lda, &
		    c_b26, &a[(i__ + ib) * a_dim1 + 1], lda);
	    a[i__ + ib + (i__ + ib - 1) * a_dim1] = ei;

/*           Apply the block reflector H to A(1:i,i+1:i+ib-1) from the */
/*           right */

	    i__3 = ib - 1;
	    dtrmm_("Right", "Lower", "Transpose", "Unit", &i__, &i__3, &c_b26,
		     &a[i__ + 1 + i__ * a_dim1], lda, &work[1], &ldwork);
	    i__3 = ib - 2;
	    for (j = 0; j <= i__3; ++j) {
		daxpy_(&i__, &c_b25, &work[ldwork * j + 1], &c__1, &a[(i__ + 
			j + 1) * a_dim1 + 1], &c__1);
/* L30: */
	    }

/*           Apply the block reflector H to A(i+1:ihi,i+ib:n) from the */
/*           left */

	    i__3 = *ihi - i__;
	    i__4 = *n - i__ - ib + 1;
	    dlarfb_("Left", "Transpose", "Forward", "Columnwise", &i__3, &
		    i__4, &ib, &a[i__ + 1 + i__ * a_dim1], lda, t, &c__65, &a[
		    i__ + 1 + (i__ + ib) * a_dim1], lda, &work[1], &ldwork);
/* L40: */
	}
    }

/*     Use unblocked code to reduce the rest of the matrix */

    dgehd2_(n, &i__, (integer*) ihi, &a[a_offset], lda, &tau[1], &work[1], &iinfo);
    work[1] = (doublereal) iws;

    return 0;

/*     End of DGEHRD */

} /* dgehrd_ */

/* Subroutine */ static int dlacpy_(char *uplo, integer *m, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2;

    /* Local variables */
    integer i__, j;

/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = Dymola_min(j,*m);
	    for (i__ = 1; i__ <= i__2; ++i__) {
		b[i__ + j * b_dim1] = a[i__ + j * a_dim1];
/* L10: */
	    }
/* L20: */
	}
    } else if (lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *m;
	    for (i__ = j; i__ <= i__2; ++i__) {
		b[i__ + j * b_dim1] = a[i__ + j * a_dim1];
/* L30: */
	    }
/* L40: */
	}
    } else {
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *m;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		b[i__ + j * b_dim1] = a[i__ + j * a_dim1];
/* L50: */
	    }
/* L60: */
	}
    }
    return 0;

/*     End of DLACPY */

} /* dlacpy_ */

/* Subroutine */ static int dorghr_(integer* n, const integer* ilo, const integer* ihi, doublereal* a, integer* lda, const doublereal* tau, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    integer i__, j, nb, nh, iinfo;
    integer lwkopt;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    nh = *ihi - *ilo;
    lquery = *lwork == -1;
    if (*n < 0) {
	*info = -1;
    } else if (*ilo < 1 || *ilo > Dymola_max(1,*n)) {
	*info = -2;
    } else if (*ihi < Dymola_min(*ilo,*n) || *ihi > *n) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -5;
    } else if (*lwork < Dymola_max(1,nh) && ! lquery) {
	*info = -8;
    }

    if (*info == 0) {
	nb = ilaenv_(&c__1, "DORGQR", " ", &nh, &nh, &nh, &c_n1);
	lwkopt = Dymola_max(1,nh) * nb;
	work[1] = (doublereal) lwkopt;
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DORGHR", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	work[1] = 1.;
	return 0;
    }

/*     Shift the vectors which define the elementary reflectors one */
/*     column to the right, and set the first ilo and the last n-ihi */
/*     rows and columns to those of the unit matrix */

    i__1 = *ilo + 1;
    for (j = *ihi; j >= i__1; --j) {
	i__2 = j - 1;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    a[i__ + j * a_dim1] = 0.;
/* L10: */
	}
	i__2 = *ihi;
	for (i__ = j + 1; i__ <= i__2; ++i__) {
	    a[i__ + j * a_dim1] = a[i__ + (j - 1) * a_dim1];
/* L20: */
	}
	i__2 = *n;
	for (i__ = *ihi + 1; i__ <= i__2; ++i__) {
	    a[i__ + j * a_dim1] = 0.;
/* L30: */
	}
/* L40: */
    }
    i__1 = *ilo;
    for (j = 1; j <= i__1; ++j) {
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    a[i__ + j * a_dim1] = 0.;
/* L50: */
	}
	a[j + j * a_dim1] = 1.;
/* L60: */
    }
    i__1 = *n;
    for (j = *ihi + 1; j <= i__1; ++j) {
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    a[i__ + j * a_dim1] = 0.;
/* L70: */
	}
	a[j + j * a_dim1] = 1.;
/* L80: */
    }

    if (nh > 0) {

/*        Generate Q(ilo+1:ihi,ilo+1:ihi) */

	dorgqr_(&nh, &nh, &nh, &a[*ilo + 1 + (*ilo + 1) * a_dim1], lda, &tau[*
		ilo], &work[1], lwork, &iinfo);
    }
    work[1] = (doublereal) lwkopt;
    return 0;

/*     End of DORGHR */

} /* dorghr_ */

/* Subroutine */ static int dtrevc_(const char* side, const char* howmny, logical* select, integer* n, const doublereal* t, integer* ldt, doublereal* vl, integer* ldvl, doublereal* vr, integer* ldvr, integer* mm, integer* m, doublereal* work, integer* info)
{
    /* System generated locals */
    integer t_dim1, t_offset, vl_dim1, vl_offset, vr_dim1, vr_offset, i__1, 
	    i__2, i__3;
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    integer i__, j, k;
    doublereal x[4]	/* was [2][2] */;
    integer j1, j2, n2, ii, ki, ip, is;
    doublereal wi, wr, rec, ulp, beta, emax;
    logical pair;
    logical allv;
    integer ierr;
    doublereal unfl, ovfl, smin;
    logical over;
    doublereal vmax;
    integer jnxt;
    doublereal scale;
    doublereal remax;
    logical leftv, bothv;
    doublereal vcrit;
    logical somev;
    doublereal xnorm;
    doublereal bignum;
    logical rightv;
    doublereal smlnum;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode and test the input parameters */

    /* Parameter adjustments */
    --select;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --work;

    /* Function Body */
    bothv = lsame_(side, "B", (ftnlen)1, (ftnlen)1);
    rightv = lsame_(side, "R", (ftnlen)1, (ftnlen)1) || bothv;
    leftv = lsame_(side, "L", (ftnlen)1, (ftnlen)1) || bothv;

    allv = lsame_(howmny, "A", (ftnlen)1, (ftnlen)1);
    over = lsame_(howmny, "B", (ftnlen)1, (ftnlen)1);
    somev = lsame_(howmny, "S", (ftnlen)1, (ftnlen)1);

    *info = 0;
    if (! rightv && ! leftv) {
	*info = -1;
    } else if (! allv && ! over && ! somev) {
	*info = -2;
    } else if (*n < 0) {
	*info = -4;
    } else if (*ldt < Dymola_max(1,*n)) {
	*info = -6;
    } else if (*ldvl < 1 || leftv && *ldvl < *n) {
	*info = -8;
    } else if (*ldvr < 1 || rightv && *ldvr < *n) {
	*info = -10;
    } else {

/*        Set M to the number of columns required to store the selected */
/*        eigenvectors, standardize the array SELECT if necessary, and */
/*        test MM. */

	if (somev) {
	    *m = 0;
	    pair = FALSE_;
	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		if (pair) {
		    pair = FALSE_;
		    select[j] = FALSE_;
		} else {
		    if (j < *n) {
			if (t[j + 1 + j * t_dim1] == 0.) {
			    if (select[j]) {
				++(*m);
			    }
			} else {
			    pair = TRUE_;
			    if (select[j] || select[j + 1]) {
				select[j] = TRUE_;
				*m += 2;
			    }
			}
		    } else {
			if (select[*n]) {
			    ++(*m);
			}
		    }
		}
/* L10: */
	    }
	} else {
	    *m = *n;
	}

	if (*mm < *m) {
	    *info = -11;
	}
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTREVC", &i__1);
	return 0;
    }

/*     Quick return if possible. */

    if (*n == 0) {
	return 0;
    }

/*     Set the constants to control overflow. */

    unfl = dlamch_("Safe minimum");
    ovfl = 1. / unfl;
    dlabad_(&unfl, &ovfl);
    ulp = dlamch_("Precision");
    smlnum = unfl * (*n / ulp);
    bignum = (1. - ulp) / smlnum;

/*     Compute 1-norm of each column of strictly upper triangular */
/*     part of T to control overflow in triangular solver. */

    work[1] = 0.;
    i__1 = *n;
    for (j = 2; j <= i__1; ++j) {
	work[j] = 0.;
	i__2 = j - 1;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    work[j] += (d__1 = t[i__ + j * t_dim1], Dymola_abs(d__1));
/* L20: */
	}
/* L30: */
    }

/*     Index IP is used to specify the real or complex eigenvalue: */
/*       IP = 0, real eigenvalue, */
/*            1, first of conjugate complex pair: (wr,wi) */
/*           -1, second of conjugate complex pair: (wr,wi) */

    n2 = *n << 1;

    if (rightv) {

/*        Compute right eigenvectors. */

	ip = 0;
	is = *m;
	for (ki = *n; ki >= 1; --ki) {

	    if (ip == 1) {
		goto L130;
	    }
	    if (ki == 1) {
		goto L40;
	    }
	    if (t[ki + (ki - 1) * t_dim1] == 0.) {
		goto L40;
	    }
	    ip = -1;

L40:
	    if (somev) {
		if (ip == 0) {
		    if (! select[ki]) {
			goto L130;
		    }
		} else {
		    if (! select[ki - 1]) {
			goto L130;
		    }
		}
	    }

/*           Compute the KI-th eigenvalue (WR,WI). */

	    wr = t[ki + ki * t_dim1];
	    wi = 0.;
	    if (ip != 0) {
		wi = sqrt((d__1 = t[ki + (ki - 1) * t_dim1], Dymola_abs(d__1))) * 
			sqrt((d__2 = t[ki - 1 + ki * t_dim1], Dymola_abs(d__2)));
	    }
/* Computing MAX */
	    d__1 = ulp * (Dymola_abs(wr) + Dymola_abs(wi));
	    smin = Dymola_max(d__1,smlnum);

	    if (ip == 0) {

/*              Real right eigenvector */

		work[ki + *n] = 1.;

/*              Form right-hand side */

		i__1 = ki - 1;
		for (k = 1; k <= i__1; ++k) {
		    work[k + *n] = -t[k + ki * t_dim1];
/* L50: */
		}

/*              Solve the upper quasi-triangular system: */
/*                 (T(1:KI-1,1:KI-1) - WR)*X = SCALE*WORK. */

		jnxt = ki - 1;
		for (j = ki - 1; j >= 1; --j) {
		    if (j > jnxt) {
			goto L60;
		    }
		    j1 = j;
		    j2 = j;
		    jnxt = j - 1;
		    if (j > 1) {
			if (t[j + (j - 1) * t_dim1] != 0.) {
			    j1 = j - 1;
			    jnxt = j - 2;
			}
		    }

		    if (j1 == j2) {

/*                    1-by-1 diagonal block */

          dlaln2_(&c_false, &c__1, &c__1, &smin, &c_b22, (doublereal*) &t[j + 
				j * t_dim1], ldt, &c_b22, &c_b22, &work[j + *
				n], n, &wr, &c_b25_dtrevc, x, &c__2, &scale, &xnorm, 
				&ierr);

/*                    Scale X(1,1) to avoid overflow when updating */
/*                    the right-hand side. */

			if (xnorm > 1.) {
			    if (work[j] > bignum / xnorm) {
				x[0] /= xnorm;
				scale /= xnorm;
			    }
			}

/*                    Scale if necessary */

			if (scale != 1.) {
			    dscal_(&ki, &scale, &work[*n + 1], &c__1);
			}
			work[j + *n] = x[0];

/*                    Update right-hand side */

			i__1 = j - 1;
			d__1 = -x[0];
			daxpy_(&i__1, &d__1, (doublereal*) &t[j * t_dim1 + 1], &c__1, &work[
				*n + 1], &c__1);

		    } else {

/*                    2-by-2 diagonal block */

			dlaln2_(&c_false, &c__2, &c__1, &smin, &c_b22, (doublereal*) &t[j - 
				1 + (j - 1) * t_dim1], ldt, &c_b22, &c_b22, &
				work[j - 1 + *n], n, &wr, &c_b25_dtrevc, x, &c__2, &
				scale, &xnorm, &ierr);

/*                    Scale X(1,1) and X(2,1) to avoid overflow when */
/*                    updating the right-hand side. */

			if (xnorm > 1.) {
/* Computing MAX */
			    d__1 = work[j - 1], d__2 = work[j];
			    beta = Dymola_max(d__1,d__2);
			    if (beta > bignum / xnorm) {
				x[0] /= xnorm;
				x[1] /= xnorm;
				scale /= xnorm;
			    }
			}

/*                    Scale if necessary */

			if (scale != 1.) {
			    dscal_(&ki, &scale, &work[*n + 1], &c__1);
			}
			work[j - 1 + *n] = x[0];
			work[j + *n] = x[1];

/*                    Update right-hand side */

			i__1 = j - 2;
			d__1 = -x[0];
			daxpy_(&i__1, &d__1, (doublereal*) &t[(j - 1) * t_dim1 + 1], &c__1, 
				&work[*n + 1], &c__1);
			i__1 = j - 2;
			d__1 = -x[1];
			daxpy_(&i__1, &d__1, (doublereal*) &t[j * t_dim1 + 1], &c__1, &work[
				*n + 1], &c__1);
		    }
L60:
		    ;
		}

/*              Copy the vector x or Q*x to VR and normalize. */

		if (! over) {
		    dcopy_(&ki, &work[*n + 1], &c__1, &vr[is * vr_dim1 + 1], &
			    c__1);

		    ii = idamax_(&ki, &vr[is * vr_dim1 + 1], &c__1);
		    remax = 1. / (d__1 = vr[ii + is * vr_dim1], Dymola_abs(d__1));
		    dscal_(&ki, &remax, &vr[is * vr_dim1 + 1], &c__1);

		    i__1 = *n;
		    for (k = ki + 1; k <= i__1; ++k) {
			vr[k + is * vr_dim1] = 0.;
/* L70: */
		    }
		} else {
		    if (ki > 1) {
			i__1 = ki - 1;
			dgemv_("N", n, &i__1, &c_b22, &vr[vr_offset], ldvr, &
				work[*n + 1], &c__1, &work[ki + *n], &vr[ki * 
				vr_dim1 + 1], &c__1);
		    }

		    ii = idamax_(n, &vr[ki * vr_dim1 + 1], &c__1);
		    remax = 1. / (d__1 = vr[ii + ki * vr_dim1], Dymola_abs(d__1));
		    dscal_(n, &remax, &vr[ki * vr_dim1 + 1], &c__1);
		}

	    } else {

/*              Complex right eigenvector. */

/*              Initial solve */
/*                [ (T(KI-1,KI-1) T(KI-1,KI) ) - (WR + I* WI)]*X = 0. */
/*                [ (T(KI,KI-1)   T(KI,KI)   )               ] */

		if ((d__1 = t[ki - 1 + ki * t_dim1], Dymola_abs(d__1)) >= (d__2 = t[
			ki + (ki - 1) * t_dim1], Dymola_abs(d__2))) {
		    work[ki - 1 + *n] = 1.;
		    work[ki + n2] = wi / t[ki - 1 + ki * t_dim1];
		} else {
		    work[ki - 1 + *n] = -wi / t[ki + (ki - 1) * t_dim1];
		    work[ki + n2] = 1.;
		}
		work[ki + *n] = 0.;
		work[ki - 1 + n2] = 0.;

/*              Form right-hand side */

		i__1 = ki - 2;
		for (k = 1; k <= i__1; ++k) {
		    work[k + *n] = -work[ki - 1 + *n] * t[k + (ki - 1) * 
			    t_dim1];
		    work[k + n2] = -work[ki + n2] * t[k + ki * t_dim1];
/* L80: */
		}

/*              Solve upper quasi-triangular system: */
/*              (T(1:KI-2,1:KI-2) - (WR+i*WI))*X = SCALE*(WORK+i*WORK2) */

		jnxt = ki - 2;
		for (j = ki - 2; j >= 1; --j) {
		    if (j > jnxt) {
			goto L90;
		    }
		    j1 = j;
		    j2 = j;
		    jnxt = j - 1;
		    if (j > 1) {
			if (t[j + (j - 1) * t_dim1] != 0.) {
			    j1 = j - 1;
			    jnxt = j - 2;
			}
		    }

		    if (j1 == j2) {

/*                    1-by-1 diagonal block */

			dlaln2_(&c_false, &c__1, &c__2, &smin, &c_b22, (doublereal*) &t[j + 
				j * t_dim1], ldt, &c_b22, &c_b22, &work[j + *
				n], n, &wr, &wi, x, &c__2, &scale, &xnorm, &
				ierr);

/*                    Scale X(1,1) and X(1,2) to avoid overflow when */
/*                    updating the right-hand side. */

			if (xnorm > 1.) {
			    if (work[j] > bignum / xnorm) {
				x[0] /= xnorm;
				x[2] /= xnorm;
				scale /= xnorm;
			    }
			}

/*                    Scale if necessary */

			if (scale != 1.) {
			    dscal_(&ki, &scale, &work[*n + 1], &c__1);
			    dscal_(&ki, &scale, &work[n2 + 1], &c__1);
			}
			work[j + *n] = x[0];
			work[j + n2] = x[2];

/*                    Update the right-hand side */

			i__1 = j - 1;
			d__1 = -x[0];
			daxpy_(&i__1, &d__1, (doublereal*) &t[j * t_dim1 + 1], &c__1, &work[
				*n + 1], &c__1);
			i__1 = j - 1;
			d__1 = -x[2];
			daxpy_(&i__1, &d__1, (doublereal*) &t[j * t_dim1 + 1], &c__1, &work[
				n2 + 1], &c__1);

		    } else {

/*                    2-by-2 diagonal block */

			dlaln2_(&c_false, &c__2, &c__2, &smin, &c_b22, (doublereal*) &t[j - 
				1 + (j - 1) * t_dim1], ldt, &c_b22, &c_b22, &
				work[j - 1 + *n], n, &wr, &wi, x, &c__2, &
				scale, &xnorm, &ierr);

/*                    Scale X to avoid overflow when updating */
/*                    the right-hand side. */

			if (xnorm > 1.) {
/* Computing MAX */
			    d__1 = work[j - 1], d__2 = work[j];
			    beta = Dymola_max(d__1,d__2);
			    if (beta > bignum / xnorm) {
				rec = 1. / xnorm;
				x[0] *= rec;
				x[2] *= rec;
				x[1] *= rec;
				x[3] *= rec;
				scale *= rec;
			    }
			}

/*                    Scale if necessary */

			if (scale != 1.) {
			    dscal_(&ki, &scale, &work[*n + 1], &c__1);
			    dscal_(&ki, &scale, &work[n2 + 1], &c__1);
			}
			work[j - 1 + *n] = x[0];
			work[j + *n] = x[1];
			work[j - 1 + n2] = x[2];
			work[j + n2] = x[3];

/*                    Update the right-hand side */

			i__1 = j - 2;
			d__1 = -x[0];
			daxpy_(&i__1, &d__1, (doublereal*) &t[(j - 1) * t_dim1 + 1], &c__1, 
				&work[*n + 1], &c__1);
			i__1 = j - 2;
			d__1 = -x[1];
			daxpy_(&i__1, &d__1, (doublereal*) &t[j * t_dim1 + 1], &c__1, &work[
				*n + 1], &c__1);
			i__1 = j - 2;
			d__1 = -x[2];
			daxpy_(&i__1, &d__1, (doublereal*) &t[(j - 1) * t_dim1 + 1], &c__1, 
				&work[n2 + 1], &c__1);
			i__1 = j - 2;
			d__1 = -x[3];
			daxpy_(&i__1, &d__1, (doublereal*) &t[j * t_dim1 + 1], &c__1, &work[
				n2 + 1], &c__1);
		    }
L90:
		    ;
		}

/*              Copy the vector x or Q*x to VR and normalize. */

		if (! over) {
		    dcopy_(&ki, &work[*n + 1], &c__1, &vr[(is - 1) * vr_dim1 
			    + 1], &c__1);
		    dcopy_(&ki, &work[n2 + 1], &c__1, &vr[is * vr_dim1 + 1], &
			    c__1);

		    emax = 0.;
		    i__1 = ki;
		    for (k = 1; k <= i__1; ++k) {
/* Computing MAX */
			d__3 = emax, d__4 = (d__1 = vr[k + (is - 1) * vr_dim1]
				, Dymola_abs(d__1)) + (d__2 = vr[k + is * vr_dim1], 
				Dymola_abs(d__2));
			emax = Dymola_max(d__3,d__4);
/* L100: */
		    }

		    remax = 1. / emax;
		    dscal_(&ki, &remax, &vr[(is - 1) * vr_dim1 + 1], &c__1);
		    dscal_(&ki, &remax, &vr[is * vr_dim1 + 1], &c__1);

		    i__1 = *n;
		    for (k = ki + 1; k <= i__1; ++k) {
			vr[k + (is - 1) * vr_dim1] = 0.;
			vr[k + is * vr_dim1] = 0.;
/* L110: */
		    }

		} else {

		    if (ki > 2) {
			i__1 = ki - 2;
			dgemv_("N", n, &i__1, &c_b22, &vr[vr_offset], ldvr, &
				work[*n + 1], &c__1, &work[ki - 1 + *n], &vr[(
				ki - 1) * vr_dim1 + 1], &c__1);
			i__1 = ki - 2;
			dgemv_("N", n, &i__1, &c_b22, &vr[vr_offset], ldvr, &
				work[n2 + 1], &c__1, &work[ki + n2], &vr[ki * 
				vr_dim1 + 1], &c__1);
		    } else {
			dscal_(n, &work[ki - 1 + *n], &vr[(ki - 1) * vr_dim1 
				+ 1], &c__1);
			dscal_(n, &work[ki + n2], &vr[ki * vr_dim1 + 1], &
				c__1);
		    }

		    emax = 0.;
		    i__1 = *n;
		    for (k = 1; k <= i__1; ++k) {
/* Computing MAX */
			d__3 = emax, d__4 = (d__1 = vr[k + (ki - 1) * vr_dim1]
				, Dymola_abs(d__1)) + (d__2 = vr[k + ki * vr_dim1], 
				Dymola_abs(d__2));
			emax = Dymola_max(d__3,d__4);
/* L120: */
		    }
		    remax = 1. / emax;
		    dscal_(n, &remax, &vr[(ki - 1) * vr_dim1 + 1], &c__1);
		    dscal_(n, &remax, &vr[ki * vr_dim1 + 1], &c__1);
		}
	    }

	    --is;
	    if (ip != 0) {
		--is;
	    }
L130:
	    if (ip == 1) {
		ip = 0;
	    }
	    if (ip == -1) {
		ip = 1;
	    }
/* L140: */
	}
    }

    if (leftv) {

/*        Compute left eigenvectors. */

	ip = 0;
	is = 1;
	i__1 = *n;
	for (ki = 1; ki <= i__1; ++ki) {

	    if (ip == -1) {
		goto L250;
	    }
	    if (ki == *n) {
		goto L150;
	    }
	    if (t[ki + 1 + ki * t_dim1] == 0.) {
		goto L150;
	    }
	    ip = 1;

L150:
	    if (somev) {
		if (! select[ki]) {
		    goto L250;
		}
	    }

/*           Compute the KI-th eigenvalue (WR,WI). */

	    wr = t[ki + ki * t_dim1];
	    wi = 0.;
	    if (ip != 0) {
		wi = sqrt((d__1 = t[ki + (ki + 1) * t_dim1], Dymola_abs(d__1))) * 
			sqrt((d__2 = t[ki + 1 + ki * t_dim1], Dymola_abs(d__2)));
	    }
/* Computing MAX */
	    d__1 = ulp * (Dymola_abs(wr) + Dymola_abs(wi));
	    smin = Dymola_max(d__1,smlnum);

	    if (ip == 0) {

/*              Real left eigenvector. */

		work[ki + *n] = 1.;

/*              Form right-hand side */

		i__2 = *n;
		for (k = ki + 1; k <= i__2; ++k) {
		    work[k + *n] = -t[ki + k * t_dim1];
/* L160: */
		}

/*              Solve the quasi-triangular system: */
/*                 (T(KI+1:N,KI+1:N) - WR)**T*X = SCALE*WORK */

		vmax = 1.;
		vcrit = bignum;

		jnxt = ki + 1;
		i__2 = *n;
		for (j = ki + 1; j <= i__2; ++j) {
		    if (j < jnxt) {
			goto L170;
		    }
		    j1 = j;
		    j2 = j;
		    jnxt = j + 1;
		    if (j < *n) {
			if (t[j + 1 + j * t_dim1] != 0.) {
			    j2 = j + 1;
			    jnxt = j + 2;
			}
		    }

		    if (j1 == j2) {

/*                    1-by-1 diagonal block */

/*                    Scale if necessary to avoid overflow when forming */
/*                    the right-hand side. */

			if (work[j] > vcrit) {
			    rec = 1. / vmax;
			    i__3 = *n - ki + 1;
			    dscal_(&i__3, &rec, &work[ki + *n], &c__1);
			    vmax = 1.;
			    vcrit = bignum;
			}

			i__3 = j - ki - 1;
			work[j + *n] -= ddot_(&i__3, (doublereal*) &t[ki + 1 + j * t_dim1], 
				&c__1, &work[ki + 1 + *n], &c__1);

/*                    Solve (T(J,J)-WR)**T*X = WORK */

			dlaln2_(&c_false, &c__1, &c__1, &smin, &c_b22, (doublereal*) &t[j + 
				j * t_dim1], ldt, &c_b22, &c_b22, &work[j + *
				n], n, &wr, &c_b25_dtrevc, x, &c__2, &scale, &xnorm, 
				&ierr);

/*                    Scale if necessary */

			if (scale != 1.) {
			    i__3 = *n - ki + 1;
			    dscal_(&i__3, &scale, &work[ki + *n], &c__1);
			}
			work[j + *n] = x[0];
/* Computing MAX */
			d__2 = (d__1 = work[j + *n], Dymola_abs(d__1));
			vmax = Dymola_max(d__2,vmax);
			vcrit = bignum / vmax;

		    } else {

/*                    2-by-2 diagonal block */

/*                    Scale if necessary to avoid overflow when forming */
/*                    the right-hand side. */

/* Computing MAX */
			d__1 = work[j], d__2 = work[j + 1];
			beta = Dymola_max(d__1,d__2);
			if (beta > vcrit) {
			    rec = 1. / vmax;
			    i__3 = *n - ki + 1;
			    dscal_(&i__3, &rec, &work[ki + *n], &c__1);
			    vmax = 1.;
			    vcrit = bignum;
			}

			i__3 = j - ki - 1;
			work[j + *n] -= ddot_(&i__3, (doublereal*) &t[ki + 1 + j * t_dim1], 
				&c__1, &work[ki + 1 + *n], &c__1);

			i__3 = j - ki - 1;
			work[j + 1 + *n] -= ddot_(&i__3, (doublereal*) &t[ki + 1 + (j + 1) *
				 t_dim1], &c__1, &work[ki + 1 + *n], &c__1);

/*                    Solve */
/*                      [T(J,J)-WR   T(J,J+1)     ]**T * X = SCALE*( WORK1 ) */
/*                      [T(J+1,J)    T(J+1,J+1)-WR]                ( WORK2 ) */

			dlaln2_(&c_true, &c__2, &c__1, &smin, &c_b22, (doublereal*) &t[j + 
				j * t_dim1], ldt, &c_b22, &c_b22, &work[j + *
				n], n, &wr, &c_b25_dtrevc, x, &c__2, &scale, &xnorm, 
				&ierr);

/*                    Scale if necessary */

			if (scale != 1.) {
			    i__3 = *n - ki + 1;
			    dscal_(&i__3, &scale, &work[ki + *n], &c__1);
			}
			work[j + *n] = x[0];
			work[j + 1 + *n] = x[1];

/* Computing MAX */
			d__3 = (d__1 = work[j + *n], Dymola_abs(d__1)), d__4 = (d__2 
				= work[j + 1 + *n], Dymola_abs(d__2)), d__3 = Dymola_max(
				d__3,d__4);
			vmax = Dymola_max(d__3,vmax);
			vcrit = bignum / vmax;

		    }
L170:
		    ;
		}

/*              Copy the vector x or Q*x to VL and normalize. */

		if (! over) {
		    i__2 = *n - ki + 1;
		    dcopy_(&i__2, &work[ki + *n], &c__1, &vl[ki + is * 
			    vl_dim1], &c__1);

		    i__2 = *n - ki + 1;
		    ii = idamax_(&i__2, &vl[ki + is * vl_dim1], &c__1) + ki - 
			    1;
		    remax = 1. / (d__1 = vl[ii + is * vl_dim1], Dymola_abs(d__1));
		    i__2 = *n - ki + 1;
		    dscal_(&i__2, &remax, &vl[ki + is * vl_dim1], &c__1);

		    i__2 = ki - 1;
		    for (k = 1; k <= i__2; ++k) {
			vl[k + is * vl_dim1] = 0.;
/* L180: */
		    }

		} else {

		    if (ki < *n) {
			i__2 = *n - ki;
			dgemv_("N", n, &i__2, &c_b22, &vl[(ki + 1) * vl_dim1 
				+ 1], ldvl, &work[ki + 1 + *n], &c__1, &work[
				ki + *n], &vl[ki * vl_dim1 + 1], &c__1);
		    }

		    ii = idamax_(n, &vl[ki * vl_dim1 + 1], &c__1);
		    remax = 1. / (d__1 = vl[ii + ki * vl_dim1], Dymola_abs(d__1));
		    dscal_(n, &remax, &vl[ki * vl_dim1 + 1], &c__1);

		}

	    } else {

/*              Complex left eigenvector. */

/*               Initial solve: */
/*                 ((T(KI,KI)    T(KI,KI+1) )**T - (WR - I* WI))*X = 0. */
/*                 ((T(KI+1,KI) T(KI+1,KI+1))                ) */

		if ((d__1 = t[ki + (ki + 1) * t_dim1], Dymola_abs(d__1)) >= (d__2 = 
			t[ki + 1 + ki * t_dim1], Dymola_abs(d__2))) {
		    work[ki + *n] = wi / t[ki + (ki + 1) * t_dim1];
		    work[ki + 1 + n2] = 1.;
		} else {
		    work[ki + *n] = 1.;
		    work[ki + 1 + n2] = -wi / t[ki + 1 + ki * t_dim1];
		}
		work[ki + 1 + *n] = 0.;
		work[ki + n2] = 0.;

/*              Form right-hand side */

		i__2 = *n;
		for (k = ki + 2; k <= i__2; ++k) {
		    work[k + *n] = -work[ki + *n] * t[ki + k * t_dim1];
		    work[k + n2] = -work[ki + 1 + n2] * t[ki + 1 + k * t_dim1]
			    ;
/* L190: */
		}

/*              Solve complex quasi-triangular system: */
/*              ( T(KI+2,N:KI+2,N) - (WR-i*WI) )*X = WORK1+i*WORK2 */

		vmax = 1.;
		vcrit = bignum;

		jnxt = ki + 2;
		i__2 = *n;
		for (j = ki + 2; j <= i__2; ++j) {
		    if (j < jnxt) {
			goto L200;
		    }
		    j1 = j;
		    j2 = j;
		    jnxt = j + 1;
		    if (j < *n) {
			if (t[j + 1 + j * t_dim1] != 0.) {
			    j2 = j + 1;
			    jnxt = j + 2;
			}
		    }

		    if (j1 == j2) {

/*                    1-by-1 diagonal block */

/*                    Scale if necessary to avoid overflow when */
/*                    forming the right-hand side elements. */

			if (work[j] > vcrit) {
			    rec = 1. / vmax;
			    i__3 = *n - ki + 1;
			    dscal_(&i__3, &rec, &work[ki + *n], &c__1);
			    i__3 = *n - ki + 1;
			    dscal_(&i__3, &rec, &work[ki + n2], &c__1);
			    vmax = 1.;
			    vcrit = bignum;
			}

			i__3 = j - ki - 2;
			work[j + *n] -= ddot_(&i__3, (doublereal*) &t[ki + 2 + j * t_dim1], 
				&c__1, &work[ki + 2 + *n], &c__1);
			i__3 = j - ki - 2;
			work[j + n2] -= ddot_(&i__3, (doublereal*) &t[ki + 2 + j * t_dim1], 
				&c__1, &work[ki + 2 + n2], &c__1);

/*                    Solve (T(J,J)-(WR-i*WI))*(X11+i*X12)= WK+I*WK2 */

			d__1 = -wi;
			dlaln2_(&c_false, &c__1, &c__2, &smin, &c_b22, (doublereal*) &t[j + 
				j * t_dim1], ldt, &c_b22, &c_b22, &work[j + *
				n], n, &wr, &d__1, x, &c__2, &scale, &xnorm, &
				ierr);

/*                    Scale if necessary */

			if (scale != 1.) {
			    i__3 = *n - ki + 1;
			    dscal_(&i__3, &scale, &work[ki + *n], &c__1);
			    i__3 = *n - ki + 1;
			    dscal_(&i__3, &scale, &work[ki + n2], &c__1);
			}
			work[j + *n] = x[0];
			work[j + n2] = x[2];
/* Computing MAX */
			d__3 = (d__1 = work[j + *n], Dymola_abs(d__1)), d__4 = (d__2 
				= work[j + n2], Dymola_abs(d__2)), d__3 = Dymola_max(d__3,
				d__4);
			vmax = Dymola_max(d__3,vmax);
			vcrit = bignum / vmax;

		    } else {

/*                    2-by-2 diagonal block */

/*                    Scale if necessary to avoid overflow when forming */
/*                    the right-hand side elements. */

/* Computing MAX */
			d__1 = work[j], d__2 = work[j + 1];
			beta = Dymola_max(d__1,d__2);
			if (beta > vcrit) {
			    rec = 1. / vmax;
			    i__3 = *n - ki + 1;
			    dscal_(&i__3, &rec, &work[ki + *n], &c__1);
			    i__3 = *n - ki + 1;
			    dscal_(&i__3, &rec, &work[ki + n2], &c__1);
			    vmax = 1.;
			    vcrit = bignum;
			}

			i__3 = j - ki - 2;
			work[j + *n] -= ddot_(&i__3, (doublereal*) &t[ki + 2 + j * t_dim1], 
				&c__1, &work[ki + 2 + *n], &c__1);

			i__3 = j - ki - 2;
			work[j + n2] -= ddot_(&i__3, (doublereal*) &t[ki + 2 + j * t_dim1], 
				&c__1, &work[ki + 2 + n2], &c__1);

			i__3 = j - ki - 2;
			work[j + 1 + *n] -= ddot_(&i__3, (doublereal*) &t[ki + 2 + (j + 1) *
				 t_dim1], &c__1, &work[ki + 2 + *n], &c__1);

			i__3 = j - ki - 2;
			work[j + 1 + n2] -= ddot_(&i__3, (doublereal*) &t[ki + 2 + (j + 1) *
				 t_dim1], &c__1, &work[ki + 2 + n2], &c__1);

/*                    Solve 2-by-2 complex linear equation */
/*                      ([T(j,j)   T(j,j+1)  ]**T-(wr-i*wi)*I)*X = SCALE*B */
/*                      ([T(j+1,j) T(j+1,j+1)]               ) */

			d__1 = -wi;
			dlaln2_(&c_true, &c__2, &c__2, &smin, &c_b22, (doublereal*) &t[j + 
				j * t_dim1], ldt, &c_b22, &c_b22, &work[j + *
				n], n, &wr, &d__1, x, &c__2, &scale, &xnorm, &
				ierr);

/*                    Scale if necessary */

			if (scale != 1.) {
			    i__3 = *n - ki + 1;
			    dscal_(&i__3, &scale, &work[ki + *n], &c__1);
			    i__3 = *n - ki + 1;
			    dscal_(&i__3, &scale, &work[ki + n2], &c__1);
			}
			work[j + *n] = x[0];
			work[j + n2] = x[2];
			work[j + 1 + *n] = x[1];
			work[j + 1 + n2] = x[3];
/* Computing MAX */
			d__1 = Dymola_abs(x[0]), d__2 = Dymola_abs(x[2]), d__1 = Dymola_max(d__1,
				d__2), d__2 = Dymola_abs(x[1]), d__1 = Dymola_max(d__1,d__2)
				, d__2 = Dymola_abs(x[3]), d__1 = Dymola_max(d__1,d__2);
			vmax = Dymola_max(d__1,vmax);
			vcrit = bignum / vmax;

		    }
L200:
		    ;
		}

/*              Copy the vector x or Q*x to VL and normalize. */

		if (! over) {
		    i__2 = *n - ki + 1;
		    dcopy_(&i__2, &work[ki + *n], &c__1, &vl[ki + is * 
			    vl_dim1], &c__1);
		    i__2 = *n - ki + 1;
		    dcopy_(&i__2, &work[ki + n2], &c__1, &vl[ki + (is + 1) * 
			    vl_dim1], &c__1);

		    emax = 0.;
		    i__2 = *n;
		    for (k = ki; k <= i__2; ++k) {
/* Computing MAX */
			d__3 = emax, d__4 = (d__1 = vl[k + is * vl_dim1], Dymola_abs(
				d__1)) + (d__2 = vl[k + (is + 1) * vl_dim1], 
				Dymola_abs(d__2));
			emax = Dymola_max(d__3,d__4);
/* L220: */
		    }
		    remax = 1. / emax;
		    i__2 = *n - ki + 1;
		    dscal_(&i__2, &remax, &vl[ki + is * vl_dim1], &c__1);
		    i__2 = *n - ki + 1;
		    dscal_(&i__2, &remax, &vl[ki + (is + 1) * vl_dim1], &c__1)
			    ;

		    i__2 = ki - 1;
		    for (k = 1; k <= i__2; ++k) {
			vl[k + is * vl_dim1] = 0.;
			vl[k + (is + 1) * vl_dim1] = 0.;
/* L230: */
		    }
		} else {
		    if (ki < *n - 1) {
			i__2 = *n - ki - 1;
			dgemv_("N", n, &i__2, &c_b22, &vl[(ki + 2) * vl_dim1 
				+ 1], ldvl, &work[ki + 2 + *n], &c__1, &work[
				ki + *n], &vl[ki * vl_dim1 + 1], &c__1);
			i__2 = *n - ki - 1;
			dgemv_("N", n, &i__2, &c_b22, &vl[(ki + 2) * vl_dim1 
				+ 1], ldvl, &work[ki + 2 + n2], &c__1, &work[
				ki + 1 + n2], &vl[(ki + 1) * vl_dim1 + 1], &
				c__1);
		    } else {
			dscal_(n, &work[ki + *n], &vl[ki * vl_dim1 + 1], &
				c__1);
			dscal_(n, &work[ki + 1 + n2], &vl[(ki + 1) * vl_dim1 
				+ 1], &c__1);
		    }

		    emax = 0.;
		    i__2 = *n;
		    for (k = 1; k <= i__2; ++k) {
/* Computing MAX */
			d__3 = emax, d__4 = (d__1 = vl[k + ki * vl_dim1], Dymola_abs(
				d__1)) + (d__2 = vl[k + (ki + 1) * vl_dim1], 
				Dymola_abs(d__2));
			emax = Dymola_max(d__3,d__4);
/* L240: */
		    }
		    remax = 1. / emax;
		    dscal_(n, &remax, &vl[ki * vl_dim1 + 1], &c__1);
		    dscal_(n, &remax, &vl[(ki + 1) * vl_dim1 + 1], &c__1);

		}

	    }

	    ++is;
	    if (ip != 0) {
		++is;
	    }
L250:
	    if (ip == -1) {
		ip = 0;
	    }
	    if (ip == 1) {
		ip = -1;
	    }

/* L260: */
	}

    }

    return 0;

/*     End of DTREVC */

} /* dtrevc_ */

/* Subroutine */ static int dgebak_(char* job, char* side, integer* n, integer* ilo, integer* ihi, doublereal* scale, integer* m, doublereal* v, integer* ldv, integer* info)
{
    /* System generated locals */
    integer v_dim1, v_offset, i__1;

    /* Local variables */
    integer i__, k;
    doublereal s;
    integer ii;
    logical leftv;
    logical rightv;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode and Test the input parameters */

    /* Parameter adjustments */
    --scale;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;

    /* Function Body */
    rightv = lsame_(side, "R", (ftnlen)1, (ftnlen)1);
    leftv = lsame_(side, "L", (ftnlen)1, (ftnlen)1);

    *info = 0;
    if (! lsame_(job, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(job, "P", (
	    ftnlen)1, (ftnlen)1) && ! lsame_(job, "S", (ftnlen)1, (ftnlen)1) 
	    && ! lsame_(job, "B", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! rightv && ! leftv) {
	*info = -2;
    } else if (*n < 0) {
	*info = -3;
    } else if (*ilo < 1 || *ilo > Dymola_max(1,*n)) {
	*info = -4;
    } else if (*ihi < Dymola_min(*ilo,*n) || *ihi > *n) {
	*info = -5;
    } else if (*m < 0) {
	*info = -7;
    } else if (*ldv < Dymola_max(1,*n)) {
	*info = -9;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGEBAK", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }
    if (*m == 0) {
	return 0;
    }
    if (lsame_(job, "N", (ftnlen)1, (ftnlen)1)) {
	return 0;
    }

    if (*ilo == *ihi) {
	goto L30;
    }

/*     Backward balance */

    if (lsame_(job, "S", (ftnlen)1, (ftnlen)1) || lsame_(job, "B", (ftnlen)1, 
	    (ftnlen)1)) {

	if (rightv) {
	    i__1 = *ihi;
	    for (i__ = *ilo; i__ <= i__1; ++i__) {
		s = scale[i__];
		dscal_(m, &s, &v[i__ + v_dim1], ldv);
/* L10: */
	    }
	}

	if (leftv) {
	    i__1 = *ihi;
	    for (i__ = *ilo; i__ <= i__1; ++i__) {
		s = 1. / scale[i__];
		dscal_(m, &s, &v[i__ + v_dim1], ldv);
/* L20: */
	    }
	}

    }

/*     Backward permutation */

/*     For  I = ILO-1 step -1 until 1, */
/*              IHI+1 step 1 until N do -- */

L30:
    if (lsame_(job, "P", (ftnlen)1, (ftnlen)1) || lsame_(job, "B", (ftnlen)1, 
	    (ftnlen)1)) {
	if (rightv) {
	    i__1 = *n;
	    for (ii = 1; ii <= i__1; ++ii) {
		i__ = ii;
		if (i__ >= *ilo && i__ <= *ihi) {
		    goto L40;
		}
		if (i__ < *ilo) {
		    i__ = *ilo - ii;
		}
		k = (integer) scale[i__];
		if (k == i__) {
		    goto L40;
		}
		dswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
L40:
		;
	    }
	}

	if (leftv) {
	    i__1 = *n;
	    for (ii = 1; ii <= i__1; ++ii) {
		i__ = ii;
		if (i__ >= *ilo && i__ <= *ihi) {
		    goto L50;
		}
		if (i__ < *ilo) {
		    i__ = *ilo - ii;
		}
		k = (integer) scale[i__];
		if (k == i__) {
		    goto L50;
		}
		dswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
L50:
		;
	    }
	}
    }

    return 0;

/*     End of DGEBAK */

} /* dgebak_ */

/* Subroutine */ static int dlartg_(doublereal *f, doublereal *g, doublereal *cs, doublereal *sn, doublereal *r__)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Local variables */
    integer i__;
    doublereal f1, g1, eps, scale;
    integer count;
    doublereal safmn2, safmx2;
    doublereal safmin;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     LOGICAL            FIRST */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Save statement .. */
/*     SAVE               FIRST, SAFMX2, SAFMIN, SAFMN2 */
/*     .. */
/*     .. Data statements .. */
/*     DATA               FIRST / .TRUE. / */
/*     .. */
/*     .. Executable Statements .. */

/*     IF( FIRST ) THEN */
    safmin = dlamch_("S");
    eps = dlamch_("E");
    d__1 = dlamch_("B");
    i__1 = (integer) (log(safmin / eps) / log(dlamch_("B")) / 2.);
    safmn2 = pow_di(&d__1, &i__1);
    safmx2 = 1. / safmn2;
/*        FIRST = .FALSE. */
/*     END IF */
    if (*g == 0.) {
	*cs = 1.;
	*sn = 0.;
	*r__ = *f;
    } else if (*f == 0.) {
	*cs = 0.;
	*sn = 1.;
	*r__ = *g;
    } else {
	f1 = *f;
	g1 = *g;
/* Computing MAX */
	d__1 = Dymola_abs(f1), d__2 = Dymola_abs(g1);
	scale = Dymola_max(d__1,d__2);
	if (scale >= safmx2) {
	    count = 0;
L10:
	    ++count;
	    f1 *= safmn2;
	    g1 *= safmn2;
/* Computing MAX */
	    d__1 = Dymola_abs(f1), d__2 = Dymola_abs(g1);
	    scale = Dymola_max(d__1,d__2);
	    if (scale >= safmx2) {
		goto L10;
	    }
/* Computing 2nd power */
	    d__1 = f1;
/* Computing 2nd power */
	    d__2 = g1;
	    *r__ = sqrt(d__1 * d__1 + d__2 * d__2);
	    *cs = f1 / *r__;
	    *sn = g1 / *r__;
	    i__1 = count;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		*r__ *= safmx2;
/* L20: */
	    }
	} else if (scale <= safmn2) {
	    count = 0;
L30:
	    ++count;
	    f1 *= safmx2;
	    g1 *= safmx2;
/* Computing MAX */
	    d__1 = Dymola_abs(f1), d__2 = Dymola_abs(g1);
	    scale = Dymola_max(d__1,d__2);
	    if (scale <= safmn2) {
		goto L30;
	    }
/* Computing 2nd power */
	    d__1 = f1;
/* Computing 2nd power */
	    d__2 = g1;
	    *r__ = sqrt(d__1 * d__1 + d__2 * d__2);
	    *cs = f1 / *r__;
	    *sn = g1 / *r__;
	    i__1 = count;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		*r__ *= safmn2;
/* L40: */
	    }
	} else {
/* Computing 2nd power */
	    d__1 = f1;
/* Computing 2nd power */
	    d__2 = g1;
	    *r__ = sqrt(d__1 * d__1 + d__2 * d__2);
	    *cs = f1 / *r__;
	    *sn = g1 / *r__;
	}
	if (Dymola_abs(*f) > Dymola_abs(*g) && *cs < 0.) {
	    *cs = -(*cs);
	    *sn = -(*sn);
	    *r__ = -(*r__);
	}
    }
    return 0;

/*     End of DLARTG */

} /* dlartg_ */

/* Subroutine */ static int drot_(integer *n, doublereal *dx, integer *incx, doublereal *dy, integer *incy, doublereal *c__, doublereal *s)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    integer i__, ix, iy;
    doublereal dtemp;


/*  -- Reference BLAS level1 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
    /* Parameter adjustments */
    --dy;
    --dx;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    if (*incx == 1 && *incy == 1) {

/*       code for both increments equal to 1 */

	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    dtemp = *c__ * dx[i__] + *s * dy[i__];
	    dy[i__] = *c__ * dy[i__] - *s * dx[i__];
	    dx[i__] = dtemp;
	}
    } else {

/*       code for unequal increments or equal increments not equal */
/*         to 1 */

	ix = 1;
	iy = 1;
	if (*incx < 0) {
	    ix = (-(*n) + 1) * *incx + 1;
	}
	if (*incy < 0) {
	    iy = (-(*n) + 1) * *incy + 1;
	}
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    dtemp = *c__ * dx[ix] + *s * dy[iy];
	    dy[iy] = *c__ * dy[iy] - *s * dx[ix];
	    dx[ix] = dtemp;
	    ix += *incx;
	    iy += *incy;
	}
    }
    return 0;
} /* drot_ */

/* Subroutine */ static int dlaqr0_(logical* wantt, logical* wantz, integer* n, integer* ilo, integer* ihi, doublereal* h__, integer* ldh, doublereal* wr, doublereal* wi, integer* iloz, integer* ihiz, doublereal* z__, integer* ldz, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5;
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    integer i__, k;
    doublereal aa, bb, cc, dd;
    integer ld;
    doublereal cs;
    integer nh, it, ks, kt;
    doublereal sn;
    integer ku, kv, ls, ns;
    doublereal ss;
    integer nw, inf, kdu, nho, nve, kwh, nsr, nwr, kwv, ndec, ndfl, kbot, 
	    nmin;
    doublereal swap;
    integer ktop;
    doublereal zdum[1]	/* was [1][1] */;
    integer kacc22, itmax, nsmax, nwmax, kwtop;
    integer nibble;
    char jbcmpz[2];
    integer nwupbd;
    logical sorted;
    integer lwkopt;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ================================================================ */

/*     .. Parameters .. */

/*     ==== Matrices of order NTINY or smaller must be processed by */
/*     .    DLAHQR because of insufficient subdiagonal scratch space. */
/*     .    (This is a hard limit.) ==== */

/*     ==== Exceptional deflation windows:  try to cure rare */
/*     .    slow convergence by varying the size of the */
/*     .    deflation window after KEXNW iterations. ==== */

/*     ==== Exceptional shifts: try to cure rare slow convergence */
/*     .    with ad-hoc exceptional shifts every KEXSH iterations. */
/*     .    ==== */

/*     ==== The constants WILK1 and WILK2 are used to form the */
/*     .    exceptional shifts. ==== */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */
    /* Parameter adjustments */
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    --wr;
    --wi;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --work;

    /* Function Body */
    *info = 0;

/*     ==== Quick return for N = 0: nothing to do. ==== */

    if (*n == 0) {
	work[1] = 1.;
	return 0;
    }

    if (*n <= 11) {

/*        ==== Tiny matrices must use DLAHQR. ==== */

	lwkopt = 1;
	if (*lwork != -1) {
	    dlahqr_(wantt, wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], &
		    wi[1], iloz, ihiz, &z__[z_offset], ldz, info);
	}
    } else {

/*        ==== Use small bulge multi-shift QR with aggressive early */
/*        .    deflation on larger-than-tiny matrices. ==== */

/*        ==== Hope for the best. ==== */

	*info = 0;

/*        ==== Set up job flags for ILAENV. ==== */

	if (*wantt) {
	    *(unsigned char *)jbcmpz = 'S';
	} else {
	    *(unsigned char *)jbcmpz = 'E';
	}
	if (*wantz) {
	    *(unsigned char *)&jbcmpz[1] = 'V';
	} else {
	    *(unsigned char *)&jbcmpz[1] = 'N';
	}

/*        ==== NWR = recommended deflation window size.  At this */
/*        .    point,  N .GT. NTINY = 11, so there is enough */
/*        .    subdiagonal workspace for NWR.GE.2 as required. */
/*        .    (In fact, there is enough subdiagonal space for */
/*        .    NWR.GE.3.) ==== */

	nwr = ilaenv_(&c__13, "DLAQR0", jbcmpz, n, ilo, ihi, lwork);
	nwr = Dymola_max(2,nwr);
/* Computing MIN */
	i__1 = *ihi - *ilo + 1, i__2 = (*n - 1) / 3, i__1 = Dymola_min(i__1,i__2);
	nwr = Dymola_min(i__1,nwr);

/*        ==== NSR = recommended number of simultaneous shifts. */
/*        .    At this point N .GT. NTINY = 11, so there is at */
/*        .    enough subdiagonal workspace for NSR to be even */
/*        .    and greater than or equal to two as required. ==== */

	nsr = ilaenv_(&c__15, "DLAQR0", jbcmpz, n, ilo, ihi, lwork);
/* Computing MIN */
	i__1 = nsr, i__2 = (*n + 6) / 9, i__1 = Dymola_min(i__1,i__2), i__2 = *ihi - 
		*ilo;
	nsr = Dymola_min(i__1,i__2);
/* Computing MAX */
	i__1 = 2, i__2 = nsr - nsr % 2;
	nsr = Dymola_max(i__1,i__2);

/*        ==== Estimate optimal workspace ==== */

/*        ==== Workspace query call to DLAQR3 ==== */

	i__1 = nwr + 1;
	dlaqr3_(wantt, wantz, n, ilo, ihi, &i__1, &h__[h_offset], ldh, iloz, 
		ihiz, &z__[z_offset], ldz, &ls, &ld, &wr[1], &wi[1], &h__[
		h_offset], ldh, n, &h__[h_offset], ldh, n, &h__[h_offset], 
		ldh, &work[1], &c_n1);

/*        ==== Optimal workspace = MAX(DLAQR5, DLAQR3) ==== */

/* Computing MAX */
	i__1 = nsr * 3 / 2, i__2 = (integer) work[1];
	lwkopt = Dymola_max(i__1,i__2);

/*        ==== Quick return in case of workspace query. ==== */

	if (*lwork == -1) {
	    work[1] = (doublereal) lwkopt;
	    return 0;
	}

/*        ==== DLAHQR/DLAQR0 crossover point ==== */

	nmin = ilaenv_(&c__12, "DLAQR0", jbcmpz, n, ilo, ihi, lwork);
	nmin = Dymola_max(11,nmin);

/*        ==== Nibble crossover point ==== */

	nibble = ilaenv_(&c__14, "DLAQR0", jbcmpz, n, ilo, ihi, lwork);
	nibble = Dymola_max(0,nibble);

/*        ==== Accumulate reflections during ttswp?  Use block */
/*        .    2-by-2 structure during matrix-matrix multiply? ==== */

	kacc22 = ilaenv_(&c__16, "DLAQR0", jbcmpz, n, ilo, ihi, lwork);
	kacc22 = Dymola_max(0,kacc22);
	kacc22 = Dymola_min(2,kacc22);

/*        ==== NWMAX = the largest possible deflation window for */
/*        .    which there is sufficient workspace. ==== */

/* Computing MIN */
	i__1 = (*n - 1) / 3, i__2 = *lwork / 2;
	nwmax = Dymola_min(i__1,i__2);
	nw = nwmax;

/*        ==== NSMAX = the Largest number of simultaneous shifts */
/*        .    for which there is sufficient workspace. ==== */

/* Computing MIN */
	i__1 = (*n + 6) / 9, i__2 = (*lwork << 1) / 3;
	nsmax = Dymola_min(i__1,i__2);
	nsmax -= nsmax % 2;

/*        ==== NDFL: an iteration count restarted at deflation. ==== */

	ndfl = 1;

/*        ==== ITMAX = iteration limit ==== */

/* Computing MAX */
	i__1 = 10, i__2 = *ihi - *ilo + 1;
	itmax = Dymola_max(i__1,i__2) * 30;

/*        ==== Last row and column in the active block ==== */

	kbot = *ihi;

/*        ==== Main Loop ==== */

	i__1 = itmax;
	for (it = 1; it <= i__1; ++it) {

/*           ==== Done when KBOT falls below ILO ==== */

	    if (kbot < *ilo) {
		goto L90;
	    }

/*           ==== Locate active block ==== */

	    i__2 = *ilo + 1;
	    for (k = kbot; k >= i__2; --k) {
		if (h__[k + (k - 1) * h_dim1] == 0.) {
		    goto L20;
		}
/* L10: */
	    }
	    k = *ilo;
L20:
	    ktop = k;

/*           ==== Select deflation window size: */
/*           .    Typical Case: */
/*           .      If possible and advisable, nibble the entire */
/*           .      active block.  If not, use size MIN(NWR,NWMAX) */
/*           .      or MIN(NWR+1,NWMAX) depending upon which has */
/*           .      the smaller corresponding subdiagonal entry */
/*           .      (a heuristic). */
/*           . */
/*           .    Exceptional Case: */
/*           .      If there have been no deflations in KEXNW or */
/*           .      more iterations, then vary the deflation window */
/*           .      size.   At first, because, larger windows are, */
/*           .      in general, more powerful than smaller ones, */
/*           .      rapidly increase the window to the maximum possible. */
/*           .      Then, gradually reduce the window size. ==== */

	    nh = kbot - ktop + 1;
	    nwupbd = Dymola_min(nh,nwmax);
	    if (ndfl < 5) {
		nw = Dymola_min(nwupbd,nwr);
	    } else {
/* Computing MIN */
		i__2 = nwupbd, i__3 = nw << 1;
		nw = Dymola_min(i__2,i__3);
	    }
	    if (nw < nwmax) {
		if (nw >= nh - 1) {
		    nw = nh;
		} else {
		    kwtop = kbot - nw + 1;
		    if ((d__1 = h__[kwtop + (kwtop - 1) * h_dim1], Dymola_abs(d__1)) 
			    > (d__2 = h__[kwtop - 1 + (kwtop - 2) * h_dim1], 
			    Dymola_abs(d__2))) {
			++nw;
		    }
		}
	    }
	    if (ndfl < 5) {
		ndec = -1;
	    } else if (ndec >= 0 || nw >= nwupbd) {
		++ndec;
		if (nw - ndec < 2) {
		    ndec = 0;
		}
		nw -= ndec;
	    }

/*           ==== Aggressive early deflation: */
/*           .    split workspace under the subdiagonal into */
/*           .      - an nw-by-nw work array V in the lower */
/*           .        left-hand-corner, */
/*           .      - an NW-by-at-least-NW-but-more-is-better */
/*           .        (NW-by-NHO) horizontal work array along */
/*           .        the bottom edge, */
/*           .      - an at-least-NW-but-more-is-better (NHV-by-NW) */
/*           .        vertical work array along the left-hand-edge. */
/*           .        ==== */

	    kv = *n - nw + 1;
	    kt = nw + 1;
	    nho = *n - nw - 1 - kt + 1;
	    kwv = nw + 2;
	    nve = *n - nw - kwv + 1;

/*           ==== Aggressive early deflation ==== */

	    dlaqr3_(wantt, wantz, n, &ktop, &kbot, &nw, &h__[h_offset], ldh, 
		    iloz, ihiz, &z__[z_offset], ldz, &ls, &ld, &wr[1], &wi[1],
		     &h__[kv + h_dim1], ldh, &nho, &h__[kv + kt * h_dim1], 
		    ldh, &nve, &h__[kwv + h_dim1], ldh, &work[1], lwork);

/*           ==== Adjust KBOT accounting for new deflations. ==== */

	    kbot -= ld;

/*           ==== KS points to the shifts. ==== */

	    ks = kbot - ls + 1;

/*           ==== Skip an expensive QR sweep if there is a (partly */
/*           .    heuristic) reason to expect that many eigenvalues */
/*           .    will deflate without it.  Here, the QR sweep is */
/*           .    skipped if many eigenvalues have just been deflated */
/*           .    or if the remaining active block is small. */

	    if (ld == 0 || ld * 100 <= nw * nibble && kbot - ktop + 1 > Dymola_min(
		    nmin,nwmax)) {

/*              ==== NS = nominal number of simultaneous shifts. */
/*              .    This may be lowered (slightly) if DLAQR3 */
/*              .    did not provide that many shifts. ==== */

/* Computing MIN */
/* Computing MAX */
		i__4 = 2, i__5 = kbot - ktop;
		i__2 = Dymola_min(nsmax,nsr), i__3 = Dymola_max(i__4,i__5);
		ns = Dymola_min(i__2,i__3);
		ns -= ns % 2;

/*              ==== If there have been no deflations */
/*              .    in a multiple of KEXSH iterations, */
/*              .    then try exceptional shifts. */
/*              .    Otherwise use shifts provided by */
/*              .    DLAQR3 above or from the eigenvalues */
/*              .    of a trailing principal submatrix. ==== */

		if (ndfl % 6 == 0) {
		    ks = kbot - ns + 1;
/* Computing MAX */
		    i__3 = ks + 1, i__4 = ktop + 2;
		    i__2 = Dymola_max(i__3,i__4);
		    for (i__ = kbot; i__ >= i__2; i__ += -2) {
			ss = (d__1 = h__[i__ + (i__ - 1) * h_dim1], Dymola_abs(d__1))
				 + (d__2 = h__[i__ - 1 + (i__ - 2) * h_dim1], 
				Dymola_abs(d__2));
			aa = ss * .75 + h__[i__ + i__ * h_dim1];
			bb = ss;
			cc = ss * -.4375;
			dd = aa;
			dlanv2_(&aa, &bb, &cc, &dd, &wr[i__ - 1], &wi[i__ - 1]
				, &wr[i__], &wi[i__], &cs, &sn);
/* L30: */
		    }
		    if (ks == ktop) {
			wr[ks + 1] = h__[ks + 1 + (ks + 1) * h_dim1];
			wi[ks + 1] = 0.;
			wr[ks] = wr[ks + 1];
			wi[ks] = wi[ks + 1];
		    }
		} else {

/*                 ==== Got NS/2 or fewer shifts? Use DLAQR4 or */
/*                 .    DLAHQR on a trailing principal submatrix to */
/*                 .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9, */
/*                 .    there is enough space below the subdiagonal */
/*                 .    to fit an NS-by-NS scratch array.) ==== */

		    if (kbot - ks + 1 <= ns / 2) {
			ks = kbot - ns + 1;
			kt = *n - ns + 1;
			dlacpy_("A", &ns, &ns, &h__[ks + ks * h_dim1], ldh, &
				h__[kt + h_dim1], ldh);
			if (ns > nmin) {
			    dlaqr4_(&c_false, &c_false, &ns, &c__1, &ns, &h__[
				    kt + h_dim1], ldh, &wr[ks], &wi[ks], &
				    c__1, &c__1, zdum, &c__1, &work[1], lwork,
				     &inf);
			} else {
			    dlahqr_(&c_false, &c_false, &ns, &c__1, &ns, &h__[
				    kt + h_dim1], ldh, &wr[ks], &wi[ks], &
				    c__1, &c__1, zdum, &c__1, &inf);
			}
			ks += inf;

/*                    ==== In case of a rare QR failure use */
/*                    .    eigenvalues of the trailing 2-by-2 */
/*                    .    principal submatrix.  ==== */

			if (ks >= kbot) {
			    aa = h__[kbot - 1 + (kbot - 1) * h_dim1];
			    cc = h__[kbot + (kbot - 1) * h_dim1];
			    bb = h__[kbot - 1 + kbot * h_dim1];
			    dd = h__[kbot + kbot * h_dim1];
			    dlanv2_(&aa, &bb, &cc, &dd, &wr[kbot - 1], &wi[
				    kbot - 1], &wr[kbot], &wi[kbot], &cs, &sn)
				    ;
			    ks = kbot - 1;
			}
		    }

		    if (kbot - ks + 1 > ns) {

/*                    ==== Sort the shifts (Helps a little) */
/*                    .    Bubble sort keeps complex conjugate */
/*                    .    pairs together. ==== */

			sorted = FALSE_;
			i__2 = ks + 1;
			for (k = kbot; k >= i__2; --k) {
			    if (sorted) {
				goto L60;
			    }
			    sorted = TRUE_;
			    i__3 = k - 1;
			    for (i__ = ks; i__ <= i__3; ++i__) {
				if ((d__1 = wr[i__], Dymola_abs(d__1)) + (d__2 = wi[
					i__], Dymola_abs(d__2)) < (d__3 = wr[i__ + 1]
					, Dymola_abs(d__3)) + (d__4 = wi[i__ + 1], 
					Dymola_abs(d__4))) {
				    sorted = FALSE_;

				    swap = wr[i__];
				    wr[i__] = wr[i__ + 1];
				    wr[i__ + 1] = swap;

				    swap = wi[i__];
				    wi[i__] = wi[i__ + 1];
				    wi[i__ + 1] = swap;
				}
/* L40: */
			    }
/* L50: */
			}
L60:
			;
		    }

/*                 ==== Shuffle shifts into pairs of real shifts */
/*                 .    and pairs of complex conjugate shifts */
/*                 .    assuming complex conjugate shifts are */
/*                 .    already adjacent to one another. (Yes, */
/*                 .    they are.)  ==== */

		    i__2 = ks + 2;
		    for (i__ = kbot; i__ >= i__2; i__ += -2) {
			if (wi[i__] != -wi[i__ - 1]) {

			    swap = wr[i__];
			    wr[i__] = wr[i__ - 1];
			    wr[i__ - 1] = wr[i__ - 2];
			    wr[i__ - 2] = swap;

			    swap = wi[i__];
			    wi[i__] = wi[i__ - 1];
			    wi[i__ - 1] = wi[i__ - 2];
			    wi[i__ - 2] = swap;
			}
/* L70: */
		    }
		}

/*              ==== If there are only two shifts and both are */
/*              .    real, then use only one.  ==== */

		if (kbot - ks + 1 == 2) {
		    if (wi[kbot] == 0.) {
			if ((d__1 = wr[kbot] - h__[kbot + kbot * h_dim1], Dymola_abs(
				d__1)) < (d__2 = wr[kbot - 1] - h__[kbot + 
				kbot * h_dim1], Dymola_abs(d__2))) {
			    wr[kbot - 1] = wr[kbot];
			} else {
			    wr[kbot] = wr[kbot - 1];
			}
		    }
		}

/*              ==== Use up to NS of the the smallest magnatiude */
/*              .    shifts.  If there aren't NS shifts available, */
/*              .    then use them all, possibly dropping one to */
/*              .    make the number of shifts even. ==== */

/* Computing MIN */
		i__2 = ns, i__3 = kbot - ks + 1;
		ns = Dymola_min(i__2,i__3);
		ns -= ns % 2;
		ks = kbot - ns + 1;

/*              ==== Small-bulge multi-shift QR sweep: */
/*              .    split workspace under the subdiagonal into */
/*              .    - a KDU-by-KDU work array U in the lower */
/*              .      left-hand-corner, */
/*              .    - a KDU-by-at-least-KDU-but-more-is-better */
/*              .      (KDU-by-NHo) horizontal work array WH along */
/*              .      the bottom edge, */
/*              .    - and an at-least-KDU-but-more-is-better-by-KDU */
/*              .      (NVE-by-KDU) vertical work WV arrow along */
/*              .      the left-hand-edge. ==== */

		kdu = ns * 3 - 3;
		ku = *n - kdu + 1;
		kwh = kdu + 1;
		nho = *n - kdu - 3 - (kdu + 1) + 1;
		kwv = kdu + 4;
		nve = *n - kdu - kwv + 1;

/*              ==== Small-bulge multi-shift QR sweep ==== */

		dlaqr5_(wantt, wantz, &kacc22, n, &ktop, &kbot, &ns, &wr[ks], 
			&wi[ks], &h__[h_offset], ldh, iloz, ihiz, &z__[
			z_offset], ldz, &work[1], &c__3, &h__[ku + h_dim1], 
			ldh, &nve, &h__[kwv + h_dim1], ldh, &nho, &h__[ku + 
			kwh * h_dim1], ldh);
	    }

/*           ==== Note progress (or the lack of it). ==== */

	    if (ld > 0) {
		ndfl = 1;
	    } else {
		++ndfl;
	    }

/*           ==== End of main loop ==== */
/* L80: */
	}

/*        ==== Iteration limit exceeded.  Set INFO to show where */
/*        .    the problem occurred and exit. ==== */

	*info = kbot;
L90:
	;
    }

/*     ==== Return the optimal value of LWORK. ==== */

    work[1] = (doublereal) lwkopt;

/*     ==== End of DLAQR0 ==== */

    return 0;
} /* dlaqr0_ */

/* Subroutine */ static int dlaset_(char *uplo, integer *m, integer *n, doublereal *alpha, doublereal *beta, doublereal *a, integer *lda)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    integer i__, j;

/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/* ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {

/*        Set the strictly upper triangular or trapezoidal part of the */
/*        array to ALPHA. */

	i__1 = *n;
	for (j = 2; j <= i__1; ++j) {
/* Computing MIN */
	    i__3 = j - 1;
	    i__2 = Dymola_min(i__3,*m);
	    for (i__ = 1; i__ <= i__2; ++i__) {
		a[i__ + j * a_dim1] = *alpha;
/* L10: */
	    }
/* L20: */
	}

    } else if (lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {

/*        Set the strictly lower triangular or trapezoidal part of the */
/*        array to ALPHA. */

	i__1 = Dymola_min(*m,*n);
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *m;
	    for (i__ = j + 1; i__ <= i__2; ++i__) {
		a[i__ + j * a_dim1] = *alpha;
/* L30: */
	    }
/* L40: */
	}

    } else {

/*        Set the leading m-by-n submatrix to ALPHA. */

	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *m;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		a[i__ + j * a_dim1] = *alpha;
/* L50: */
	    }
/* L60: */
	}
    }

/*     Set the first min(M,N) diagonal elements to BETA. */

    i__1 = Dymola_min(*m,*n);
    for (i__ = 1; i__ <= i__1; ++i__) {
	a[i__ + i__ * a_dim1] = *beta;
/* L70: */
    }

    return 0;

/*     End of DLASET */

} /* dlaset_ */

/* Subroutine */ static int dlahqr_(logical* wantt, logical* wantz, integer* n, integer* ilo, integer* ihi, doublereal* h__, integer* ldh, doublereal* wr, doublereal* wi, integer* iloz, integer* ihiz, doublereal* z__, integer* ldz, integer* info)
{
    /* System generated locals */
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3;
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    integer i__, j, k, l, m;
    doublereal s, v[3];
    integer i1, i2;
    doublereal t1, t2, t3, v2, v3, aa, ab, ba, bb, h11, h12, h21, h22, cs;
    integer nh;
    doublereal sn;
    integer nr;
    doublereal tr;
    integer nz;
    doublereal det, h21s;
    integer its;
    doublereal ulp, sum, tst, rt1i, rt2i, rt1r, rt2r;
    doublereal safmin, safmax, rtdisc, smlnum;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ========================================================= */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    --wr;
    --wi;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;

    /* Function Body */
    *info = 0;

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }
    if (*ilo == *ihi) {
	wr[*ilo] = h__[*ilo + *ilo * h_dim1];
	wi[*ilo] = 0.;
	return 0;
    }

/*     ==== clear out the trash ==== */
    i__1 = *ihi - 3;
    for (j = *ilo; j <= i__1; ++j) {
	h__[j + 2 + j * h_dim1] = 0.;
	h__[j + 3 + j * h_dim1] = 0.;
/* L10: */
    }
    if (*ilo <= *ihi - 2) {
	h__[*ihi + (*ihi - 2) * h_dim1] = 0.;
    }

    nh = *ihi - *ilo + 1;
    nz = *ihiz - *iloz + 1;

/*     Set machine-dependent constants for the stopping criterion. */

    safmin = dlamch_("SAFE MINIMUM");
    safmax = 1. / safmin;
    dlabad_(&safmin, &safmax);
    ulp = dlamch_("PRECISION");
    smlnum = safmin * ((doublereal) nh / ulp);

/*     I1 and I2 are the indices of the first row and last column of H */
/*     to which transformations must be applied. If eigenvalues only are */
/*     being computed, I1 and I2 are set inside the main loop. */

    if (*wantt) {
	i1 = 1;
	i2 = *n;
    }

/*     The main loop begins here. I is the loop index and decreases from */
/*     IHI to ILO in steps of 1 or 2. Each iteration of the loop works */
/*     with the active submatrix in rows and columns L to I. */
/*     Eigenvalues I+1 to IHI have already converged. Either L = ILO or */
/*     H(L,L-1) is negligible so that the matrix splits. */

    i__ = *ihi;
L20:
    l = *ilo;
    if (i__ < *ilo) {
	goto L160;
    }

/*     Perform QR iterations on rows and columns ILO to I until a */
/*     submatrix of order 1 or 2 splits off at the bottom because a */
/*     subdiagonal element has become negligible. */

    for (its = 0; its <= 30; ++its) {

/*        Look for a single small subdiagonal element. */

	i__1 = l + 1;
	for (k = i__; k >= i__1; --k) {
	    if ((d__1 = h__[k + (k - 1) * h_dim1], Dymola_abs(d__1)) <= smlnum) {
		goto L40;
	    }
	    tst = (d__1 = h__[k - 1 + (k - 1) * h_dim1], Dymola_abs(d__1)) + (d__2 = 
		    h__[k + k * h_dim1], Dymola_abs(d__2));
	    if (tst == 0.) {
		if (k - 2 >= *ilo) {
		    tst += (d__1 = h__[k - 1 + (k - 2) * h_dim1], Dymola_abs(d__1));
		}
		if (k + 1 <= *ihi) {
		    tst += (d__1 = h__[k + 1 + k * h_dim1], Dymola_abs(d__1));
		}
	    }
/*           ==== The following is a conservative small subdiagonal */
/*           .    deflation  criterion due to Ahues & Tisseur (LAWN 122, */
/*           .    1997). It has better mathematical foundation and */
/*           .    improves accuracy in some cases.  ==== */
	    if ((d__1 = h__[k + (k - 1) * h_dim1], Dymola_abs(d__1)) <= ulp * tst) {
/* Computing MAX */
		d__3 = (d__1 = h__[k + (k - 1) * h_dim1], Dymola_abs(d__1)), d__4 = (
			d__2 = h__[k - 1 + k * h_dim1], Dymola_abs(d__2));
		ab = Dymola_max(d__3,d__4);
/* Computing MIN */
		d__3 = (d__1 = h__[k + (k - 1) * h_dim1], Dymola_abs(d__1)), d__4 = (
			d__2 = h__[k - 1 + k * h_dim1], Dymola_abs(d__2));
		ba = Dymola_min(d__3,d__4);
/* Computing MAX */
		d__3 = (d__1 = h__[k + k * h_dim1], Dymola_abs(d__1)), d__4 = (d__2 =
			 h__[k - 1 + (k - 1) * h_dim1] - h__[k + k * h_dim1], 
			Dymola_abs(d__2));
		aa = Dymola_max(d__3,d__4);
/* Computing MIN */
		d__3 = (d__1 = h__[k + k * h_dim1], Dymola_abs(d__1)), d__4 = (d__2 =
			 h__[k - 1 + (k - 1) * h_dim1] - h__[k + k * h_dim1], 
			Dymola_abs(d__2));
		bb = Dymola_min(d__3,d__4);
		s = aa + ab;
/* Computing MAX */
		d__1 = smlnum, d__2 = ulp * (bb * (aa / s));
		if (ba * (ab / s) <= Dymola_max(d__1,d__2)) {
		    goto L40;
		}
	    }
/* L30: */
	}
L40:
	l = k;
	if (l > *ilo) {

/*           H(L,L-1) is negligible */

	    h__[l + (l - 1) * h_dim1] = 0.;
	}

/*        Exit from loop if a submatrix of order 1 or 2 has split off. */

	if (l >= i__ - 1) {
	    goto L150;
	}

/*        Now the active submatrix is in rows and columns L to I. If */
/*        eigenvalues only are being computed, only the active submatrix */
/*        need be transformed. */

	if (! (*wantt)) {
	    i1 = l;
	    i2 = i__;
	}

	if (its == 10) {

/*           Exceptional shift. */

	    s = (d__1 = h__[l + 1 + l * h_dim1], Dymola_abs(d__1)) + (d__2 = h__[l + 
		    2 + (l + 1) * h_dim1], Dymola_abs(d__2));
	    h11 = s * .75 + h__[l + l * h_dim1];
	    h12 = s * -.4375;
	    h21 = s;
	    h22 = h11;
	} else if (its == 20) {

/*           Exceptional shift. */

	    s = (d__1 = h__[i__ + (i__ - 1) * h_dim1], Dymola_abs(d__1)) + (d__2 = 
		    h__[i__ - 1 + (i__ - 2) * h_dim1], Dymola_abs(d__2));
	    h11 = s * .75 + h__[i__ + i__ * h_dim1];
	    h12 = s * -.4375;
	    h21 = s;
	    h22 = h11;
	} else {

/*           Prepare to use Francis' double shift */
/*           (i.e. 2nd degree generalized Rayleigh quotient) */

	    h11 = h__[i__ - 1 + (i__ - 1) * h_dim1];
	    h21 = h__[i__ + (i__ - 1) * h_dim1];
	    h12 = h__[i__ - 1 + i__ * h_dim1];
	    h22 = h__[i__ + i__ * h_dim1];
	}
	s = Dymola_abs(h11) + Dymola_abs(h12) + Dymola_abs(h21) + Dymola_abs(h22);
	if (s == 0.) {
	    rt1r = 0.;
	    rt1i = 0.;
	    rt2r = 0.;
	    rt2i = 0.;
	} else {
	    h11 /= s;
	    h21 /= s;
	    h12 /= s;
	    h22 /= s;
	    tr = (h11 + h22) / 2.;
	    det = (h11 - tr) * (h22 - tr) - h12 * h21;
	    rtdisc = sqrt((Dymola_abs(det)));
	    if (det >= 0.) {

/*              ==== complex conjugate shifts ==== */

		rt1r = tr * s;
		rt2r = rt1r;
		rt1i = rtdisc * s;
		rt2i = -rt1i;
	    } else {

/*              ==== real shifts (use only one of them)  ==== */

		rt1r = tr + rtdisc;
		rt2r = tr - rtdisc;
		if ((d__1 = rt1r - h22, Dymola_abs(d__1)) <= (d__2 = rt2r - h22, Dymola_abs(
			d__2))) {
		    rt1r *= s;
		    rt2r = rt1r;
		} else {
		    rt2r *= s;
		    rt1r = rt2r;
		}
		rt1i = 0.;
		rt2i = 0.;
	    }
	}

/*        Look for two consecutive small subdiagonal elements. */

	i__1 = l;
	for (m = i__ - 2; m >= i__1; --m) {
/*           Determine the effect of starting the double-shift QR */
/*           iteration at row M, and see if this would make H(M,M-1) */
/*           negligible.  (The following uses scaling to avoid */
/*           overflows and most underflows.) */

	    h21s = h__[m + 1 + m * h_dim1];
	    s = (d__1 = h__[m + m * h_dim1] - rt2r, Dymola_abs(d__1)) + Dymola_abs(rt2i) + 
		    Dymola_abs(h21s);
	    h21s = h__[m + 1 + m * h_dim1] / s;
	    v[0] = h21s * h__[m + (m + 1) * h_dim1] + (h__[m + m * h_dim1] - 
		    rt1r) * ((h__[m + m * h_dim1] - rt2r) / s) - rt1i * (rt2i 
		    / s);
	    v[1] = h21s * (h__[m + m * h_dim1] + h__[m + 1 + (m + 1) * h_dim1]
		     - rt1r - rt2r);
	    v[2] = h21s * h__[m + 2 + (m + 1) * h_dim1];
	    s = Dymola_abs(v[0]) + Dymola_abs(v[1]) + Dymola_abs(v[2]);
	    v[0] /= s;
	    v[1] /= s;
	    v[2] /= s;
	    if (m == l) {
		goto L60;
	    }
	    if ((d__1 = h__[m + (m - 1) * h_dim1], Dymola_abs(d__1)) * (Dymola_abs(v[1]) + 
		    Dymola_abs(v[2])) <= ulp * Dymola_abs(v[0]) * ((d__2 = h__[m - 1 + (m - 
		    1) * h_dim1], Dymola_abs(d__2)) + (d__3 = h__[m + m * h_dim1], 
		    Dymola_abs(d__3)) + (d__4 = h__[m + 1 + (m + 1) * h_dim1], Dymola_abs(
		    d__4)))) {
		goto L60;
	    }
/* L50: */
	}
L60:

/*        Double-shift QR step */

	i__1 = i__ - 1;
	for (k = m; k <= i__1; ++k) {

/*           The first iteration of this loop determines a reflection G */
/*           from the vector V and applies it from left and right to H, */
/*           thus creating a nonzero bulge below the subdiagonal. */

/*           Each subsequent iteration determines a reflection G to */
/*           restore the Hessenberg form in the (K-1)th column, and thus */
/*           chases the bulge one step toward the bottom of the active */
/*           submatrix. NR is the order of G. */

/* Computing MIN */
	    i__2 = 3, i__3 = i__ - k + 1;
	    nr = Dymola_min(i__2,i__3);
	    if (k > m) {
		dcopy_(&nr, &h__[k + (k - 1) * h_dim1], &c__1, v, &c__1);
	    }
	    dlarfg_(&nr, v, &v[1], &c__1, &t1);
	    if (k > m) {
		h__[k + (k - 1) * h_dim1] = v[0];
		h__[k + 1 + (k - 1) * h_dim1] = 0.;
		if (k < i__ - 1) {
		    h__[k + 2 + (k - 1) * h_dim1] = 0.;
		}
	    } else if (m > l) {
/*               ==== Use the following instead of */
/*               .    H( K, K-1 ) = -H( K, K-1 ) to */
/*               .    avoid a bug when v(2) and v(3) */
/*               .    underflow. ==== */
		h__[k + (k - 1) * h_dim1] *= 1. - t1;
	    }
	    v2 = v[1];
	    t2 = t1 * v2;
	    if (nr == 3) {
		v3 = v[2];
		t3 = t1 * v3;

/*              Apply G from the left to transform the rows of the matrix */
/*              in columns K to I2. */

		i__2 = i2;
		for (j = k; j <= i__2; ++j) {
		    sum = h__[k + j * h_dim1] + v2 * h__[k + 1 + j * h_dim1] 
			    + v3 * h__[k + 2 + j * h_dim1];
		    h__[k + j * h_dim1] -= sum * t1;
		    h__[k + 1 + j * h_dim1] -= sum * t2;
		    h__[k + 2 + j * h_dim1] -= sum * t3;
/* L70: */
		}

/*              Apply G from the right to transform the columns of the */
/*              matrix in rows I1 to Dymola_min(K+3,I). */

/* Computing MIN */
		i__3 = k + 3;
		i__2 = Dymola_min(i__3,i__);
		for (j = i1; j <= i__2; ++j) {
		    sum = h__[j + k * h_dim1] + v2 * h__[j + (k + 1) * h_dim1]
			     + v3 * h__[j + (k + 2) * h_dim1];
		    h__[j + k * h_dim1] -= sum * t1;
		    h__[j + (k + 1) * h_dim1] -= sum * t2;
		    h__[j + (k + 2) * h_dim1] -= sum * t3;
/* L80: */
		}

		if (*wantz) {

/*                 Accumulate transformations in the matrix Z */

		    i__2 = *ihiz;
		    for (j = *iloz; j <= i__2; ++j) {
			sum = z__[j + k * z_dim1] + v2 * z__[j + (k + 1) * 
				z_dim1] + v3 * z__[j + (k + 2) * z_dim1];
			z__[j + k * z_dim1] -= sum * t1;
			z__[j + (k + 1) * z_dim1] -= sum * t2;
			z__[j + (k + 2) * z_dim1] -= sum * t3;
/* L90: */
		    }
		}
	    } else if (nr == 2) {

/*              Apply G from the left to transform the rows of the matrix */
/*              in columns K to I2. */

		i__2 = i2;
		for (j = k; j <= i__2; ++j) {
		    sum = h__[k + j * h_dim1] + v2 * h__[k + 1 + j * h_dim1];
		    h__[k + j * h_dim1] -= sum * t1;
		    h__[k + 1 + j * h_dim1] -= sum * t2;
/* L100: */
		}

/*              Apply G from the right to transform the columns of the */
/*              matrix in rows I1 to Dymola_min(K+3,I). */

		i__2 = i__;
		for (j = i1; j <= i__2; ++j) {
		    sum = h__[j + k * h_dim1] + v2 * h__[j + (k + 1) * h_dim1]
			    ;
		    h__[j + k * h_dim1] -= sum * t1;
		    h__[j + (k + 1) * h_dim1] -= sum * t2;
/* L110: */
		}

		if (*wantz) {

/*                 Accumulate transformations in the matrix Z */

		    i__2 = *ihiz;
		    for (j = *iloz; j <= i__2; ++j) {
			sum = z__[j + k * z_dim1] + v2 * z__[j + (k + 1) * 
				z_dim1];
			z__[j + k * z_dim1] -= sum * t1;
			z__[j + (k + 1) * z_dim1] -= sum * t2;
/* L120: */
		    }
		}
	    }
/* L130: */
	}

/* L140: */
    }

/*     Failure to converge in remaining number of iterations */

    *info = i__;
    return 0;

L150:

    if (l == i__) {

/*        H(I,I-1) is negligible: one eigenvalue has converged. */

	wr[i__] = h__[i__ + i__ * h_dim1];
	wi[i__] = 0.;
    } else if (l == i__ - 1) {

/*        H(I-1,I-2) is negligible: a pair of eigenvalues have converged. */

/*        Transform the 2-by-2 submatrix to standard Schur form, */
/*        and compute and store the eigenvalues. */

	dlanv2_(&h__[i__ - 1 + (i__ - 1) * h_dim1], &h__[i__ - 1 + i__ * 
		h_dim1], &h__[i__ + (i__ - 1) * h_dim1], &h__[i__ + i__ * 
		h_dim1], &wr[i__ - 1], &wi[i__ - 1], &wr[i__], &wi[i__], &cs, 
		&sn);

	if (*wantt) {

/*           Apply the transformation to the rest of H. */

	    if (i2 > i__) {
		i__1 = i2 - i__;
		drot_(&i__1, &h__[i__ - 1 + (i__ + 1) * h_dim1], ldh, &h__[
			i__ + (i__ + 1) * h_dim1], ldh, &cs, &sn);
	    }
	    i__1 = i__ - i1 - 1;
	    drot_(&i__1, &h__[i1 + (i__ - 1) * h_dim1], &c__1, &h__[i1 + i__ *
		     h_dim1], &c__1, &cs, &sn);
	}
	if (*wantz) {

/*           Apply the transformation to Z. */

	    drot_(&nz, &z__[*iloz + (i__ - 1) * z_dim1], &c__1, &z__[*iloz + 
		    i__ * z_dim1], &c__1, &cs, &sn);
	}
    }

/*     return to start of the main loop with new value of I. */

    i__ = l - 1;
    goto L20;

L160:
    return 0;

/*     End of DLAHQR */

} /* dlahqr_ */

/* Subroutine */ static int dlahr2_(integer *n, integer *k, integer *nb, doublereal *a, integer *lda, doublereal *tau, doublereal *t, integer *ldt, doublereal *y, integer *ldy)
{
    /* System generated locals */
    integer a_dim1, a_offset, t_dim1, t_offset, y_dim1, y_offset, i__1, i__2, 
	    i__3;
    doublereal d__1;

    /* Local variables */
    integer i__;
    doublereal ei;

/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Quick return if possible */

    /* Parameter adjustments */
    --tau;
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    y_dim1 = *ldy;
    y_offset = 1 + y_dim1;
    y -= y_offset;

    /* Function Body */
    if (*n <= 1) {
	return 0;
    }

    i__1 = *nb;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ > 1) {

/*           Update A(K+1:N,I) */

/*           Update I-th column of A - Y * V**T */

	    i__2 = *n - *k;
	    i__3 = i__ - 1;
	    dgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b4_dlahr2, &y[*k + 1 + y_dim1], 
		    ldy, &a[*k + i__ - 1 + a_dim1], lda, &c_b5, &a[*k + 1 + 
		    i__ * a_dim1], &c__1);

/*           Apply I - V * T**T * V**T to this column (call it b) from the */
/*           left, using the last column of T as workspace */

/*           Let  V = ( V1 )   and   b = ( b1 )   (first I-1 rows) */
/*                    ( V2 )             ( b2 ) */

/*           where V1 is unit lower triangular */

/*           w := V1**T * b1 */

	    i__2 = i__ - 1;
	    dcopy_(&i__2, &a[*k + 1 + i__ * a_dim1], &c__1, &t[*nb * t_dim1 + 
		    1], &c__1);
	    i__2 = i__ - 1;
	    dtrmv_("Lower", "Transpose", "UNIT", &i__2, &a[*k + 1 + a_dim1], 
		    lda, &t[*nb * t_dim1 + 1], &c__1);

/*           w := w + V2**T * b2 */

	    i__2 = *n - *k - i__ + 1;
	    i__3 = i__ - 1;
	    dgemv_("Transpose", &i__2, &i__3, &c_b5, &a[*k + i__ + a_dim1], 
		    lda, &a[*k + i__ + i__ * a_dim1], &c__1, &c_b5, &t[*nb * 
		    t_dim1 + 1], &c__1);

/*           w := T**T * w */

	    i__2 = i__ - 1;
	    dtrmv_("Upper", "Transpose", "NON-UNIT", &i__2, &t[t_offset], ldt,
		     &t[*nb * t_dim1 + 1], &c__1);

/*           b2 := b2 - V2*w */

	    i__2 = *n - *k - i__ + 1;
	    i__3 = i__ - 1;
	    dgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b4_dlahr2, &a[*k + i__ + a_dim1],
		     lda, &t[*nb * t_dim1 + 1], &c__1, &c_b5, &a[*k + i__ + 
		    i__ * a_dim1], &c__1);

/*           b1 := b1 - V1*w */

	    i__2 = i__ - 1;
	    dtrmv_("Lower", "NO TRANSPOSE", "UNIT", &i__2, &a[*k + 1 + a_dim1]
		    , lda, &t[*nb * t_dim1 + 1], &c__1);
	    i__2 = i__ - 1;
	    daxpy_(&i__2, &c_b4_dlahr2, &t[*nb * t_dim1 + 1], &c__1, &a[*k + 1 + i__ 
		    * a_dim1], &c__1);

	    a[*k + i__ - 1 + (i__ - 1) * a_dim1] = ei;
	}

/*        Generate the elementary reflector H(I) to annihilate */
/*        A(K+I+1:N,I) */

	i__2 = *n - *k - i__ + 1;
/* Computing MIN */
	i__3 = *k + i__ + 1;
	dlarfg_(&i__2, &a[*k + i__ + i__ * a_dim1], &a[Dymola_min(i__3,*n) + i__ * 
		a_dim1], &c__1, &tau[i__]);
	ei = a[*k + i__ + i__ * a_dim1];
	a[*k + i__ + i__ * a_dim1] = 1.;

/*        Compute  Y(K+1:N,I) */

	i__2 = *n - *k;
	i__3 = *n - *k - i__ + 1;
	dgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b5, &a[*k + 1 + (i__ + 1) * 
		a_dim1], lda, &a[*k + i__ + i__ * a_dim1], &c__1, &c_b38, &y[*
		k + 1 + i__ * y_dim1], &c__1);
	i__2 = *n - *k - i__ + 1;
	i__3 = i__ - 1;
	dgemv_("Transpose", &i__2, &i__3, &c_b5, &a[*k + i__ + a_dim1], lda, &
		a[*k + i__ + i__ * a_dim1], &c__1, &c_b38, &t[i__ * t_dim1 + 
		1], &c__1);
	i__2 = *n - *k;
	i__3 = i__ - 1;
	dgemv_("NO TRANSPOSE", &i__2, &i__3, &c_b4_dlahr2, &y[*k + 1 + y_dim1], ldy, 
		&t[i__ * t_dim1 + 1], &c__1, &c_b5, &y[*k + 1 + i__ * y_dim1],
		 &c__1);
	i__2 = *n - *k;
	dscal_(&i__2, &tau[i__], &y[*k + 1 + i__ * y_dim1], &c__1);

/*        Compute T(1:I,I) */

	i__2 = i__ - 1;
	d__1 = -tau[i__];
	dscal_(&i__2, &d__1, &t[i__ * t_dim1 + 1], &c__1);
	i__2 = i__ - 1;
	dtrmv_("Upper", "No Transpose", "NON-UNIT", &i__2, &t[t_offset], ldt, 
		&t[i__ * t_dim1 + 1], &c__1)
		;
	t[i__ + i__ * t_dim1] = tau[i__];

/* L10: */
    }
    a[*k + *nb + *nb * a_dim1] = ei;

/*     Compute Y(1:K,1:NB) */

    dlacpy_("ALL", k, nb, &a[(a_dim1 << 1) + 1], lda, &y[y_offset], ldy);
    dtrmm_("RIGHT", "Lower", "NO TRANSPOSE", "UNIT", k, nb, &c_b5, &a[*k + 1 
	    + a_dim1], lda, &y[y_offset], ldy);
    if (*n > *k + *nb) {
	i__1 = *n - *k - *nb;
	dgemm_("NO TRANSPOSE", "NO TRANSPOSE", k, nb, &i__1, &c_b5, &a[(*nb + 
		2) * a_dim1 + 1], lda, &a[*k + 1 + *nb + a_dim1], lda, &c_b5, 
		&y[y_offset], ldy);
    }
    dtrmm_("RIGHT", "Upper", "NO TRANSPOSE", "NON-UNIT", k, nb, &c_b5, &t[
	    t_offset], ldt, &y[y_offset], ldy);

    return 0;

/*     End of DLAHR2 */

} /* dlahr2_ */

/* Subroutine */ static int dtrmm_(char *side, char *uplo, char *transa, char *diag, integer *m, integer *n, doublereal *alpha, doublereal *a, integer *lda, doublereal *b, integer *ldb)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3;

    /* Local variables */
    integer i__, j, k, info;
    doublereal temp;
    logical lside;
    integer nrowa;
    logical upper;
    logical nounit;


/*  -- Reference BLAS level3 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Parameters .. */
/*     .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    lside = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
    if (lside) {
	nrowa = *m;
    } else {
	nrowa = *n;
    }
    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);

    info = 0;
    if (! lside && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
	info = 1;
    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
	info = 2;
    } else if (! lsame_(transa, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(transa,
	     "T", (ftnlen)1, (ftnlen)1) && ! lsame_(transa, "C", (ftnlen)1, (
	    ftnlen)1)) {
	info = 3;
    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
	    "N", (ftnlen)1, (ftnlen)1)) {
	info = 4;
    } else if (*m < 0) {
	info = 5;
    } else if (*n < 0) {
	info = 6;
    } else if (*lda < Dymola_max(1,nrowa)) {
	info = 9;
    } else if (*ldb < Dymola_max(1,*m)) {
	info = 11;
    }
    if (info != 0) {
	xerbla_("DTRMM ", &info);
	return 0;
    }

/*     Quick return if possible. */

    if (*m == 0 || *n == 0) {
	return 0;
    }

/*     And when  alpha.eq.zero. */

    if (*alpha == 0.) {
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *m;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		b[i__ + j * b_dim1] = 0.;
/* L10: */
	    }
/* L20: */
	}
	return 0;
    }

/*     Start the operations. */

    if (lside) {
	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {

/*           Form  B := alpha*A*B. */

	    if (upper) {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = *m;
		    for (k = 1; k <= i__2; ++k) {
			if (b[k + j * b_dim1] != 0.) {
			    temp = *alpha * b[k + j * b_dim1];
			    i__3 = k - 1;
			    for (i__ = 1; i__ <= i__3; ++i__) {
				b[i__ + j * b_dim1] += temp * a[i__ + k * 
					a_dim1];
/* L30: */
			    }
			    if (nounit) {
				temp *= a[k + k * a_dim1];
			    }
			    b[k + j * b_dim1] = temp;
			}
/* L40: */
		    }
/* L50: */
		}
	    } else {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    for (k = *m; k >= 1; --k) {
			if (b[k + j * b_dim1] != 0.) {
			    temp = *alpha * b[k + j * b_dim1];
			    b[k + j * b_dim1] = temp;
			    if (nounit) {
				b[k + j * b_dim1] *= a[k + k * a_dim1];
			    }
			    i__2 = *m;
			    for (i__ = k + 1; i__ <= i__2; ++i__) {
				b[i__ + j * b_dim1] += temp * a[i__ + k * 
					a_dim1];
/* L60: */
			    }
			}
/* L70: */
		    }
/* L80: */
		}
	    }
	} else {

/*           Form  B := alpha*A**T*B. */

	    if (upper) {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    for (i__ = *m; i__ >= 1; --i__) {
			temp = b[i__ + j * b_dim1];
			if (nounit) {
			    temp *= a[i__ + i__ * a_dim1];
			}
			i__2 = i__ - 1;
			for (k = 1; k <= i__2; ++k) {
			    temp += a[k + i__ * a_dim1] * b[k + j * b_dim1];
/* L90: */
			}
			b[i__ + j * b_dim1] = *alpha * temp;
/* L100: */
		    }
/* L110: */
		}
	    } else {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = *m;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			temp = b[i__ + j * b_dim1];
			if (nounit) {
			    temp *= a[i__ + i__ * a_dim1];
			}
			i__3 = *m;
			for (k = i__ + 1; k <= i__3; ++k) {
			    temp += a[k + i__ * a_dim1] * b[k + j * b_dim1];
/* L120: */
			}
			b[i__ + j * b_dim1] = *alpha * temp;
/* L130: */
		    }
/* L140: */
		}
	    }
	}
    } else {
	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {

/*           Form  B := alpha*B*A. */

	    if (upper) {
		for (j = *n; j >= 1; --j) {
		    temp = *alpha;
		    if (nounit) {
			temp *= a[j + j * a_dim1];
		    }
		    i__1 = *m;
		    for (i__ = 1; i__ <= i__1; ++i__) {
			b[i__ + j * b_dim1] = temp * b[i__ + j * b_dim1];
/* L150: */
		    }
		    i__1 = j - 1;
		    for (k = 1; k <= i__1; ++k) {
			if (a[k + j * a_dim1] != 0.) {
			    temp = *alpha * a[k + j * a_dim1];
			    i__2 = *m;
			    for (i__ = 1; i__ <= i__2; ++i__) {
				b[i__ + j * b_dim1] += temp * b[i__ + k * 
					b_dim1];
/* L160: */
			    }
			}
/* L170: */
		    }
/* L180: */
		}
	    } else {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    temp = *alpha;
		    if (nounit) {
			temp *= a[j + j * a_dim1];
		    }
		    i__2 = *m;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			b[i__ + j * b_dim1] = temp * b[i__ + j * b_dim1];
/* L190: */
		    }
		    i__2 = *n;
		    for (k = j + 1; k <= i__2; ++k) {
			if (a[k + j * a_dim1] != 0.) {
			    temp = *alpha * a[k + j * a_dim1];
			    i__3 = *m;
			    for (i__ = 1; i__ <= i__3; ++i__) {
				b[i__ + j * b_dim1] += temp * b[i__ + k * 
					b_dim1];
/* L200: */
			    }
			}
/* L210: */
		    }
/* L220: */
		}
	    }
	} else {

/*           Form  B := alpha*B*A**T. */

	    if (upper) {
		i__1 = *n;
		for (k = 1; k <= i__1; ++k) {
		    i__2 = k - 1;
		    for (j = 1; j <= i__2; ++j) {
			if (a[j + k * a_dim1] != 0.) {
			    temp = *alpha * a[j + k * a_dim1];
			    i__3 = *m;
			    for (i__ = 1; i__ <= i__3; ++i__) {
				b[i__ + j * b_dim1] += temp * b[i__ + k * 
					b_dim1];
/* L230: */
			    }
			}
/* L240: */
		    }
		    temp = *alpha;
		    if (nounit) {
			temp *= a[k + k * a_dim1];
		    }
		    if (temp != 1.) {
			i__2 = *m;
			for (i__ = 1; i__ <= i__2; ++i__) {
			    b[i__ + k * b_dim1] = temp * b[i__ + k * b_dim1];
/* L250: */
			}
		    }
/* L260: */
		}
	    } else {
		for (k = *n; k >= 1; --k) {
		    i__1 = *n;
		    for (j = k + 1; j <= i__1; ++j) {
			if (a[j + k * a_dim1] != 0.) {
			    temp = *alpha * a[j + k * a_dim1];
			    i__2 = *m;
			    for (i__ = 1; i__ <= i__2; ++i__) {
				b[i__ + j * b_dim1] += temp * b[i__ + k * 
					b_dim1];
/* L270: */
			    }
			}
/* L280: */
		    }
		    temp = *alpha;
		    if (nounit) {
			temp *= a[k + k * a_dim1];
		    }
		    if (temp != 1.) {
			i__1 = *m;
			for (i__ = 1; i__ <= i__1; ++i__) {
			    b[i__ + k * b_dim1] = temp * b[i__ + k * b_dim1];
/* L290: */
			}
		    }
/* L300: */
		}
	    }
	}
    }

    return 0;

/*     End of DTRMM . */

} /* dtrmm_ */

/* Subroutine */ static int dlarfb_(char *side, char *trans, char *direct, char *storev, integer *m, integer *n, integer *k, doublereal *v, integer *ldv, doublereal *t, integer *ldt, doublereal *c__, integer *ldc, doublereal *work, integer *ldwork)
{
    /* System generated locals */
    integer c_dim1, c_offset, t_dim1, t_offset, v_dim1, v_offset, work_dim1, 
	    work_offset, i__1, i__2;

    /* Local variables */
    integer i__, j;
    char transt[1];


/*  -- LAPACK auxiliary routine (version 3.5.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     June 2013 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Quick return if possible */

    /* Parameter adjustments */
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    work_dim1 = *ldwork;
    work_offset = 1 + work_dim1;
    work -= work_offset;

    /* Function Body */
    if (*m <= 0 || *n <= 0) {
	return 0;
    }

    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
	*(unsigned char *)transt = 'T';
    } else {
	*(unsigned char *)transt = 'N';
    }

    if (lsame_(storev, "C", (ftnlen)1, (ftnlen)1)) {

	if (lsame_(direct, "F", (ftnlen)1, (ftnlen)1)) {

/*           Let  V =  ( V1 )    (first K rows) */
/*                     ( V2 ) */
/*           where  V1  is unit lower triangular. */

	    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {

/*              Form  H * C  or  H**T * C  where  C = ( C1 ) */
/*                                                    ( C2 ) */

/*              W := C**T * V  =  (C1**T * V1 + C2**T * V2)  (stored in WORK) */

/*              W := C1**T */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    dcopy_(n, &c__[j + c_dim1], ldc, &work[j * work_dim1 + 1],
			     &c__1);
/* L10: */
		}

/*              W := W * V1 */

		dtrmm_("Right", "Lower", "No transpose", "Unit", n, k, &c_b14,
			 &v[v_offset], ldv, &work[work_offset], ldwork);
		if (*m > *k) {

/*                 W := W + C2**T * V2 */

		    i__1 = *m - *k;
		    dgemm_("Transpose", "No transpose", n, k, &i__1, &c_b14, &
			    c__[*k + 1 + c_dim1], ldc, &v[*k + 1 + v_dim1], 
			    ldv, &c_b14, &work[work_offset], ldwork);
		}

/*              W := W * T**T  or  W * T */

		dtrmm_("Right", "Upper", transt, "Non-unit", n, k, &c_b14, &t[
			t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - V * W**T */

		if (*m > *k) {

/*                 C2 := C2 - V2 * W**T */

		    i__1 = *m - *k;
		    dgemm_("No transpose", "Transpose", &i__1, n, k, &c_b25, &
			    v[*k + 1 + v_dim1], ldv, &work[work_offset], 
			    ldwork, &c_b14, &c__[*k + 1 + c_dim1], ldc);
		}

/*              W := W * V1**T */

		dtrmm_("Right", "Lower", "Transpose", "Unit", n, k, &c_b14, &
			v[v_offset], ldv, &work[work_offset], ldwork);

/*              C1 := C1 - W**T */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = *n;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[j + i__ * c_dim1] -= work[i__ + j * work_dim1];
/* L20: */
		    }
/* L30: */
		}

	    } else if (lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {

/*              Form  C * H  or  C * H**T  where  C = ( C1  C2 ) */

/*              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK) */

/*              W := C1 */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    dcopy_(m, &c__[j * c_dim1 + 1], &c__1, &work[j * 
			    work_dim1 + 1], &c__1);
/* L40: */
		}

/*              W := W * V1 */

		dtrmm_("Right", "Lower", "No transpose", "Unit", m, k, &c_b14,
			 &v[v_offset], ldv, &work[work_offset], ldwork);
		if (*n > *k) {

/*                 W := W + C2 * V2 */

		    i__1 = *n - *k;
		    dgemm_("No transpose", "No transpose", m, k, &i__1, &
			    c_b14, &c__[(*k + 1) * c_dim1 + 1], ldc, &v[*k + 
			    1 + v_dim1], ldv, &c_b14, &work[work_offset], 
			    ldwork);
		}

/*              W := W * T  or  W * T**T */

		dtrmm_("Right", "Upper", trans, "Non-unit", m, k, &c_b14, &t[
			t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V**T */

		if (*n > *k) {

/*                 C2 := C2 - W * V2**T */

		    i__1 = *n - *k;
		    dgemm_("No transpose", "Transpose", m, &i__1, k, &c_b25, &
			    work[work_offset], ldwork, &v[*k + 1 + v_dim1], 
			    ldv, &c_b14, &c__[(*k + 1) * c_dim1 + 1], ldc);
		}

/*              W := W * V1**T */

		dtrmm_("Right", "Lower", "Transpose", "Unit", m, k, &c_b14, &
			v[v_offset], ldv, &work[work_offset], ldwork);

/*              C1 := C1 - W */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = *m;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] -= work[i__ + j * work_dim1];
/* L50: */
		    }
/* L60: */
		}
	    }

	} else {

/*           Let  V =  ( V1 ) */
/*                     ( V2 )    (last K rows) */
/*           where  V2  is unit upper triangular. */

	    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {

/*              Form  H * C  or  H**T * C  where  C = ( C1 ) */
/*                                                    ( C2 ) */

/*              W := C**T * V  =  (C1**T * V1 + C2**T * V2)  (stored in WORK) */

/*              W := C2**T */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    dcopy_(n, &c__[*m - *k + j + c_dim1], ldc, &work[j * 
			    work_dim1 + 1], &c__1);
/* L70: */
		}

/*              W := W * V2 */

		dtrmm_("Right", "Upper", "No transpose", "Unit", n, k, &c_b14,
			 &v[*m - *k + 1 + v_dim1], ldv, &work[work_offset], 
			ldwork);
		if (*m > *k) {

/*                 W := W + C1**T * V1 */

		    i__1 = *m - *k;
		    dgemm_("Transpose", "No transpose", n, k, &i__1, &c_b14, &
			    c__[c_offset], ldc, &v[v_offset], ldv, &c_b14, &
			    work[work_offset], ldwork);
		}

/*              W := W * T**T  or  W * T */

		dtrmm_("Right", "Lower", transt, "Non-unit", n, k, &c_b14, &t[
			t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - V * W**T */

		if (*m > *k) {

/*                 C1 := C1 - V1 * W**T */

		    i__1 = *m - *k;
		    dgemm_("No transpose", "Transpose", &i__1, n, k, &c_b25, &
			    v[v_offset], ldv, &work[work_offset], ldwork, &
			    c_b14, &c__[c_offset], ldc);
		}

/*              W := W * V2**T */

		dtrmm_("Right", "Upper", "Transpose", "Unit", n, k, &c_b14, &
			v[*m - *k + 1 + v_dim1], ldv, &work[work_offset], 
			ldwork);

/*              C2 := C2 - W**T */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = *n;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[*m - *k + j + i__ * c_dim1] -= work[i__ + j * 
				work_dim1];
/* L80: */
		    }
/* L90: */
		}

	    } else if (lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {

/*              Form  C * H  or  C * H**T  where  C = ( C1  C2 ) */

/*              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK) */

/*              W := C2 */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    dcopy_(m, &c__[(*n - *k + j) * c_dim1 + 1], &c__1, &work[
			    j * work_dim1 + 1], &c__1);
/* L100: */
		}

/*              W := W * V2 */

		dtrmm_("Right", "Upper", "No transpose", "Unit", m, k, &c_b14,
			 &v[*n - *k + 1 + v_dim1], ldv, &work[work_offset], 
			ldwork);
		if (*n > *k) {

/*                 W := W + C1 * V1 */

		    i__1 = *n - *k;
		    dgemm_("No transpose", "No transpose", m, k, &i__1, &
			    c_b14, &c__[c_offset], ldc, &v[v_offset], ldv, &
			    c_b14, &work[work_offset], ldwork);
		}

/*              W := W * T  or  W * T**T */

		dtrmm_("Right", "Lower", trans, "Non-unit", m, k, &c_b14, &t[
			t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V**T */

		if (*n > *k) {

/*                 C1 := C1 - W * V1**T */

		    i__1 = *n - *k;
		    dgemm_("No transpose", "Transpose", m, &i__1, k, &c_b25, &
			    work[work_offset], ldwork, &v[v_offset], ldv, &
			    c_b14, &c__[c_offset], ldc);
		}

/*              W := W * V2**T */

		dtrmm_("Right", "Upper", "Transpose", "Unit", m, k, &c_b14, &
			v[*n - *k + 1 + v_dim1], ldv, &work[work_offset], 
			ldwork);

/*              C2 := C2 - W */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = *m;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[i__ + (*n - *k + j) * c_dim1] -= work[i__ + j * 
				work_dim1];
/* L110: */
		    }
/* L120: */
		}
	    }
	}

    } else if (lsame_(storev, "R", (ftnlen)1, (ftnlen)1)) {

	if (lsame_(direct, "F", (ftnlen)1, (ftnlen)1)) {

/*           Let  V =  ( V1  V2 )    (V1: first K columns) */
/*           where  V1  is unit upper triangular. */

	    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {

/*              Form  H * C  or  H**T * C  where  C = ( C1 ) */
/*                                                    ( C2 ) */

/*              W := C**T * V**T  =  (C1**T * V1**T + C2**T * V2**T) (stored in WORK) */

/*              W := C1**T */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    dcopy_(n, &c__[j + c_dim1], ldc, &work[j * work_dim1 + 1],
			     &c__1);
/* L130: */
		}

/*              W := W * V1**T */

		dtrmm_("Right", "Upper", "Transpose", "Unit", n, k, &c_b14, &
			v[v_offset], ldv, &work[work_offset], ldwork);
		if (*m > *k) {

/*                 W := W + C2**T * V2**T */

		    i__1 = *m - *k;
		    dgemm_("Transpose", "Transpose", n, k, &i__1, &c_b14, &
			    c__[*k + 1 + c_dim1], ldc, &v[(*k + 1) * v_dim1 + 
			    1], ldv, &c_b14, &work[work_offset], ldwork);
		}

/*              W := W * T**T  or  W * T */

		dtrmm_("Right", "Upper", transt, "Non-unit", n, k, &c_b14, &t[
			t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - V**T * W**T */

		if (*m > *k) {

/*                 C2 := C2 - V2**T * W**T */

		    i__1 = *m - *k;
		    dgemm_("Transpose", "Transpose", &i__1, n, k, &c_b25, &v[(
			    *k + 1) * v_dim1 + 1], ldv, &work[work_offset], 
			    ldwork, &c_b14, &c__[*k + 1 + c_dim1], ldc);
		}

/*              W := W * V1 */

		dtrmm_("Right", "Upper", "No transpose", "Unit", n, k, &c_b14,
			 &v[v_offset], ldv, &work[work_offset], ldwork);

/*              C1 := C1 - W**T */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = *n;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[j + i__ * c_dim1] -= work[i__ + j * work_dim1];
/* L140: */
		    }
/* L150: */
		}

	    } else if (lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {

/*              Form  C * H  or  C * H**T  where  C = ( C1  C2 ) */

/*              W := C * V**T  =  (C1*V1**T + C2*V2**T)  (stored in WORK) */

/*              W := C1 */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    dcopy_(m, &c__[j * c_dim1 + 1], &c__1, &work[j * 
			    work_dim1 + 1], &c__1);
/* L160: */
		}

/*              W := W * V1**T */

		dtrmm_("Right", "Upper", "Transpose", "Unit", m, k, &c_b14, &
			v[v_offset], ldv, &work[work_offset], ldwork);
		if (*n > *k) {

/*                 W := W + C2 * V2**T */

		    i__1 = *n - *k;
		    dgemm_("No transpose", "Transpose", m, k, &i__1, &c_b14, &
			    c__[(*k + 1) * c_dim1 + 1], ldc, &v[(*k + 1) * 
			    v_dim1 + 1], ldv, &c_b14, &work[work_offset], 
			    ldwork);
		}

/*              W := W * T  or  W * T**T */

		dtrmm_("Right", "Upper", trans, "Non-unit", m, k, &c_b14, &t[
			t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V */

		if (*n > *k) {

/*                 C2 := C2 - W * V2 */

		    i__1 = *n - *k;
		    dgemm_("No transpose", "No transpose", m, &i__1, k, &
			    c_b25, &work[work_offset], ldwork, &v[(*k + 1) * 
			    v_dim1 + 1], ldv, &c_b14, &c__[(*k + 1) * c_dim1 
			    + 1], ldc);
		}

/*              W := W * V1 */

		dtrmm_("Right", "Upper", "No transpose", "Unit", m, k, &c_b14,
			 &v[v_offset], ldv, &work[work_offset], ldwork);

/*              C1 := C1 - W */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = *m;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] -= work[i__ + j * work_dim1];
/* L170: */
		    }
/* L180: */
		}

	    }

	} else {

/*           Let  V =  ( V1  V2 )    (V2: last K columns) */
/*           where  V2  is unit lower triangular. */

	    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {

/*              Form  H * C  or  H**T * C  where  C = ( C1 ) */
/*                                                    ( C2 ) */

/*              W := C**T * V**T  =  (C1**T * V1**T + C2**T * V2**T) (stored in WORK) */

/*              W := C2**T */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    dcopy_(n, &c__[*m - *k + j + c_dim1], ldc, &work[j * 
			    work_dim1 + 1], &c__1);
/* L190: */
		}

/*              W := W * V2**T */

		dtrmm_("Right", "Lower", "Transpose", "Unit", n, k, &c_b14, &
			v[(*m - *k + 1) * v_dim1 + 1], ldv, &work[work_offset]
			, ldwork);
		if (*m > *k) {

/*                 W := W + C1**T * V1**T */

		    i__1 = *m - *k;
		    dgemm_("Transpose", "Transpose", n, k, &i__1, &c_b14, &
			    c__[c_offset], ldc, &v[v_offset], ldv, &c_b14, &
			    work[work_offset], ldwork);
		}

/*              W := W * T**T  or  W * T */

		dtrmm_("Right", "Lower", transt, "Non-unit", n, k, &c_b14, &t[
			t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - V**T * W**T */

		if (*m > *k) {

/*                 C1 := C1 - V1**T * W**T */

		    i__1 = *m - *k;
		    dgemm_("Transpose", "Transpose", &i__1, n, k, &c_b25, &v[
			    v_offset], ldv, &work[work_offset], ldwork, &
			    c_b14, &c__[c_offset], ldc);
		}

/*              W := W * V2 */

		dtrmm_("Right", "Lower", "No transpose", "Unit", n, k, &c_b14,
			 &v[(*m - *k + 1) * v_dim1 + 1], ldv, &work[
			work_offset], ldwork);

/*              C2 := C2 - W**T */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = *n;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[*m - *k + j + i__ * c_dim1] -= work[i__ + j * 
				work_dim1];
/* L200: */
		    }
/* L210: */
		}

	    } else if (lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {

/*              Form  C * H  or  C * H'  where  C = ( C1  C2 ) */

/*              W := C * V**T  =  (C1*V1**T + C2*V2**T)  (stored in WORK) */

/*              W := C2 */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    dcopy_(m, &c__[(*n - *k + j) * c_dim1 + 1], &c__1, &work[
			    j * work_dim1 + 1], &c__1);
/* L220: */
		}

/*              W := W * V2**T */

		dtrmm_("Right", "Lower", "Transpose", "Unit", m, k, &c_b14, &
			v[(*n - *k + 1) * v_dim1 + 1], ldv, &work[work_offset]
			, ldwork);
		if (*n > *k) {

/*                 W := W + C1 * V1**T */

		    i__1 = *n - *k;
		    dgemm_("No transpose", "Transpose", m, k, &i__1, &c_b14, &
			    c__[c_offset], ldc, &v[v_offset], ldv, &c_b14, &
			    work[work_offset], ldwork);
		}

/*              W := W * T  or  W * T**T */

		dtrmm_("Right", "Lower", trans, "Non-unit", m, k, &c_b14, &t[
			t_offset], ldt, &work[work_offset], ldwork);

/*              C := C - W * V */

		if (*n > *k) {

/*                 C1 := C1 - W * V1 */

		    i__1 = *n - *k;
		    dgemm_("No transpose", "No transpose", m, &i__1, k, &
			    c_b25, &work[work_offset], ldwork, &v[v_offset], 
			    ldv, &c_b14, &c__[c_offset], ldc);
		}

/*              W := W * V2 */

		dtrmm_("Right", "Lower", "No transpose", "Unit", m, k, &c_b14,
			 &v[(*n - *k + 1) * v_dim1 + 1], ldv, &work[
			work_offset], ldwork);

/*              C1 := C1 - W */

		i__1 = *k;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = *m;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[i__ + (*n - *k + j) * c_dim1] -= work[i__ + j * 
				work_dim1];
/* L230: */
		    }
/* L240: */
		}

	    }

	}
    }

    return 0;

/*     End of DLARFB */

} /* dlarfb_ */

/* Subroutine */ static int dgehd2_(integer* n, integer* ilo, integer* ihi, doublereal* a, integer* lda, doublereal* tau, doublereal* work, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    integer i__;
    doublereal aii;

/*  -- LAPACK computational routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    if (*n < 0) {
	*info = -1;
    } else if (*ilo < 1 || *ilo > Dymola_max(1,*n)) {
	*info = -2;
    } else if (*ihi < Dymola_min(*ilo,*n) || *ihi > *n) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -5;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGEHD2", &i__1);
	return 0;
    }

    i__1 = *ihi - 1;
    for (i__ = *ilo; i__ <= i__1; ++i__) {

/*        Compute elementary reflector H(i) to annihilate A(i+2:ihi,i) */

	i__2 = *ihi - i__;
/* Computing MIN */
	i__3 = i__ + 2;
	dlarfg_(&i__2, &a[i__ + 1 + i__ * a_dim1], &a[Dymola_min(i__3,*n) + i__ * 
		a_dim1], &c__1, &tau[i__]);
	aii = a[i__ + 1 + i__ * a_dim1];
	a[i__ + 1 + i__ * a_dim1] = 1.;

/*        Apply H(i) to A(1:ihi,i+1:ihi) from the right */

	i__2 = *ihi - i__;
	dlarf_("Right", ihi, &i__2, &a[i__ + 1 + i__ * a_dim1], &c__1, &tau[
		i__], &a[(i__ + 1) * a_dim1 + 1], lda, &work[1]);

/*        Apply H(i) to A(i+1:ihi,i+1:n) from the left */

	i__2 = *ihi - i__;
	i__3 = *n - i__;
	dlarf_("Left", &i__2, &i__3, &a[i__ + 1 + i__ * a_dim1], &c__1, &tau[
		i__], &a[i__ + 1 + (i__ + 1) * a_dim1], lda, &work[1]);

	a[i__ + 1 + i__ * a_dim1] = aii;
/* L10: */
    }

    return 0;

/*     End of DGEHD2 */

} /* dgehd2_ */

/* Subroutine */ static int dorgqr_(const integer* m, const integer* n, const integer* k, doublereal* a, integer* lda, const doublereal* tau, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    integer i__, j, l, ib, nb, ki, kk, nx, iws, nbmin, iinfo;
    integer ldwork, lwkopt;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    nb = ilaenv_(&c__1, "DORGQR", " ", m, n, k, &c_n1);
    lwkopt = Dymola_max(1,*n) * nb;
    work[1] = (doublereal) lwkopt;
    lquery = *lwork == -1;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0 || *n > *m) {
	*info = -2;
    } else if (*k < 0 || *k > *n) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -5;
    } else if (*lwork < Dymola_max(1,*n) && ! lquery) {
	*info = -8;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DORGQR", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*n <= 0) {
	work[1] = 1.;
	return 0;
    }

    nbmin = 2;
    nx = 0;
    iws = *n;
    if (nb > 1 && nb < *k) {

/*        Determine when to cross over from blocked to unblocked code. */

/* Computing MAX */
	i__1 = 0, i__2 = ilaenv_(&c__3, "DORGQR", " ", m, n, k, &c_n1);
	nx = Dymola_max(i__1,i__2);
	if (nx < *k) {

/*           Determine if workspace is large enough for blocked code. */

	    ldwork = *n;
	    iws = ldwork * nb;
	    if (*lwork < iws) {

/*              Not enough workspace to use optimal NB:  reduce NB and */
/*              determine the minimum value of NB. */

		nb = *lwork / ldwork;
/* Computing MAX */
		i__1 = 2, i__2 = ilaenv_(&c__2, "DORGQR", " ", m, n, k, &c_n1);
		nbmin = Dymola_max(i__1,i__2);
	    }
	}
    }

    if (nb >= nbmin && nb < *k && nx < *k) {

/*        Use blocked code after the last block. */
/*        The first kk columns are handled by the block method. */

	ki = (*k - nx - 1) / nb * nb;
/* Computing MIN */
	i__1 = *k, i__2 = ki + nb;
	kk = Dymola_min(i__1,i__2);

/*        Set A(1:kk,kk+1:n) to zero. */

	i__1 = *n;
	for (j = kk + 1; j <= i__1; ++j) {
	    i__2 = kk;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		a[i__ + j * a_dim1] = 0.;
/* L10: */
	    }
/* L20: */
	}
    } else {
	kk = 0;
    }

/*     Use unblocked code for the last or only block. */

    if (kk < *n) {
	i__1 = *m - kk;
	i__2 = *n - kk;
	i__3 = *k - kk;
	dorg2r_(&i__1, &i__2, &i__3, &a[kk + 1 + (kk + 1) * a_dim1], lda, (doublereal*) &
		tau[kk + 1], &work[1], &iinfo);
    }

    if (kk > 0) {

/*        Use blocked code */

	i__1 = -nb;
	for (i__ = ki + 1; i__1 < 0 ? i__ >= 1 : i__ <= 1; i__ += i__1) {
/* Computing MIN */
	    i__2 = nb, i__3 = *k - i__ + 1;
	    ib = Dymola_min(i__2,i__3);
	    if (i__ + ib <= *n) {

/*              Form the triangular factor of the block reflector */
/*              H = H(i) H(i+1) . . . H(i+ib-1) */

		i__2 = *m - i__ + 1;
		dlarft_("Forward", "Columnwise", &i__2, &ib, &a[i__ + i__ *a_dim1], lda, (doublereal*) &tau[i__], &work[1], &ldwork);

/*              Apply H to A(i:m,i+ib:n) from the left */

		i__2 = *m - i__ + 1;
		i__3 = *n - i__ - ib + 1;
		dlarfb_("Left", "No transpose", "Forward", "Columnwise", &
			i__2, &i__3, &ib, &a[i__ + i__ * a_dim1], lda, &work[
			1], &ldwork, &a[i__ + (i__ + ib) * a_dim1], lda, &
			work[ib + 1], &ldwork);
	    }

/*           Apply H to rows i:m of current block */

	    i__2 = *m - i__ + 1;
	    dorg2r_(&i__2, &ib, &ib, &a[i__ + i__ * a_dim1], lda, (doublereal*) &tau[i__], &work[1], &iinfo);

/*           Set rows 1:i-1 of current block to zero */

	    i__2 = i__ + ib - 1;
	    for (j = i__; j <= i__2; ++j) {
		i__3 = i__ - 1;
		for (l = 1; l <= i__3; ++l) {
		    a[l + j * a_dim1] = 0.;
/* L30: */
		}
/* L40: */
	    }
/* L50: */
	}
    }

    work[1] = (doublereal) iws;
    return 0;

/*     End of DORGQR */

} /* dorgqr_ */

/* Subroutine */ static int dlaln2_(logical* ltrans, integer* na, integer* nw, doublereal* smin, doublereal* ca, doublereal* a, integer* lda, doublereal* d1, doublereal* d2, doublereal* b, integer* ldb, doublereal* wr, doublereal* wi, doublereal* x, integer* ldx, doublereal* scale, doublereal* xnorm, integer* info)
{
    /* Initialized data */

    static logical zswap[4] = { FALSE_,FALSE_,TRUE_,TRUE_ };
    static logical rswap[4] = { FALSE_,TRUE_,FALSE_,TRUE_ };
    static integer ipivot[16]	/* was [4][4] */ = { 1,2,3,4,2,1,4,3,3,4,1,2,
	    4,3,2,1 };

    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, x_dim1, x_offset;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6;
    static doublereal equiv_0[4], equiv_1[4];

    /* Local variables */
    integer j;
#define ci (equiv_0)
#define cr (equiv_1)
    doublereal bi1, bi2, br1, br2, xi1, xi2, xr1, xr2, ci21, ci22, cr21, cr22,
	     li21, csi, ui11, lr21, ui12, ui22;
#define civ (equiv_0)
    doublereal csr, ur11, ur12, ur22;
#define crv (equiv_1)
    doublereal bbnd, cmax, ui11r, ui12s, temp, ur11r, ur12s, u22abs;
    integer icmax;
    doublereal bnorm, cnorm, smini;
    doublereal bignum, smlnum;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/* ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Equivalences .. */
/*     .. */
/*     .. Data statements .. */
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    x_dim1 = *ldx;
    x_offset = 1 + x_dim1;
    x -= x_offset;

    /* Function Body */
/*     .. */
/*     .. Executable Statements .. */

/*     Compute BIGNUM */

    smlnum = 2. * dlamch_("Safe minimum");
    bignum = 1. / smlnum;
    smini = Dymola_max(*smin,smlnum);

/*     Don't check for input errors */

    *info = 0;

/*     Standard Initializations */

    *scale = 1.;

    if (*na == 1) {

/*        1 x 1  (i.e., scalar) system   C X = B */

	if (*nw == 1) {

/*           Real 1x1 system. */

/*           C = ca A - w D */

	    csr = *ca * a[a_dim1 + 1] - *wr * *d1;
	    cnorm = Dymola_abs(csr);

/*           If | C | < SMINI, use C = SMINI */

	    if (cnorm < smini) {
		csr = smini;
		cnorm = smini;
		*info = 1;
	    }

/*           Check scaling for  X = B / C */

	    bnorm = (d__1 = b[b_dim1 + 1], Dymola_abs(d__1));
	    if (cnorm < 1. && bnorm > 1.) {
		if (bnorm > bignum * cnorm) {
		    *scale = 1. / bnorm;
		}
	    }

/*           Compute X */

	    x[x_dim1 + 1] = b[b_dim1 + 1] * *scale / csr;
	    *xnorm = (d__1 = x[x_dim1 + 1], Dymola_abs(d__1));
	} else {

/*           Complex 1x1 system (w is complex) */

/*           C = ca A - w D */

	    csr = *ca * a[a_dim1 + 1] - *wr * *d1;
	    csi = -(*wi) * *d1;
	    cnorm = Dymola_abs(csr) + Dymola_abs(csi);

/*           If | C | < SMINI, use C = SMINI */

	    if (cnorm < smini) {
		csr = smini;
		csi = 0.;
		cnorm = smini;
		*info = 1;
	    }

/*           Check scaling for  X = B / C */

	    bnorm = (d__1 = b[b_dim1 + 1], Dymola_abs(d__1)) + (d__2 = b[(b_dim1 << 
		    1) + 1], Dymola_abs(d__2));
	    if (cnorm < 1. && bnorm > 1.) {
		if (bnorm > bignum * cnorm) {
		    *scale = 1. / bnorm;
		}
	    }

/*           Compute X */

	    d__1 = *scale * b[b_dim1 + 1];
	    d__2 = *scale * b[(b_dim1 << 1) + 1];
	    dladiv_(&d__1, &d__2, &csr, &csi, &x[x_dim1 + 1], &x[(x_dim1 << 1)
		     + 1]);
	    *xnorm = (d__1 = x[x_dim1 + 1], Dymola_abs(d__1)) + (d__2 = x[(x_dim1 << 
		    1) + 1], Dymola_abs(d__2));
	}

    } else {

/*        2x2 System */

/*        Compute the real part of  C = ca A - w D  (or  ca A**T - w D ) */

	cr[0] = *ca * a[a_dim1 + 1] - *wr * *d1;
	cr[3] = *ca * a[(a_dim1 << 1) + 2] - *wr * *d2;
	if (*ltrans) {
	    cr[2] = *ca * a[a_dim1 + 2];
	    cr[1] = *ca * a[(a_dim1 << 1) + 1];
	} else {
	    cr[1] = *ca * a[a_dim1 + 2];
	    cr[2] = *ca * a[(a_dim1 << 1) + 1];
	}

	if (*nw == 1) {

/*           Real 2x2 system  (w is real) */

/*           Find the largest element in C */

	    cmax = 0.;
	    icmax = 0;

	    for (j = 1; j <= 4; ++j) {
		if ((d__1 = crv[j - 1], Dymola_abs(d__1)) > cmax) {
		    cmax = (d__1 = crv[j - 1], Dymola_abs(d__1));
		    icmax = j;
		}
/* L10: */
	    }

/*           If norm(C) < SMINI, use SMINI*identity. */

	    if (cmax < smini) {
/* Computing MAX */
		d__3 = (d__1 = b[b_dim1 + 1], Dymola_abs(d__1)), d__4 = (d__2 = b[
			b_dim1 + 2], Dymola_abs(d__2));
		bnorm = Dymola_max(d__3,d__4);
		if (smini < 1. && bnorm > 1.) {
		    if (bnorm > bignum * smini) {
			*scale = 1. / bnorm;
		    }
		}
		temp = *scale / smini;
		x[x_dim1 + 1] = temp * b[b_dim1 + 1];
		x[x_dim1 + 2] = temp * b[b_dim1 + 2];
		*xnorm = temp * bnorm;
		*info = 1;
		return 0;
	    }

/*           Gaussian elimination with complete pivoting. */

	    ur11 = crv[icmax - 1];
	    cr21 = crv[ipivot[(icmax << 2) - 3] - 1];
	    ur12 = crv[ipivot[(icmax << 2) - 2] - 1];
	    cr22 = crv[ipivot[(icmax << 2) - 1] - 1];
	    ur11r = 1. / ur11;
	    lr21 = ur11r * cr21;
	    ur22 = cr22 - ur12 * lr21;

/*           If smaller pivot < SMINI, use SMINI */

	    if (Dymola_abs(ur22) < smini) {
		ur22 = smini;
		*info = 1;
	    }
	    if (rswap[icmax - 1]) {
		br1 = b[b_dim1 + 2];
		br2 = b[b_dim1 + 1];
	    } else {
		br1 = b[b_dim1 + 1];
		br2 = b[b_dim1 + 2];
	    }
	    br2 -= lr21 * br1;
/* Computing MAX */
	    d__2 = (d__1 = br1 * (ur22 * ur11r), Dymola_abs(d__1)), d__3 = Dymola_abs(br2);
	    bbnd = Dymola_max(d__2,d__3);
	    if (bbnd > 1. && Dymola_abs(ur22) < 1.) {
		if (bbnd >= bignum * Dymola_abs(ur22)) {
		    *scale = 1. / bbnd;
		}
	    }

	    xr2 = br2 * *scale / ur22;
	    xr1 = *scale * br1 * ur11r - xr2 * (ur11r * ur12);
	    if (zswap[icmax - 1]) {
		x[x_dim1 + 1] = xr2;
		x[x_dim1 + 2] = xr1;
	    } else {
		x[x_dim1 + 1] = xr1;
		x[x_dim1 + 2] = xr2;
	    }
/* Computing MAX */
	    d__1 = Dymola_abs(xr1), d__2 = Dymola_abs(xr2);
	    *xnorm = Dymola_max(d__1,d__2);

/*           Further scaling if  norm(A) norm(X) > overflow */

	    if (*xnorm > 1. && cmax > 1.) {
		if (*xnorm > bignum / cmax) {
		    temp = cmax / bignum;
		    x[x_dim1 + 1] = temp * x[x_dim1 + 1];
		    x[x_dim1 + 2] = temp * x[x_dim1 + 2];
		    *xnorm = temp * *xnorm;
		    *scale = temp * *scale;
		}
	    }
	} else {

/*           Complex 2x2 system  (w is complex) */

/*           Find the largest element in C */

	    ci[0] = -(*wi) * *d1;
	    ci[1] = 0.;
	    ci[2] = 0.;
	    ci[3] = -(*wi) * *d2;
	    cmax = 0.;
	    icmax = 0;

	    for (j = 1; j <= 4; ++j) {
		if ((d__1 = crv[j - 1], Dymola_abs(d__1)) + (d__2 = civ[j - 1], Dymola_abs(
			d__2)) > cmax) {
		    cmax = (d__1 = crv[j - 1], Dymola_abs(d__1)) + (d__2 = civ[j - 1]
			    , Dymola_abs(d__2));
		    icmax = j;
		}
/* L20: */
	    }

/*           If norm(C) < SMINI, use SMINI*identity. */

	    if (cmax < smini) {
/* Computing MAX */
		d__5 = (d__1 = b[b_dim1 + 1], Dymola_abs(d__1)) + (d__2 = b[(b_dim1 
			<< 1) + 1], Dymola_abs(d__2)), d__6 = (d__3 = b[b_dim1 + 2], 
			Dymola_abs(d__3)) + (d__4 = b[(b_dim1 << 1) + 2], Dymola_abs(d__4));
		bnorm = Dymola_max(d__5,d__6);
		if (smini < 1. && bnorm > 1.) {
		    if (bnorm > bignum * smini) {
			*scale = 1. / bnorm;
		    }
		}
		temp = *scale / smini;
		x[x_dim1 + 1] = temp * b[b_dim1 + 1];
		x[x_dim1 + 2] = temp * b[b_dim1 + 2];
		x[(x_dim1 << 1) + 1] = temp * b[(b_dim1 << 1) + 1];
		x[(x_dim1 << 1) + 2] = temp * b[(b_dim1 << 1) + 2];
		*xnorm = temp * bnorm;
		*info = 1;
		return 0;
	    }

/*           Gaussian elimination with complete pivoting. */

	    ur11 = crv[icmax - 1];
	    ui11 = civ[icmax - 1];
	    cr21 = crv[ipivot[(icmax << 2) - 3] - 1];
	    ci21 = civ[ipivot[(icmax << 2) - 3] - 1];
	    ur12 = crv[ipivot[(icmax << 2) - 2] - 1];
	    ui12 = civ[ipivot[(icmax << 2) - 2] - 1];
	    cr22 = crv[ipivot[(icmax << 2) - 1] - 1];
	    ci22 = civ[ipivot[(icmax << 2) - 1] - 1];
	    if (icmax == 1 || icmax == 4) {

/*              Code when off-diagonals of pivoted C are real */

		if (Dymola_abs(ur11) > Dymola_abs(ui11)) {
		    temp = ui11 / ur11;
/* Computing 2nd power */
		    d__1 = temp;
		    ur11r = 1. / (ur11 * (d__1 * d__1 + 1.));
		    ui11r = -temp * ur11r;
		} else {
		    temp = ur11 / ui11;
/* Computing 2nd power */
		    d__1 = temp;
		    ui11r = -1. / (ui11 * (d__1 * d__1 + 1.));
		    ur11r = -temp * ui11r;
		}
		lr21 = cr21 * ur11r;
		li21 = cr21 * ui11r;
		ur12s = ur12 * ur11r;
		ui12s = ur12 * ui11r;
		ur22 = cr22 - ur12 * lr21;
		ui22 = ci22 - ur12 * li21;
	    } else {

/*              Code when diagonals of pivoted C are real */

		ur11r = 1. / ur11;
		ui11r = 0.;
		lr21 = cr21 * ur11r;
		li21 = ci21 * ur11r;
		ur12s = ur12 * ur11r;
		ui12s = ui12 * ur11r;
		ur22 = cr22 - ur12 * lr21 + ui12 * li21;
		ui22 = -ur12 * li21 - ui12 * lr21;
	    }
	    u22abs = Dymola_abs(ur22) + Dymola_abs(ui22);

/*           If smaller pivot < SMINI, use SMINI */

	    if (u22abs < smini) {
		ur22 = smini;
		ui22 = 0.;
		*info = 1;
	    }
	    if (rswap[icmax - 1]) {
		br2 = b[b_dim1 + 1];
		br1 = b[b_dim1 + 2];
		bi2 = b[(b_dim1 << 1) + 1];
		bi1 = b[(b_dim1 << 1) + 2];
	    } else {
		br1 = b[b_dim1 + 1];
		br2 = b[b_dim1 + 2];
		bi1 = b[(b_dim1 << 1) + 1];
		bi2 = b[(b_dim1 << 1) + 2];
	    }
	    br2 = br2 - lr21 * br1 + li21 * bi1;
	    bi2 = bi2 - li21 * br1 - lr21 * bi1;
/* Computing MAX */
	    d__1 = (Dymola_abs(br1) + Dymola_abs(bi1)) * (u22abs * (Dymola_abs(ur11r) + Dymola_abs(ui11r))
		    ), d__2 = Dymola_abs(br2) + Dymola_abs(bi2);
	    bbnd = Dymola_max(d__1,d__2);
	    if (bbnd > 1. && u22abs < 1.) {
		if (bbnd >= bignum * u22abs) {
		    *scale = 1. / bbnd;
		    br1 = *scale * br1;
		    bi1 = *scale * bi1;
		    br2 = *scale * br2;
		    bi2 = *scale * bi2;
		}
	    }

	    dladiv_(&br2, &bi2, &ur22, &ui22, &xr2, &xi2);
	    xr1 = ur11r * br1 - ui11r * bi1 - ur12s * xr2 + ui12s * xi2;
	    xi1 = ui11r * br1 + ur11r * bi1 - ui12s * xr2 - ur12s * xi2;
	    if (zswap[icmax - 1]) {
		x[x_dim1 + 1] = xr2;
		x[x_dim1 + 2] = xr1;
		x[(x_dim1 << 1) + 1] = xi2;
		x[(x_dim1 << 1) + 2] = xi1;
	    } else {
		x[x_dim1 + 1] = xr1;
		x[x_dim1 + 2] = xr2;
		x[(x_dim1 << 1) + 1] = xi1;
		x[(x_dim1 << 1) + 2] = xi2;
	    }
/* Computing MAX */
	    d__1 = Dymola_abs(xr1) + Dymola_abs(xi1), d__2 = Dymola_abs(xr2) + Dymola_abs(xi2);
	    *xnorm = Dymola_max(d__1,d__2);

/*           Further scaling if  norm(A) norm(X) > overflow */

	    if (*xnorm > 1. && cmax > 1.) {
		if (*xnorm > bignum / cmax) {
		    temp = cmax / bignum;
		    x[x_dim1 + 1] = temp * x[x_dim1 + 1];
		    x[x_dim1 + 2] = temp * x[x_dim1 + 2];
		    x[(x_dim1 << 1) + 1] = temp * x[(x_dim1 << 1) + 1];
		    x[(x_dim1 << 1) + 2] = temp * x[(x_dim1 << 1) + 2];
		    *xnorm = temp * *xnorm;
		    *scale = temp * *scale;
		}
	    }
	}
    }

    return 0;

/*     End of DLALN2 */

} /* dlaln2_ */

#undef crv
#undef civ
#undef cr
#undef ci

/* Subroutine */ static int dlaqr3_(logical* wantt, logical* wantz, integer* n, integer* ktop, integer* kbot, integer* nw, doublereal* h__, integer* ldh, integer* iloz, integer* ihiz, doublereal* z__, integer* ldz, integer* ns, integer* nd, doublereal* sr, doublereal* si, doublereal* v, integer* ldv, integer* nh, doublereal* t, integer* ldt, integer* nv, doublereal* wv, integer* ldwv, doublereal* work, integer* lwork)
{
    /* System generated locals */
    integer h_dim1, h_offset, t_dim1, t_offset, v_dim1, v_offset, wv_dim1, 
	    wv_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6;

    /* Local variables */
    integer i__, j, k;
    doublereal s, aa, bb, cc, dd, cs, sn;
    integer jw;
    doublereal evi, evk, foo;
    integer kln;
    doublereal tau, ulp;
    integer lwk1, lwk2, lwk3;
    doublereal beta;
    integer kend, kcol, info, nmin, ifst, ilst, ltop, krow;
    logical bulge;
    integer infqr, kwtop;
    doublereal safmin;
    doublereal safmax;
    logical sorted;
    doublereal smlnum;
    integer lwkopt;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ================================================================ */
/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     ==== Estimate optimal workspace. ==== */

    /* Parameter adjustments */
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --sr;
    --si;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    wv_dim1 = *ldwv;
    wv_offset = 1 + wv_dim1;
    wv -= wv_offset;
    --work;

    /* Function Body */
/* Computing MIN */
    i__1 = *nw, i__2 = *kbot - *ktop + 1;
    jw = Dymola_min(i__1,i__2);
    if (jw <= 2) {
	lwkopt = 1;
    } else {

/*        ==== Workspace query call to DGEHRD ==== */

	i__1 = jw - 1;
	dgehrd_(&jw, &c__1, &i__1, &t[t_offset], ldt, &work[1], &work[1], &
		c_n1, &info);
	lwk1 = (integer) work[1];

/*        ==== Workspace query call to DORMHR ==== */

	i__1 = jw - 1;
	dormhr_("R", "N", &jw, &jw, &c__1, &i__1, &t[t_offset], ldt, &work[1],
		 &v[v_offset], ldv, &work[1], &c_n1, &info);
	lwk2 = (integer) work[1];

/*        ==== Workspace query call to DLAQR4 ==== */

	dlaqr4_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sr[1], 
		&si[1], &c__1, &jw, &v[v_offset], ldv, &work[1], &c_n1, &
		infqr);
	lwk3 = (integer) work[1];

/*        ==== Optimal workspace ==== */

/* Computing MAX */
	i__1 = jw + Dymola_max(lwk1,lwk2);
	lwkopt = Dymola_max(i__1,lwk3);
    }

/*     ==== Quick return in case of workspace query. ==== */

    if (*lwork == -1) {
	work[1] = (doublereal) lwkopt;
	return 0;
    }

/*     ==== Nothing to do ... */
/*     ... for an empty active block ... ==== */
    *ns = 0;
    *nd = 0;
    work[1] = 1.;
    if (*ktop > *kbot) {
	return 0;
    }
/*     ... nor for an empty deflation window. ==== */
    if (*nw < 1) {
	return 0;
    }

/*     ==== Machine constants ==== */

    safmin = dlamch_("SAFE MINIMUM");
    safmax = 1. / safmin;
    dlabad_(&safmin, &safmax);
    ulp = dlamch_("PRECISION");
    smlnum = safmin * ((doublereal) (*n) / ulp);

/*     ==== Setup deflation window ==== */

/* Computing MIN */
    i__1 = *nw, i__2 = *kbot - *ktop + 1;
    jw = Dymola_min(i__1,i__2);
    kwtop = *kbot - jw + 1;
    if (kwtop == *ktop) {
	s = 0.;
    } else {
	s = h__[kwtop + (kwtop - 1) * h_dim1];
    }

    if (*kbot == kwtop) {

/*        ==== 1-by-1 deflation window: not much to do ==== */

	sr[kwtop] = h__[kwtop + kwtop * h_dim1];
	si[kwtop] = 0.;
	*ns = 1;
	*nd = 0;
/* Computing MAX */
	d__2 = smlnum, d__3 = ulp * (d__1 = h__[kwtop + kwtop * h_dim1], Dymola_abs(
		d__1));
	if (Dymola_abs(s) <= Dymola_max(d__2,d__3)) {
	    *ns = 0;
	    *nd = 1;
	    if (kwtop > *ktop) {
		h__[kwtop + (kwtop - 1) * h_dim1] = 0.;
	    }
	}
	work[1] = 1.;
	return 0;
    }

/*     ==== Convert to spike-triangular form.  (In case of a */
/*     .    rare QR failure, this routine continues to do */
/*     .    aggressive early deflation using that part of */
/*     .    the deflation window that converged using INFQR */
/*     .    here and there to keep track.) ==== */

    dlacpy_("U", &jw, &jw, &h__[kwtop + kwtop * h_dim1], ldh, &t[t_offset], 
	    ldt);
    i__1 = jw - 1;
    i__2 = *ldh + 1;
    i__3 = *ldt + 1;
    dcopy_(&i__1, &h__[kwtop + 1 + kwtop * h_dim1], &i__2, &t[t_dim1 + 2], &
	    i__3);

    dlaset_("A", &jw, &jw, &c_b17, &c_b18_dlaqr3, &v[v_offset], ldv);
    nmin = ilaenv_(&c__12, "DLAQR3", "SV", &jw, &c__1, &jw, lwork);
    if (jw > nmin) {
	dlaqr4_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sr[
		kwtop], &si[kwtop], &c__1, &jw, &v[v_offset], ldv, &work[1], 
		lwork, &infqr);
    } else {
	dlahqr_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sr[
		kwtop], &si[kwtop], &c__1, &jw, &v[v_offset], ldv, &infqr);
    }

/*     ==== DTREXC needs a clean margin near the diagonal ==== */

    i__1 = jw - 3;
    for (j = 1; j <= i__1; ++j) {
	t[j + 2 + j * t_dim1] = 0.;
	t[j + 3 + j * t_dim1] = 0.;
/* L10: */
    }
    if (jw > 2) {
	t[jw + (jw - 2) * t_dim1] = 0.;
    }

/*     ==== Deflation detection loop ==== */

    *ns = jw;
    ilst = infqr + 1;
L20:
    if (ilst <= *ns) {
	if (*ns == 1) {
	    bulge = FALSE_;
	} else {
	    bulge = t[*ns + (*ns - 1) * t_dim1] != 0.;
	}

/*        ==== Small spike tip test for deflation ==== */

	if (! bulge) {

/*           ==== Real eigenvalue ==== */

	    foo = (d__1 = t[*ns + *ns * t_dim1], Dymola_abs(d__1));
	    if (foo == 0.) {
		foo = Dymola_abs(s);
	    }
/* Computing MAX */
	    d__2 = smlnum, d__3 = ulp * foo;
	    if ((d__1 = s * v[*ns * v_dim1 + 1], Dymola_abs(d__1)) <= Dymola_max(d__2,d__3))
		     {

/*              ==== Deflatable ==== */

		--(*ns);
	    } else {

/*              ==== Undeflatable.   Move it up out of the way. */
/*              .    (DTREXC can not fail in this case.) ==== */

		ifst = *ns;
		dtrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
			 &ilst, &work[1], &info);
		++ilst;
	    }
	} else {

/*           ==== Complex conjugate pair ==== */

	    foo = (d__3 = t[*ns + *ns * t_dim1], Dymola_abs(d__3)) + sqrt((d__1 = t[*
		    ns + (*ns - 1) * t_dim1], Dymola_abs(d__1))) * sqrt((d__2 = t[*
		    ns - 1 + *ns * t_dim1], Dymola_abs(d__2)));
	    if (foo == 0.) {
		foo = Dymola_abs(s);
	    }
/* Computing MAX */
	    d__3 = (d__1 = s * v[*ns * v_dim1 + 1], Dymola_abs(d__1)), d__4 = (d__2 =
		     s * v[(*ns - 1) * v_dim1 + 1], Dymola_abs(d__2));
/* Computing MAX */
	    d__5 = smlnum, d__6 = ulp * foo;
	    if (Dymola_max(d__3,d__4) <= Dymola_max(d__5,d__6)) {

/*              ==== Deflatable ==== */

		*ns += -2;
	    } else {

/*              ==== Undeflatable. Move them up out of the way. */
/*              .    Fortunately, DTREXC does the right thing with */
/*              .    ILST in case of a rare exchange failure. ==== */

		ifst = *ns;
		dtrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
			 &ilst, &work[1], &info);
		ilst += 2;
	    }
	}

/*        ==== End deflation detection loop ==== */

	goto L20;
    }

/*        ==== Return to Hessenberg form ==== */

    if (*ns == 0) {
	s = 0.;
    }

    if (*ns < jw) {

/*        ==== sorting diagonal blocks of T improves accuracy for */
/*        .    graded matrices.  Bubble sort deals well with */
/*        .    exchange failures. ==== */

	sorted = FALSE_;
	i__ = *ns + 1;
L30:
	if (sorted) {
	    goto L50;
	}
	sorted = TRUE_;

	kend = i__ - 1;
	i__ = infqr + 1;
	if (i__ == *ns) {
	    k = i__ + 1;
	} else if (t[i__ + 1 + i__ * t_dim1] == 0.) {
	    k = i__ + 1;
	} else {
	    k = i__ + 2;
	}
L40:
	if (k <= kend) {
	    if (k == i__ + 1) {
		evi = (d__1 = t[i__ + i__ * t_dim1], Dymola_abs(d__1));
	    } else {
		evi = (d__3 = t[i__ + i__ * t_dim1], Dymola_abs(d__3)) + sqrt((d__1 =
			 t[i__ + 1 + i__ * t_dim1], Dymola_abs(d__1))) * sqrt((d__2 =
			 t[i__ + (i__ + 1) * t_dim1], Dymola_abs(d__2)));
	    }

	    if (k == kend) {
		evk = (d__1 = t[k + k * t_dim1], Dymola_abs(d__1));
	    } else if (t[k + 1 + k * t_dim1] == 0.) {
		evk = (d__1 = t[k + k * t_dim1], Dymola_abs(d__1));
	    } else {
		evk = (d__3 = t[k + k * t_dim1], Dymola_abs(d__3)) + sqrt((d__1 = t[
			k + 1 + k * t_dim1], Dymola_abs(d__1))) * sqrt((d__2 = t[k + 
			(k + 1) * t_dim1], Dymola_abs(d__2)));
	    }

	    if (evi >= evk) {
		i__ = k;
	    } else {
		sorted = FALSE_;
		ifst = i__;
		ilst = k;
		dtrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
			 &ilst, &work[1], &info);
		if (info == 0) {
		    i__ = ilst;
		} else {
		    i__ = k;
		}
	    }
	    if (i__ == kend) {
		k = i__ + 1;
	    } else if (t[i__ + 1 + i__ * t_dim1] == 0.) {
		k = i__ + 1;
	    } else {
		k = i__ + 2;
	    }
	    goto L40;
	}
	goto L30;
L50:
	;
    }

/*     ==== Restore shift/eigenvalue array from T ==== */

    i__ = jw;
L60:
    if (i__ >= infqr + 1) {
	if (i__ == infqr + 1) {
	    sr[kwtop + i__ - 1] = t[i__ + i__ * t_dim1];
	    si[kwtop + i__ - 1] = 0.;
	    --i__;
	} else if (t[i__ + (i__ - 1) * t_dim1] == 0.) {
	    sr[kwtop + i__ - 1] = t[i__ + i__ * t_dim1];
	    si[kwtop + i__ - 1] = 0.;
	    --i__;
	} else {
	    aa = t[i__ - 1 + (i__ - 1) * t_dim1];
	    cc = t[i__ + (i__ - 1) * t_dim1];
	    bb = t[i__ - 1 + i__ * t_dim1];
	    dd = t[i__ + i__ * t_dim1];
	    dlanv2_(&aa, &bb, &cc, &dd, &sr[kwtop + i__ - 2], &si[kwtop + i__ 
		    - 2], &sr[kwtop + i__ - 1], &si[kwtop + i__ - 1], &cs, &
		    sn);
	    i__ += -2;
	}
	goto L60;
    }

    if (*ns < jw || s == 0.) {
	if (*ns > 1 && s != 0.) {

/*           ==== Reflect spike back into lower triangle ==== */

	    dcopy_(ns, &v[v_offset], ldv, &work[1], &c__1);
	    beta = work[1];
	    dlarfg_(ns, &beta, &work[2], &c__1, &tau);
	    work[1] = 1.;

	    i__1 = jw - 2;
	    i__2 = jw - 2;
	    dlaset_("L", &i__1, &i__2, &c_b17, &c_b17, &t[t_dim1 + 3], ldt);

	    dlarf_("L", ns, &jw, &work[1], &c__1, &tau, &t[t_offset], ldt, &
		    work[jw + 1]);
	    dlarf_("R", ns, ns, &work[1], &c__1, &tau, &t[t_offset], ldt, &
		    work[jw + 1]);
	    dlarf_("R", &jw, ns, &work[1], &c__1, &tau, &v[v_offset], ldv, &
		    work[jw + 1]);

	    i__1 = *lwork - jw;
	    dgehrd_(&jw, &c__1, ns, &t[t_offset], ldt, &work[1], &work[jw + 1]
		    , &i__1, &info);
	}

/*        ==== Copy updated reduced window into place ==== */

	if (kwtop > 1) {
	    h__[kwtop + (kwtop - 1) * h_dim1] = s * v[v_dim1 + 1];
	}
	dlacpy_("U", &jw, &jw, &t[t_offset], ldt, &h__[kwtop + kwtop * h_dim1]
		, ldh);
	i__1 = jw - 1;
	i__2 = *ldt + 1;
	i__3 = *ldh + 1;
	dcopy_(&i__1, &t[t_dim1 + 2], &i__2, &h__[kwtop + 1 + kwtop * h_dim1],
		 &i__3);

/*        ==== Accumulate orthogonal matrix in order update */
/*        .    H and Z, if requested.  ==== */

	if (*ns > 1 && s != 0.) {
	    i__1 = *lwork - jw;
	    dormhr_("R", "N", &jw, ns, &c__1, ns, &t[t_offset], ldt, &work[1],
		     &v[v_offset], ldv, &work[jw + 1], &i__1, &info);
	}

/*        ==== Update vertical slab in H ==== */

	if (*wantt) {
	    ltop = 1;
	} else {
	    ltop = *ktop;
	}
	i__1 = kwtop - 1;
	i__2 = *nv;
	for (krow = ltop; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow += 
		i__2) {
/* Computing MIN */
	    i__3 = *nv, i__4 = kwtop - krow;
	    kln = Dymola_min(i__3,i__4);
	    dgemm_("N", "N", &kln, &jw, &jw, &c_b18_dlaqr3, &h__[krow + kwtop * 
		    h_dim1], ldh, &v[v_offset], ldv, &c_b17, &wv[wv_offset], 
		    ldwv);
	    dlacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &h__[krow + kwtop * 
		    h_dim1], ldh);
/* L70: */
	}

/*        ==== Update horizontal slab in H ==== */

	if (*wantt) {
	    i__2 = *n;
	    i__1 = *nh;
	    for (kcol = *kbot + 1; i__1 < 0 ? kcol >= i__2 : kcol <= i__2; 
		    kcol += i__1) {
/* Computing MIN */
		i__3 = *nh, i__4 = *n - kcol + 1;
		kln = Dymola_min(i__3,i__4);
		dgemm_("C", "N", &jw, &kln, &jw, &c_b18_dlaqr3, &v[v_offset], ldv, &
			h__[kwtop + kcol * h_dim1], ldh, &c_b17, &t[t_offset],
			 ldt);
		dlacpy_("A", &jw, &kln, &t[t_offset], ldt, &h__[kwtop + kcol *
			 h_dim1], ldh);
/* L80: */
	    }
	}

/*        ==== Update vertical slab in Z ==== */

	if (*wantz) {
	    i__1 = *ihiz;
	    i__2 = *nv;
	    for (krow = *iloz; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
		     i__2) {
/* Computing MIN */
		i__3 = *nv, i__4 = *ihiz - krow + 1;
		kln = Dymola_min(i__3,i__4);
		dgemm_("N", "N", &kln, &jw, &jw, &c_b18_dlaqr3, &z__[krow + kwtop * 
			z_dim1], ldz, &v[v_offset], ldv, &c_b17, &wv[
			wv_offset], ldwv);
		dlacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &z__[krow + 
			kwtop * z_dim1], ldz);
/* L90: */
	    }
	}
    }

/*     ==== Return the number of deflations ... ==== */

    *nd = jw - *ns;

/*     ==== ... and the number of shifts. (Subtracting */
/*     .    INFQR from the spike length takes care */
/*     .    of the case of a rare QR failure while */
/*     .    calculating eigenvalues of the deflation */
/*     .    window.)  ==== */

    *ns -= infqr;

/*      ==== Return optimal workspace. ==== */

    work[1] = (doublereal) lwkopt;

/*     ==== End of DLAQR3 ==== */

    return 0;
} /* dlaqr3_ */

/* Subroutine */ static int dlaqr4_(logical* wantt, logical* wantz, integer* n, integer* ilo, integer* ihi, doublereal* h__, integer* ldh, doublereal* wr, doublereal* wi, integer* iloz, integer* ihiz, doublereal* z__, integer* ldz, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    integer h_dim1, h_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4, i__5;
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    integer i__, k;
    doublereal aa, bb, cc, dd;
    integer ld;
    doublereal cs;
    integer nh, it, ks, kt;
    doublereal sn;
    integer ku, kv, ls, ns;
    doublereal ss;
    integer nw, inf, kdu, nho, nve, kwh, nsr, nwr, kwv, ndec, ndfl, kbot, 
	    nmin;
    doublereal swap;
    integer ktop;
    doublereal zdum[1]	/* was [1][1] */;
    integer kacc22, itmax, nsmax, nwmax, kwtop;
    integer nibble;
    char jbcmpz[2];
    integer nwupbd;
    logical sorted;
    integer lwkopt;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ================================================================ */
/*     .. Parameters .. */

/*     ==== Matrices of order NTINY or smaller must be processed by */
/*     .    DLAHQR because of insufficient subdiagonal scratch space. */
/*     .    (This is a hard limit.) ==== */

/*     ==== Exceptional deflation windows:  try to cure rare */
/*     .    slow convergence by varying the size of the */
/*     .    deflation window after KEXNW iterations. ==== */

/*     ==== Exceptional shifts: try to cure rare slow convergence */
/*     .    with ad-hoc exceptional shifts every KEXSH iterations. */
/*     .    ==== */

/*     ==== The constants WILK1 and WILK2 are used to form the */
/*     .    exceptional shifts. ==== */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */
    /* Parameter adjustments */
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    --wr;
    --wi;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --work;

    /* Function Body */
    *info = 0;

/*     ==== Quick return for N = 0: nothing to do. ==== */

    if (*n == 0) {
	work[1] = 1.;
	return 0;
    }

    if (*n <= 11) {

/*        ==== Tiny matrices must use DLAHQR. ==== */

	lwkopt = 1;
	if (*lwork != -1) {
	    dlahqr_(wantt, wantz, n, ilo, ihi, &h__[h_offset], ldh, &wr[1], &
		    wi[1], iloz, ihiz, &z__[z_offset], ldz, info);
	}
    } else {

/*        ==== Use small bulge multi-shift QR with aggressive early */
/*        .    deflation on larger-than-tiny matrices. ==== */

/*        ==== Hope for the best. ==== */

	*info = 0;

/*        ==== Set up job flags for ILAENV. ==== */

	if (*wantt) {
	    *(unsigned char *)jbcmpz = 'S';
	} else {
	    *(unsigned char *)jbcmpz = 'E';
	}
	if (*wantz) {
	    *(unsigned char *)&jbcmpz[1] = 'V';
	} else {
	    *(unsigned char *)&jbcmpz[1] = 'N';
	}

/*        ==== NWR = recommended deflation window size.  At this */
/*        .    point,  N .GT. NTINY = 11, so there is enough */
/*        .    subdiagonal workspace for NWR.GE.2 as required. */
/*        .    (In fact, there is enough subdiagonal space for */
/*        .    NWR.GE.3.) ==== */

	nwr = ilaenv_(&c__13, "DLAQR4", jbcmpz, n, ilo, ihi, lwork);
	nwr = Dymola_max(2,nwr);
/* Computing MIN */
	i__1 = *ihi - *ilo + 1, i__2 = (*n - 1) / 3, i__1 = Dymola_min(i__1,i__2);
	nwr = Dymola_min(i__1,nwr);

/*        ==== NSR = recommended number of simultaneous shifts. */
/*        .    At this point N .GT. NTINY = 11, so there is at */
/*        .    enough subdiagonal workspace for NSR to be even */
/*        .    and greater than or equal to two as required. ==== */

	nsr = ilaenv_(&c__15, "DLAQR4", jbcmpz, n, ilo, ihi, lwork);
/* Computing MIN */
	i__1 = nsr, i__2 = (*n + 6) / 9, i__1 = Dymola_min(i__1,i__2), i__2 = *ihi - 
		*ilo;
	nsr = Dymola_min(i__1,i__2);
/* Computing MAX */
	i__1 = 2, i__2 = nsr - nsr % 2;
	nsr = Dymola_max(i__1,i__2);

/*        ==== Estimate optimal workspace ==== */

/*        ==== Workspace query call to DLAQR2 ==== */

	i__1 = nwr + 1;
	dlaqr2_(wantt, wantz, n, ilo, ihi, &i__1, &h__[h_offset], ldh, iloz, 
		ihiz, &z__[z_offset], ldz, &ls, &ld, &wr[1], &wi[1], &h__[
		h_offset], ldh, n, &h__[h_offset], ldh, n, &h__[h_offset], 
		ldh, &work[1], &c_n1);

/*        ==== Optimal workspace = MAX(DLAQR5, DLAQR2) ==== */

/* Computing MAX */
	i__1 = nsr * 3 / 2, i__2 = (integer) work[1];
	lwkopt = Dymola_max(i__1,i__2);

/*        ==== Quick return in case of workspace query. ==== */

	if (*lwork == -1) {
	    work[1] = (doublereal) lwkopt;
	    return 0;
	}

/*        ==== DLAHQR/DLAQR0 crossover point ==== */

	nmin = ilaenv_(&c__12, "DLAQR4", jbcmpz, n, ilo, ihi, lwork);
	nmin = Dymola_max(11,nmin);

/*        ==== Nibble crossover point ==== */

	nibble = ilaenv_(&c__14, "DLAQR4", jbcmpz, n, ilo, ihi, lwork);
	nibble = Dymola_max(0,nibble);

/*        ==== Accumulate reflections during ttswp?  Use block */
/*        .    2-by-2 structure during matrix-matrix multiply? ==== */

	kacc22 = ilaenv_(&c__16, "DLAQR4", jbcmpz, n, ilo, ihi, lwork);
	kacc22 = Dymola_max(0,kacc22);
	kacc22 = Dymola_min(2,kacc22);

/*        ==== NWMAX = the largest possible deflation window for */
/*        .    which there is sufficient workspace. ==== */

/* Computing MIN */
	i__1 = (*n - 1) / 3, i__2 = *lwork / 2;
	nwmax = Dymola_min(i__1,i__2);
	nw = nwmax;

/*        ==== NSMAX = the Largest number of simultaneous shifts */
/*        .    for which there is sufficient workspace. ==== */

/* Computing MIN */
	i__1 = (*n + 6) / 9, i__2 = (*lwork << 1) / 3;
	nsmax = Dymola_min(i__1,i__2);
	nsmax -= nsmax % 2;

/*        ==== NDFL: an iteration count restarted at deflation. ==== */

	ndfl = 1;

/*        ==== ITMAX = iteration limit ==== */

/* Computing MAX */
	i__1 = 10, i__2 = *ihi - *ilo + 1;
	itmax = Dymola_max(i__1,i__2) * 30;

/*        ==== Last row and column in the active block ==== */

	kbot = *ihi;

/*        ==== Main Loop ==== */

	i__1 = itmax;
	for (it = 1; it <= i__1; ++it) {

/*           ==== Done when KBOT falls below ILO ==== */

	    if (kbot < *ilo) {
		goto L90;
	    }

/*           ==== Locate active block ==== */

	    i__2 = *ilo + 1;
	    for (k = kbot; k >= i__2; --k) {
		if (h__[k + (k - 1) * h_dim1] == 0.) {
		    goto L20;
		}
/* L10: */
	    }
	    k = *ilo;
L20:
	    ktop = k;

/*           ==== Select deflation window size: */
/*           .    Typical Case: */
/*           .      If possible and advisable, nibble the entire */
/*           .      active block.  If not, use size MIN(NWR,NWMAX) */
/*           .      or MIN(NWR+1,NWMAX) depending upon which has */
/*           .      the smaller corresponding subdiagonal entry */
/*           .      (a heuristic). */
/*           . */
/*           .    Exceptional Case: */
/*           .      If there have been no deflations in KEXNW or */
/*           .      more iterations, then vary the deflation window */
/*           .      size.   At first, because, larger windows are, */
/*           .      in general, more powerful than smaller ones, */
/*           .      rapidly increase the window to the maximum possible. */
/*           .      Then, gradually reduce the window size. ==== */

	    nh = kbot - ktop + 1;
	    nwupbd = Dymola_min(nh,nwmax);
	    if (ndfl < 5) {
		nw = Dymola_min(nwupbd,nwr);
	    } else {
/* Computing MIN */
		i__2 = nwupbd, i__3 = nw << 1;
		nw = Dymola_min(i__2,i__3);
	    }
	    if (nw < nwmax) {
		if (nw >= nh - 1) {
		    nw = nh;
		} else {
		    kwtop = kbot - nw + 1;
		    if ((d__1 = h__[kwtop + (kwtop - 1) * h_dim1], Dymola_abs(d__1)) 
			    > (d__2 = h__[kwtop - 1 + (kwtop - 2) * h_dim1], 
			    Dymola_abs(d__2))) {
			++nw;
		    }
		}
	    }
	    if (ndfl < 5) {
		ndec = -1;
	    } else if (ndec >= 0 || nw >= nwupbd) {
		++ndec;
		if (nw - ndec < 2) {
		    ndec = 0;
		}
		nw -= ndec;
	    }

/*           ==== Aggressive early deflation: */
/*           .    split workspace under the subdiagonal into */
/*           .      - an nw-by-nw work array V in the lower */
/*           .        left-hand-corner, */
/*           .      - an NW-by-at-least-NW-but-more-is-better */
/*           .        (NW-by-NHO) horizontal work array along */
/*           .        the bottom edge, */
/*           .      - an at-least-NW-but-more-is-better (NHV-by-NW) */
/*           .        vertical work array along the left-hand-edge. */
/*           .        ==== */

	    kv = *n - nw + 1;
	    kt = nw + 1;
	    nho = *n - nw - 1 - kt + 1;
	    kwv = nw + 2;
	    nve = *n - nw - kwv + 1;

/*           ==== Aggressive early deflation ==== */

	    dlaqr2_(wantt, wantz, n, &ktop, &kbot, &nw, &h__[h_offset], ldh, 
		    iloz, ihiz, &z__[z_offset], ldz, &ls, &ld, &wr[1], &wi[1],
		     &h__[kv + h_dim1], ldh, &nho, &h__[kv + kt * h_dim1], 
		    ldh, &nve, &h__[kwv + h_dim1], ldh, &work[1], lwork);

/*           ==== Adjust KBOT accounting for new deflations. ==== */

	    kbot -= ld;

/*           ==== KS points to the shifts. ==== */

	    ks = kbot - ls + 1;

/*           ==== Skip an expensive QR sweep if there is a (partly */
/*           .    heuristic) reason to expect that many eigenvalues */
/*           .    will deflate without it.  Here, the QR sweep is */
/*           .    skipped if many eigenvalues have just been deflated */
/*           .    or if the remaining active block is small. */

	    if (ld == 0 || ld * 100 <= nw * nibble && kbot - ktop + 1 > Dymola_min(
		    nmin,nwmax)) {

/*              ==== NS = nominal number of simultaneous shifts. */
/*              .    This may be lowered (slightly) if DLAQR2 */
/*              .    did not provide that many shifts. ==== */

/* Computing MIN */
/* Computing MAX */
		i__4 = 2, i__5 = kbot - ktop;
		i__2 = Dymola_min(nsmax,nsr), i__3 = Dymola_max(i__4,i__5);
		ns = Dymola_min(i__2,i__3);
		ns -= ns % 2;

/*              ==== If there have been no deflations */
/*              .    in a multiple of KEXSH iterations, */
/*              .    then try exceptional shifts. */
/*              .    Otherwise use shifts provided by */
/*              .    DLAQR2 above or from the eigenvalues */
/*              .    of a trailing principal submatrix. ==== */

		if (ndfl % 6 == 0) {
		    ks = kbot - ns + 1;
/* Computing MAX */
		    i__3 = ks + 1, i__4 = ktop + 2;
		    i__2 = Dymola_max(i__3,i__4);
		    for (i__ = kbot; i__ >= i__2; i__ += -2) {
			ss = (d__1 = h__[i__ + (i__ - 1) * h_dim1], Dymola_abs(d__1))
				 + (d__2 = h__[i__ - 1 + (i__ - 2) * h_dim1], 
				Dymola_abs(d__2));
			aa = ss * .75 + h__[i__ + i__ * h_dim1];
			bb = ss;
			cc = ss * -.4375;
			dd = aa;
			dlanv2_(&aa, &bb, &cc, &dd, &wr[i__ - 1], &wi[i__ - 1]
				, &wr[i__], &wi[i__], &cs, &sn);
/* L30: */
		    }
		    if (ks == ktop) {
			wr[ks + 1] = h__[ks + 1 + (ks + 1) * h_dim1];
			wi[ks + 1] = 0.;
			wr[ks] = wr[ks + 1];
			wi[ks] = wi[ks + 1];
		    }
		} else {

/*                 ==== Got NS/2 or fewer shifts? Use DLAHQR */
/*                 .    on a trailing principal submatrix to */
/*                 .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9, */
/*                 .    there is enough space below the subdiagonal */
/*                 .    to fit an NS-by-NS scratch array.) ==== */

		    if (kbot - ks + 1 <= ns / 2) {
			ks = kbot - ns + 1;
			kt = *n - ns + 1;
			dlacpy_("A", &ns, &ns, &h__[ks + ks * h_dim1], ldh, &
				h__[kt + h_dim1], ldh);
			dlahqr_(&c_false, &c_false, &ns, &c__1, &ns, &h__[kt 
				+ h_dim1], ldh, &wr[ks], &wi[ks], &c__1, &
				c__1, zdum, &c__1, &inf);
			ks += inf;

/*                    ==== In case of a rare QR failure use */
/*                    .    eigenvalues of the trailing 2-by-2 */
/*                    .    principal submatrix.  ==== */

			if (ks >= kbot) {
			    aa = h__[kbot - 1 + (kbot - 1) * h_dim1];
			    cc = h__[kbot + (kbot - 1) * h_dim1];
			    bb = h__[kbot - 1 + kbot * h_dim1];
			    dd = h__[kbot + kbot * h_dim1];
			    dlanv2_(&aa, &bb, &cc, &dd, &wr[kbot - 1], &wi[
				    kbot - 1], &wr[kbot], &wi[kbot], &cs, &sn)
				    ;
			    ks = kbot - 1;
			}
		    }

		    if (kbot - ks + 1 > ns) {

/*                    ==== Sort the shifts (Helps a little) */
/*                    .    Bubble sort keeps complex conjugate */
/*                    .    pairs together. ==== */

			sorted = FALSE_;
			i__2 = ks + 1;
			for (k = kbot; k >= i__2; --k) {
			    if (sorted) {
				goto L60;
			    }
			    sorted = TRUE_;
			    i__3 = k - 1;
			    for (i__ = ks; i__ <= i__3; ++i__) {
				if ((d__1 = wr[i__], Dymola_abs(d__1)) + (d__2 = wi[
					i__], Dymola_abs(d__2)) < (d__3 = wr[i__ + 1]
					, Dymola_abs(d__3)) + (d__4 = wi[i__ + 1], 
					Dymola_abs(d__4))) {
				    sorted = FALSE_;

				    swap = wr[i__];
				    wr[i__] = wr[i__ + 1];
				    wr[i__ + 1] = swap;

				    swap = wi[i__];
				    wi[i__] = wi[i__ + 1];
				    wi[i__ + 1] = swap;
				}
/* L40: */
			    }
/* L50: */
			}
L60:
			;
		    }

/*                 ==== Shuffle shifts into pairs of real shifts */
/*                 .    and pairs of complex conjugate shifts */
/*                 .    assuming complex conjugate shifts are */
/*                 .    already adjacent to one another. (Yes, */
/*                 .    they are.)  ==== */

		    i__2 = ks + 2;
		    for (i__ = kbot; i__ >= i__2; i__ += -2) {
			if (wi[i__] != -wi[i__ - 1]) {

			    swap = wr[i__];
			    wr[i__] = wr[i__ - 1];
			    wr[i__ - 1] = wr[i__ - 2];
			    wr[i__ - 2] = swap;

			    swap = wi[i__];
			    wi[i__] = wi[i__ - 1];
			    wi[i__ - 1] = wi[i__ - 2];
			    wi[i__ - 2] = swap;
			}
/* L70: */
		    }
		}

/*              ==== If there are only two shifts and both are */
/*              .    real, then use only one.  ==== */

		if (kbot - ks + 1 == 2) {
		    if (wi[kbot] == 0.) {
			if ((d__1 = wr[kbot] - h__[kbot + kbot * h_dim1], Dymola_abs(
				d__1)) < (d__2 = wr[kbot - 1] - h__[kbot + 
				kbot * h_dim1], Dymola_abs(d__2))) {
			    wr[kbot - 1] = wr[kbot];
			} else {
			    wr[kbot] = wr[kbot - 1];
			}
		    }
		}

/*              ==== Use up to NS of the the smallest magnatiude */
/*              .    shifts.  If there aren't NS shifts available, */
/*              .    then use them all, possibly dropping one to */
/*              .    make the number of shifts even. ==== */

/* Computing MIN */
		i__2 = ns, i__3 = kbot - ks + 1;
		ns = Dymola_min(i__2,i__3);
		ns -= ns % 2;
		ks = kbot - ns + 1;

/*              ==== Small-bulge multi-shift QR sweep: */
/*              .    split workspace under the subdiagonal into */
/*              .    - a KDU-by-KDU work array U in the lower */
/*              .      left-hand-corner, */
/*              .    - a KDU-by-at-least-KDU-but-more-is-better */
/*              .      (KDU-by-NHo) horizontal work array WH along */
/*              .      the bottom edge, */
/*              .    - and an at-least-KDU-but-more-is-better-by-KDU */
/*              .      (NVE-by-KDU) vertical work WV arrow along */
/*              .      the left-hand-edge. ==== */

		kdu = ns * 3 - 3;
		ku = *n - kdu + 1;
		kwh = kdu + 1;
		nho = *n - kdu - 3 - (kdu + 1) + 1;
		kwv = kdu + 4;
		nve = *n - kdu - kwv + 1;

/*              ==== Small-bulge multi-shift QR sweep ==== */

		dlaqr5_(wantt, wantz, &kacc22, n, &ktop, &kbot, &ns, &wr[ks], 
			&wi[ks], &h__[h_offset], ldh, iloz, ihiz, &z__[
			z_offset], ldz, &work[1], &c__3, &h__[ku + h_dim1], 
			ldh, &nve, &h__[kwv + h_dim1], ldh, &nho, &h__[ku + 
			kwh * h_dim1], ldh);
	    }

/*           ==== Note progress (or the lack of it). ==== */

	    if (ld > 0) {
		ndfl = 1;
	    } else {
		++ndfl;
	    }

/*           ==== End of main loop ==== */
/* L80: */
	}

/*        ==== Iteration limit exceeded.  Set INFO to show where */
/*        .    the problem occurred and exit. ==== */

	*info = kbot;
L90:
	;
    }

/*     ==== Return the optimal value of LWORK. ==== */

    work[1] = (doublereal) lwkopt;

/*     ==== End of DLAQR4 ==== */

    return 0;
} /* dlaqr4_ */

/* Subroutine */ static int dlaqr5_(logical *wantt, logical *wantz, integer *kacc22, integer *n, integer *ktop, integer *kbot, integer *nshfts, doublereal *sr, doublereal *si, doublereal *h__, integer *ldh, integer *iloz, integer *ihiz, doublereal *z__, integer *ldz, doublereal *v, integer *ldv, doublereal *u, integer *ldu, integer *nv, doublereal *wv, integer *ldwv, integer *nh, doublereal *wh, integer *ldwh)
{
    /* System generated locals */
    integer h_dim1, h_offset, u_dim1, u_offset, v_dim1, v_offset, wh_dim1, 
	    wh_offset, wv_dim1, wv_offset, z_dim1, z_offset, i__1, i__2, i__3,
	     i__4, i__5, i__6, i__7;
    doublereal d__1, d__2, d__3, d__4, d__5;

    /* Local variables */
    integer i__, j, k, m, i2, j2, i4, j4, k1;
    doublereal h11, h12, h21, h22;
    integer m22, ns, nu;
    doublereal vt[3], scl;
    integer kdu, kms;
    doublereal ulp;
    integer knz, kzs;
    doublereal tst1, tst2, beta;
    logical blk22, bmp22;
    integer mend, jcol, jlen, jbot, mbot;
    doublereal swap;
    integer jtop, jrow, mtop;
    doublereal alpha;
    logical accum;
    integer ndcol, incol, krcol, nbmps;
    doublereal safmin;
    doublereal safmax, refsum;
    integer mstart;
    doublereal smlnum;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ================================================================ */
/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */

/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Executable Statements .. */

/*     ==== If there are no shifts, then there is nothing to do. ==== */

    /* Parameter adjustments */
    --sr;
    --si;
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    u_dim1 = *ldu;
    u_offset = 1 + u_dim1;
    u -= u_offset;
    wv_dim1 = *ldwv;
    wv_offset = 1 + wv_dim1;
    wv -= wv_offset;
    wh_dim1 = *ldwh;
    wh_offset = 1 + wh_dim1;
    wh -= wh_offset;

    /* Function Body */
    if (*nshfts < 2) {
	return 0;
    }

/*     ==== If the active block is empty or 1-by-1, then there */
/*     .    is nothing to do. ==== */

    if (*ktop >= *kbot) {
	return 0;
    }

/*     ==== Shuffle shifts into pairs of real shifts and pairs */
/*     .    of complex conjugate shifts assuming complex */
/*     .    conjugate shifts are already adjacent to one */
/*     .    another. ==== */

    i__1 = *nshfts - 2;
    for (i__ = 1; i__ <= i__1; i__ += 2) {
	if (si[i__] != -si[i__ + 1]) {

	    swap = sr[i__];
	    sr[i__] = sr[i__ + 1];
	    sr[i__ + 1] = sr[i__ + 2];
	    sr[i__ + 2] = swap;

	    swap = si[i__];
	    si[i__] = si[i__ + 1];
	    si[i__ + 1] = si[i__ + 2];
	    si[i__ + 2] = swap;
	}
/* L10: */
    }

/*     ==== NSHFTS is supposed to be even, but if it is odd, */
/*     .    then simply reduce it by one.  The shuffle above */
/*     .    ensures that the dropped shift is real and that */
/*     .    the remaining shifts are paired. ==== */

    ns = *nshfts - *nshfts % 2;

/*     ==== Machine constants for deflation ==== */

    safmin = dlamch_("SAFE MINIMUM");
    safmax = 1. / safmin;
    dlabad_(&safmin, &safmax);
    ulp = dlamch_("PRECISION");
    smlnum = safmin * ((doublereal) (*n) / ulp);

/*     ==== Use accumulated reflections to update far-from-diagonal */
/*     .    entries ? ==== */

    accum = *kacc22 == 1 || *kacc22 == 2;

/*     ==== If so, exploit the 2-by-2 block structure? ==== */

    blk22 = ns > 2 && *kacc22 == 2;

/*     ==== clear trash ==== */

    if (*ktop + 2 <= *kbot) {
	h__[*ktop + 2 + *ktop * h_dim1] = 0.;
    }

/*     ==== NBMPS = number of 2-shift bulges in the chain ==== */

    nbmps = ns / 2;

/*     ==== KDU = width of slab ==== */

    kdu = nbmps * 6 - 3;

/*     ==== Create and chase chains of NBMPS bulges ==== */

    i__1 = *kbot - 2;
    i__2 = nbmps * 3 - 2;
    for (incol = (1 - nbmps) * 3 + *ktop - 1; i__2 < 0 ? incol >= i__1 : 
	    incol <= i__1; incol += i__2) {
	ndcol = incol + kdu;
	if (accum) {
	    dlaset_("ALL", &kdu, &kdu, &c_b7_dlaqr5, &c_b8, &u[u_offset], ldu);
	}

/*        ==== Near-the-diagonal bulge chase.  The following loop */
/*        .    performs the near-the-diagonal part of a small bulge */
/*        .    multi-shift QR sweep.  Each 6*NBMPS-2 column diagonal */
/*        .    chunk extends from column INCOL to column NDCOL */
/*        .    (including both column INCOL and column NDCOL). The */
/*        .    following loop chases a 3*NBMPS column long chain of */
/*        .    NBMPS bulges 3*NBMPS-2 columns to the right.  (INCOL */
/*        .    may be less than KTOP and and NDCOL may be greater than */
/*        .    KBOT indicating phantom columns from which to chase */
/*        .    bulges before they are actually introduced or to which */
/*        .    to chase bulges beyond column KBOT.)  ==== */

/* Computing MIN */
	i__4 = incol + nbmps * 3 - 3, i__5 = *kbot - 2;
	i__3 = Dymola_min(i__4,i__5);
	for (krcol = incol; krcol <= i__3; ++krcol) {

/*           ==== Bulges number MTOP to MBOT are active double implicit */
/*           .    shift bulges.  There may or may not also be small */
/*           .    2-by-2 bulge, if there is room.  The inactive bulges */
/*           .    (if any) must wait until the active bulges have moved */
/*           .    down the diagonal to make room.  The phantom matrix */
/*           .    paradigm described above helps keep track.  ==== */

/* Computing MAX */
	    i__4 = 1, i__5 = (*ktop - 1 - krcol + 2) / 3 + 1;
	    mtop = Dymola_max(i__4,i__5);
/* Computing MIN */
	    i__4 = nbmps, i__5 = (*kbot - krcol) / 3;
	    mbot = Dymola_min(i__4,i__5);
	    m22 = mbot + 1;
	    bmp22 = mbot < nbmps && krcol + (m22 - 1) * 3 == *kbot - 2;

/*           ==== Generate reflections to chase the chain right */
/*           .    one column.  (The minimum value of K is KTOP-1.) ==== */

	    i__4 = mbot;
	    for (m = mtop; m <= i__4; ++m) {
		k = krcol + (m - 1) * 3;
		if (k == *ktop - 1) {
		    dlaqr1_(&c__3, &h__[*ktop + *ktop * h_dim1], ldh, &sr[(m 
			    << 1) - 1], &si[(m << 1) - 1], &sr[m * 2], &si[m *
			     2], &v[m * v_dim1 + 1]);
		    alpha = v[m * v_dim1 + 1];
		    dlarfg_(&c__3, &alpha, &v[m * v_dim1 + 2], &c__1, &v[m * 
			    v_dim1 + 1]);
		} else {
		    beta = h__[k + 1 + k * h_dim1];
		    v[m * v_dim1 + 2] = h__[k + 2 + k * h_dim1];
		    v[m * v_dim1 + 3] = h__[k + 3 + k * h_dim1];
		    dlarfg_(&c__3, &beta, &v[m * v_dim1 + 2], &c__1, &v[m * 
			    v_dim1 + 1]);

/*                 ==== A Bulge may collapse because of vigilant */
/*                 .    deflation or destructive underflow.  In the */
/*                 .    underflow case, try the two-small-subdiagonals */
/*                 .    trick to try to reinflate the bulge.  ==== */

		    if (h__[k + 3 + k * h_dim1] != 0. || h__[k + 3 + (k + 1) *
			     h_dim1] != 0. || h__[k + 3 + (k + 2) * h_dim1] ==
			     0.) {

/*                    ==== Typical case: not collapsed (yet). ==== */

			h__[k + 1 + k * h_dim1] = beta;
			h__[k + 2 + k * h_dim1] = 0.;
			h__[k + 3 + k * h_dim1] = 0.;
		    } else {

/*                    ==== Atypical case: collapsed.  Attempt to */
/*                    .    reintroduce ignoring H(K+1,K) and H(K+2,K). */
/*                    .    If the fill resulting from the new */
/*                    .    reflector is too large, then abandon it. */
/*                    .    Otherwise, use the new one. ==== */

			dlaqr1_(&c__3, &h__[k + 1 + (k + 1) * h_dim1], ldh, &
				sr[(m << 1) - 1], &si[(m << 1) - 1], &sr[m * 
				2], &si[m * 2], vt);
			alpha = vt[0];
			dlarfg_(&c__3, &alpha, &vt[1], &c__1, vt);
			refsum = vt[0] * (h__[k + 1 + k * h_dim1] + vt[1] * 
				h__[k + 2 + k * h_dim1]);

			if ((d__1 = h__[k + 2 + k * h_dim1] - refsum * vt[1], 
				Dymola_abs(d__1)) + (d__2 = refsum * vt[2], Dymola_abs(d__2)
				) > ulp * ((d__3 = h__[k + k * h_dim1], Dymola_abs(
				d__3)) + (d__4 = h__[k + 1 + (k + 1) * h_dim1]
				, Dymola_abs(d__4)) + (d__5 = h__[k + 2 + (k + 2) * 
				h_dim1], Dymola_abs(d__5)))) {

/*                       ==== Starting a new bulge here would */
/*                       .    create non-negligible fill.  Use */
/*                       .    the old one with trepidation. ==== */

			    h__[k + 1 + k * h_dim1] = beta;
			    h__[k + 2 + k * h_dim1] = 0.;
			    h__[k + 3 + k * h_dim1] = 0.;
			} else {

/*                       ==== Stating a new bulge here would */
/*                       .    create only negligible fill. */
/*                       .    Replace the old reflector with */
/*                       .    the new one. ==== */

			    h__[k + 1 + k * h_dim1] -= refsum;
			    h__[k + 2 + k * h_dim1] = 0.;
			    h__[k + 3 + k * h_dim1] = 0.;
			    v[m * v_dim1 + 1] = vt[0];
			    v[m * v_dim1 + 2] = vt[1];
			    v[m * v_dim1 + 3] = vt[2];
			}
		    }
		}
/* L20: */
	    }

/*           ==== Generate a 2-by-2 reflection, if needed. ==== */

	    k = krcol + (m22 - 1) * 3;
	    if (bmp22) {
		if (k == *ktop - 1) {
		    dlaqr1_(&c__2, &h__[k + 1 + (k + 1) * h_dim1], ldh, &sr[(
			    m22 << 1) - 1], &si[(m22 << 1) - 1], &sr[m22 * 2],
			     &si[m22 * 2], &v[m22 * v_dim1 + 1]);
		    beta = v[m22 * v_dim1 + 1];
		    dlarfg_(&c__2, &beta, &v[m22 * v_dim1 + 2], &c__1, &v[m22 
			    * v_dim1 + 1]);
		} else {
		    beta = h__[k + 1 + k * h_dim1];
		    v[m22 * v_dim1 + 2] = h__[k + 2 + k * h_dim1];
		    dlarfg_(&c__2, &beta, &v[m22 * v_dim1 + 2], &c__1, &v[m22 
			    * v_dim1 + 1]);
		    h__[k + 1 + k * h_dim1] = beta;
		    h__[k + 2 + k * h_dim1] = 0.;
		}
	    }

/*           ==== Multiply H by reflections from the left ==== */

	    if (accum) {
		jbot = Dymola_min(ndcol,*kbot);
	    } else if (*wantt) {
		jbot = *n;
	    } else {
		jbot = *kbot;
	    }
	    i__4 = jbot;
	    for (j = Dymola_max(*ktop,krcol); j <= i__4; ++j) {
/* Computing MIN */
		i__5 = mbot, i__6 = (j - krcol + 2) / 3;
		mend = Dymola_min(i__5,i__6);
		i__5 = mend;
		for (m = mtop; m <= i__5; ++m) {
		    k = krcol + (m - 1) * 3;
		    refsum = v[m * v_dim1 + 1] * (h__[k + 1 + j * h_dim1] + v[
			    m * v_dim1 + 2] * h__[k + 2 + j * h_dim1] + v[m * 
			    v_dim1 + 3] * h__[k + 3 + j * h_dim1]);
		    h__[k + 1 + j * h_dim1] -= refsum;
		    h__[k + 2 + j * h_dim1] -= refsum * v[m * v_dim1 + 2];
		    h__[k + 3 + j * h_dim1] -= refsum * v[m * v_dim1 + 3];
/* L30: */
		}
/* L40: */
	    }
	    if (bmp22) {
		k = krcol + (m22 - 1) * 3;
/* Computing MAX */
		i__4 = k + 1;
		i__5 = jbot;
		for (j = Dymola_max(i__4,*ktop); j <= i__5; ++j) {
		    refsum = v[m22 * v_dim1 + 1] * (h__[k + 1 + j * h_dim1] + 
			    v[m22 * v_dim1 + 2] * h__[k + 2 + j * h_dim1]);
		    h__[k + 1 + j * h_dim1] -= refsum;
		    h__[k + 2 + j * h_dim1] -= refsum * v[m22 * v_dim1 + 2];
/* L50: */
		}
	    }

/*           ==== Multiply H by reflections from the right. */
/*           .    Delay filling in the last row until the */
/*           .    vigilant deflation check is complete. ==== */

	    if (accum) {
		jtop = Dymola_max(*ktop,incol);
	    } else if (*wantt) {
		jtop = 1;
	    } else {
		jtop = *ktop;
	    }
	    i__5 = mbot;
	    for (m = mtop; m <= i__5; ++m) {
		if (v[m * v_dim1 + 1] != 0.) {
		    k = krcol + (m - 1) * 3;
/* Computing MIN */
		    i__6 = *kbot, i__7 = k + 3;
		    i__4 = Dymola_min(i__6,i__7);
		    for (j = jtop; j <= i__4; ++j) {
			refsum = v[m * v_dim1 + 1] * (h__[j + (k + 1) * 
				h_dim1] + v[m * v_dim1 + 2] * h__[j + (k + 2) 
				* h_dim1] + v[m * v_dim1 + 3] * h__[j + (k + 
				3) * h_dim1]);
			h__[j + (k + 1) * h_dim1] -= refsum;
			h__[j + (k + 2) * h_dim1] -= refsum * v[m * v_dim1 + 
				2];
			h__[j + (k + 3) * h_dim1] -= refsum * v[m * v_dim1 + 
				3];
/* L60: */
		    }

		    if (accum) {

/*                    ==== Accumulate U. (If necessary, update Z later */
/*                    .    with with an efficient matrix-matrix */
/*                    .    multiply.) ==== */

			kms = k - incol;
/* Computing MAX */
			i__4 = 1, i__6 = *ktop - incol;
			i__7 = kdu;
			for (j = Dymola_max(i__4,i__6); j <= i__7; ++j) {
			    refsum = v[m * v_dim1 + 1] * (u[j + (kms + 1) * 
				    u_dim1] + v[m * v_dim1 + 2] * u[j + (kms 
				    + 2) * u_dim1] + v[m * v_dim1 + 3] * u[j 
				    + (kms + 3) * u_dim1]);
			    u[j + (kms + 1) * u_dim1] -= refsum;
			    u[j + (kms + 2) * u_dim1] -= refsum * v[m * 
				    v_dim1 + 2];
			    u[j + (kms + 3) * u_dim1] -= refsum * v[m * 
				    v_dim1 + 3];
/* L70: */
			}
		    } else if (*wantz) {

/*                    ==== U is not accumulated, so update Z */
/*                    .    now by multiplying by reflections */
/*                    .    from the right. ==== */

			i__7 = *ihiz;
			for (j = *iloz; j <= i__7; ++j) {
			    refsum = v[m * v_dim1 + 1] * (z__[j + (k + 1) * 
				    z_dim1] + v[m * v_dim1 + 2] * z__[j + (k 
				    + 2) * z_dim1] + v[m * v_dim1 + 3] * z__[
				    j + (k + 3) * z_dim1]);
			    z__[j + (k + 1) * z_dim1] -= refsum;
			    z__[j + (k + 2) * z_dim1] -= refsum * v[m * 
				    v_dim1 + 2];
			    z__[j + (k + 3) * z_dim1] -= refsum * v[m * 
				    v_dim1 + 3];
/* L80: */
			}
		    }
		}
/* L90: */
	    }

/*           ==== Special case: 2-by-2 reflection (if needed) ==== */

	    k = krcol + (m22 - 1) * 3;
	    if (bmp22) {
		if (v[m22 * v_dim1 + 1] != 0.) {
/* Computing MIN */
		    i__7 = *kbot, i__4 = k + 3;
		    i__5 = Dymola_min(i__7,i__4);
		    for (j = jtop; j <= i__5; ++j) {
			refsum = v[m22 * v_dim1 + 1] * (h__[j + (k + 1) * 
				h_dim1] + v[m22 * v_dim1 + 2] * h__[j + (k + 
				2) * h_dim1]);
			h__[j + (k + 1) * h_dim1] -= refsum;
			h__[j + (k + 2) * h_dim1] -= refsum * v[m22 * v_dim1 
				+ 2];
/* L100: */
		    }

		    if (accum) {
			kms = k - incol;
/* Computing MAX */
			i__5 = 1, i__7 = *ktop - incol;
			i__4 = kdu;
			for (j = Dymola_max(i__5,i__7); j <= i__4; ++j) {
			    refsum = v[m22 * v_dim1 + 1] * (u[j + (kms + 1) * 
				    u_dim1] + v[m22 * v_dim1 + 2] * u[j + (
				    kms + 2) * u_dim1]);
			    u[j + (kms + 1) * u_dim1] -= refsum;
			    u[j + (kms + 2) * u_dim1] -= refsum * v[m22 * 
				    v_dim1 + 2];
/* L110: */
			}
		    } else if (*wantz) {
			i__4 = *ihiz;
			for (j = *iloz; j <= i__4; ++j) {
			    refsum = v[m22 * v_dim1 + 1] * (z__[j + (k + 1) * 
				    z_dim1] + v[m22 * v_dim1 + 2] * z__[j + (
				    k + 2) * z_dim1]);
			    z__[j + (k + 1) * z_dim1] -= refsum;
			    z__[j + (k + 2) * z_dim1] -= refsum * v[m22 * 
				    v_dim1 + 2];
/* L120: */
			}
		    }
		}
	    }

/*           ==== Vigilant deflation check ==== */

	    mstart = mtop;
	    if (krcol + (mstart - 1) * 3 < *ktop) {
		++mstart;
	    }
	    mend = mbot;
	    if (bmp22) {
		++mend;
	    }
	    if (krcol == *kbot - 2) {
		++mend;
	    }
	    i__4 = mend;
	    for (m = mstart; m <= i__4; ++m) {
/* Computing MIN */
		i__5 = *kbot - 1, i__7 = krcol + (m - 1) * 3;
		k = Dymola_min(i__5,i__7);

/*              ==== The following convergence test requires that */
/*              .    the tradition small-compared-to-nearby-diagonals */
/*              .    criterion and the Ahues & Tisseur (LAWN 122, 1997) */
/*              .    criteria both be satisfied.  The latter improves */
/*              .    accuracy in some examples. Falling back on an */
/*              .    alternate convergence criterion when TST1 or TST2 */
/*              .    is zero (as done here) is traditional but probably */
/*              .    unnecessary. ==== */

		if (h__[k + 1 + k * h_dim1] != 0.) {
		    tst1 = (d__1 = h__[k + k * h_dim1], Dymola_abs(d__1)) + (d__2 = 
			    h__[k + 1 + (k + 1) * h_dim1], Dymola_abs(d__2));
		    if (tst1 == 0.) {
			if (k >= *ktop + 1) {
			    tst1 += (d__1 = h__[k + (k - 1) * h_dim1], Dymola_abs(
				    d__1));
			}
			if (k >= *ktop + 2) {
			    tst1 += (d__1 = h__[k + (k - 2) * h_dim1], Dymola_abs(
				    d__1));
			}
			if (k >= *ktop + 3) {
			    tst1 += (d__1 = h__[k + (k - 3) * h_dim1], Dymola_abs(
				    d__1));
			}
			if (k <= *kbot - 2) {
			    tst1 += (d__1 = h__[k + 2 + (k + 1) * h_dim1], 
				    Dymola_abs(d__1));
			}
			if (k <= *kbot - 3) {
			    tst1 += (d__1 = h__[k + 3 + (k + 1) * h_dim1], 
				    Dymola_abs(d__1));
			}
			if (k <= *kbot - 4) {
			    tst1 += (d__1 = h__[k + 4 + (k + 1) * h_dim1], 
				    Dymola_abs(d__1));
			}
		    }
/* Computing MAX */
		    d__2 = smlnum, d__3 = ulp * tst1;
		    if ((d__1 = h__[k + 1 + k * h_dim1], Dymola_abs(d__1)) <= Dymola_max(
			    d__2,d__3)) {
/* Computing MAX */
			d__3 = (d__1 = h__[k + 1 + k * h_dim1], Dymola_abs(d__1)), 
				d__4 = (d__2 = h__[k + (k + 1) * h_dim1], Dymola_abs(
				d__2));
			h12 = Dymola_max(d__3,d__4);
/* Computing MIN */
			d__3 = (d__1 = h__[k + 1 + k * h_dim1], Dymola_abs(d__1)), 
				d__4 = (d__2 = h__[k + (k + 1) * h_dim1], Dymola_abs(
				d__2));
			h21 = Dymola_min(d__3,d__4);
/* Computing MAX */
			d__3 = (d__1 = h__[k + 1 + (k + 1) * h_dim1], Dymola_abs(
				d__1)), d__4 = (d__2 = h__[k + k * h_dim1] - 
				h__[k + 1 + (k + 1) * h_dim1], Dymola_abs(d__2));
			h11 = Dymola_max(d__3,d__4);
/* Computing MIN */
			d__3 = (d__1 = h__[k + 1 + (k + 1) * h_dim1], Dymola_abs(
				d__1)), d__4 = (d__2 = h__[k + k * h_dim1] - 
				h__[k + 1 + (k + 1) * h_dim1], Dymola_abs(d__2));
			h22 = Dymola_min(d__3,d__4);
			scl = h11 + h12;
			tst2 = h22 * (h11 / scl);

/* Computing MAX */
			d__1 = smlnum, d__2 = ulp * tst2;
			if (tst2 == 0. || h21 * (h12 / scl) <= Dymola_max(d__1,d__2))
				 {
			    h__[k + 1 + k * h_dim1] = 0.;
			}
		    }
		}
/* L130: */
	    }

/*           ==== Fill in the last row of each bulge. ==== */

/* Computing MIN */
	    i__4 = nbmps, i__5 = (*kbot - krcol - 1) / 3;
	    mend = Dymola_min(i__4,i__5);
	    i__4 = mend;
	    for (m = mtop; m <= i__4; ++m) {
		k = krcol + (m - 1) * 3;
		refsum = v[m * v_dim1 + 1] * v[m * v_dim1 + 3] * h__[k + 4 + (
			k + 3) * h_dim1];
		h__[k + 4 + (k + 1) * h_dim1] = -refsum;
		h__[k + 4 + (k + 2) * h_dim1] = -refsum * v[m * v_dim1 + 2];
		h__[k + 4 + (k + 3) * h_dim1] -= refsum * v[m * v_dim1 + 3];
/* L140: */
	    }

/*           ==== End of near-the-diagonal bulge chase. ==== */

/* L150: */
	}

/*        ==== Use U (if accumulated) to update far-from-diagonal */
/*        .    entries in H.  If required, use U to update Z as */
/*        .    well. ==== */

	if (accum) {
	    if (*wantt) {
		jtop = 1;
		jbot = *n;
	    } else {
		jtop = *ktop;
		jbot = *kbot;
	    }
	    if (! blk22 || incol < *ktop || ndcol > *kbot || ns <= 2) {

/*              ==== Updates not exploiting the 2-by-2 block */
/*              .    structure of U.  K1 and NU keep track of */
/*              .    the location and size of U in the special */
/*              .    cases of introducing bulges and chasing */
/*              .    bulges off the bottom.  In these special */
/*              .    cases and in case the number of shifts */
/*              .    is NS = 2, there is no 2-by-2 block */
/*              .    structure to exploit.  ==== */

/* Computing MAX */
		i__3 = 1, i__4 = *ktop - incol;
		k1 = Dymola_max(i__3,i__4);
/* Computing MAX */
		i__3 = 0, i__4 = ndcol - *kbot;
		nu = kdu - Dymola_max(i__3,i__4) - k1 + 1;

/*              ==== Horizontal Multiply ==== */

		i__3 = jbot;
		i__4 = *nh;
		for (jcol = Dymola_min(ndcol,*kbot) + 1; i__4 < 0 ? jcol >= i__3 : 
			jcol <= i__3; jcol += i__4) {
/* Computing MIN */
		    i__5 = *nh, i__7 = jbot - jcol + 1;
		    jlen = Dymola_min(i__5,i__7);
		    dgemm_("C", "N", &nu, &jlen, &nu, &c_b8, &u[k1 + k1 * 
			    u_dim1], ldu, &h__[incol + k1 + jcol * h_dim1], 
			    ldh, &c_b7_dlaqr5, &wh[wh_offset], ldwh);
		    dlacpy_("ALL", &nu, &jlen, &wh[wh_offset], ldwh, &h__[
			    incol + k1 + jcol * h_dim1], ldh);
/* L160: */
		}

/*              ==== Vertical multiply ==== */

		i__4 = Dymola_max(*ktop,incol) - 1;
		i__3 = *nv;
		for (jrow = jtop; i__3 < 0 ? jrow >= i__4 : jrow <= i__4; 
			jrow += i__3) {
/* Computing MIN */
		    i__5 = *nv, i__7 = Dymola_max(*ktop,incol) - jrow;
		    jlen = Dymola_min(i__5,i__7);
		    dgemm_("N", "N", &jlen, &nu, &nu, &c_b8, &h__[jrow + (
			    incol + k1) * h_dim1], ldh, &u[k1 + k1 * u_dim1], 
			    ldu, &c_b7_dlaqr5, &wv[wv_offset], ldwv);
		    dlacpy_("ALL", &jlen, &nu, &wv[wv_offset], ldwv, &h__[
			    jrow + (incol + k1) * h_dim1], ldh);
/* L170: */
		}

/*              ==== Z multiply (also vertical) ==== */

		if (*wantz) {
		    i__3 = *ihiz;
		    i__4 = *nv;
		    for (jrow = *iloz; i__4 < 0 ? jrow >= i__3 : jrow <= i__3;
			     jrow += i__4) {
/* Computing MIN */
			i__5 = *nv, i__7 = *ihiz - jrow + 1;
			jlen = Dymola_min(i__5,i__7);
			dgemm_("N", "N", &jlen, &nu, &nu, &c_b8, &z__[jrow + (
				incol + k1) * z_dim1], ldz, &u[k1 + k1 * 
				u_dim1], ldu, &c_b7_dlaqr5, &wv[wv_offset], ldwv);
			dlacpy_("ALL", &jlen, &nu, &wv[wv_offset], ldwv, &z__[
				jrow + (incol + k1) * z_dim1], ldz)
				;
/* L180: */
		    }
		}
	    } else {

/*              ==== Updates exploiting U's 2-by-2 block structure. */
/*              .    (I2, I4, J2, J4 are the last rows and columns */
/*              .    of the blocks.) ==== */

		i2 = (kdu + 1) / 2;
		i4 = kdu;
		j2 = i4 - i2;
		j4 = kdu;

/*              ==== KZS and KNZ deal with the band of zeros */
/*              .    along the diagonal of one of the triangular */
/*              .    blocks. ==== */

		kzs = j4 - j2 - (ns + 1);
		knz = ns + 1;

/*              ==== Horizontal multiply ==== */

		i__4 = jbot;
		i__3 = *nh;
		for (jcol = Dymola_min(ndcol,*kbot) + 1; i__3 < 0 ? jcol >= i__4 : 
			jcol <= i__4; jcol += i__3) {
/* Computing MIN */
		    i__5 = *nh, i__7 = jbot - jcol + 1;
		    jlen = Dymola_min(i__5,i__7);

/*                 ==== Copy bottom of H to top+KZS of scratch ==== */
/*                  (The first KZS rows get multiplied by zero.) ==== */

		    dlacpy_("ALL", &knz, &jlen, &h__[incol + 1 + j2 + jcol * 
			    h_dim1], ldh, &wh[kzs + 1 + wh_dim1], ldwh);

/*                 ==== Multiply by U21**T ==== */

		    dlaset_("ALL", &kzs, &jlen, &c_b7_dlaqr5, &c_b7_dlaqr5, &wh[wh_offset], 
			    ldwh);
		    dtrmm_("L", "U", "C", "N", &knz, &jlen, &c_b8, &u[j2 + 1 
			    + (kzs + 1) * u_dim1], ldu, &wh[kzs + 1 + wh_dim1]
			    , ldwh);

/*                 ==== Multiply top of H by U11**T ==== */

		    dgemm_("C", "N", &i2, &jlen, &j2, &c_b8, &u[u_offset], 
			    ldu, &h__[incol + 1 + jcol * h_dim1], ldh, &c_b8, 
			    &wh[wh_offset], ldwh);

/*                 ==== Copy top of H to bottom of WH ==== */

		    dlacpy_("ALL", &j2, &jlen, &h__[incol + 1 + jcol * h_dim1]
			    , ldh, &wh[i2 + 1 + wh_dim1], ldwh);

/*                 ==== Multiply by U21**T ==== */

		    dtrmm_("L", "L", "C", "N", &j2, &jlen, &c_b8, &u[(i2 + 1) 
			    * u_dim1 + 1], ldu, &wh[i2 + 1 + wh_dim1], ldwh);

/*                 ==== Multiply by U22 ==== */

		    i__5 = i4 - i2;
		    i__7 = j4 - j2;
		    dgemm_("C", "N", &i__5, &jlen, &i__7, &c_b8, &u[j2 + 1 + (
			    i2 + 1) * u_dim1], ldu, &h__[incol + 1 + j2 + 
			    jcol * h_dim1], ldh, &c_b8, &wh[i2 + 1 + wh_dim1],
			     ldwh);

/*                 ==== Copy it back ==== */

		    dlacpy_("ALL", &kdu, &jlen, &wh[wh_offset], ldwh, &h__[
			    incol + 1 + jcol * h_dim1], ldh);
/* L190: */
		}

/*              ==== Vertical multiply ==== */

		i__3 = Dymola_max(incol,*ktop) - 1;
		i__4 = *nv;
		for (jrow = jtop; i__4 < 0 ? jrow >= i__3 : jrow <= i__3; 
			jrow += i__4) {
/* Computing MIN */
		    i__5 = *nv, i__7 = Dymola_max(incol,*ktop) - jrow;
		    jlen = Dymola_min(i__5,i__7);

/*                 ==== Copy right of H to scratch (the first KZS */
/*                 .    columns get multiplied by zero) ==== */

		    dlacpy_("ALL", &jlen, &knz, &h__[jrow + (incol + 1 + j2) *
			     h_dim1], ldh, &wv[(kzs + 1) * wv_dim1 + 1], ldwv);

/*                 ==== Multiply by U21 ==== */

		    dlaset_("ALL", &jlen, &kzs, &c_b7_dlaqr5, &c_b7_dlaqr5, &wv[wv_offset], 
			    ldwv);
		    dtrmm_("R", "U", "N", "N", &jlen, &knz, &c_b8, &u[j2 + 1 
			    + (kzs + 1) * u_dim1], ldu, &wv[(kzs + 1) * 
			    wv_dim1 + 1], ldwv);

/*                 ==== Multiply by U11 ==== */

		    dgemm_("N", "N", &jlen, &i2, &j2, &c_b8, &h__[jrow + (
			    incol + 1) * h_dim1], ldh, &u[u_offset], ldu, &
			    c_b8, &wv[wv_offset], ldwv);

/*                 ==== Copy left of H to right of scratch ==== */

		    dlacpy_("ALL", &jlen, &j2, &h__[jrow + (incol + 1) * 
			    h_dim1], ldh, &wv[(i2 + 1) * wv_dim1 + 1], ldwv);

/*                 ==== Multiply by U21 ==== */

		    i__5 = i4 - i2;
		    dtrmm_("R", "L", "N", "N", &jlen, &i__5, &c_b8, &u[(i2 + 
			    1) * u_dim1 + 1], ldu, &wv[(i2 + 1) * wv_dim1 + 1]
			    , ldwv);

/*                 ==== Multiply by U22 ==== */

		    i__5 = i4 - i2;
		    i__7 = j4 - j2;
		    dgemm_("N", "N", &jlen, &i__5, &i__7, &c_b8, &h__[jrow + (
			    incol + 1 + j2) * h_dim1], ldh, &u[j2 + 1 + (i2 + 
			    1) * u_dim1], ldu, &c_b8, &wv[(i2 + 1) * wv_dim1 
			    + 1], ldwv);

/*                 ==== Copy it back ==== */

		    dlacpy_("ALL", &jlen, &kdu, &wv[wv_offset], ldwv, &h__[
			    jrow + (incol + 1) * h_dim1], ldh);
/* L200: */
		}

/*              ==== Multiply Z (also vertical) ==== */

		if (*wantz) {
		    i__4 = *ihiz;
		    i__3 = *nv;
		    for (jrow = *iloz; i__3 < 0 ? jrow >= i__4 : jrow <= i__4;
			     jrow += i__3) {
/* Computing MIN */
			i__5 = *nv, i__7 = *ihiz - jrow + 1;
			jlen = Dymola_min(i__5,i__7);

/*                    ==== Copy right of Z to left of scratch (first */
/*                    .     KZS columns get multiplied by zero) ==== */

			dlacpy_("ALL", &jlen, &knz, &z__[jrow + (incol + 1 + 
				j2) * z_dim1], ldz, &wv[(kzs + 1) * wv_dim1 + 
				1], ldwv);

/*                    ==== Multiply by U12 ==== */

			dlaset_("ALL", &jlen, &kzs, &c_b7_dlaqr5, &c_b7_dlaqr5, &wv[
				wv_offset], ldwv);
			dtrmm_("R", "U", "N", "N", &jlen, &knz, &c_b8, &u[j2 
				+ 1 + (kzs + 1) * u_dim1], ldu, &wv[(kzs + 1) 
				* wv_dim1 + 1], ldwv);

/*                    ==== Multiply by U11 ==== */

			dgemm_("N", "N", &jlen, &i2, &j2, &c_b8, &z__[jrow + (
				incol + 1) * z_dim1], ldz, &u[u_offset], ldu, 
				&c_b8, &wv[wv_offset], ldwv);

/*                    ==== Copy left of Z to right of scratch ==== */

			dlacpy_("ALL", &jlen, &j2, &z__[jrow + (incol + 1) * 
				z_dim1], ldz, &wv[(i2 + 1) * wv_dim1 + 1], 
				ldwv);

/*                    ==== Multiply by U21 ==== */

			i__5 = i4 - i2;
			dtrmm_("R", "L", "N", "N", &jlen, &i__5, &c_b8, &u[(
				i2 + 1) * u_dim1 + 1], ldu, &wv[(i2 + 1) * 
				wv_dim1 + 1], ldwv);

/*                    ==== Multiply by U22 ==== */

			i__5 = i4 - i2;
			i__7 = j4 - j2;
			dgemm_("N", "N", &jlen, &i__5, &i__7, &c_b8, &z__[
				jrow + (incol + 1 + j2) * z_dim1], ldz, &u[j2 
				+ 1 + (i2 + 1) * u_dim1], ldu, &c_b8, &wv[(i2 
				+ 1) * wv_dim1 + 1], ldwv);

/*                    ==== Copy the result back to Z ==== */

			dlacpy_("ALL", &jlen, &kdu, &wv[wv_offset], ldwv, &
				z__[jrow + (incol + 1) * z_dim1], ldz);
/* L210: */
		    }
		}
	    }
	}
/* L220: */
    }

/*     ==== End of DLAQR5 ==== */

    return 0;
} /* dlaqr5_ */

/* Subroutine */ static int dlanv2_(doublereal *a, doublereal *b, doublereal *c__, doublereal *d__, doublereal *rt1r, doublereal *rt1i, doublereal *rt2r, doublereal *rt2i, doublereal *cs, doublereal *sn)
{
    /* System generated locals */
    doublereal d__1, d__2;

    /* Local variables */
    doublereal p, z__, aa, bb, cc, dd, cs1, sn1, sab, sac, eps, tau, temp, 
	    scale, bcmax, bcmis, sigma;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    eps = dlamch_("P");
    if (*c__ == 0.) {
	*cs = 1.;
	*sn = 0.;
	goto L10;

    } else if (*b == 0.) {

/*        Swap rows and columns */

	*cs = 0.;
	*sn = 1.;
	temp = *d__;
	*d__ = *a;
	*a = temp;
	*b = -(*c__);
	*c__ = 0.;
	goto L10;
    } else if (*a - *d__ == 0. && d_sign(&c_b4, b) != d_sign(&c_b4, c__)) {
	*cs = 1.;
	*sn = 0.;
	goto L10;
    } else {

	temp = *a - *d__;
	p = temp * .5;
/* Computing MAX */
	d__1 = Dymola_abs(*b), d__2 = Dymola_abs(*c__);
	bcmax = Dymola_max(d__1,d__2);
/* Computing MIN */
	d__1 = Dymola_abs(*b), d__2 = Dymola_abs(*c__);
	bcmis = Dymola_min(d__1,d__2) * d_sign(&c_b4, b) * d_sign(&c_b4, c__);
/* Computing MAX */
	d__1 = Dymola_abs(p);
	scale = Dymola_max(d__1,bcmax);
	z__ = p / scale * p + bcmax / scale * bcmis;

/*        If Z is of the order of the machine accuracy, postpone the */
/*        decision on the nature of eigenvalues */

	if (z__ >= eps * 4.) {

/*           Real eigenvalues. Compute A and D. */

	    d__1 = sqrt(scale) * sqrt(z__);
	    z__ = p + d_sign(&d__1, &p);
	    *a = *d__ + z__;
	    *d__ -= bcmax / z__ * bcmis;

/*           Compute B and the rotation matrix */

	    tau = dlapy2_(c__, &z__);
	    *cs = z__ / tau;
	    *sn = *c__ / tau;
	    *b -= *c__;
	    *c__ = 0.;
	} else {

/*           Complex eigenvalues, or real (almost) equal eigenvalues. */
/*           Make diagonal elements equal. */

	    sigma = *b + *c__;
	    tau = dlapy2_(&sigma, &temp);
	    *cs = sqrt((Dymola_abs(sigma) / tau + 1.) * .5);
	    *sn = -(p / (tau * *cs)) * d_sign(&c_b4, &sigma);

/*           Compute [ AA  BB ] = [ A  B ] [ CS -SN ] */
/*                   [ CC  DD ]   [ C  D ] [ SN  CS ] */

	    aa = *a * *cs + *b * *sn;
	    bb = -(*a) * *sn + *b * *cs;
	    cc = *c__ * *cs + *d__ * *sn;
	    dd = -(*c__) * *sn + *d__ * *cs;

/*           Compute [ A  B ] = [ CS  SN ] [ AA  BB ] */
/*                   [ C  D ]   [-SN  CS ] [ CC  DD ] */

	    *a = aa * *cs + cc * *sn;
	    *b = bb * *cs + dd * *sn;
	    *c__ = -aa * *sn + cc * *cs;
	    *d__ = -bb * *sn + dd * *cs;

	    temp = (*a + *d__) * .5;
	    *a = temp;
	    *d__ = temp;

	    if (*c__ != 0.) {
		if (*b != 0.) {
		    if (d_sign(&c_b4, b) == d_sign(&c_b4, c__)) {

/*                    Real eigenvalues: reduce to upper triangular form */

			sab = sqrt((Dymola_abs(*b)));
			sac = sqrt((Dymola_abs(*c__)));
			d__1 = sab * sac;
			p = d_sign(&d__1, c__);
			tau = 1. / sqrt((d__1 = *b + *c__, Dymola_abs(d__1)));
			*a = temp + p;
			*d__ = temp - p;
			*b -= *c__;
			*c__ = 0.;
			cs1 = sab * tau;
			sn1 = sac * tau;
			temp = *cs * cs1 - *sn * sn1;
			*sn = *cs * sn1 + *sn * cs1;
			*cs = temp;
		    }
		} else {
		    *b = -(*c__);
		    *c__ = 0.;
		    temp = *cs;
		    *cs = -(*sn);
		    *sn = temp;
		}
	    }
	}

    }

L10:

/*     Store eigenvalues in (RT1R,RT1I) and (RT2R,RT2I). */

    *rt1r = *a;
    *rt2r = *d__;
    if (*c__ == 0.) {
	*rt1i = 0.;
	*rt2i = 0.;
    } else {
	*rt1i = sqrt((Dymola_abs(*b))) * sqrt((Dymola_abs(*c__)));
	*rt2i = -(*rt1i);
    }
    return 0;

/*     End of DLANV2 */

} /* dlanv2_ */

/* Subroutine */ static int dtrmv_(char *uplo, char *trans, char *diag, integer *n, doublereal *a, integer *lda, doublereal *x, integer *incx)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    integer i__, j, ix, jx, kx, info;
    doublereal temp;
    logical nounit;


/*  -- Reference BLAS level2 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --x;

    /* Function Body */
    info = 0;
    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
	    ftnlen)1, (ftnlen)1)) {
	info = 1;
    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
	    ftnlen)1)) {
	info = 2;
    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
	    "N", (ftnlen)1, (ftnlen)1)) {
	info = 3;
    } else if (*n < 0) {
	info = 4;
    } else if (*lda < Dymola_max(1,*n)) {
	info = 6;
    } else if (*incx == 0) {
	info = 8;
    }
    if (info != 0) {
	xerbla_("DTRMV ", &info);
	return 0;
    }

/*     Quick return if possible. */

    if (*n == 0) {
	return 0;
    }

    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);

/*     Set up the start point in X if the increment is not unity. This */
/*     will be  ( N - 1 )*INCX  too small for descending loops. */

    if (*incx <= 0) {
	kx = 1 - (*n - 1) * *incx;
    } else if (*incx != 1) {
	kx = 1;
    }

/*     Start the operations. In this version the elements of A are */
/*     accessed sequentially with one pass through A. */

    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {

/*        Form  x := A*x. */

	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
	    if (*incx == 1) {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    if (x[j] != 0.) {
			temp = x[j];
			i__2 = j - 1;
			for (i__ = 1; i__ <= i__2; ++i__) {
			    x[i__] += temp * a[i__ + j * a_dim1];
/* L10: */
			}
			if (nounit) {
			    x[j] *= a[j + j * a_dim1];
			}
		    }
/* L20: */
		}
	    } else {
		jx = kx;
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    if (x[jx] != 0.) {
			temp = x[jx];
			ix = kx;
			i__2 = j - 1;
			for (i__ = 1; i__ <= i__2; ++i__) {
			    x[ix] += temp * a[i__ + j * a_dim1];
			    ix += *incx;
/* L30: */
			}
			if (nounit) {
			    x[jx] *= a[j + j * a_dim1];
			}
		    }
		    jx += *incx;
/* L40: */
		}
	    }
	} else {
	    if (*incx == 1) {
		for (j = *n; j >= 1; --j) {
		    if (x[j] != 0.) {
			temp = x[j];
			i__1 = j + 1;
			for (i__ = *n; i__ >= i__1; --i__) {
			    x[i__] += temp * a[i__ + j * a_dim1];
/* L50: */
			}
			if (nounit) {
			    x[j] *= a[j + j * a_dim1];
			}
		    }
/* L60: */
		}
	    } else {
		kx += (*n - 1) * *incx;
		jx = kx;
		for (j = *n; j >= 1; --j) {
		    if (x[jx] != 0.) {
			temp = x[jx];
			ix = kx;
			i__1 = j + 1;
			for (i__ = *n; i__ >= i__1; --i__) {
			    x[ix] += temp * a[i__ + j * a_dim1];
			    ix -= *incx;
/* L70: */
			}
			if (nounit) {
			    x[jx] *= a[j + j * a_dim1];
			}
		    }
		    jx -= *incx;
/* L80: */
		}
	    }
	}
    } else {

/*        Form  x := A**T*x. */

	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
	    if (*incx == 1) {
		for (j = *n; j >= 1; --j) {
		    temp = x[j];
		    if (nounit) {
			temp *= a[j + j * a_dim1];
		    }
		    for (i__ = j - 1; i__ >= 1; --i__) {
			temp += a[i__ + j * a_dim1] * x[i__];
/* L90: */
		    }
		    x[j] = temp;
/* L100: */
		}
	    } else {
		jx = kx + (*n - 1) * *incx;
		for (j = *n; j >= 1; --j) {
		    temp = x[jx];
		    ix = jx;
		    if (nounit) {
			temp *= a[j + j * a_dim1];
		    }
		    for (i__ = j - 1; i__ >= 1; --i__) {
			ix -= *incx;
			temp += a[i__ + j * a_dim1] * x[ix];
/* L110: */
		    }
		    x[jx] = temp;
		    jx -= *incx;
/* L120: */
		}
	    }
	} else {
	    if (*incx == 1) {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    temp = x[j];
		    if (nounit) {
			temp *= a[j + j * a_dim1];
		    }
		    i__2 = *n;
		    for (i__ = j + 1; i__ <= i__2; ++i__) {
			temp += a[i__ + j * a_dim1] * x[i__];
/* L130: */
		    }
		    x[j] = temp;
/* L140: */
		}
	    } else {
		jx = kx;
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    temp = x[jx];
		    ix = jx;
		    if (nounit) {
			temp *= a[j + j * a_dim1];
		    }
		    i__2 = *n;
		    for (i__ = j + 1; i__ <= i__2; ++i__) {
			ix += *incx;
			temp += a[i__ + j * a_dim1] * x[ix];
/* L150: */
		    }
		    x[jx] = temp;
		    jx += *incx;
/* L160: */
		}
	    }
	}
    }

    return 0;

/*     End of DTRMV . */

} /* dtrmv_ */

/* Subroutine */ static int dorg2r_(integer* m, integer* n, integer* k, doublereal* a, integer* lda, doublereal* tau, doublereal* work, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    integer i__, j, l;

/*  -- LAPACK computational routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0 || *n > *m) {
	*info = -2;
    } else if (*k < 0 || *k > *n) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -5;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DORG2R", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n <= 0) {
	return 0;
    }

/*     Initialise columns k+1:n to columns of the unit matrix */

    i__1 = *n;
    for (j = *k + 1; j <= i__1; ++j) {
	i__2 = *m;
	for (l = 1; l <= i__2; ++l) {
	    a[l + j * a_dim1] = 0.;
/* L10: */
	}
	a[j + j * a_dim1] = 1.;
/* L20: */
    }

    for (i__ = *k; i__ >= 1; --i__) {

/*        Apply H(i) to A(i:m,i:n) from the left */

	if (i__ < *n) {
	    a[i__ + i__ * a_dim1] = 1.;
	    i__1 = *m - i__ + 1;
	    i__2 = *n - i__;
	    dlarf_("Left", &i__1, &i__2, &a[i__ + i__ * a_dim1], &c__1, &tau[
		    i__], &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]);
	}
	if (i__ < *m) {
	    i__1 = *m - i__;
	    d__1 = -tau[i__];
	    dscal_(&i__1, &d__1, &a[i__ + 1 + i__ * a_dim1], &c__1);
	}
	a[i__ + i__ * a_dim1] = 1. - tau[i__];

/*        Set A(1:i-1,i) to zero */

	i__1 = i__ - 1;
	for (l = 1; l <= i__1; ++l) {
	    a[l + i__ * a_dim1] = 0.;
/* L30: */
	}
/* L40: */
    }
    return 0;

/*     End of DORG2R */

} /* dorg2r_ */

/* Subroutine */ static int dlarft_(char *direct, char *storev, integer *n, integer *k, doublereal *v, integer *ldv, doublereal *tau, doublereal *t, integer *ldt)
{
    /* System generated locals */
    integer t_dim1, t_offset, v_dim1, v_offset, i__1, i__2, i__3;
    doublereal d__1;

    /* Local variables */
    integer i__, j, prevlastv;
    integer lastv;

/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Quick return if possible */

    /* Parameter adjustments */
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    --tau;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;

    /* Function Body */
    if (*n == 0) {
	return 0;
    }

    if (lsame_(direct, "F", (ftnlen)1, (ftnlen)1)) {
	prevlastv = *n;
	i__1 = *k;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    prevlastv = Dymola_max(i__,prevlastv);
	    if (tau[i__] == 0.) {

/*              H(i)  =  I */

		i__2 = i__;
		for (j = 1; j <= i__2; ++j) {
		    t[j + i__ * t_dim1] = 0.;
		}
	    } else {

/*              general case */

		if (lsame_(storev, "C", (ftnlen)1, (ftnlen)1)) {
/*                 Skip any trailing zeros. */
		    i__2 = i__ + 1;
		    for (lastv = *n; lastv >= i__2; --lastv) {
			if (v[lastv + i__ * v_dim1] != 0.) {
			    goto L222;
			}
		    }
L222:
		    i__2 = i__ - 1;
		    for (j = 1; j <= i__2; ++j) {
			t[j + i__ * t_dim1] = -tau[i__] * v[i__ + j * v_dim1];
		    }
		    j = Dymola_min(lastv,prevlastv);

/*                 T(1:i-1,i) := - tau(i) * V(i:j,1:i-1)**T * V(i:j,i) */

		    i__2 = j - i__;
		    i__3 = i__ - 1;
		    d__1 = -tau[i__];
		    dgemv_("Transpose", &i__2, &i__3, &d__1, &v[i__ + 1 + 
			    v_dim1], ldv, &v[i__ + 1 + i__ * v_dim1], &c__1, &
			    c_b7_dlarft, &t[i__ * t_dim1 + 1], &c__1);
		} else {
/*                 Skip any trailing zeros. */
		    i__2 = i__ + 1;
		    for (lastv = *n; lastv >= i__2; --lastv) {
			if (v[i__ + lastv * v_dim1] != 0.) {
			    goto L238;
			}
		    }
L238:
		    i__2 = i__ - 1;
		    for (j = 1; j <= i__2; ++j) {
			t[j + i__ * t_dim1] = -tau[i__] * v[j + i__ * v_dim1];
		    }
		    j = Dymola_min(lastv,prevlastv);

/*                 T(1:i-1,i) := - tau(i) * V(1:i-1,i:j) * V(i,i:j)**T */

		    i__2 = i__ - 1;
		    i__3 = j - i__;
		    d__1 = -tau[i__];
		    dgemv_("No transpose", &i__2, &i__3, &d__1, &v[(i__ + 1) *
			     v_dim1 + 1], ldv, &v[i__ + (i__ + 1) * v_dim1], 
			    ldv, &c_b7_dlarft, &t[i__ * t_dim1 + 1], &c__1);
		}

/*              T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i) */

		i__2 = i__ - 1;
		dtrmv_("Upper", "No transpose", "Non-unit", &i__2, &t[
			t_offset], ldt, &t[i__ * t_dim1 + 1], &c__1);
		t[i__ + i__ * t_dim1] = tau[i__];
		if (i__ > 1) {
		    prevlastv = Dymola_max(prevlastv,lastv);
		} else {
		    prevlastv = lastv;
		}
	    }
	}
    } else {
	prevlastv = 1;
	for (i__ = *k; i__ >= 1; --i__) {
	    if (tau[i__] == 0.) {

/*              H(i)  =  I */

		i__1 = *k;
		for (j = i__; j <= i__1; ++j) {
		    t[j + i__ * t_dim1] = 0.;
		}
	    } else {

/*              general case */

		if (i__ < *k) {
		    if (lsame_(storev, "C", (ftnlen)1, (ftnlen)1)) {
/*                    Skip any leading zeros. */
			i__1 = i__ - 1;
			for (lastv = 1; lastv <= i__1; ++lastv) {
			    if (v[lastv + i__ * v_dim1] != 0.) {
				goto L282;
			    }
L282:
			    ;
			}
			i__1 = *k;
			for (j = i__ + 1; j <= i__1; ++j) {
			    t[j + i__ * t_dim1] = -tau[i__] * v[*n - *k + i__ 
				    + j * v_dim1];
			}
			j = Dymola_max(lastv,prevlastv);

/*                    T(i+1:k,i) = -tau(i) * V(j:n-k+i,i+1:k)**T * V(j:n-k+i,i) */

			i__1 = *n - *k + i__ - j;
			i__2 = *k - i__;
			d__1 = -tau[i__];
			dgemv_("Transpose", &i__1, &i__2, &d__1, &v[j + (i__ 
				+ 1) * v_dim1], ldv, &v[j + i__ * v_dim1], &
				c__1, &c_b7_dlarft, &t[i__ + 1 + i__ * t_dim1], &
				c__1);
		    } else {
/*                    Skip any leading zeros. */
			i__1 = i__ - 1;
			for (lastv = 1; lastv <= i__1; ++lastv) {
			    if (v[i__ + lastv * v_dim1] != 0.) {
				goto L298;
			    }
L298:
			    ;
			}
			i__1 = *k;
			for (j = i__ + 1; j <= i__1; ++j) {
			    t[j + i__ * t_dim1] = -tau[i__] * v[j + (*n - *k 
				    + i__) * v_dim1];
			}
			j = Dymola_max(lastv,prevlastv);

/*                    T(i+1:k,i) = -tau(i) * V(i+1:k,j:n-k+i) * V(i,j:n-k+i)**T */

			i__1 = *k - i__;
			i__2 = *n - *k + i__ - j;
			d__1 = -tau[i__];
			dgemv_("No transpose", &i__1, &i__2, &d__1, &v[i__ + 
				1 + j * v_dim1], ldv, &v[i__ + j * v_dim1], 
				ldv, &c_b7_dlarft, &t[i__ + 1 + i__ * t_dim1], &c__1);
		    }

/*                 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i) */

		    i__1 = *k - i__;
		    dtrmv_("Lower", "No transpose", "Non-unit", &i__1, &t[i__ 
			    + 1 + (i__ + 1) * t_dim1], ldt, &t[i__ + 1 + i__ *
			     t_dim1], &c__1)
			    ;
		    if (i__ > 1) {
			prevlastv = Dymola_min(prevlastv,lastv);
		    } else {
			prevlastv = lastv;
		    }
		}
		t[i__ + i__ * t_dim1] = tau[i__];
	    }
	}
    }
    return 0;

/*     End of DLARFT */

} /* dlarft_ */

/* Subroutine */ static int dladiv_(doublereal *a, doublereal *b, doublereal *c__, doublereal *d__, doublereal *p, doublereal *q)
{
    /* System generated locals */
    doublereal d__1, d__2;

    /* Local variables */
    doublereal s, aa, ab, bb, cc, cd, dd, be, un, ov, eps;

/*  -- LAPACK auxiliary routine (version 3.5.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     January 2013 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */

/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    aa = *a;
    bb = *b;
    cc = *c__;
    dd = *d__;
/* Computing MAX */
    d__1 = Dymola_abs(*a), d__2 = Dymola_abs(*b);
    ab = Dymola_max(d__1,d__2);
/* Computing MAX */
    d__1 = Dymola_abs(*c__), d__2 = Dymola_abs(*d__);
    cd = Dymola_max(d__1,d__2);
    s = 1.;
    ov = dlamch_("Overflow threshold");
    un = dlamch_("Safe minimum");
    eps = dlamch_("Epsilon");
    be = 2. / (eps * eps);
    if (ab >= ov * .5) {
	aa *= .5;
	bb *= .5;
	s *= 2.;
    }
    if (cd >= ov * .5) {
	cc *= .5;
	dd *= .5;
	s *= .5;
    }
    if (ab <= un * 2. / eps) {
	aa *= be;
	bb *= be;
	s /= be;
    }
    if (cd <= un * 2. / eps) {
	cc *= be;
	dd *= be;
	s *= be;
    }
    if (Dymola_abs(*d__) <= Dymola_abs(*c__)) {
	dladiv1_(&aa, &bb, &cc, &dd, p, q);
    } else {
	dladiv1_(&bb, &aa, &dd, &cc, p, q);
	*q = -(*q);
    }
    *p *= s;
    *q *= s;

    return 0;

/*     End of DLADIV */

} /* dladiv_ */

/* Subroutine */ static int dormhr_(const char* side, const char* trans, integer* m, integer* n, const integer* ilo, const integer* ihi, const doublereal* a, integer* lda, const doublereal* tau, doublereal* c__, integer* ldc, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1[2], i__2;
    char ch__1[2];

    /* Local variables */
    integer i1, i2, nb, mi, nh, ni, nq, nw;
    logical left;
    integer iinfo;
    integer lwkopt;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    nh = *ihi - *ilo;
    left = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
    lquery = *lwork == -1;

/*     NQ is the order of Q and NW is the minimum dimension of WORK */

    if (left) {
	nq = *m;
	nw = *n;
    } else {
	nq = *n;
	nw = *m;
    }
    if (! left && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
	    "T", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (*m < 0) {
	*info = -3;
    } else if (*n < 0) {
	*info = -4;
    } else if (*ilo < 1 || *ilo > Dymola_max(1,nq)) {
	*info = -5;
    } else if (*ihi < Dymola_min(*ilo,nq) || *ihi > nq) {
	*info = -6;
    } else if (*lda < Dymola_max(1,nq)) {
	*info = -8;
    } else if (*ldc < Dymola_max(1,*m)) {
	*info = -11;
    } else if (*lwork < Dymola_max(1,nw) && ! lquery) {
	*info = -13;
    }

    if (*info == 0) {
	if (left) {
/* Writing concatenation */
	    i__1[0] = 1, a__1[0] = side;
	    i__1[1] = 1, a__1[1] = trans;
	    s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
	    nb = ilaenv_(&c__1, "DORMQR", ch__1, &nh, n, &nh, &c_n1);
	} else {
/* Writing concatenation */
	    i__1[0] = 1, a__1[0] = side;
	    i__1[1] = 1, a__1[1] = trans;
	    s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)2);
	    nb = ilaenv_(&c__1, "DORMQR", ch__1, m, &nh, &nh, &c_n1);
	}
	lwkopt = Dymola_max(1,nw) * nb;
	work[1] = (doublereal) lwkopt;
    }

    if (*info != 0) {
	i__2 = -(*info);
	xerbla_("DORMHR", &i__2);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0 || nh == 0) {
	work[1] = 1.;
	return 0;
    }

    if (left) {
	mi = nh;
	ni = *n;
	i1 = *ilo + 1;
	i2 = 1;
    } else {
	mi = *m;
	ni = nh;
	i1 = 1;
	i2 = *ilo + 1;
    }

    dormqr_(side, trans, &mi, &ni, &nh, &a[*ilo + 1 + *ilo * a_dim1], lda, &
	    tau[*ilo], &c__[i1 + i2 * c_dim1], ldc, &work[1], lwork, &iinfo);

    work[1] = (doublereal) lwkopt;
    return 0;

/*     End of DORMHR */

} /* dormhr_ */

/* Subroutine */ static int dtrexc_(char* compq, integer* n, doublereal* t, integer* ldt, doublereal* q, integer* ldq, integer* ifst, integer* ilst, doublereal* work, integer* info)
{
    /* System generated locals */
    integer q_dim1, q_offset, t_dim1, t_offset, i__1;

    /* Local variables */
    integer nbf, nbl, here;
    logical wantq;
    integer nbnext;

/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode and test the input arguments. */

    /* Parameter adjustments */
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --work;

    /* Function Body */
    *info = 0;
    wantq = lsame_(compq, "V", (ftnlen)1, (ftnlen)1);
    if (! wantq && ! lsame_(compq, "N", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*ldt < Dymola_max(1,*n)) {
	*info = -4;
    } else if (*ldq < 1 || wantq && *ldq < Dymola_max(1,*n)) {
	*info = -6;
    } else if (*ifst < 1 || *ifst > *n) {
	*info = -7;
    } else if (*ilst < 1 || *ilst > *n) {
	*info = -8;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTREXC", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n <= 1) {
	return 0;
    }

/*     Determine the first row of specified block */
/*     and find out it is 1 by 1 or 2 by 2. */

    if (*ifst > 1) {
	if (t[*ifst + (*ifst - 1) * t_dim1] != 0.) {
	    --(*ifst);
	}
    }
    nbf = 1;
    if (*ifst < *n) {
	if (t[*ifst + 1 + *ifst * t_dim1] != 0.) {
	    nbf = 2;
	}
    }

/*     Determine the first row of the final block */
/*     and find out it is 1 by 1 or 2 by 2. */

    if (*ilst > 1) {
	if (t[*ilst + (*ilst - 1) * t_dim1] != 0.) {
	    --(*ilst);
	}
    }
    nbl = 1;
    if (*ilst < *n) {
	if (t[*ilst + 1 + *ilst * t_dim1] != 0.) {
	    nbl = 2;
	}
    }

    if (*ifst == *ilst) {
	return 0;
    }

    if (*ifst < *ilst) {

/*        Update ILST */

	if (nbf == 2 && nbl == 1) {
	    --(*ilst);
	}
	if (nbf == 1 && nbl == 2) {
	    ++(*ilst);
	}

	here = *ifst;

L10:

/*        Swap block with next one below */

	if (nbf == 1 || nbf == 2) {

/*           Current block either 1 by 1 or 2 by 2 */

	    nbnext = 1;
	    if (here + nbf + 1 <= *n) {
		if (t[here + nbf + 1 + (here + nbf) * t_dim1] != 0.) {
		    nbnext = 2;
		}
	    }
	    dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &here, &
		    nbf, &nbnext, &work[1], info);
	    if (*info != 0) {
		*ilst = here;
		return 0;
	    }
	    here += nbnext;

/*           Test if 2 by 2 block breaks into two 1 by 1 blocks */

	    if (nbf == 2) {
		if (t[here + 1 + here * t_dim1] == 0.) {
		    nbf = 3;
		}
	    }

	} else {

/*           Current block consists of two 1 by 1 blocks each of which */
/*           must be swapped individually */

	    nbnext = 1;
	    if (here + 3 <= *n) {
		if (t[here + 3 + (here + 2) * t_dim1] != 0.) {
		    nbnext = 2;
		}
	    }
	    i__1 = here + 1;
	    dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &i__1, &
		    c__1, &nbnext, &work[1], info);
	    if (*info != 0) {
		*ilst = here;
		return 0;
	    }
	    if (nbnext == 1) {

/*              Swap two 1 by 1 blocks, no problems possible */

		dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
			here, &c__1, &nbnext, &work[1], info);
		++here;
	    } else {

/*              Recompute NBNEXT in case 2 by 2 split */

		if (t[here + 2 + (here + 1) * t_dim1] == 0.) {
		    nbnext = 1;
		}
		if (nbnext == 2) {

/*                 2 by 2 Block did not split */

		    dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
			    here, &c__1, &nbnext, &work[1], info);
		    if (*info != 0) {
			*ilst = here;
			return 0;
		    }
		    here += 2;
		} else {

/*                 2 by 2 Block did split */

		    dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
			    here, &c__1, &c__1, &work[1], info);
		    i__1 = here + 1;
		    dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
			    i__1, &c__1, &c__1, &work[1], info);
		    here += 2;
		}
	    }
	}
	if (here < *ilst) {
	    goto L10;
	}

    } else {

	here = *ifst;
L20:

/*        Swap block with next one above */

	if (nbf == 1 || nbf == 2) {

/*           Current block either 1 by 1 or 2 by 2 */

	    nbnext = 1;
	    if (here >= 3) {
		if (t[here - 1 + (here - 2) * t_dim1] != 0.) {
		    nbnext = 2;
		}
	    }
	    i__1 = here - nbnext;
	    dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &i__1, &
		    nbnext, &nbf, &work[1], info);
	    if (*info != 0) {
		*ilst = here;
		return 0;
	    }
	    here -= nbnext;

/*           Test if 2 by 2 block breaks into two 1 by 1 blocks */

	    if (nbf == 2) {
		if (t[here + 1 + here * t_dim1] == 0.) {
		    nbf = 3;
		}
	    }

	} else {

/*           Current block consists of two 1 by 1 blocks each of which */
/*           must be swapped individually */

	    nbnext = 1;
	    if (here >= 3) {
		if (t[here - 1 + (here - 2) * t_dim1] != 0.) {
		    nbnext = 2;
		}
	    }
	    i__1 = here - nbnext;
	    dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &i__1, &
		    nbnext, &c__1, &work[1], info);
	    if (*info != 0) {
		*ilst = here;
		return 0;
	    }
	    if (nbnext == 1) {

/*              Swap two 1 by 1 blocks, no problems possible */

		dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
			here, &nbnext, &c__1, &work[1], info);
		--here;
	    } else {

/*              Recompute NBNEXT in case 2 by 2 split */

		if (t[here + (here - 1) * t_dim1] == 0.) {
		    nbnext = 1;
		}
		if (nbnext == 2) {

/*                 2 by 2 Block did not split */

		    i__1 = here - 1;
		    dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
			    i__1, &c__2, &c__1, &work[1], info);
		    if (*info != 0) {
			*ilst = here;
			return 0;
		    }
		    here += -2;
		} else {

/*                 2 by 2 Block did split */

		    dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
			    here, &c__1, &c__1, &work[1], info);
		    i__1 = here - 1;
		    dlaexc_(&wantq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
			    i__1, &c__1, &c__1, &work[1], info);
		    here += -2;
		}
	    }
	}
	if (here > *ilst) {
	    goto L20;
	}
    }
    *ilst = here;

    return 0;

/*     End of DTREXC */

} /* dtrexc_ */


/* Subroutine */ static int dlaqr1_(integer *n, doublereal *h__, integer *ldh, doublereal *sr1, doublereal *si1, doublereal *sr2, doublereal *si2, doublereal *v)
{
    /* System generated locals */
    integer h_dim1, h_offset;
    doublereal d__1, d__2, d__3;

    /* Local variables */
    doublereal s, h21s, h31s;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ================================================================ */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */
    /* Parameter adjustments */
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    --v;

    /* Function Body */
    if (*n == 2) {
	s = (d__1 = h__[h_dim1 + 1] - *sr2, Dymola_abs(d__1)) + Dymola_abs(*si2) + (d__2 = 
		h__[h_dim1 + 2], Dymola_abs(d__2));
	if (s == 0.) {
	    v[1] = 0.;
	    v[2] = 0.;
	} else {
	    h21s = h__[h_dim1 + 2] / s;
	    v[1] = h21s * h__[(h_dim1 << 1) + 1] + (h__[h_dim1 + 1] - *sr1) * 
		    ((h__[h_dim1 + 1] - *sr2) / s) - *si1 * (*si2 / s);
	    v[2] = h21s * (h__[h_dim1 + 1] + h__[(h_dim1 << 1) + 2] - *sr1 - *
		    sr2);
	}
    } else {
	s = (d__1 = h__[h_dim1 + 1] - *sr2, Dymola_abs(d__1)) + Dymola_abs(*si2) + (d__2 = 
		h__[h_dim1 + 2], Dymola_abs(d__2)) + (d__3 = h__[h_dim1 + 3], Dymola_abs(
		d__3));
	if (s == 0.) {
	    v[1] = 0.;
	    v[2] = 0.;
	    v[3] = 0.;
	} else {
	    h21s = h__[h_dim1 + 2] / s;
	    h31s = h__[h_dim1 + 3] / s;
	    v[1] = (h__[h_dim1 + 1] - *sr1) * ((h__[h_dim1 + 1] - *sr2) / s) 
		    - *si1 * (*si2 / s) + h__[(h_dim1 << 1) + 1] * h21s + h__[
		    h_dim1 * 3 + 1] * h31s;
	    v[2] = h21s * (h__[h_dim1 + 1] + h__[(h_dim1 << 1) + 2] - *sr1 - *
		    sr2) + h__[h_dim1 * 3 + 2] * h31s;
	    v[3] = h31s * (h__[h_dim1 + 1] + h__[h_dim1 * 3 + 3] - *sr1 - *
		    sr2) + h21s * h__[(h_dim1 << 1) + 3];
	}
    }
    return 0;
} /* dlaqr1_ */

/* Subroutine */ static int dlaqr2_(logical* wantt, logical* wantz, integer* n, integer* ktop, integer* kbot, integer* nw, doublereal* h__, integer* ldh, integer* iloz, integer* ihiz, doublereal* z__, integer* ldz, integer* ns, integer* nd, doublereal* sr, doublereal* si, doublereal* v, integer* ldv, integer* nh, doublereal* t, integer* ldt, integer* nv, doublereal* wv, integer* ldwv, doublereal* work, integer* lwork)
{
    /* System generated locals */
    integer h_dim1, h_offset, t_dim1, t_offset, v_dim1, v_offset, wv_dim1, 
	    wv_offset, z_dim1, z_offset, i__1, i__2, i__3, i__4;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6;

    /* Local variables */
    integer i__, j, k;
    doublereal s, aa, bb, cc, dd, cs, sn;
    integer jw;
    doublereal evi, evk, foo;
    integer kln;
    doublereal tau, ulp;
    integer lwk1, lwk2;
    doublereal beta;
    integer kend, kcol, info, ifst, ilst, ltop, krow;
    logical bulge;
    integer infqr, kwtop;
    doublereal safmin;
    doublereal safmax;
    logical sorted;
    doublereal smlnum;
    integer lwkopt;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ================================================================ */
/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     ==== Estimate optimal workspace. ==== */

    /* Parameter adjustments */
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --sr;
    --si;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    wv_dim1 = *ldwv;
    wv_offset = 1 + wv_dim1;
    wv -= wv_offset;
    --work;

    /* Function Body */
/* Computing MIN */
    i__1 = *nw, i__2 = *kbot - *ktop + 1;
    jw = Dymola_min(i__1,i__2);
    if (jw <= 2) {
	lwkopt = 1;
    } else {

/*        ==== Workspace query call to DGEHRD ==== */

	i__1 = jw - 1;
	dgehrd_(&jw, &c__1, &i__1, &t[t_offset], ldt, &work[1], &work[1], &
		c_n1, &info);
	lwk1 = (integer) work[1];

/*        ==== Workspace query call to DORMHR ==== */

	i__1 = jw - 1;
	dormhr_("R", "N", &jw, &jw, &c__1, &i__1, &t[t_offset], ldt, &work[1],
		 &v[v_offset], ldv, &work[1], &c_n1, &info);
	lwk2 = (integer) work[1];

/*        ==== Optimal workspace ==== */

	lwkopt = jw + Dymola_max(lwk1,lwk2);
    }

/*     ==== Quick return in case of workspace query. ==== */

    if (*lwork == -1) {
	work[1] = (doublereal) lwkopt;
	return 0;
    }

/*     ==== Nothing to do ... */
/*     ... for an empty active block ... ==== */
    *ns = 0;
    *nd = 0;
    work[1] = 1.;
    if (*ktop > *kbot) {
	return 0;
    }
/*     ... nor for an empty deflation window. ==== */
    if (*nw < 1) {
	return 0;
    }

/*     ==== Machine constants ==== */

    safmin = dlamch_("SAFE MINIMUM");
    safmax = 1. / safmin;
    dlabad_(&safmin, &safmax);
    ulp = dlamch_("PRECISION");
    smlnum = safmin * ((doublereal) (*n) / ulp);

/*     ==== Setup deflation window ==== */

/* Computing MIN */
    i__1 = *nw, i__2 = *kbot - *ktop + 1;
    jw = Dymola_min(i__1,i__2);
    kwtop = *kbot - jw + 1;
    if (kwtop == *ktop) {
	s = 0.;
    } else {
	s = h__[kwtop + (kwtop - 1) * h_dim1];
    }

    if (*kbot == kwtop) {

/*        ==== 1-by-1 deflation window: not much to do ==== */

	sr[kwtop] = h__[kwtop + kwtop * h_dim1];
	si[kwtop] = 0.;
	*ns = 1;
	*nd = 0;
/* Computing MAX */
	d__2 = smlnum, d__3 = ulp * (d__1 = h__[kwtop + kwtop * h_dim1], Dymola_abs(
		d__1));
	if (Dymola_abs(s) <= Dymola_max(d__2,d__3)) {
	    *ns = 0;
	    *nd = 1;
	    if (kwtop > *ktop) {
		h__[kwtop + (kwtop - 1) * h_dim1] = 0.;
	    }
	}
	work[1] = 1.;
	return 0;
    }

/*     ==== Convert to spike-triangular form.  (In case of a */
/*     .    rare QR failure, this routine continues to do */
/*     .    aggressive early deflation using that part of */
/*     .    the deflation window that converged using INFQR */
/*     .    here and there to keep track.) ==== */

    dlacpy_("U", &jw, &jw, &h__[kwtop + kwtop * h_dim1], ldh, &t[t_offset], 
	    ldt);
    i__1 = jw - 1;
    i__2 = *ldh + 1;
    i__3 = *ldt + 1;
    dcopy_(&i__1, &h__[kwtop + 1 + kwtop * h_dim1], &i__2, &t[t_dim1 + 2], &
	    i__3);

    dlaset_("A", &jw, &jw, &c_b12_dlaqr2, &c_b13, &v[v_offset], ldv);
    dlahqr_(&c_true, &c_true, &jw, &c__1, &jw, &t[t_offset], ldt, &sr[kwtop], 
	    &si[kwtop], &c__1, &jw, &v[v_offset], ldv, &infqr);

/*     ==== DTREXC needs a clean margin near the diagonal ==== */

    i__1 = jw - 3;
    for (j = 1; j <= i__1; ++j) {
	t[j + 2 + j * t_dim1] = 0.;
	t[j + 3 + j * t_dim1] = 0.;
/* L10: */
    }
    if (jw > 2) {
	t[jw + (jw - 2) * t_dim1] = 0.;
    }

/*     ==== Deflation detection loop ==== */

    *ns = jw;
    ilst = infqr + 1;
L20:
    if (ilst <= *ns) {
	if (*ns == 1) {
	    bulge = FALSE_;
	} else {
	    bulge = t[*ns + (*ns - 1) * t_dim1] != 0.;
	}

/*        ==== Small spike tip test for deflation ==== */

	if (! bulge) {

/*           ==== Real eigenvalue ==== */

	    foo = (d__1 = t[*ns + *ns * t_dim1], Dymola_abs(d__1));
	    if (foo == 0.) {
		foo = Dymola_abs(s);
	    }
/* Computing MAX */
	    d__2 = smlnum, d__3 = ulp * foo;
	    if ((d__1 = s * v[*ns * v_dim1 + 1], Dymola_abs(d__1)) <= Dymola_max(d__2,d__3))
		     {

/*              ==== Deflatable ==== */

		--(*ns);
	    } else {

/*              ==== Undeflatable.   Move it up out of the way. */
/*              .    (DTREXC can not fail in this case.) ==== */

		ifst = *ns;
		dtrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
			 &ilst, &work[1], &info);
		++ilst;
	    }
	} else {

/*           ==== Complex conjugate pair ==== */

	    foo = (d__3 = t[*ns + *ns * t_dim1], Dymola_abs(d__3)) + sqrt((d__1 = t[*
		    ns + (*ns - 1) * t_dim1], Dymola_abs(d__1))) * sqrt((d__2 = t[*
		    ns - 1 + *ns * t_dim1], Dymola_abs(d__2)));
	    if (foo == 0.) {
		foo = Dymola_abs(s);
	    }
/* Computing MAX */
	    d__3 = (d__1 = s * v[*ns * v_dim1 + 1], Dymola_abs(d__1)), d__4 = (d__2 =
		     s * v[(*ns - 1) * v_dim1 + 1], Dymola_abs(d__2));
/* Computing MAX */
	    d__5 = smlnum, d__6 = ulp * foo;
	    if (Dymola_max(d__3,d__4) <= Dymola_max(d__5,d__6)) {

/*              ==== Deflatable ==== */

		*ns += -2;
	    } else {

/*              ==== Undeflatable. Move them up out of the way. */
/*              .    Fortunately, DTREXC does the right thing with */
/*              .    ILST in case of a rare exchange failure. ==== */

		ifst = *ns;
		dtrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
			 &ilst, &work[1], &info);
		ilst += 2;
	    }
	}

/*        ==== End deflation detection loop ==== */

	goto L20;
    }

/*        ==== Return to Hessenberg form ==== */

    if (*ns == 0) {
	s = 0.;
    }

    if (*ns < jw) {

/*        ==== sorting diagonal blocks of T improves accuracy for */
/*        .    graded matrices.  Bubble sort deals well with */
/*        .    exchange failures. ==== */

	sorted = FALSE_;
	i__ = *ns + 1;
L30:
	if (sorted) {
	    goto L50;
	}
	sorted = TRUE_;

	kend = i__ - 1;
	i__ = infqr + 1;
	if (i__ == *ns) {
	    k = i__ + 1;
	} else if (t[i__ + 1 + i__ * t_dim1] == 0.) {
	    k = i__ + 1;
	} else {
	    k = i__ + 2;
	}
L40:
	if (k <= kend) {
	    if (k == i__ + 1) {
		evi = (d__1 = t[i__ + i__ * t_dim1], Dymola_abs(d__1));
	    } else {
		evi = (d__3 = t[i__ + i__ * t_dim1], Dymola_abs(d__3)) + sqrt((d__1 =
			 t[i__ + 1 + i__ * t_dim1], Dymola_abs(d__1))) * sqrt((d__2 =
			 t[i__ + (i__ + 1) * t_dim1], Dymola_abs(d__2)));
	    }

	    if (k == kend) {
		evk = (d__1 = t[k + k * t_dim1], Dymola_abs(d__1));
	    } else if (t[k + 1 + k * t_dim1] == 0.) {
		evk = (d__1 = t[k + k * t_dim1], Dymola_abs(d__1));
	    } else {
		evk = (d__3 = t[k + k * t_dim1], Dymola_abs(d__3)) + sqrt((d__1 = t[
			k + 1 + k * t_dim1], Dymola_abs(d__1))) * sqrt((d__2 = t[k + 
			(k + 1) * t_dim1], Dymola_abs(d__2)));
	    }

	    if (evi >= evk) {
		i__ = k;
	    } else {
		sorted = FALSE_;
		ifst = i__;
		ilst = k;
		dtrexc_("V", &jw, &t[t_offset], ldt, &v[v_offset], ldv, &ifst,
			 &ilst, &work[1], &info);
		if (info == 0) {
		    i__ = ilst;
		} else {
		    i__ = k;
		}
	    }
	    if (i__ == kend) {
		k = i__ + 1;
	    } else if (t[i__ + 1 + i__ * t_dim1] == 0.) {
		k = i__ + 1;
	    } else {
		k = i__ + 2;
	    }
	    goto L40;
	}
	goto L30;
L50:
	;
    }

/*     ==== Restore shift/eigenvalue array from T ==== */

    i__ = jw;
L60:
    if (i__ >= infqr + 1) {
	if (i__ == infqr + 1) {
	    sr[kwtop + i__ - 1] = t[i__ + i__ * t_dim1];
	    si[kwtop + i__ - 1] = 0.;
	    --i__;
	} else if (t[i__ + (i__ - 1) * t_dim1] == 0.) {
	    sr[kwtop + i__ - 1] = t[i__ + i__ * t_dim1];
	    si[kwtop + i__ - 1] = 0.;
	    --i__;
	} else {
	    aa = t[i__ - 1 + (i__ - 1) * t_dim1];
	    cc = t[i__ + (i__ - 1) * t_dim1];
	    bb = t[i__ - 1 + i__ * t_dim1];
	    dd = t[i__ + i__ * t_dim1];
	    dlanv2_(&aa, &bb, &cc, &dd, &sr[kwtop + i__ - 2], &si[kwtop + i__ 
		    - 2], &sr[kwtop + i__ - 1], &si[kwtop + i__ - 1], &cs, &
		    sn);
	    i__ += -2;
	}
	goto L60;
    }

    if (*ns < jw || s == 0.) {
	if (*ns > 1 && s != 0.) {

/*           ==== Reflect spike back into lower triangle ==== */

	    dcopy_(ns, &v[v_offset], ldv, &work[1], &c__1);
	    beta = work[1];
	    dlarfg_(ns, &beta, &work[2], &c__1, &tau);
	    work[1] = 1.;

	    i__1 = jw - 2;
	    i__2 = jw - 2;
	    dlaset_("L", &i__1, &i__2, &c_b12_dlaqr2, &c_b12_dlaqr2, &t[t_dim1 + 3], ldt);

	    dlarf_("L", ns, &jw, &work[1], &c__1, &tau, &t[t_offset], ldt, &
		    work[jw + 1]);
	    dlarf_("R", ns, ns, &work[1], &c__1, &tau, &t[t_offset], ldt, &
		    work[jw + 1]);
	    dlarf_("R", &jw, ns, &work[1], &c__1, &tau, &v[v_offset], ldv, &
		    work[jw + 1]);

	    i__1 = *lwork - jw;
	    dgehrd_(&jw, &c__1, ns, &t[t_offset], ldt, &work[1], &work[jw + 1]
		    , &i__1, &info);
	}

/*        ==== Copy updated reduced window into place ==== */

	if (kwtop > 1) {
	    h__[kwtop + (kwtop - 1) * h_dim1] = s * v[v_dim1 + 1];
	}
	dlacpy_("U", &jw, &jw, &t[t_offset], ldt, &h__[kwtop + kwtop * h_dim1]
		, ldh);
	i__1 = jw - 1;
	i__2 = *ldt + 1;
	i__3 = *ldh + 1;
	dcopy_(&i__1, &t[t_dim1 + 2], &i__2, &h__[kwtop + 1 + kwtop * h_dim1],
		 &i__3);

/*        ==== Accumulate orthogonal matrix in order update */
/*        .    H and Z, if requested.  ==== */

	if (*ns > 1 && s != 0.) {
	    i__1 = *lwork - jw;
	    dormhr_("R", "N", &jw, ns, &c__1, ns, &t[t_offset], ldt, &work[1],
		     &v[v_offset], ldv, &work[jw + 1], &i__1, &info);
	}

/*        ==== Update vertical slab in H ==== */

	if (*wantt) {
	    ltop = 1;
	} else {
	    ltop = *ktop;
	}
	i__1 = kwtop - 1;
	i__2 = *nv;
	for (krow = ltop; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow += 
		i__2) {
/* Computing MIN */
	    i__3 = *nv, i__4 = kwtop - krow;
	    kln = Dymola_min(i__3,i__4);
	    dgemm_("N", "N", &kln, &jw, &jw, &c_b13, &h__[krow + kwtop * 
		    h_dim1], ldh, &v[v_offset], ldv, &c_b12_dlaqr2, &wv[wv_offset], 
		    ldwv);
	    dlacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &h__[krow + kwtop * 
		    h_dim1], ldh);
/* L70: */
	}

/*        ==== Update horizontal slab in H ==== */

	if (*wantt) {
	    i__2 = *n;
	    i__1 = *nh;
	    for (kcol = *kbot + 1; i__1 < 0 ? kcol >= i__2 : kcol <= i__2; 
		    kcol += i__1) {
/* Computing MIN */
		i__3 = *nh, i__4 = *n - kcol + 1;
		kln = Dymola_min(i__3,i__4);
		dgemm_("C", "N", &jw, &kln, &jw, &c_b13, &v[v_offset], ldv, &
			h__[kwtop + kcol * h_dim1], ldh, &c_b12_dlaqr2, &t[t_offset],
			 ldt);
		dlacpy_("A", &jw, &kln, &t[t_offset], ldt, &h__[kwtop + kcol *
			 h_dim1], ldh);
/* L80: */
	    }
	}

/*        ==== Update vertical slab in Z ==== */

	if (*wantz) {
	    i__1 = *ihiz;
	    i__2 = *nv;
	    for (krow = *iloz; i__2 < 0 ? krow >= i__1 : krow <= i__1; krow +=
		     i__2) {
/* Computing MIN */
		i__3 = *nv, i__4 = *ihiz - krow + 1;
		kln = Dymola_min(i__3,i__4);
		dgemm_("N", "N", &kln, &jw, &jw, &c_b13, &z__[krow + kwtop * 
			z_dim1], ldz, &v[v_offset], ldv, &c_b12_dlaqr2, &wv[
			wv_offset], ldwv);
		dlacpy_("A", &kln, &jw, &wv[wv_offset], ldwv, &z__[krow + 
			kwtop * z_dim1], ldz);
/* L90: */
	    }
	}
    }

/*     ==== Return the number of deflations ... ==== */

    *nd = jw - *ns;

/*     ==== ... and the number of shifts. (Subtracting */
/*     .    INFQR from the spike length takes care */
/*     .    of the case of a rare QR failure while */
/*     .    calculating eigenvalues of the deflation */
/*     .    window.)  ==== */

    *ns -= infqr;

/*      ==== Return optimal workspace. ==== */

    work[1] = (doublereal) lwkopt;

/*     ==== End of DLAQR2 ==== */

    return 0;
} /* dlaqr2_ */

/* Subroutine */ static int dormqr_(const char* side, const char* trans, integer* m, integer* n, integer* k, const doublereal* a, integer* lda, const doublereal* tau, doublereal* c__, integer* ldc, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4, 
	    i__5;
    char ch__1[2];

    /* Local variables */
    integer i__;
    doublereal t[4160]	/* was [65][64] */;
    integer i1, i2, i3, ib, ic, jc, nb, mi, ni, nq, nw, iws;
    logical left;
    integer nbmin, iinfo;
    logical notran;
    integer ldwork, lwkopt;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
    notran = lsame_(trans, "N", (ftnlen)1, (ftnlen)1);
    lquery = *lwork == -1;

/*     NQ is the order of Q and NW is the minimum dimension of WORK */

    if (left) {
	nq = *m;
	nw = *n;
    } else {
	nq = *n;
	nw = *m;
    }
    if (! left && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! notran && ! lsame_(trans, "T", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (*m < 0) {
	*info = -3;
    } else if (*n < 0) {
	*info = -4;
    } else if (*k < 0 || *k > nq) {
	*info = -5;
    } else if (*lda < Dymola_max(1,nq)) {
	*info = -7;
    } else if (*ldc < Dymola_max(1,*m)) {
	*info = -10;
    } else if (*lwork < Dymola_max(1,nw) && ! lquery) {
	*info = -12;
    }

    if (*info == 0) {

/*        Determine the block size.  NB may be at most NBMAX, where NBMAX */
/*        is used to define the local array T. */

/* Computing MIN */
/* Writing concatenation */
	i__3[0] = 1, a__1[0] = side;
	i__3[1] = 1, a__1[1] = trans;
	s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
	i__1 = 64, i__2 = ilaenv_(&c__1, "DORMQR", ch__1, m, n, k, &c_n1);
	nb = Dymola_min(i__1,i__2);
	lwkopt = Dymola_max(1,nw) * nb;
	work[1] = (doublereal) lwkopt;
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DORMQR", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0 || *k == 0) {
	work[1] = 1.;
	return 0;
    }

    nbmin = 2;
    ldwork = nw;
    if (nb > 1 && nb < *k) {
	iws = nw * nb;
	if (*lwork < iws) {
	    nb = *lwork / ldwork;
/* Computing MAX */
/* Writing concatenation */
	    i__3[0] = 1, a__1[0] = side;
	    i__3[1] = 1, a__1[1] = trans;
	    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
	    i__1 = 2, i__2 = ilaenv_(&c__2, "DORMQR", ch__1, m, n, k, &c_n1);
	    nbmin = Dymola_max(i__1,i__2);
	}
    } else {
	iws = nw;
    }

    if (nb < nbmin || nb >= *k) {

/*        Use unblocked code */

      dorm2r_((char*) side, (char*) trans, m, n, k, (doublereal*) &a[a_offset], lda, (doublereal*) &tau[1], &c__[c_offset], ldc, &work[1], &iinfo);
    } else {

/*        Use blocked code */

	if (left && ! notran || ! left && notran) {
	    i1 = 1;
	    i2 = *k;
	    i3 = nb;
	} else {
	    i1 = (*k - 1) / nb * nb + 1;
	    i2 = 1;
	    i3 = -nb;
	}

	if (left) {
	    ni = *n;
	    jc = 1;
	} else {
	    mi = *m;
	    ic = 1;
	}

	i__1 = i2;
	i__2 = i3;
	for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
	    i__4 = nb, i__5 = *k - i__ + 1;
	    ib = Dymola_min(i__4,i__5);

/*           Form the triangular factor of the block reflector */
/*           H = H(i) H(i+1) . . . H(i+ib-1) */

	    i__4 = nq - i__ + 1;
	    dlarft_("Forward", "Columnwise", &i__4, &ib, (doublereal*) &a[i__ + i__ *  a_dim1], lda, (doublereal*) &tau[i__], t, &c__65);
	    if (left) {

/*              H or H**T is applied to C(i:m,1:n) */

		mi = *m - i__ + 1;
		ic = i__;
	    } else {

/*              H or H**T is applied to C(1:m,i:n) */

		ni = *n - i__ + 1;
		jc = i__;
	    }

/*           Apply H or H**T */

	    dlarfb_((char*) side, (char*) trans, "Forward", "Columnwise", &mi, &ni, &ib, (doublereal*) &a[
		    i__ + i__ * a_dim1], lda, t, &c__65, &c__[ic + jc * 
		    c_dim1], ldc, &work[1], &ldwork);
/* L10: */
	}
    }
    work[1] = (doublereal) lwkopt;
    return 0;

/*     End of DORMQR */

} /* dormqr_ */

/* Subroutine */ static int dlaexc_(logical* wantq, integer* n, doublereal* t, integer* ldt, doublereal* q, integer* ldq, integer* j1, integer* n1, integer* n2, doublereal* work, integer* info)
{
    /* System generated locals */
    integer q_dim1, q_offset, t_dim1, t_offset, i__1;
    doublereal d__1, d__2, d__3;

    /* Local variables */
    doublereal d__[16]	/* was [4][4] */;
    integer k;
    doublereal u[3], x[4]	/* was [2][2] */;
    integer j2, j3, j4;
    doublereal u1[3], u2[3];
    integer nd;
    doublereal cs, t11, t22, t33, sn, wi1, wi2, wr1, wr2, eps, tau, tau1, 
	    tau2;
    integer ierr;
    doublereal temp;
    doublereal scale, dnorm, xnorm;
    doublereal thresh, smlnum;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --work;

    /* Function Body */
    *info = 0;

/*     Quick return if possible */

    if (*n == 0 || *n1 == 0 || *n2 == 0) {
	return 0;
    }
    if (*j1 + *n1 > *n) {
	return 0;
    }

    j2 = *j1 + 1;
    j3 = *j1 + 2;
    j4 = *j1 + 3;

    if (*n1 == 1 && *n2 == 1) {

/*        Swap two 1-by-1 blocks. */

	t11 = t[*j1 + *j1 * t_dim1];
	t22 = t[j2 + j2 * t_dim1];

/*        Determine the transformation to perform the interchange. */

	d__1 = t22 - t11;
	dlartg_(&t[*j1 + j2 * t_dim1], &d__1, &cs, &sn, &temp);

/*        Apply transformation to the matrix T. */

	if (j3 <= *n) {
	    i__1 = *n - *j1 - 1;
	    drot_(&i__1, &t[*j1 + j3 * t_dim1], ldt, &t[j2 + j3 * t_dim1], 
		    ldt, &cs, &sn);
	}
	i__1 = *j1 - 1;
	drot_(&i__1, &t[*j1 * t_dim1 + 1], &c__1, &t[j2 * t_dim1 + 1], &c__1, 
		&cs, &sn);

	t[*j1 + *j1 * t_dim1] = t22;
	t[j2 + j2 * t_dim1] = t11;

	if (*wantq) {

/*           Accumulate transformation in the matrix Q. */

	    drot_(n, &q[*j1 * q_dim1 + 1], &c__1, &q[j2 * q_dim1 + 1], &c__1, 
		    &cs, &sn);
	}

    } else {

/*        Swapping involves at least one 2-by-2 block. */

/*        Copy the diagonal block of order N1+N2 to the local array D */
/*        and compute its norm. */

	nd = *n1 + *n2;
	dlacpy_("Full", &nd, &nd, &t[*j1 + *j1 * t_dim1], ldt, d__, &c__4);
	dnorm = dlange_("Max", &nd, &nd, d__, &c__4, &work[1]);

/*        Compute machine-dependent threshold for test for accepting */
/*        swap. */

	eps = dlamch_("P");
	smlnum = dlamch_("S") / eps;
/* Computing MAX */
	d__1 = eps * 10. * dnorm;
	thresh = Dymola_max(d__1,smlnum);

/*        Solve T11*X - X*T22 = scale*T12 for X. */

	dlasy2_(&c_false, &c_false, &c_n1, n1, n2, d__, &c__4, &d__[*n1 + 1 + 
		(*n1 + 1 << 2) - 5], &c__4, &d__[(*n1 + 1 << 2) - 4], &c__4, &
		scale, x, &c__2, &xnorm, &ierr);

/*        Swap the adjacent diagonal blocks. */

	k = *n1 + *n1 + *n2 - 3;
	switch (k) {
	    case 1:  goto L10;
	    case 2:  goto L20;
	    case 3:  goto L30;
	}

L10:

/*        N1 = 1, N2 = 2: generate elementary reflector H so that: */

/*        ( scale, X11, X12 ) H = ( 0, 0, * ) */

	u[0] = scale;
	u[1] = x[0];
	u[2] = x[2];
	dlarfg_(&c__3, &u[2], u, &c__1, &tau);
	u[2] = 1.;
	t11 = t[*j1 + *j1 * t_dim1];

/*        Perform swap provisionally on diagonal block in D. */

	dlarfx_("L", &c__3, &c__3, u, &tau, d__, &c__4, &work[1]);
	dlarfx_("R", &c__3, &c__3, u, &tau, d__, &c__4, &work[1]);

/*        Test whether to reject swap. */

/* Computing MAX */
	d__2 = Dymola_abs(d__[2]), d__3 = Dymola_abs(d__[6]), d__2 = Dymola_max(d__2,d__3), d__3 = 
		(d__1 = d__[10] - t11, Dymola_abs(d__1));
	if (Dymola_max(d__2,d__3) > thresh) {
	    goto L50;
	}

/*        Accept swap: apply transformation to the entire matrix T. */

	i__1 = *n - *j1 + 1;
	dlarfx_("L", &c__3, &i__1, u, &tau, &t[*j1 + *j1 * t_dim1], ldt, &
		work[1]);
	dlarfx_("R", &j2, &c__3, u, &tau, &t[*j1 * t_dim1 + 1], ldt, &work[1]);

	t[j3 + *j1 * t_dim1] = 0.;
	t[j3 + j2 * t_dim1] = 0.;
	t[j3 + j3 * t_dim1] = t11;

	if (*wantq) {

/*           Accumulate transformation in the matrix Q. */

	    dlarfx_("R", n, &c__3, u, &tau, &q[*j1 * q_dim1 + 1], ldq, &work[
		    1]);
	}
	goto L40;

L20:

/*        N1 = 2, N2 = 1: generate elementary reflector H so that: */

/*        H (  -X11 ) = ( * ) */
/*          (  -X21 ) = ( 0 ) */
/*          ( scale ) = ( 0 ) */

	u[0] = -x[0];
	u[1] = -x[1];
	u[2] = scale;
	dlarfg_(&c__3, u, &u[1], &c__1, &tau);
	u[0] = 1.;
	t33 = t[j3 + j3 * t_dim1];

/*        Perform swap provisionally on diagonal block in D. */

	dlarfx_("L", &c__3, &c__3, u, &tau, d__, &c__4, &work[1]);
	dlarfx_("R", &c__3, &c__3, u, &tau, d__, &c__4, &work[1]);

/*        Test whether to reject swap. */

/* Computing MAX */
	d__2 = Dymola_abs(d__[1]), d__3 = Dymola_abs(d__[2]), d__2 = Dymola_max(d__2,d__3), d__3 = 
		(d__1 = d__[0] - t33, Dymola_abs(d__1));
	if (Dymola_max(d__2,d__3) > thresh) {
	    goto L50;
	}

/*        Accept swap: apply transformation to the entire matrix T. */

	dlarfx_("R", &j3, &c__3, u, &tau, &t[*j1 * t_dim1 + 1], ldt, &work[1]);
	i__1 = *n - *j1;
	dlarfx_("L", &c__3, &i__1, u, &tau, &t[*j1 + j2 * t_dim1], ldt, &work[
		1]);

	t[*j1 + *j1 * t_dim1] = t33;
	t[j2 + *j1 * t_dim1] = 0.;
	t[j3 + *j1 * t_dim1] = 0.;

	if (*wantq) {

/*           Accumulate transformation in the matrix Q. */

	    dlarfx_("R", n, &c__3, u, &tau, &q[*j1 * q_dim1 + 1], ldq, &work[
		    1]);
	}
	goto L40;

L30:

/*        N1 = 2, N2 = 2: generate elementary reflectors H(1) and H(2) so */
/*        that: */

/*        H(2) H(1) (  -X11  -X12 ) = (  *  * ) */
/*                  (  -X21  -X22 )   (  0  * ) */
/*                  ( scale    0  )   (  0  0 ) */
/*                  (    0  scale )   (  0  0 ) */

	u1[0] = -x[0];
	u1[1] = -x[1];
	u1[2] = scale;
	dlarfg_(&c__3, u1, &u1[1], &c__1, &tau1);
	u1[0] = 1.;

	temp = -tau1 * (x[2] + u1[1] * x[3]);
	u2[0] = -temp * u1[1] - x[3];
	u2[1] = -temp * u1[2];
	u2[2] = scale;
	dlarfg_(&c__3, u2, &u2[1], &c__1, &tau2);
	u2[0] = 1.;

/*        Perform swap provisionally on diagonal block in D. */

	dlarfx_("L", &c__3, &c__4, u1, &tau1, d__, &c__4, &work[1])
		;
	dlarfx_("R", &c__4, &c__3, u1, &tau1, d__, &c__4, &work[1])
		;
	dlarfx_("L", &c__3, &c__4, u2, &tau2, &d__[1], &c__4, &work[1]);
	dlarfx_("R", &c__4, &c__3, u2, &tau2, &d__[4], &c__4, &work[1]);

/*        Test whether to reject swap. */

/* Computing MAX */
	d__1 = Dymola_abs(d__[2]), d__2 = Dymola_abs(d__[6]), d__1 = Dymola_max(d__1,d__2), d__2 = 
		Dymola_abs(d__[3]), d__1 = Dymola_max(d__1,d__2), d__2 = Dymola_abs(d__[7]);
	if (Dymola_max(d__1,d__2) > thresh) {
	    goto L50;
	}

/*        Accept swap: apply transformation to the entire matrix T. */

	i__1 = *n - *j1 + 1;
	dlarfx_("L", &c__3, &i__1, u1, &tau1, &t[*j1 + *j1 * t_dim1], ldt, &
		work[1]);
	dlarfx_("R", &j4, &c__3, u1, &tau1, &t[*j1 * t_dim1 + 1], ldt, &work[
		1]);
	i__1 = *n - *j1 + 1;
	dlarfx_("L", &c__3, &i__1, u2, &tau2, &t[j2 + *j1 * t_dim1], ldt, &
		work[1]);
	dlarfx_("R", &j4, &c__3, u2, &tau2, &t[j2 * t_dim1 + 1], ldt, &work[1]);

	t[j3 + *j1 * t_dim1] = 0.;
	t[j3 + j2 * t_dim1] = 0.;
	t[j4 + *j1 * t_dim1] = 0.;
	t[j4 + j2 * t_dim1] = 0.;

	if (*wantq) {

/*           Accumulate transformation in the matrix Q. */

	    dlarfx_("R", n, &c__3, u1, &tau1, &q[*j1 * q_dim1 + 1], ldq, &
		    work[1]);
	    dlarfx_("R", n, &c__3, u2, &tau2, &q[j2 * q_dim1 + 1], ldq, &work[
		    1]);
	}

L40:

	if (*n2 == 2) {

/*           Standardize new 2-by-2 block T11 */

	    dlanv2_(&t[*j1 + *j1 * t_dim1], &t[*j1 + j2 * t_dim1], &t[j2 + *
		    j1 * t_dim1], &t[j2 + j2 * t_dim1], &wr1, &wi1, &wr2, &
		    wi2, &cs, &sn);
	    i__1 = *n - *j1 - 1;
	    drot_(&i__1, &t[*j1 + (*j1 + 2) * t_dim1], ldt, &t[j2 + (*j1 + 2) 
		    * t_dim1], ldt, &cs, &sn);
	    i__1 = *j1 - 1;
	    drot_(&i__1, &t[*j1 * t_dim1 + 1], &c__1, &t[j2 * t_dim1 + 1], &
		    c__1, &cs, &sn);
	    if (*wantq) {
		drot_(n, &q[*j1 * q_dim1 + 1], &c__1, &q[j2 * q_dim1 + 1], &
			c__1, &cs, &sn);
	    }
	}

	if (*n1 == 2) {

/*           Standardize new 2-by-2 block T22 */

	    j3 = *j1 + *n2;
	    j4 = j3 + 1;
	    dlanv2_(&t[j3 + j3 * t_dim1], &t[j3 + j4 * t_dim1], &t[j4 + j3 * 
		    t_dim1], &t[j4 + j4 * t_dim1], &wr1, &wi1, &wr2, &wi2, &
		    cs, &sn);
	    if (j3 + 2 <= *n) {
		i__1 = *n - j3 - 1;
		drot_(&i__1, &t[j3 + (j3 + 2) * t_dim1], ldt, &t[j4 + (j3 + 2)
			 * t_dim1], ldt, &cs, &sn);
	    }
	    i__1 = j3 - 1;
	    drot_(&i__1, &t[j3 * t_dim1 + 1], &c__1, &t[j4 * t_dim1 + 1], &
		    c__1, &cs, &sn);
	    if (*wantq) {
		drot_(n, &q[j3 * q_dim1 + 1], &c__1, &q[j4 * q_dim1 + 1], &
			c__1, &cs, &sn);
	    }
	}

    }
    return 0;

/*     Exit with INFO = 1 if swap was rejected. */

L50:
    *info = 1;
    return 0;

/*     End of DLAEXC */

} /* dlaexc_ */

/* Subroutine */ static int dlasy2_(logical* ltranl, logical* ltranr, integer* isgn, integer* n1, integer* n2, doublereal* tl, integer* ldtl, doublereal* tr, integer* ldtr, doublereal* b, integer* ldb, doublereal* scale, doublereal* x, integer* ldx, doublereal* xnorm, integer* info)
{
    /* Initialized data */

    static integer locu12[4] = { 3,4,1,2 };
    static integer locl21[4] = { 2,1,4,3 };
    static integer locu22[4] = { 4,3,2,1 };
    static logical xswpiv[4] = { FALSE_,FALSE_,TRUE_,TRUE_ };
    static logical bswpiv[4] = { FALSE_,TRUE_,FALSE_,TRUE_ };

    /* System generated locals */
    integer b_dim1, b_offset, tl_dim1, tl_offset, tr_dim1, tr_offset, x_dim1, 
	    x_offset;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6, d__7, d__8;

    /* Local variables */
    integer i__, j, k;
    doublereal x2[2], l21, u11, u12;
    integer ip, jp;
    doublereal u22, t16[16]	/* was [4][4] */, gam, bet, eps, sgn, tmp[4], 
	    tau1, btmp[4], smin;
    integer ipiv;
    doublereal temp;
    integer jpiv[4];
    doublereal xmax;
    integer ipsv, jpsv;
    logical bswap;
    logical xswap;
    doublereal smlnum;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/* ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Data statements .. */
    /* Parameter adjustments */
    tl_dim1 = *ldtl;
    tl_offset = 1 + tl_dim1;
    tl -= tl_offset;
    tr_dim1 = *ldtr;
    tr_offset = 1 + tr_dim1;
    tr -= tr_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    x_dim1 = *ldx;
    x_offset = 1 + x_dim1;
    x -= x_offset;

    /* Function Body */
/*     .. */
/*     .. Executable Statements .. */

/*     Do not check the input parameters for errors */

    *info = 0;

/*     Quick return if possible */

    if (*n1 == 0 || *n2 == 0) {
	return 0;
    }

/*     Set constants to control overflow */

    eps = dlamch_("P");
    smlnum = dlamch_("S") / eps;
    sgn = (doublereal) (*isgn);

    k = *n1 + *n1 + *n2 - 2;
    switch (k) {
	case 1:  goto L10;
	case 2:  goto L20;
	case 3:  goto L30;
	case 4:  goto L50;
    }

/*     1 by 1: TL11*X + SGN*X*TR11 = B11 */

L10:
    tau1 = tl[tl_dim1 + 1] + sgn * tr[tr_dim1 + 1];
    bet = Dymola_abs(tau1);
    if (bet <= smlnum) {
	tau1 = smlnum;
	bet = smlnum;
	*info = 1;
    }

    *scale = 1.;
    gam = (d__1 = b[b_dim1 + 1], Dymola_abs(d__1));
    if (smlnum * gam > bet) {
	*scale = 1. / gam;
    }

    x[x_dim1 + 1] = b[b_dim1 + 1] * *scale / tau1;
    *xnorm = (d__1 = x[x_dim1 + 1], Dymola_abs(d__1));
    return 0;

/*     1 by 2: */
/*     TL11*[X11 X12] + ISGN*[X11 X12]*op[TR11 TR12]  = [B11 B12] */
/*                                       [TR21 TR22] */

L20:

/* Computing MAX */
/* Computing MAX */
    d__7 = (d__1 = tl[tl_dim1 + 1], Dymola_abs(d__1)), d__8 = (d__2 = tr[tr_dim1 + 1]
	    , Dymola_abs(d__2)), d__7 = Dymola_max(d__7,d__8), d__8 = (d__3 = tr[(tr_dim1 <<
	     1) + 1], Dymola_abs(d__3)), d__7 = Dymola_max(d__7,d__8), d__8 = (d__4 = tr[
	    tr_dim1 + 2], Dymola_abs(d__4)), d__7 = Dymola_max(d__7,d__8), d__8 = (d__5 = 
	    tr[(tr_dim1 << 1) + 2], Dymola_abs(d__5));
    d__6 = eps * Dymola_max(d__7,d__8);
    smin = Dymola_max(d__6,smlnum);
    tmp[0] = tl[tl_dim1 + 1] + sgn * tr[tr_dim1 + 1];
    tmp[3] = tl[tl_dim1 + 1] + sgn * tr[(tr_dim1 << 1) + 2];
    if (*ltranr) {
	tmp[1] = sgn * tr[tr_dim1 + 2];
	tmp[2] = sgn * tr[(tr_dim1 << 1) + 1];
    } else {
	tmp[1] = sgn * tr[(tr_dim1 << 1) + 1];
	tmp[2] = sgn * tr[tr_dim1 + 2];
    }
    btmp[0] = b[b_dim1 + 1];
    btmp[1] = b[(b_dim1 << 1) + 1];
    goto L40;

/*     2 by 1: */
/*          op[TL11 TL12]*[X11] + ISGN* [X11]*TR11  = [B11] */
/*            [TL21 TL22] [X21]         [X21]         [B21] */

L30:
/* Computing MAX */
/* Computing MAX */
    d__7 = (d__1 = tr[tr_dim1 + 1], Dymola_abs(d__1)), d__8 = (d__2 = tl[tl_dim1 + 1]
	    , Dymola_abs(d__2)), d__7 = Dymola_max(d__7,d__8), d__8 = (d__3 = tl[(tl_dim1 <<
	     1) + 1], Dymola_abs(d__3)), d__7 = Dymola_max(d__7,d__8), d__8 = (d__4 = tl[
	    tl_dim1 + 2], Dymola_abs(d__4)), d__7 = Dymola_max(d__7,d__8), d__8 = (d__5 = 
	    tl[(tl_dim1 << 1) + 2], Dymola_abs(d__5));
    d__6 = eps * Dymola_max(d__7,d__8);
    smin = Dymola_max(d__6,smlnum);
    tmp[0] = tl[tl_dim1 + 1] + sgn * tr[tr_dim1 + 1];
    tmp[3] = tl[(tl_dim1 << 1) + 2] + sgn * tr[tr_dim1 + 1];
    if (*ltranl) {
	tmp[1] = tl[(tl_dim1 << 1) + 1];
	tmp[2] = tl[tl_dim1 + 2];
    } else {
	tmp[1] = tl[tl_dim1 + 2];
	tmp[2] = tl[(tl_dim1 << 1) + 1];
    }
    btmp[0] = b[b_dim1 + 1];
    btmp[1] = b[b_dim1 + 2];
L40:

/*     Solve 2 by 2 system using complete pivoting. */
/*     Set pivots less than SMIN to SMIN. */

    ipiv = idamax_(&c__4, tmp, &c__1);
    u11 = tmp[ipiv - 1];
    if (Dymola_abs(u11) <= smin) {
	*info = 1;
	u11 = smin;
    }
    u12 = tmp[locu12[ipiv - 1] - 1];
    l21 = tmp[locl21[ipiv - 1] - 1] / u11;
    u22 = tmp[locu22[ipiv - 1] - 1] - u12 * l21;
    xswap = xswpiv[ipiv - 1];
    bswap = bswpiv[ipiv - 1];
    if (Dymola_abs(u22) <= smin) {
	*info = 1;
	u22 = smin;
    }
    if (bswap) {
	temp = btmp[1];
	btmp[1] = btmp[0] - l21 * temp;
	btmp[0] = temp;
    } else {
	btmp[1] -= l21 * btmp[0];
    }
    *scale = 1.;
    if (smlnum * 2. * Dymola_abs(btmp[1]) > Dymola_abs(u22) || smlnum * 2. * Dymola_abs(btmp[0]) > 
	    Dymola_abs(u11)) {
/* Computing MAX */
	d__1 = Dymola_abs(btmp[0]), d__2 = Dymola_abs(btmp[1]);
	*scale = .5 / Dymola_max(d__1,d__2);
	btmp[0] *= *scale;
	btmp[1] *= *scale;
    }
    x2[1] = btmp[1] / u22;
    x2[0] = btmp[0] / u11 - u12 / u11 * x2[1];
    if (xswap) {
	temp = x2[1];
	x2[1] = x2[0];
	x2[0] = temp;
    }
    x[x_dim1 + 1] = x2[0];
    if (*n1 == 1) {
	x[(x_dim1 << 1) + 1] = x2[1];
	*xnorm = (d__1 = x[x_dim1 + 1], Dymola_abs(d__1)) + (d__2 = x[(x_dim1 << 1) 
		+ 1], Dymola_abs(d__2));
    } else {
	x[x_dim1 + 2] = x2[1];
/* Computing MAX */
	d__3 = (d__1 = x[x_dim1 + 1], Dymola_abs(d__1)), d__4 = (d__2 = x[x_dim1 + 2]
		, Dymola_abs(d__2));
	*xnorm = Dymola_max(d__3,d__4);
    }
    return 0;

/*     2 by 2: */
/*     op[TL11 TL12]*[X11 X12] +ISGN* [X11 X12]*op[TR11 TR12] = [B11 B12] */
/*       [TL21 TL22] [X21 X22]        [X21 X22]   [TR21 TR22]   [B21 B22] */

/*     Solve equivalent 4 by 4 system using complete pivoting. */
/*     Set pivots less than SMIN to SMIN. */

L50:
/* Computing MAX */
    d__5 = (d__1 = tr[tr_dim1 + 1], Dymola_abs(d__1)), d__6 = (d__2 = tr[(tr_dim1 << 
	    1) + 1], Dymola_abs(d__2)), d__5 = Dymola_max(d__5,d__6), d__6 = (d__3 = tr[
	    tr_dim1 + 2], Dymola_abs(d__3)), d__5 = Dymola_max(d__5,d__6), d__6 = (d__4 = 
	    tr[(tr_dim1 << 1) + 2], Dymola_abs(d__4));
    smin = Dymola_max(d__5,d__6);
/* Computing MAX */
    d__5 = smin, d__6 = (d__1 = tl[tl_dim1 + 1], Dymola_abs(d__1)), d__5 = Dymola_max(d__5,
	    d__6), d__6 = (d__2 = tl[(tl_dim1 << 1) + 1], Dymola_abs(d__2)), d__5 = 
	    Dymola_max(d__5,d__6), d__6 = (d__3 = tl[tl_dim1 + 2], Dymola_abs(d__3)), d__5 =
	     Dymola_max(d__5,d__6), d__6 = (d__4 = tl[(tl_dim1 << 1) + 2], Dymola_abs(d__4))
	    ;
    smin = Dymola_max(d__5,d__6);
/* Computing MAX */
    d__1 = eps * smin;
    smin = Dymola_max(d__1,smlnum);
    btmp[0] = 0.;
    dcopy_(&c__16, btmp, &c__0, t16, &c__1);
    t16[0] = tl[tl_dim1 + 1] + sgn * tr[tr_dim1 + 1];
    t16[5] = tl[(tl_dim1 << 1) + 2] + sgn * tr[tr_dim1 + 1];
    t16[10] = tl[tl_dim1 + 1] + sgn * tr[(tr_dim1 << 1) + 2];
    t16[15] = tl[(tl_dim1 << 1) + 2] + sgn * tr[(tr_dim1 << 1) + 2];
    if (*ltranl) {
	t16[4] = tl[tl_dim1 + 2];
	t16[1] = tl[(tl_dim1 << 1) + 1];
	t16[14] = tl[tl_dim1 + 2];
	t16[11] = tl[(tl_dim1 << 1) + 1];
    } else {
	t16[4] = tl[(tl_dim1 << 1) + 1];
	t16[1] = tl[tl_dim1 + 2];
	t16[14] = tl[(tl_dim1 << 1) + 1];
	t16[11] = tl[tl_dim1 + 2];
    }
    if (*ltranr) {
	t16[8] = sgn * tr[(tr_dim1 << 1) + 1];
	t16[13] = sgn * tr[(tr_dim1 << 1) + 1];
	t16[2] = sgn * tr[tr_dim1 + 2];
	t16[7] = sgn * tr[tr_dim1 + 2];
    } else {
	t16[8] = sgn * tr[tr_dim1 + 2];
	t16[13] = sgn * tr[tr_dim1 + 2];
	t16[2] = sgn * tr[(tr_dim1 << 1) + 1];
	t16[7] = sgn * tr[(tr_dim1 << 1) + 1];
    }
    btmp[0] = b[b_dim1 + 1];
    btmp[1] = b[b_dim1 + 2];
    btmp[2] = b[(b_dim1 << 1) + 1];
    btmp[3] = b[(b_dim1 << 1) + 2];

/*     Perform elimination */

    for (i__ = 1; i__ <= 3; ++i__) {
	xmax = 0.;
	for (ip = i__; ip <= 4; ++ip) {
	    for (jp = i__; jp <= 4; ++jp) {
		if ((d__1 = t16[ip + (jp << 2) - 5], Dymola_abs(d__1)) >= xmax) {
		    xmax = (d__1 = t16[ip + (jp << 2) - 5], Dymola_abs(d__1));
		    ipsv = ip;
		    jpsv = jp;
		}
/* L60: */
	    }
/* L70: */
	}
	if (ipsv != i__) {
	    dswap_(&c__4, &t16[ipsv - 1], &c__4, &t16[i__ - 1], &c__4);
	    temp = btmp[i__ - 1];
	    btmp[i__ - 1] = btmp[ipsv - 1];
	    btmp[ipsv - 1] = temp;
	}
	if (jpsv != i__) {
	    dswap_(&c__4, &t16[(jpsv << 2) - 4], &c__1, &t16[(i__ << 2) - 4], 
		    &c__1);
	}
	jpiv[i__ - 1] = jpsv;
	if ((d__1 = t16[i__ + (i__ << 2) - 5], Dymola_abs(d__1)) < smin) {
	    *info = 1;
	    t16[i__ + (i__ << 2) - 5] = smin;
	}
	for (j = i__ + 1; j <= 4; ++j) {
	    t16[j + (i__ << 2) - 5] /= t16[i__ + (i__ << 2) - 5];
	    btmp[j - 1] -= t16[j + (i__ << 2) - 5] * btmp[i__ - 1];
	    for (k = i__ + 1; k <= 4; ++k) {
		t16[j + (k << 2) - 5] -= t16[j + (i__ << 2) - 5] * t16[i__ + (
			k << 2) - 5];
/* L80: */
	    }
/* L90: */
	}
/* L100: */
    }
    if (Dymola_abs(t16[15]) < smin) {
	t16[15] = smin;
    }
    *scale = 1.;
    if (smlnum * 8. * Dymola_abs(btmp[0]) > Dymola_abs(t16[0]) || smlnum * 8. * Dymola_abs(btmp[1])
	     > Dymola_abs(t16[5]) || smlnum * 8. * Dymola_abs(btmp[2]) > Dymola_abs(t16[10]) || 
	    smlnum * 8. * Dymola_abs(btmp[3]) > Dymola_abs(t16[15])) {
/* Computing MAX */
	d__1 = Dymola_abs(btmp[0]), d__2 = Dymola_abs(btmp[1]), d__1 = Dymola_max(d__1,d__2), d__2 
		= Dymola_abs(btmp[2]), d__1 = Dymola_max(d__1,d__2), d__2 = Dymola_abs(btmp[3]);
	*scale = .125 / Dymola_max(d__1,d__2);
	btmp[0] *= *scale;
	btmp[1] *= *scale;
	btmp[2] *= *scale;
	btmp[3] *= *scale;
    }
    for (i__ = 1; i__ <= 4; ++i__) {
	k = 5 - i__;
	temp = 1. / t16[k + (k << 2) - 5];
	tmp[k - 1] = btmp[k - 1] * temp;
	for (j = k + 1; j <= 4; ++j) {
	    tmp[k - 1] -= temp * t16[k + (j << 2) - 5] * tmp[j - 1];
/* L110: */
	}
/* L120: */
    }
    for (i__ = 1; i__ <= 3; ++i__) {
	if (jpiv[4 - i__ - 1] != 4 - i__) {
	    temp = tmp[4 - i__ - 1];
	    tmp[4 - i__ - 1] = tmp[jpiv[4 - i__ - 1] - 1];
	    tmp[jpiv[4 - i__ - 1] - 1] = temp;
	}
/* L130: */
    }
    x[x_dim1 + 1] = tmp[0];
    x[x_dim1 + 2] = tmp[1];
    x[(x_dim1 << 1) + 1] = tmp[2];
    x[(x_dim1 << 1) + 2] = tmp[3];
/* Computing MAX */
    d__1 = Dymola_abs(tmp[0]) + Dymola_abs(tmp[2]), d__2 = Dymola_abs(tmp[1]) + Dymola_abs(tmp[3]);
    *xnorm = Dymola_max(d__1,d__2);
    return 0;

/*     End of DLASY2 */

} /* dlasy2_ */

/* Subroutine */ static int dlarfx_(char *side, integer *m, integer *n, doublereal *v, doublereal *tau, doublereal *c__, integer *ldc, doublereal *work)
{
    /* System generated locals */
    integer c_dim1, c_offset, i__1;

    /* Local variables */
    integer j;
    doublereal t1, t2, t3, t4, t5, t6, t7, t8, t9, v1, v2, v3, v4, v5, v6, v7,
	     v8, v9, t10, v10, sum;

/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    --v;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    if (*tau == 0.) {
	return 0;
    }
    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {

/*        Form  H * C, where H has order m. */

	switch (*m) {
	    case 1:  goto L10;
	    case 2:  goto L30;
	    case 3:  goto L50;
	    case 4:  goto L70;
	    case 5:  goto L90;
	    case 6:  goto L110;
	    case 7:  goto L130;
	    case 8:  goto L150;
	    case 9:  goto L170;
	    case 10:  goto L190;
	}

/*        Code for general M */

	dlarf_(side, m, n, &v[1], &c__1, tau, &c__[c_offset], ldc, &work[1]);
	goto L410;
L10:

/*        Special code for 1 x 1 Householder */

	t1 = 1. - *tau * v[1] * v[1];
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    c__[j * c_dim1 + 1] = t1 * c__[j * c_dim1 + 1];
/* L20: */
	}
	goto L410;
L30:

/*        Special code for 2 x 2 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2];
	    c__[j * c_dim1 + 1] -= sum * t1;
	    c__[j * c_dim1 + 2] -= sum * t2;
/* L40: */
	}
	goto L410;
L50:

/*        Special code for 3 x 3 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 * 
		    c__[j * c_dim1 + 3];
	    c__[j * c_dim1 + 1] -= sum * t1;
	    c__[j * c_dim1 + 2] -= sum * t2;
	    c__[j * c_dim1 + 3] -= sum * t3;
/* L60: */
	}
	goto L410;
L70:

/*        Special code for 4 x 4 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 * 
		    c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4];
	    c__[j * c_dim1 + 1] -= sum * t1;
	    c__[j * c_dim1 + 2] -= sum * t2;
	    c__[j * c_dim1 + 3] -= sum * t3;
	    c__[j * c_dim1 + 4] -= sum * t4;
/* L80: */
	}
	goto L410;
L90:

/*        Special code for 5 x 5 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	v5 = v[5];
	t5 = *tau * v5;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 * 
		    c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
		    j * c_dim1 + 5];
	    c__[j * c_dim1 + 1] -= sum * t1;
	    c__[j * c_dim1 + 2] -= sum * t2;
	    c__[j * c_dim1 + 3] -= sum * t3;
	    c__[j * c_dim1 + 4] -= sum * t4;
	    c__[j * c_dim1 + 5] -= sum * t5;
/* L100: */
	}
	goto L410;
L110:

/*        Special code for 6 x 6 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	v5 = v[5];
	t5 = *tau * v5;
	v6 = v[6];
	t6 = *tau * v6;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 * 
		    c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
		    j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6];
	    c__[j * c_dim1 + 1] -= sum * t1;
	    c__[j * c_dim1 + 2] -= sum * t2;
	    c__[j * c_dim1 + 3] -= sum * t3;
	    c__[j * c_dim1 + 4] -= sum * t4;
	    c__[j * c_dim1 + 5] -= sum * t5;
	    c__[j * c_dim1 + 6] -= sum * t6;
/* L120: */
	}
	goto L410;
L130:

/*        Special code for 7 x 7 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	v5 = v[5];
	t5 = *tau * v5;
	v6 = v[6];
	t6 = *tau * v6;
	v7 = v[7];
	t7 = *tau * v7;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 * 
		    c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
		    j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6] + v7 * c__[j * 
		    c_dim1 + 7];
	    c__[j * c_dim1 + 1] -= sum * t1;
	    c__[j * c_dim1 + 2] -= sum * t2;
	    c__[j * c_dim1 + 3] -= sum * t3;
	    c__[j * c_dim1 + 4] -= sum * t4;
	    c__[j * c_dim1 + 5] -= sum * t5;
	    c__[j * c_dim1 + 6] -= sum * t6;
	    c__[j * c_dim1 + 7] -= sum * t7;
/* L140: */
	}
	goto L410;
L150:

/*        Special code for 8 x 8 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	v5 = v[5];
	t5 = *tau * v5;
	v6 = v[6];
	t6 = *tau * v6;
	v7 = v[7];
	t7 = *tau * v7;
	v8 = v[8];
	t8 = *tau * v8;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 * 
		    c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
		    j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6] + v7 * c__[j * 
		    c_dim1 + 7] + v8 * c__[j * c_dim1 + 8];
	    c__[j * c_dim1 + 1] -= sum * t1;
	    c__[j * c_dim1 + 2] -= sum * t2;
	    c__[j * c_dim1 + 3] -= sum * t3;
	    c__[j * c_dim1 + 4] -= sum * t4;
	    c__[j * c_dim1 + 5] -= sum * t5;
	    c__[j * c_dim1 + 6] -= sum * t6;
	    c__[j * c_dim1 + 7] -= sum * t7;
	    c__[j * c_dim1 + 8] -= sum * t8;
/* L160: */
	}
	goto L410;
L170:

/*        Special code for 9 x 9 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	v5 = v[5];
	t5 = *tau * v5;
	v6 = v[6];
	t6 = *tau * v6;
	v7 = v[7];
	t7 = *tau * v7;
	v8 = v[8];
	t8 = *tau * v8;
	v9 = v[9];
	t9 = *tau * v9;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 * 
		    c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
		    j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6] + v7 * c__[j * 
		    c_dim1 + 7] + v8 * c__[j * c_dim1 + 8] + v9 * c__[j * 
		    c_dim1 + 9];
	    c__[j * c_dim1 + 1] -= sum * t1;
	    c__[j * c_dim1 + 2] -= sum * t2;
	    c__[j * c_dim1 + 3] -= sum * t3;
	    c__[j * c_dim1 + 4] -= sum * t4;
	    c__[j * c_dim1 + 5] -= sum * t5;
	    c__[j * c_dim1 + 6] -= sum * t6;
	    c__[j * c_dim1 + 7] -= sum * t7;
	    c__[j * c_dim1 + 8] -= sum * t8;
	    c__[j * c_dim1 + 9] -= sum * t9;
/* L180: */
	}
	goto L410;
L190:

/*        Special code for 10 x 10 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	v5 = v[5];
	t5 = *tau * v5;
	v6 = v[6];
	t6 = *tau * v6;
	v7 = v[7];
	t7 = *tau * v7;
	v8 = v[8];
	t8 = *tau * v8;
	v9 = v[9];
	t9 = *tau * v9;
	v10 = v[10];
	t10 = *tau * v10;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j * c_dim1 + 1] + v2 * c__[j * c_dim1 + 2] + v3 * 
		    c__[j * c_dim1 + 3] + v4 * c__[j * c_dim1 + 4] + v5 * c__[
		    j * c_dim1 + 5] + v6 * c__[j * c_dim1 + 6] + v7 * c__[j * 
		    c_dim1 + 7] + v8 * c__[j * c_dim1 + 8] + v9 * c__[j * 
		    c_dim1 + 9] + v10 * c__[j * c_dim1 + 10];
	    c__[j * c_dim1 + 1] -= sum * t1;
	    c__[j * c_dim1 + 2] -= sum * t2;
	    c__[j * c_dim1 + 3] -= sum * t3;
	    c__[j * c_dim1 + 4] -= sum * t4;
	    c__[j * c_dim1 + 5] -= sum * t5;
	    c__[j * c_dim1 + 6] -= sum * t6;
	    c__[j * c_dim1 + 7] -= sum * t7;
	    c__[j * c_dim1 + 8] -= sum * t8;
	    c__[j * c_dim1 + 9] -= sum * t9;
	    c__[j * c_dim1 + 10] -= sum * t10;
/* L200: */
	}
	goto L410;
    } else {

/*        Form  C * H, where H has order n. */

	switch (*n) {
	    case 1:  goto L210;
	    case 2:  goto L230;
	    case 3:  goto L250;
	    case 4:  goto L270;
	    case 5:  goto L290;
	    case 6:  goto L310;
	    case 7:  goto L330;
	    case 8:  goto L350;
	    case 9:  goto L370;
	    case 10:  goto L390;
	}

/*        Code for general N */

	dlarf_(side, m, n, &v[1], &c__1, tau, &c__[c_offset], ldc, &work[1]);
	goto L410;
L210:

/*        Special code for 1 x 1 Householder */

	t1 = 1. - *tau * v[1] * v[1];
	i__1 = *m;
	for (j = 1; j <= i__1; ++j) {
	    c__[j + c_dim1] = t1 * c__[j + c_dim1];
/* L220: */
	}
	goto L410;
L230:

/*        Special code for 2 x 2 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	i__1 = *m;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)];
	    c__[j + c_dim1] -= sum * t1;
	    c__[j + (c_dim1 << 1)] -= sum * t2;
/* L240: */
	}
	goto L410;
L250:

/*        Special code for 3 x 3 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	i__1 = *m;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 * 
		    c__[j + c_dim1 * 3];
	    c__[j + c_dim1] -= sum * t1;
	    c__[j + (c_dim1 << 1)] -= sum * t2;
	    c__[j + c_dim1 * 3] -= sum * t3;
/* L260: */
	}
	goto L410;
L270:

/*        Special code for 4 x 4 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	i__1 = *m;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 * 
		    c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)];
	    c__[j + c_dim1] -= sum * t1;
	    c__[j + (c_dim1 << 1)] -= sum * t2;
	    c__[j + c_dim1 * 3] -= sum * t3;
	    c__[j + (c_dim1 << 2)] -= sum * t4;
/* L280: */
	}
	goto L410;
L290:

/*        Special code for 5 x 5 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	v5 = v[5];
	t5 = *tau * v5;
	i__1 = *m;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 * 
		    c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 * 
		    c__[j + c_dim1 * 5];
	    c__[j + c_dim1] -= sum * t1;
	    c__[j + (c_dim1 << 1)] -= sum * t2;
	    c__[j + c_dim1 * 3] -= sum * t3;
	    c__[j + (c_dim1 << 2)] -= sum * t4;
	    c__[j + c_dim1 * 5] -= sum * t5;
/* L300: */
	}
	goto L410;
L310:

/*        Special code for 6 x 6 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	v5 = v[5];
	t5 = *tau * v5;
	v6 = v[6];
	t6 = *tau * v6;
	i__1 = *m;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 * 
		    c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 * 
		    c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6];
	    c__[j + c_dim1] -= sum * t1;
	    c__[j + (c_dim1 << 1)] -= sum * t2;
	    c__[j + c_dim1 * 3] -= sum * t3;
	    c__[j + (c_dim1 << 2)] -= sum * t4;
	    c__[j + c_dim1 * 5] -= sum * t5;
	    c__[j + c_dim1 * 6] -= sum * t6;
/* L320: */
	}
	goto L410;
L330:

/*        Special code for 7 x 7 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	v5 = v[5];
	t5 = *tau * v5;
	v6 = v[6];
	t6 = *tau * v6;
	v7 = v[7];
	t7 = *tau * v7;
	i__1 = *m;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 * 
		    c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 * 
		    c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6] + v7 * c__[
		    j + c_dim1 * 7];
	    c__[j + c_dim1] -= sum * t1;
	    c__[j + (c_dim1 << 1)] -= sum * t2;
	    c__[j + c_dim1 * 3] -= sum * t3;
	    c__[j + (c_dim1 << 2)] -= sum * t4;
	    c__[j + c_dim1 * 5] -= sum * t5;
	    c__[j + c_dim1 * 6] -= sum * t6;
	    c__[j + c_dim1 * 7] -= sum * t7;
/* L340: */
	}
	goto L410;
L350:

/*        Special code for 8 x 8 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	v5 = v[5];
	t5 = *tau * v5;
	v6 = v[6];
	t6 = *tau * v6;
	v7 = v[7];
	t7 = *tau * v7;
	v8 = v[8];
	t8 = *tau * v8;
	i__1 = *m;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 * 
		    c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 * 
		    c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6] + v7 * c__[
		    j + c_dim1 * 7] + v8 * c__[j + (c_dim1 << 3)];
	    c__[j + c_dim1] -= sum * t1;
	    c__[j + (c_dim1 << 1)] -= sum * t2;
	    c__[j + c_dim1 * 3] -= sum * t3;
	    c__[j + (c_dim1 << 2)] -= sum * t4;
	    c__[j + c_dim1 * 5] -= sum * t5;
	    c__[j + c_dim1 * 6] -= sum * t6;
	    c__[j + c_dim1 * 7] -= sum * t7;
	    c__[j + (c_dim1 << 3)] -= sum * t8;
/* L360: */
	}
	goto L410;
L370:

/*        Special code for 9 x 9 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	v5 = v[5];
	t5 = *tau * v5;
	v6 = v[6];
	t6 = *tau * v6;
	v7 = v[7];
	t7 = *tau * v7;
	v8 = v[8];
	t8 = *tau * v8;
	v9 = v[9];
	t9 = *tau * v9;
	i__1 = *m;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 * 
		    c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 * 
		    c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6] + v7 * c__[
		    j + c_dim1 * 7] + v8 * c__[j + (c_dim1 << 3)] + v9 * c__[
		    j + c_dim1 * 9];
	    c__[j + c_dim1] -= sum * t1;
	    c__[j + (c_dim1 << 1)] -= sum * t2;
	    c__[j + c_dim1 * 3] -= sum * t3;
	    c__[j + (c_dim1 << 2)] -= sum * t4;
	    c__[j + c_dim1 * 5] -= sum * t5;
	    c__[j + c_dim1 * 6] -= sum * t6;
	    c__[j + c_dim1 * 7] -= sum * t7;
	    c__[j + (c_dim1 << 3)] -= sum * t8;
	    c__[j + c_dim1 * 9] -= sum * t9;
/* L380: */
	}
	goto L410;
L390:

/*        Special code for 10 x 10 Householder */

	v1 = v[1];
	t1 = *tau * v1;
	v2 = v[2];
	t2 = *tau * v2;
	v3 = v[3];
	t3 = *tau * v3;
	v4 = v[4];
	t4 = *tau * v4;
	v5 = v[5];
	t5 = *tau * v5;
	v6 = v[6];
	t6 = *tau * v6;
	v7 = v[7];
	t7 = *tau * v7;
	v8 = v[8];
	t8 = *tau * v8;
	v9 = v[9];
	t9 = *tau * v9;
	v10 = v[10];
	t10 = *tau * v10;
	i__1 = *m;
	for (j = 1; j <= i__1; ++j) {
	    sum = v1 * c__[j + c_dim1] + v2 * c__[j + (c_dim1 << 1)] + v3 * 
		    c__[j + c_dim1 * 3] + v4 * c__[j + (c_dim1 << 2)] + v5 * 
		    c__[j + c_dim1 * 5] + v6 * c__[j + c_dim1 * 6] + v7 * c__[
		    j + c_dim1 * 7] + v8 * c__[j + (c_dim1 << 3)] + v9 * c__[
		    j + c_dim1 * 9] + v10 * c__[j + c_dim1 * 10];
	    c__[j + c_dim1] -= sum * t1;
	    c__[j + (c_dim1 << 1)] -= sum * t2;
	    c__[j + c_dim1 * 3] -= sum * t3;
	    c__[j + (c_dim1 << 2)] -= sum * t4;
	    c__[j + c_dim1 * 5] -= sum * t5;
	    c__[j + c_dim1 * 6] -= sum * t6;
	    c__[j + c_dim1 * 7] -= sum * t7;
	    c__[j + (c_dim1 << 3)] -= sum * t8;
	    c__[j + c_dim1 * 9] -= sum * t9;
	    c__[j + c_dim1 * 10] -= sum * t10;
/* L400: */
	}
	goto L410;
    }
L410:
    return 0;

/*     End of DLARFX */

} /* dlarfx_ */

/* Subroutine */ static int dgegv_(const char* jobvl, const char* jobvr, integer* n, doublereal* a, integer* lda, doublereal* b, integer* ldb, doublereal* alphar, doublereal* alphai, doublereal* beta, doublereal* vl, const integer* ldvl, doublereal* vr, const integer* ldvr, doublereal* work, const integer* lwork, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, vl_dim1, vl_offset, vr_dim1, 
	    vr_offset, i__1, i__2;
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    integer jc, nb, in, jr, nb1, nb2, nb3, ihi, ilo;
    doublereal eps;
    logical ilv;
    doublereal absb, anrm, bnrm;
    integer itau;
    doublereal temp;
    logical ilvl, ilvr;
    integer lopt;
    doublereal anrm1, anrm2, bnrm1, bnrm2, absai, scale, absar, sbeta;
    integer ileft, iinfo, icols, iwork, irows;
    doublereal salfai;
    doublereal salfar;
    doublereal safmin;
    doublereal safmax;
    char chtemp[1];
    logical ldumma[1];
    integer ijobvl, iright;
    logical ilimit;
    integer ijobvr;
    doublereal onepls;
    integer lwkmin;
    integer lwkopt;
    logical lquery;


/*  -- LAPACK driver routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --alphar;
    --alphai;
    --beta;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --work;

    /* Function Body */
    if (lsame_(jobvl, "N", (ftnlen)1, (ftnlen)1)) {
	ijobvl = 1;
	ilvl = FALSE_;
    } else if (lsame_(jobvl, "V", (ftnlen)1, (ftnlen)1)) {
	ijobvl = 2;
	ilvl = TRUE_;
    } else {
	ijobvl = -1;
	ilvl = FALSE_;
    }

    if (lsame_(jobvr, "N", (ftnlen)1, (ftnlen)1)) {
	ijobvr = 1;
	ilvr = FALSE_;
    } else if (lsame_(jobvr, "V", (ftnlen)1, (ftnlen)1)) {
	ijobvr = 2;
	ilvr = TRUE_;
    } else {
	ijobvr = -1;
	ilvr = FALSE_;
    }
    ilv = ilvl || ilvr;

/*     Test the input arguments */

/* Computing MAX */
    i__1 = *n << 3;
    lwkmin = Dymola_max(i__1,1);
    lwkopt = lwkmin;
    work[1] = (doublereal) lwkopt;
    lquery = *lwork == -1;
    *info = 0;
    if (ijobvl <= 0) {
	*info = -1;
    } else if (ijobvr <= 0) {
	*info = -2;
    } else if (*n < 0) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -5;
    } else if (*ldb < Dymola_max(1,*n)) {
	*info = -7;
    } else if (*ldvl < 1 || ilvl && *ldvl < *n) {
	*info = -12;
    } else if (*ldvr < 1 || ilvr && *ldvr < *n) {
	*info = -14;
    } else if (*lwork < lwkmin && ! lquery) {
	*info = -16;
    }

    if (*info == 0) {
	nb1 = ilaenv_(&c__1, "DGEQRF", " ", n, n, &c_n1, &c_n1);
	nb2 = ilaenv_(&c__1, "DORMQR", " ", n, n, n, &c_n1);
	nb3 = ilaenv_(&c__1, "DORGQR", " ", n, n, n, &c_n1);
/* Computing MAX */
	i__1 = Dymola_max(nb1,nb2);
	nb = Dymola_max(i__1,nb3);
/* Computing MAX */
	i__1 = *n * 6, i__2 = *n * (nb + 1);
	lopt = (*n << 1) + Dymola_max(i__1,i__2);
	work[1] = (doublereal) lopt;
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGEGV ", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

/*     Get machine constants */

    eps = dlamch_("E") * dlamch_("B");
    safmin = dlamch_("S");
    safmin += safmin;
    safmax = 1. / safmin;
    onepls = eps * 4 + 1.;

/*     Scale A */

    anrm = dlange_("M", n, n, &a[a_offset], lda, &work[1]);
    anrm1 = anrm;
    anrm2 = 1.;
    if (anrm < 1.) {
	if (safmax * anrm < 1.) {
	    anrm1 = safmin;
	    anrm2 = safmax * anrm;
	}
    }

    if (anrm > 0.) {
	dlascl_("G", &c_n1, &c_n1, &anrm, &c_b27, n, n, &a[a_offset], lda, &iinfo);
	if (iinfo != 0) {
	    *info = *n + 10;
	    return 0;
	}
    }

/*     Scale B */

    bnrm = dlange_("M", n, n, &b[b_offset], ldb, &work[1]);
    bnrm1 = bnrm;
    bnrm2 = 1.;
    if (bnrm < 1.) {
	if (safmax * bnrm < 1.) {
	    bnrm1 = safmin;
	    bnrm2 = safmax * bnrm;
	}
    }

    if (bnrm > 0.) {
	dlascl_("G", &c_n1, &c_n1, &bnrm, &c_b27, n, n, &b[b_offset], ldb, &iinfo);
	if (iinfo != 0) {
	    *info = *n + 10;
	    return 0;
	}
    }

/*     Permute the matrix to make it more nearly triangular */
/*     Workspace layout:  (8*N words -- "work" requires 6*N words) */
/*        left_permutation, right_permutation, work... */

    ileft = 1;
    iright = *n + 1;
    iwork = iright + *n;
    dggbal_("P", n, &a[a_offset], lda, &b[b_offset], ldb, &ilo, &ihi, &work[
	    ileft], &work[iright], &work[iwork], &iinfo);
    if (iinfo != 0) {
	*info = *n + 1;
	goto L120;
    }

/*     Reduce B to triangular form, and initialize VL and/or VR */
/*     Workspace layout:  ("work..." must have at least N words) */
/*        left_permutation, right_permutation, tau, work... */

    irows = ihi + 1 - ilo;
    if (ilv) {
	icols = *n + 1 - ilo;
    } else {
	icols = irows;
    }
    itau = iwork;
    iwork = itau + irows;
    i__1 = *lwork + 1 - iwork;
    dgeqrf_(&irows, &icols, &b[ilo + ilo * b_dim1], ldb, &work[itau], &work[
	    iwork], &i__1, &iinfo);
    if (iinfo >= 0) {
/* Computing MAX */
	i__1 = lwkopt, i__2 = (integer) work[iwork] + iwork - 1;
	lwkopt = Dymola_max(i__1,i__2);
    }
    if (iinfo != 0) {
	*info = *n + 2;
	goto L120;
    }

    i__1 = *lwork + 1 - iwork;
    dormqr_("L", "T", &irows, &icols, &irows, &b[ilo + ilo * b_dim1], ldb, &
	    work[itau], &a[ilo + ilo * a_dim1], lda, &work[iwork], &i__1, &
	    iinfo);
    if (iinfo >= 0) {
/* Computing MAX */
	i__1 = lwkopt, i__2 = (integer) work[iwork] + iwork - 1;
	lwkopt = Dymola_max(i__1,i__2);
    }
    if (iinfo != 0) {
	*info = *n + 3;
	goto L120;
    }

    if (ilvl) {
      dlaset_("Full", n, n, &c_b38, &c_b27, &vl[vl_offset], (integer*) ldvl)
		;
	i__1 = irows - 1;
	i__2 = irows - 1;
	dlacpy_("L", &i__1, &i__2, &b[ilo + 1 + ilo * b_dim1], ldb, &vl[ilo + 
		1 + ilo * vl_dim1], (integer*) ldvl);
	i__1 = *lwork + 1 - iwork;
	dorgqr_(&irows, &irows, &irows, &vl[ilo + ilo * vl_dim1], (integer*) ldvl, &work[
		itau], &work[iwork], &i__1, &iinfo);
	if (iinfo >= 0) {
/* Computing MAX */
	    i__1 = lwkopt, i__2 = (integer) work[iwork] + iwork - 1;
	    lwkopt = Dymola_max(i__1,i__2);
	}
	if (iinfo != 0) {
	    *info = *n + 4;
	    goto L120;
	}
    }

    if (ilvr) {
	dlaset_("Full", n, n, &c_b38, &c_b27, &vr[vr_offset], (integer*) ldvr)
		;
    }

/*     Reduce to generalized Hessenberg form */

    if (ilv) {

/*        Eigenvectors requested -- work on whole matrix. */

      dgghrd_((char*) jobvl, (char*) jobvr, n, &ilo, &ihi, &a[a_offset], lda, &b[b_offset], 
              ldb, &vl[vl_offset], (integer*) ldvl, &vr[vr_offset], (integer*) ldvr, &iinfo);
    } else {
	dgghrd_("N", "N", &irows, &c__1, &irows, &a[ilo + ilo * a_dim1], lda, &b[ilo + ilo * b_dim1], ldb, &vl[vl_offset], (integer*) ldvl, &vr[vr_offset], (integer*) ldvr, &iinfo);
    }
    if (iinfo != 0) {
	*info = *n + 5;
	goto L120;
    }

/*     Perform QZ algorithm */
/*     Workspace layout:  ("work..." must have at least 1 word) */
/*        left_permutation, right_permutation, work... */

    iwork = itau;
    if (ilv) {
	*(unsigned char *)chtemp = 'S';
    } else {
	*(unsigned char *)chtemp = 'E';
    }
    i__1 = *lwork + 1 - iwork;
    dhgeqz_(chtemp, jobvl, jobvr, n, &ilo, &ihi, &a[a_offset], lda, &b[
	    b_offset], ldb, &alphar[1], &alphai[1], &beta[1], &vl[vl_offset], 
	    ldvl, &vr[vr_offset], ldvr, &work[iwork], &i__1, &iinfo);
    if (iinfo >= 0) {
/* Computing MAX */
	i__1 = lwkopt, i__2 = (integer) work[iwork] + iwork - 1;
	lwkopt = Dymola_max(i__1,i__2);
    }
    if (iinfo != 0) {
	if (iinfo > 0 && iinfo <= *n) {
	    *info = iinfo;
	} else if (iinfo > *n && iinfo <= *n << 1) {
	    *info = iinfo - *n;
	} else {
	    *info = *n + 6;
	}
	goto L120;
    }

    if (ilv) {

/*        Compute Eigenvectors  (DTGEVC requires 6*N words of workspace) */

	if (ilvl) {
	    if (ilvr) {
		*(unsigned char *)chtemp = 'B';
	    } else {
		*(unsigned char *)chtemp = 'L';
	    }
	} else {
	    *(unsigned char *)chtemp = 'R';
	}

	dtgevc_(chtemp, "B", ldumma, n, &a[a_offset], lda, &b[b_offset], ldb, 
          &vl[vl_offset], (integer*) ldvl, &vr[vr_offset], (integer*) ldvr, n, &in, &work[
		iwork], &iinfo);
	if (iinfo != 0) {
	    *info = *n + 7;
	    goto L120;
	}

/*        Undo balancing on VL and VR, rescale */

	if (ilvl) {
	    dggbak_("P", "L", n, &ilo, &ihi, &work[ileft], &work[iright], n, &
              vl[vl_offset], (integer*) ldvl, &iinfo);
	    if (iinfo != 0) {
		*info = *n + 8;
		goto L120;
	    }
	    i__1 = *n;
	    for (jc = 1; jc <= i__1; ++jc) {
		if (alphai[jc] < 0.) {
		    goto L50;
		}
		temp = 0.;
		if (alphai[jc] == 0.) {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
/* Computing MAX */
			d__2 = temp, d__3 = (d__1 = vl[jr + jc * vl_dim1], 
				Dymola_abs(d__1));
			temp = Dymola_max(d__2,d__3);
/* L10: */
		    }
		} else {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
/* Computing MAX */
			d__3 = temp, d__4 = (d__1 = vl[jr + jc * vl_dim1], 
				Dymola_abs(d__1)) + (d__2 = vl[jr + (jc + 1) * 
				vl_dim1], Dymola_abs(d__2));
			temp = Dymola_max(d__3,d__4);
/* L20: */
		    }
		}
		if (temp < safmin) {
		    goto L50;
		}
		temp = 1. / temp;
		if (alphai[jc] == 0.) {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
			vl[jr + jc * vl_dim1] *= temp;
/* L30: */
		    }
		} else {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
			vl[jr + jc * vl_dim1] *= temp;
			vl[jr + (jc + 1) * vl_dim1] *= temp;
/* L40: */
		    }
		}
L50:
		;
	    }
	}
	if (ilvr) {
	    dggbak_("P", "R", n, &ilo, &ihi, &work[ileft], &work[iright], n, &
              vr[vr_offset], (integer*) ldvr, &iinfo);
	    if (iinfo != 0) {
		*info = *n + 9;
		goto L120;
	    }
	    i__1 = *n;
	    for (jc = 1; jc <= i__1; ++jc) {
		if (alphai[jc] < 0.) {
		    goto L100;
		}
		temp = 0.;
		if (alphai[jc] == 0.) {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
/* Computing MAX */
			d__2 = temp, d__3 = (d__1 = vr[jr + jc * vr_dim1], 
				Dymola_abs(d__1));
			temp = Dymola_max(d__2,d__3);
/* L60: */
		    }
		} else {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
/* Computing MAX */
			d__3 = temp, d__4 = (d__1 = vr[jr + jc * vr_dim1], 
				Dymola_abs(d__1)) + (d__2 = vr[jr + (jc + 1) * 
				vr_dim1], Dymola_abs(d__2));
			temp = Dymola_max(d__3,d__4);
/* L70: */
		    }
		}
		if (temp < safmin) {
		    goto L100;
		}
		temp = 1. / temp;
		if (alphai[jc] == 0.) {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
			vr[jr + jc * vr_dim1] *= temp;
/* L80: */
		    }
		} else {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
			vr[jr + jc * vr_dim1] *= temp;
			vr[jr + (jc + 1) * vr_dim1] *= temp;
/* L90: */
		    }
		}
L100:
		;
	    }
	}

/*        End of eigenvector calculation */

    }

/*     Undo scaling in alpha, beta */

/*     Note: this does not give the alpha and beta for the unscaled */
/*     problem. */

/*     Un-scaling is limited to avoid underflow in alpha and beta */
/*     if they are significant. */

    i__1 = *n;
    for (jc = 1; jc <= i__1; ++jc) {
	absar = (d__1 = alphar[jc], Dymola_abs(d__1));
	absai = (d__1 = alphai[jc], Dymola_abs(d__1));
	absb = (d__1 = beta[jc], Dymola_abs(d__1));
	salfar = anrm * alphar[jc];
	salfai = anrm * alphai[jc];
	sbeta = bnrm * beta[jc];
	ilimit = FALSE_;
	scale = 1.;

/*        Check for significant underflow in ALPHAI */

/* Computing MAX */
	d__1 = safmin, d__2 = eps * absar, d__1 = Dymola_max(d__1,d__2), d__2 = eps *
		 absb;
	if (Dymola_abs(salfai) < safmin && absai >= Dymola_max(d__1,d__2)) {
	    ilimit = TRUE_;
/* Computing MAX */
	    d__1 = onepls * safmin, d__2 = anrm2 * absai;
	    scale = onepls * safmin / anrm1 / Dymola_max(d__1,d__2);

	} else if (salfai == 0.) {

/*           If insignificant underflow in ALPHAI, then make the */
/*           conjugate eigenvalue real. */

	    if (alphai[jc] < 0. && jc > 1) {
		alphai[jc - 1] = 0.;
	    } else if (alphai[jc] > 0. && jc < *n) {
		alphai[jc + 1] = 0.;
	    }
	}

/*        Check for significant underflow in ALPHAR */

/* Computing MAX */
	d__1 = safmin, d__2 = eps * absai, d__1 = Dymola_max(d__1,d__2), d__2 = eps *
		 absb;
	if (Dymola_abs(salfar) < safmin && absar >= Dymola_max(d__1,d__2)) {
	    ilimit = TRUE_;
/* Computing MAX */
/* Computing MAX */
	    d__3 = onepls * safmin, d__4 = anrm2 * absar;
	    d__1 = scale, d__2 = onepls * safmin / anrm1 / Dymola_max(d__3,d__4);
	    scale = Dymola_max(d__1,d__2);
	}

/*        Check for significant underflow in BETA */

/* Computing MAX */
	d__1 = safmin, d__2 = eps * absar, d__1 = Dymola_max(d__1,d__2), d__2 = eps *
		 absai;
	if (Dymola_abs(sbeta) < safmin && absb >= Dymola_max(d__1,d__2)) {
	    ilimit = TRUE_;
/* Computing MAX */
/* Computing MAX */
	    d__3 = onepls * safmin, d__4 = bnrm2 * absb;
	    d__1 = scale, d__2 = onepls * safmin / bnrm1 / Dymola_max(d__3,d__4);
	    scale = Dymola_max(d__1,d__2);
	}

/*        Check for possible overflow when limiting scaling */

	if (ilimit) {
/* Computing MAX */
	    d__1 = Dymola_abs(salfar), d__2 = Dymola_abs(salfai), d__1 = Dymola_max(d__1,d__2), 
		    d__2 = Dymola_abs(sbeta);
	    temp = scale * safmin * Dymola_max(d__1,d__2);
	    if (temp > 1.) {
		scale /= temp;
	    }
	    if (scale < 1.) {
		ilimit = FALSE_;
	    }
	}

/*        Recompute un-scaled ALPHAR, ALPHAI, BETA if necessary. */

	if (ilimit) {
	    salfar = scale * alphar[jc] * anrm;
	    salfai = scale * alphai[jc] * anrm;
	    sbeta = scale * beta[jc] * bnrm;
	}
	alphar[jc] = salfar;
	alphai[jc] = salfai;
	beta[jc] = sbeta;
/* L110: */
    }

L120:
    work[1] = (doublereal) lwkopt;

    return 0;

/*     End of DGEGV */

} /* dgegv_ */

/* Subroutine */ static int dggbal_(char* job, integer* n, doublereal* a, integer* lda, doublereal* b, integer* ldb, integer* ilo, integer* ihi, doublereal* lscale, doublereal* rscale, doublereal* work, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3;
    doublereal d__1, d__2, d__3;

    /* Local variables */
    integer i__, j, k, l, m;
    doublereal t;
    integer jc;
    doublereal ta, tb, tc;
    integer ir;
    doublereal ew;
    integer it, nr, ip1, jp1, lm1;
    doublereal cab, rab, ewc, cor, sum;
    integer nrp2, icab, lcab;
    doublereal beta, coef;
    integer irab, lrab;
    doublereal basl, cmax;
    doublereal coef2, coef5, gamma, alpha;
    doublereal sfmin, sfmax;
    integer iflow;
    integer kount;
    doublereal pgamma;
    integer lsfmin, lsfmax;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --lscale;
    --rscale;
    --work;

    /* Function Body */
    *info = 0;
    if (! lsame_(job, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(job, "P", (
	    ftnlen)1, (ftnlen)1) && ! lsame_(job, "S", (ftnlen)1, (ftnlen)1) 
	    && ! lsame_(job, "B", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -4;
    } else if (*ldb < Dymola_max(1,*n)) {
	*info = -6;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGGBAL", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	*ilo = 1;
	*ihi = *n;
	return 0;
    }

    if (*n == 1) {
	*ilo = 1;
	*ihi = *n;
	lscale[1] = 1.;
	rscale[1] = 1.;
	return 0;
    }

    if (lsame_(job, "N", (ftnlen)1, (ftnlen)1)) {
	*ilo = 1;
	*ihi = *n;
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    lscale[i__] = 1.;
	    rscale[i__] = 1.;
/* L10: */
	}
	return 0;
    }

    k = 1;
    l = *n;
    if (lsame_(job, "S", (ftnlen)1, (ftnlen)1)) {
	goto L190;
    }

    goto L30;

/*     Permute the matrices A and B to isolate the eigenvalues. */

/*     Find row with one nonzero in columns 1 through L */

L20:
    l = lm1;
    if (l != 1) {
	goto L30;
    }

    rscale[1] = 1.;
    lscale[1] = 1.;
    goto L190;

L30:
    lm1 = l - 1;
    for (i__ = l; i__ >= 1; --i__) {
	i__1 = lm1;
	for (j = 1; j <= i__1; ++j) {
	    jp1 = j + 1;
	    if (a[i__ + j * a_dim1] != 0. || b[i__ + j * b_dim1] != 0.) {
		goto L50;
	    }
/* L40: */
	}
	j = l;
	goto L70;

L50:
	i__1 = l;
	for (j = jp1; j <= i__1; ++j) {
	    if (a[i__ + j * a_dim1] != 0. || b[i__ + j * b_dim1] != 0.) {
		goto L80;
	    }
/* L60: */
	}
	j = jp1 - 1;

L70:
	m = l;
	iflow = 1;
	goto L160;
L80:
	;
    }
    goto L100;

/*     Find column with one nonzero in rows K through N */

L90:
    ++k;

L100:
    i__1 = l;
    for (j = k; j <= i__1; ++j) {
	i__2 = lm1;
	for (i__ = k; i__ <= i__2; ++i__) {
	    ip1 = i__ + 1;
	    if (a[i__ + j * a_dim1] != 0. || b[i__ + j * b_dim1] != 0.) {
		goto L120;
	    }
/* L110: */
	}
	i__ = l;
	goto L140;
L120:
	i__2 = l;
	for (i__ = ip1; i__ <= i__2; ++i__) {
	    if (a[i__ + j * a_dim1] != 0. || b[i__ + j * b_dim1] != 0.) {
		goto L150;
	    }
/* L130: */
	}
	i__ = ip1 - 1;
L140:
	m = k;
	iflow = 2;
	goto L160;
L150:
	;
    }
    goto L190;

/*     Permute rows M and I */

L160:
    lscale[m] = (doublereal) i__;
    if (i__ == m) {
	goto L170;
    }
    i__1 = *n - k + 1;
    dswap_(&i__1, &a[i__ + k * a_dim1], lda, &a[m + k * a_dim1], lda);
    i__1 = *n - k + 1;
    dswap_(&i__1, &b[i__ + k * b_dim1], ldb, &b[m + k * b_dim1], ldb);

/*     Permute columns M and J */

L170:
    rscale[m] = (doublereal) j;
    if (j == m) {
	goto L180;
    }
    dswap_(&l, &a[j * a_dim1 + 1], &c__1, &a[m * a_dim1 + 1], &c__1);
    dswap_(&l, &b[j * b_dim1 + 1], &c__1, &b[m * b_dim1 + 1], &c__1);

L180:
    switch (iflow) {
	case 1:  goto L20;
	case 2:  goto L90;
    }

L190:
    *ilo = k;
    *ihi = l;

    if (lsame_(job, "P", (ftnlen)1, (ftnlen)1)) {
	i__1 = *ihi;
	for (i__ = *ilo; i__ <= i__1; ++i__) {
	    lscale[i__] = 1.;
	    rscale[i__] = 1.;
/* L195: */
	}
	return 0;
    }

    if (*ilo == *ihi) {
	return 0;
    }

/*     Balance the submatrix in rows ILO to IHI. */

    nr = *ihi - *ilo + 1;
    i__1 = *ihi;
    for (i__ = *ilo; i__ <= i__1; ++i__) {
	rscale[i__] = 0.;
	lscale[i__] = 0.;

	work[i__] = 0.;
	work[i__ + *n] = 0.;
	work[i__ + (*n << 1)] = 0.;
	work[i__ + *n * 3] = 0.;
	work[i__ + (*n << 2)] = 0.;
	work[i__ + *n * 5] = 0.;
/* L200: */
    }

/*     Compute right side vector in resulting linear equations */

    basl = d_lg10(&c_b35);
    i__1 = *ihi;
    for (i__ = *ilo; i__ <= i__1; ++i__) {
	i__2 = *ihi;
	for (j = *ilo; j <= i__2; ++j) {
	    tb = b[i__ + j * b_dim1];
	    ta = a[i__ + j * a_dim1];
	    if (ta == 0.) {
		goto L210;
	    }
	    d__1 = Dymola_abs(ta);
	    ta = d_lg10(&d__1) / basl;
L210:
	    if (tb == 0.) {
		goto L220;
	    }
	    d__1 = Dymola_abs(tb);
	    tb = d_lg10(&d__1) / basl;
L220:
	    work[i__ + (*n << 2)] = work[i__ + (*n << 2)] - ta - tb;
	    work[j + *n * 5] = work[j + *n * 5] - ta - tb;
/* L230: */
	}
/* L240: */
    }

    coef = 1. / (doublereal) (nr << 1);
    coef2 = coef * coef;
    coef5 = coef2 * .5;
    nrp2 = nr + 2;
    beta = 0.;
    it = 1;

/*     Start generalized conjugate gradient iteration */

L250:

    gamma = ddot_(&nr, &work[*ilo + (*n << 2)], &c__1, &work[*ilo + (*n << 2)]
	    , &c__1) + ddot_(&nr, &work[*ilo + *n * 5], &c__1, &work[*ilo + *
	    n * 5], &c__1);

    ew = 0.;
    ewc = 0.;
    i__1 = *ihi;
    for (i__ = *ilo; i__ <= i__1; ++i__) {
	ew += work[i__ + (*n << 2)];
	ewc += work[i__ + *n * 5];
/* L260: */
    }

/* Computing 2nd power */
    d__1 = ew;
/* Computing 2nd power */
    d__2 = ewc;
/* Computing 2nd power */
    d__3 = ew - ewc;
    gamma = coef * gamma - coef2 * (d__1 * d__1 + d__2 * d__2) - coef5 * (
	    d__3 * d__3);
    if (gamma == 0.) {
	goto L350;
    }
    if (it != 1) {
	beta = gamma / pgamma;
    }
    t = coef5 * (ewc - ew * 3.);
    tc = coef5 * (ew - ewc * 3.);

    dscal_(&nr, &beta, &work[*ilo], &c__1);
    dscal_(&nr, &beta, &work[*ilo + *n], &c__1);

    daxpy_(&nr, &coef, &work[*ilo + (*n << 2)], &c__1, &work[*ilo + *n], &
	    c__1);
    daxpy_(&nr, &coef, &work[*ilo + *n * 5], &c__1, &work[*ilo], &c__1);

    i__1 = *ihi;
    for (i__ = *ilo; i__ <= i__1; ++i__) {
	work[i__] += tc;
	work[i__ + *n] += t;
/* L270: */
    }

/*     Apply matrix to vector */

    i__1 = *ihi;
    for (i__ = *ilo; i__ <= i__1; ++i__) {
	kount = 0;
	sum = 0.;
	i__2 = *ihi;
	for (j = *ilo; j <= i__2; ++j) {
	    if (a[i__ + j * a_dim1] == 0.) {
		goto L280;
	    }
	    ++kount;
	    sum += work[j];
L280:
	    if (b[i__ + j * b_dim1] == 0.) {
		goto L290;
	    }
	    ++kount;
	    sum += work[j];
L290:
	    ;
	}
	work[i__ + (*n << 1)] = (doublereal) kount * work[i__ + *n] + sum;
/* L300: */
    }

    i__1 = *ihi;
    for (j = *ilo; j <= i__1; ++j) {
	kount = 0;
	sum = 0.;
	i__2 = *ihi;
	for (i__ = *ilo; i__ <= i__2; ++i__) {
	    if (a[i__ + j * a_dim1] == 0.) {
		goto L310;
	    }
	    ++kount;
	    sum += work[i__ + *n];
L310:
	    if (b[i__ + j * b_dim1] == 0.) {
		goto L320;
	    }
	    ++kount;
	    sum += work[i__ + *n];
L320:
	    ;
	}
	work[j + *n * 3] = (doublereal) kount * work[j] + sum;
/* L330: */
    }

    sum = ddot_(&nr, &work[*ilo + *n], &c__1, &work[*ilo + (*n << 1)], &c__1) 
	    + ddot_(&nr, &work[*ilo], &c__1, &work[*ilo + *n * 3], &c__1);
    alpha = gamma / sum;

/*     Determine correction to current iteration */

    cmax = 0.;
    i__1 = *ihi;
    for (i__ = *ilo; i__ <= i__1; ++i__) {
	cor = alpha * work[i__ + *n];
	if (Dymola_abs(cor) > cmax) {
	    cmax = Dymola_abs(cor);
	}
	lscale[i__] += cor;
	cor = alpha * work[i__];
	if (Dymola_abs(cor) > cmax) {
	    cmax = Dymola_abs(cor);
	}
	rscale[i__] += cor;
/* L340: */
    }
    if (cmax < .5) {
	goto L350;
    }

    d__1 = -alpha;
    daxpy_(&nr, &d__1, &work[*ilo + (*n << 1)], &c__1, &work[*ilo + (*n << 2)]
	    , &c__1);
    d__1 = -alpha;
    daxpy_(&nr, &d__1, &work[*ilo + *n * 3], &c__1, &work[*ilo + *n * 5], &
	    c__1);

    pgamma = gamma;
    ++it;
    if (it <= nrp2) {
	goto L250;
    }

/*     End generalized conjugate gradient iteration */

L350:
    sfmin = dlamch_("S");
    sfmax = 1. / sfmin;
    lsfmin = (integer) (d_lg10(&sfmin) / basl + 1.);
    lsfmax = (integer) (d_lg10(&sfmax) / basl);
    i__1 = *ihi;
    for (i__ = *ilo; i__ <= i__1; ++i__) {
	i__2 = *n - *ilo + 1;
	irab = idamax_(&i__2, &a[i__ + *ilo * a_dim1], lda);
	rab = (d__1 = a[i__ + (irab + *ilo - 1) * a_dim1], Dymola_abs(d__1));
	i__2 = *n - *ilo + 1;
	irab = idamax_(&i__2, &b[i__ + *ilo * b_dim1], ldb);
/* Computing MAX */
	d__2 = rab, d__3 = (d__1 = b[i__ + (irab + *ilo - 1) * b_dim1], Dymola_abs(
		d__1));
	rab = Dymola_max(d__2,d__3);
	d__1 = rab + sfmin;
	lrab = (integer) (d_lg10(&d__1) / basl + 1.);
	ir = (integer) (lscale[i__] + d_sign(&c_b71, &lscale[i__]));
/* Computing MIN */
	i__2 = Dymola_max(ir,lsfmin), i__2 = Dymola_min(i__2,lsfmax), i__3 = lsfmax - lrab;
	ir = Dymola_min(i__2,i__3);
	lscale[i__] = pow_di(&c_b35, &ir);
	icab = idamax_(ihi, &a[i__ * a_dim1 + 1], &c__1);
	cab = (d__1 = a[icab + i__ * a_dim1], Dymola_abs(d__1));
	icab = idamax_(ihi, &b[i__ * b_dim1 + 1], &c__1);
/* Computing MAX */
	d__2 = cab, d__3 = (d__1 = b[icab + i__ * b_dim1], Dymola_abs(d__1));
	cab = Dymola_max(d__2,d__3);
	d__1 = cab + sfmin;
	lcab = (integer) (d_lg10(&d__1) / basl + 1.);
	jc = (integer) (rscale[i__] + d_sign(&c_b71, &rscale[i__]));
/* Computing MIN */
	i__2 = Dymola_max(jc,lsfmin), i__2 = Dymola_min(i__2,lsfmax), i__3 = lsfmax - lcab;
	jc = Dymola_min(i__2,i__3);
	rscale[i__] = pow_di(&c_b35, &jc);
/* L360: */
    }

/*     Row scaling of matrices A and B */

    i__1 = *ihi;
    for (i__ = *ilo; i__ <= i__1; ++i__) {
	i__2 = *n - *ilo + 1;
	dscal_(&i__2, &lscale[i__], &a[i__ + *ilo * a_dim1], lda);
	i__2 = *n - *ilo + 1;
	dscal_(&i__2, &lscale[i__], &b[i__ + *ilo * b_dim1], ldb);
/* L370: */
    }

/*     Column scaling of matrices A and B */

    i__1 = *ihi;
    for (j = *ilo; j <= i__1; ++j) {
	dscal_(ihi, &rscale[j], &a[j * a_dim1 + 1], &c__1);
	dscal_(ihi, &rscale[j], &b[j * b_dim1 + 1], &c__1);
/* L380: */
    }

    return 0;

/*     End of DGGBAL */

} /* dggbal_ */

/* Subroutine */ static int dgeqrf_(integer* m, integer* n, doublereal* a, integer* lda, doublereal* tau, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    integer i__, k, ib, nb, nx, iws, nbmin, iinfo;
    integer ldwork, lwkopt;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    nb = ilaenv_(&c__1, "DGEQRF", " ", m, n, &c_n1, &c_n1);
    lwkopt = *n * nb;
    work[1] = (doublereal) lwkopt;
    lquery = *lwork == -1;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -4;
    } else if (*lwork < Dymola_max(1,*n) && ! lquery) {
	*info = -7;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGEQRF", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    k = Dymola_min(*m,*n);
    if (k == 0) {
	work[1] = 1.;
	return 0;
    }

    nbmin = 2;
    nx = 0;
    iws = *n;
    if (nb > 1 && nb < k) {

/*        Determine when to cross over from blocked to unblocked code. */

/* Computing MAX */
	i__1 = 0, i__2 = ilaenv_(&c__3, "DGEQRF", " ", m, n, &c_n1, &c_n1);
	nx = Dymola_max(i__1,i__2);
	if (nx < k) {

/*           Determine if workspace is large enough for blocked code. */

	    ldwork = *n;
	    iws = ldwork * nb;
	    if (*lwork < iws) {

/*              Not enough workspace to use optimal NB:  reduce NB and */
/*              determine the minimum value of NB. */

		nb = *lwork / ldwork;
/* Computing MAX */
		i__1 = 2, i__2 = ilaenv_(&c__2, "DGEQRF", " ", m, n, &c_n1, &
			c_n1);
		nbmin = Dymola_max(i__1,i__2);
	    }
	}
    }

    if (nb >= nbmin && nb < k && nx < k) {

/*        Use blocked code initially */

	i__1 = k - nx;
	i__2 = nb;
	for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
	    i__3 = k - i__ + 1;
	    ib = Dymola_min(i__3,nb);

/*           Compute the QR factorization of the current block */
/*           A(i:m,i:i+ib-1) */

	    i__3 = *m - i__ + 1;
	    dgeqr2_(&i__3, &ib, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[
		    1], &iinfo);
	    if (i__ + ib <= *n) {

/*              Form the triangular factor of the block reflector */
/*              H = H(i) H(i+1) . . . H(i+ib-1) */

		i__3 = *m - i__ + 1;
		dlarft_("Forward", "Columnwise", &i__3, &ib, &a[i__ + i__ * 
			a_dim1], lda, &tau[i__], &work[1], &ldwork);

/*              Apply H**T to A(i:m,i+ib:n) from the left */

		i__3 = *m - i__ + 1;
		i__4 = *n - i__ - ib + 1;
		dlarfb_("Left", "Transpose", "Forward", "Columnwise", &i__3, &
			i__4, &ib, &a[i__ + i__ * a_dim1], lda, &work[1], &
			ldwork, &a[i__ + (i__ + ib) * a_dim1], lda, &work[ib 
			+ 1], &ldwork);
	    }
/* L10: */
	}
    } else {
	i__ = 1;
    }

/*     Use unblocked code to factor the last or only block. */

    if (i__ <= k) {
	i__2 = *m - i__ + 1;
	i__1 = *n - i__ + 1;
	dgeqr2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1]
		, &iinfo);
    }

    work[1] = (doublereal) iws;
    return 0;

/*     End of DGEQRF */

} /* dgeqrf_ */

/* Subroutine */ static int dgghrd_(char* compq, char* compz, integer* n, integer* ilo, integer* ihi, doublereal* a, integer* lda, doublereal* b, integer* ldb, doublereal* q, integer* ldq, doublereal* z__, integer* ldz, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, q_dim1, q_offset, z_dim1, 
	    z_offset, i__1, i__2, i__3;

    /* Local variables */
    doublereal c__, s;
    logical ilq, ilz;
    integer jcol;
    doublereal temp;
    integer jrow;
    integer icompq, icompz;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode COMPQ */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;

    /* Function Body */
    if (lsame_(compq, "N", (ftnlen)1, (ftnlen)1)) {
	ilq = FALSE_;
	icompq = 1;
    } else if (lsame_(compq, "V", (ftnlen)1, (ftnlen)1)) {
	ilq = TRUE_;
	icompq = 2;
    } else if (lsame_(compq, "I", (ftnlen)1, (ftnlen)1)) {
	ilq = TRUE_;
	icompq = 3;
    } else {
	icompq = 0;
    }

/*     Decode COMPZ */

    if (lsame_(compz, "N", (ftnlen)1, (ftnlen)1)) {
	ilz = FALSE_;
	icompz = 1;
    } else if (lsame_(compz, "V", (ftnlen)1, (ftnlen)1)) {
	ilz = TRUE_;
	icompz = 2;
    } else if (lsame_(compz, "I", (ftnlen)1, (ftnlen)1)) {
	ilz = TRUE_;
	icompz = 3;
    } else {
	icompz = 0;
    }

/*     Test the input parameters. */

    *info = 0;
    if (icompq <= 0) {
	*info = -1;
    } else if (icompz <= 0) {
	*info = -2;
    } else if (*n < 0) {
	*info = -3;
    } else if (*ilo < 1) {
	*info = -4;
    } else if (*ihi > *n || *ihi < *ilo - 1) {
	*info = -5;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -7;
    } else if (*ldb < Dymola_max(1,*n)) {
	*info = -9;
    } else if (ilq && *ldq < *n || *ldq < 1) {
	*info = -11;
    } else if (ilz && *ldz < *n || *ldz < 1) {
	*info = -13;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGGHRD", &i__1);
	return 0;
    }

/*     Initialize Q and Z if desired. */

    if (icompq == 3) {
	dlaset_("Full", n, n, &c_b10, &c_b11, &q[q_offset], ldq);
    }
    if (icompz == 3) {
	dlaset_("Full", n, n, &c_b10, &c_b11, &z__[z_offset], ldz);
    }

/*     Quick return if possible */

    if (*n <= 1) {
	return 0;
    }

/*     Zero out lower triangle of B */

    i__1 = *n - 1;
    for (jcol = 1; jcol <= i__1; ++jcol) {
	i__2 = *n;
	for (jrow = jcol + 1; jrow <= i__2; ++jrow) {
	    b[jrow + jcol * b_dim1] = 0.;
/* L10: */
	}
/* L20: */
    }

/*     Reduce A and B */

    i__1 = *ihi - 2;
    for (jcol = *ilo; jcol <= i__1; ++jcol) {

	i__2 = jcol + 2;
	for (jrow = *ihi; jrow >= i__2; --jrow) {

/*           Step 1: rotate rows JROW-1, JROW to kill A(JROW,JCOL) */

	    temp = a[jrow - 1 + jcol * a_dim1];
	    dlartg_(&temp, &a[jrow + jcol * a_dim1], &c__, &s, &a[jrow - 1 + 
		    jcol * a_dim1]);
	    a[jrow + jcol * a_dim1] = 0.;
	    i__3 = *n - jcol;
	    drot_(&i__3, &a[jrow - 1 + (jcol + 1) * a_dim1], lda, &a[jrow + (
		    jcol + 1) * a_dim1], lda, &c__, &s);
	    i__3 = *n + 2 - jrow;
	    drot_(&i__3, &b[jrow - 1 + (jrow - 1) * b_dim1], ldb, &b[jrow + (
		    jrow - 1) * b_dim1], ldb, &c__, &s);
	    if (ilq) {
		drot_(n, &q[(jrow - 1) * q_dim1 + 1], &c__1, &q[jrow * q_dim1 
			+ 1], &c__1, &c__, &s);
	    }

/*           Step 2: rotate columns JROW, JROW-1 to kill B(JROW,JROW-1) */

	    temp = b[jrow + jrow * b_dim1];
	    dlartg_(&temp, &b[jrow + (jrow - 1) * b_dim1], &c__, &s, &b[jrow 
		    + jrow * b_dim1]);
	    b[jrow + (jrow - 1) * b_dim1] = 0.;
	    drot_(ihi, &a[jrow * a_dim1 + 1], &c__1, &a[(jrow - 1) * a_dim1 + 
		    1], &c__1, &c__, &s);
	    i__3 = jrow - 1;
	    drot_(&i__3, &b[jrow * b_dim1 + 1], &c__1, &b[(jrow - 1) * b_dim1 
		    + 1], &c__1, &c__, &s);
	    if (ilz) {
		drot_(n, &z__[jrow * z_dim1 + 1], &c__1, &z__[(jrow - 1) * 
			z_dim1 + 1], &c__1, &c__, &s);
	    }
/* L30: */
	}
/* L40: */
    }

    return 0;

/*     End of DGGHRD */

} /* dgghrd_ */

/* Subroutine */ static int dhgeqz_(const char *job, const char *compq, const char *compz, integer *n, integer *ilo, integer *ihi, doublereal *h__, integer *ldh, doublereal *t, integer *ldt, doublereal *alphar, doublereal *alphai, doublereal *beta, doublereal *q, const integer *ldq, doublereal *z__, const integer *ldz, doublereal *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer h_dim1, h_offset, q_dim1, q_offset, t_dim1, t_offset, z_dim1, 
	    z_offset, i__1, i__2, i__3, i__4;
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    doublereal c__;
    integer j;
    doublereal s, v[3], s1, s2, t1, u1, u2, a11, a12, a21, a22, b11, b22, c12,
	     c21;
    integer jc;
    doublereal an, bn, cl, cq, cr;
    integer in;
    doublereal u12, w11, w12, w21;
    integer jr;
    doublereal cz, w22, sl, wi, sr, vs, wr, b1a, b2a, a1i, a2i, b1i, b2i, a1r,
	     a2r, b1r, b2r, wr2, ad11, ad12, ad21, ad22, c11i, c22i;
    integer jch;
    doublereal c11r, c22r;
    logical ilq;
    doublereal u12l, tau, sqi;
    logical ilz;
    doublereal ulp, sqr, szi, szr, ad11l, ad12l, ad21l, ad22l, ad32l, wabs, 
	    atol, btol, temp;
    doublereal temp2, s1inv, scale;
    integer iiter, ilast, jiter;
    doublereal anorm, bnorm;
    integer maxit;
    doublereal tempi, tempr;
    logical ilazr2;
    doublereal ascale, bscale;
    doublereal safmin;
    doublereal safmax;
    doublereal eshift;
    logical ilschr;
    integer icompq, ilastm, ischur;
    logical ilazro;
    integer icompz, ifirst, ifrstm, istart;
    logical ilpivt, lquery;


/*  -- LAPACK computational routine (version 3.5.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2013 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*    $                     SAFETY = 1.0E+0 ) */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode JOB, COMPQ, COMPZ */

    /* Parameter adjustments */
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --alphar;
    --alphai;
    --beta;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --work;

    /* Function Body */
    if (lsame_(job, "E", (ftnlen)1, (ftnlen)1)) {
	ilschr = FALSE_;
	ischur = 1;
    } else if (lsame_(job, "S", (ftnlen)1, (ftnlen)1)) {
	ilschr = TRUE_;
	ischur = 2;
    } else {
	ischur = 0;
    }

    if (lsame_(compq, "N", (ftnlen)1, (ftnlen)1)) {
	ilq = FALSE_;
	icompq = 1;
    } else if (lsame_(compq, "V", (ftnlen)1, (ftnlen)1)) {
	ilq = TRUE_;
	icompq = 2;
    } else if (lsame_(compq, "I", (ftnlen)1, (ftnlen)1)) {
	ilq = TRUE_;
	icompq = 3;
    } else {
	icompq = 0;
    }

    if (lsame_(compz, "N", (ftnlen)1, (ftnlen)1)) {
	ilz = FALSE_;
	icompz = 1;
    } else if (lsame_(compz, "V", (ftnlen)1, (ftnlen)1)) {
	ilz = TRUE_;
	icompz = 2;
    } else if (lsame_(compz, "I", (ftnlen)1, (ftnlen)1)) {
	ilz = TRUE_;
	icompz = 3;
    } else {
	icompz = 0;
    }

/*     Check Argument Values */

    *info = 0;
    work[1] = (doublereal) Dymola_max(1,*n);
    lquery = *lwork == -1;
    if (ischur == 0) {
	*info = -1;
    } else if (icompq == 0) {
	*info = -2;
    } else if (icompz == 0) {
	*info = -3;
    } else if (*n < 0) {
	*info = -4;
    } else if (*ilo < 1) {
	*info = -5;
    } else if (*ihi > *n || *ihi < *ilo - 1) {
	*info = -6;
    } else if (*ldh < *n) {
	*info = -8;
    } else if (*ldt < *n) {
	*info = -10;
    } else if (*ldq < 1 || ilq && *ldq < *n) {
	*info = -15;
    } else if (*ldz < 1 || ilz && *ldz < *n) {
	*info = -17;
    } else if (*lwork < Dymola_max(1,*n) && ! lquery) {
	*info = -19;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DHGEQZ", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*n <= 0) {
	work[1] = 1.;
	return 0;
    }

/*     Initialize Q and Z */

    if (icompq == 3) {
      dlaset_("Full", n, n, &c_b12_dhgeqz, &c_b13, &q[q_offset], (integer*) ldq);
    }
    if (icompz == 3) {
      dlaset_("Full", n, n, &c_b12_dhgeqz, &c_b13, &z__[z_offset], (integer*) ldz);
    }

/*     Machine Constants */

    in = *ihi + 1 - *ilo;
    safmin = dlamch_("S");
    safmax = 1. / safmin;
    ulp = dlamch_("E") * dlamch_("B");
    anorm = dlanhs_("F", &in, &h__[*ilo + *ilo * h_dim1], ldh, &work[1]);
    bnorm = dlanhs_("F", &in, &t[*ilo + *ilo * t_dim1], ldt, &work[1]);
/* Computing MAX */
    d__1 = safmin, d__2 = ulp * anorm;
    atol = Dymola_max(d__1,d__2);
/* Computing MAX */
    d__1 = safmin, d__2 = ulp * bnorm;
    btol = Dymola_max(d__1,d__2);
    ascale = 1. / Dymola_max(safmin,anorm);
    bscale = 1. / Dymola_max(safmin,bnorm);

/*     Set Eigenvalues IHI+1:N */

    i__1 = *n;
    for (j = *ihi + 1; j <= i__1; ++j) {
	if (t[j + j * t_dim1] < 0.) {
	    if (ilschr) {
		i__2 = j;
		for (jr = 1; jr <= i__2; ++jr) {
		    h__[jr + j * h_dim1] = -h__[jr + j * h_dim1];
		    t[jr + j * t_dim1] = -t[jr + j * t_dim1];
/* L10: */
		}
	    } else {
		h__[j + j * h_dim1] = -h__[j + j * h_dim1];
		t[j + j * t_dim1] = -t[j + j * t_dim1];
	    }
	    if (ilz) {
		i__2 = *n;
		for (jr = 1; jr <= i__2; ++jr) {
		    z__[jr + j * z_dim1] = -z__[jr + j * z_dim1];
/* L20: */
		}
	    }
	}
	alphar[j] = h__[j + j * h_dim1];
	alphai[j] = 0.;
	beta[j] = t[j + j * t_dim1];
/* L30: */
    }

/*     If IHI < ILO, skip QZ steps */

    if (*ihi < *ilo) {
	goto L380;
    }

/*     MAIN QZ ITERATION LOOP */

/*     Initialize dynamic indices */

/*     Eigenvalues ILAST+1:N have been found. */
/*        Column operations modify rows IFRSTM:whatever. */
/*        Row operations modify columns whatever:ILASTM. */

/*     If only eigenvalues are being computed, then */
/*        IFRSTM is the row of the last splitting row above row ILAST; */
/*        this is always at least ILO. */
/*     IITER counts iterations since the last eigenvalue was found, */
/*        to tell when to use an extraordinary shift. */
/*     MAXIT is the maximum number of QZ sweeps allowed. */

    ilast = *ihi;
    if (ilschr) {
	ifrstm = 1;
	ilastm = *n;
    } else {
	ifrstm = *ilo;
	ilastm = *ihi;
    }
    iiter = 0;
    eshift = 0.;
    maxit = (*ihi - *ilo + 1) * 30;

    i__1 = maxit;
    for (jiter = 1; jiter <= i__1; ++jiter) {

/*        Split the matrix if possible. */

/*        Two tests: */
/*           1: H(j,j-1)=0  or  j=ILO */
/*           2: T(j,j)=0 */

	if (ilast == *ilo) {

/*           Special case: j=ILAST */

	    goto L80;
	} else {
	    if ((d__1 = h__[ilast + (ilast - 1) * h_dim1], Dymola_abs(d__1)) <= atol)
		     {
		h__[ilast + (ilast - 1) * h_dim1] = 0.;
		goto L80;
	    }
	}

	if ((d__1 = t[ilast + ilast * t_dim1], Dymola_abs(d__1)) <= btol) {
	    t[ilast + ilast * t_dim1] = 0.;
	    goto L70;
	}

/*        General case: j<ILAST */

	i__2 = *ilo;
	for (j = ilast - 1; j >= i__2; --j) {

/*           Test 1: for H(j,j-1)=0 or j=ILO */

	    if (j == *ilo) {
		ilazro = TRUE_;
	    } else {
		if ((d__1 = h__[j + (j - 1) * h_dim1], Dymola_abs(d__1)) <= atol) {
		    h__[j + (j - 1) * h_dim1] = 0.;
		    ilazro = TRUE_;
		} else {
		    ilazro = FALSE_;
		}
	    }

/*           Test 2: for T(j,j)=0 */

	    if ((d__1 = t[j + j * t_dim1], Dymola_abs(d__1)) < btol) {
		t[j + j * t_dim1] = 0.;

/*              Test 1a: Check for 2 consecutive small subdiagonals in A */

		ilazr2 = FALSE_;
		if (! ilazro) {
		    temp = (d__1 = h__[j + (j - 1) * h_dim1], Dymola_abs(d__1));
		    temp2 = (d__1 = h__[j + j * h_dim1], Dymola_abs(d__1));
		    tempr = Dymola_max(temp,temp2);
		    if (tempr < 1. && tempr != 0.) {
			temp /= tempr;
			temp2 /= tempr;
		    }
		    if (temp * (ascale * (d__1 = h__[j + 1 + j * h_dim1], Dymola_abs(
			    d__1))) <= temp2 * (ascale * atol)) {
			ilazr2 = TRUE_;
		    }
		}

/*              If both tests pass (1 & 2), i.e., the leading diagonal */
/*              element of B in the block is zero, split a 1x1 block off */
/*              at the top. (I.e., at the J-th row/column) The leading */
/*              diagonal element of the remainder can also be zero, so */
/*              this may have to be done repeatedly. */

		if (ilazro || ilazr2) {
		    i__3 = ilast - 1;
		    for (jch = j; jch <= i__3; ++jch) {
			temp = h__[jch + jch * h_dim1];
			dlartg_(&temp, &h__[jch + 1 + jch * h_dim1], &c__, &s,
				 &h__[jch + jch * h_dim1]);
			h__[jch + 1 + jch * h_dim1] = 0.;
			i__4 = ilastm - jch;
			drot_(&i__4, &h__[jch + (jch + 1) * h_dim1], ldh, &
				h__[jch + 1 + (jch + 1) * h_dim1], ldh, &c__, 
				&s);
			i__4 = ilastm - jch;
			drot_(&i__4, &t[jch + (jch + 1) * t_dim1], ldt, &t[
				jch + 1 + (jch + 1) * t_dim1], ldt, &c__, &s);
			if (ilq) {
			    drot_(n, &q[jch * q_dim1 + 1], &c__1, &q[(jch + 1)
				     * q_dim1 + 1], &c__1, &c__, &s);
			}
			if (ilazr2) {
			    h__[jch + (jch - 1) * h_dim1] *= c__;
			}
			ilazr2 = FALSE_;
			if ((d__1 = t[jch + 1 + (jch + 1) * t_dim1], Dymola_abs(d__1)
				) >= btol) {
			    if (jch + 1 >= ilast) {
				goto L80;
			    } else {
				ifirst = jch + 1;
				goto L110;
			    }
			}
			t[jch + 1 + (jch + 1) * t_dim1] = 0.;
/* L40: */
		    }
		    goto L70;
		} else {

/*                 Only test 2 passed -- chase the zero to T(ILAST,ILAST) */
/*                 Then process as in the case T(ILAST,ILAST)=0 */

		    i__3 = ilast - 1;
		    for (jch = j; jch <= i__3; ++jch) {
			temp = t[jch + (jch + 1) * t_dim1];
			dlartg_(&temp, &t[jch + 1 + (jch + 1) * t_dim1], &c__,
				 &s, &t[jch + (jch + 1) * t_dim1]);
			t[jch + 1 + (jch + 1) * t_dim1] = 0.;
			if (jch < ilastm - 1) {
			    i__4 = ilastm - jch - 1;
			    drot_(&i__4, &t[jch + (jch + 2) * t_dim1], ldt, &
				    t[jch + 1 + (jch + 2) * t_dim1], ldt, &
				    c__, &s);
			}
			i__4 = ilastm - jch + 2;
			drot_(&i__4, &h__[jch + (jch - 1) * h_dim1], ldh, &
				h__[jch + 1 + (jch - 1) * h_dim1], ldh, &c__, 
				&s);
			if (ilq) {
			    drot_(n, &q[jch * q_dim1 + 1], &c__1, &q[(jch + 1)
				     * q_dim1 + 1], &c__1, &c__, &s);
			}
			temp = h__[jch + 1 + jch * h_dim1];
			dlartg_(&temp, &h__[jch + 1 + (jch - 1) * h_dim1], &
				c__, &s, &h__[jch + 1 + jch * h_dim1]);
			h__[jch + 1 + (jch - 1) * h_dim1] = 0.;
			i__4 = jch + 1 - ifrstm;
			drot_(&i__4, &h__[ifrstm + jch * h_dim1], &c__1, &h__[
				ifrstm + (jch - 1) * h_dim1], &c__1, &c__, &s)
				;
			i__4 = jch - ifrstm;
			drot_(&i__4, &t[ifrstm + jch * t_dim1], &c__1, &t[
				ifrstm + (jch - 1) * t_dim1], &c__1, &c__, &s)
				;
			if (ilz) {
			    drot_(n, &z__[jch * z_dim1 + 1], &c__1, &z__[(jch 
				    - 1) * z_dim1 + 1], &c__1, &c__, &s);
			}
/* L50: */
		    }
		    goto L70;
		}
	    } else if (ilazro) {

/*              Only test 1 passed -- work on J:ILAST */

		ifirst = j;
		goto L110;
	    }

/*           Neither test passed -- try next J */

/* L60: */
	}

/*        (Drop-through is "impossible") */

	*info = *n + 1;
	goto L420;

/*        T(ILAST,ILAST)=0 -- clear H(ILAST,ILAST-1) to split off a */
/*        1x1 block. */

L70:
	temp = h__[ilast + ilast * h_dim1];
	dlartg_(&temp, &h__[ilast + (ilast - 1) * h_dim1], &c__, &s, &h__[
		ilast + ilast * h_dim1]);
	h__[ilast + (ilast - 1) * h_dim1] = 0.;
	i__2 = ilast - ifrstm;
	drot_(&i__2, &h__[ifrstm + ilast * h_dim1], &c__1, &h__[ifrstm + (
		ilast - 1) * h_dim1], &c__1, &c__, &s);
	i__2 = ilast - ifrstm;
	drot_(&i__2, &t[ifrstm + ilast * t_dim1], &c__1, &t[ifrstm + (ilast - 
		1) * t_dim1], &c__1, &c__, &s);
	if (ilz) {
	    drot_(n, &z__[ilast * z_dim1 + 1], &c__1, &z__[(ilast - 1) * 
		    z_dim1 + 1], &c__1, &c__, &s);
	}

/*        H(ILAST,ILAST-1)=0 -- Standardize B, set ALPHAR, ALPHAI, */
/*                              and BETA */

L80:
	if (t[ilast + ilast * t_dim1] < 0.) {
	    if (ilschr) {
		i__2 = ilast;
		for (j = ifrstm; j <= i__2; ++j) {
		    h__[j + ilast * h_dim1] = -h__[j + ilast * h_dim1];
		    t[j + ilast * t_dim1] = -t[j + ilast * t_dim1];
/* L90: */
		}
	    } else {
		h__[ilast + ilast * h_dim1] = -h__[ilast + ilast * h_dim1];
		t[ilast + ilast * t_dim1] = -t[ilast + ilast * t_dim1];
	    }
	    if (ilz) {
		i__2 = *n;
		for (j = 1; j <= i__2; ++j) {
		    z__[j + ilast * z_dim1] = -z__[j + ilast * z_dim1];
/* L100: */
		}
	    }
	}
	alphar[ilast] = h__[ilast + ilast * h_dim1];
	alphai[ilast] = 0.;
	beta[ilast] = t[ilast + ilast * t_dim1];

/*        Go to next block -- exit if finished. */

	--ilast;
	if (ilast < *ilo) {
	    goto L380;
	}

/*        Reset counters */

	iiter = 0;
	eshift = 0.;
	if (! ilschr) {
	    ilastm = ilast;
	    if (ifrstm > ilast) {
		ifrstm = *ilo;
	    }
	}
	goto L350;

/*        QZ step */

/*        This iteration only involves rows/columns IFIRST:ILAST. We */
/*        assume IFIRST < ILAST, and that the diagonal of B is non-zero. */

L110:
	++iiter;
	if (! ilschr) {
	    ifrstm = ifirst;
	}

/*        Compute single shifts. */

/*        At this point, IFIRST < ILAST, and the diagonal elements of */
/*        T(IFIRST:ILAST,IFIRST,ILAST) are larger than BTOL (in */
/*        magnitude) */

	if (iiter / 10 * 10 == iiter) {

/*           Exceptional shift.  Chosen for no particularly good reason. */
/*           (Single shift only.) */

	    if ((doublereal) maxit * safmin * (d__1 = h__[ilast + (ilast - 1) 
		    * h_dim1], Dymola_abs(d__1)) < (d__2 = t[ilast - 1 + (ilast - 1) 
		    * t_dim1], Dymola_abs(d__2))) {
		eshift = h__[ilast + (ilast - 1) * h_dim1] / t[ilast - 1 + (
			ilast - 1) * t_dim1];
	    } else {
		eshift += 1. / (safmin * (doublereal) maxit);
	    }
	    s1 = 1.;
	    wr = eshift;

	} else {

/*           Shifts based on the generalized eigenvalues of the */
/*           bottom-right 2x2 block of A and B. The first eigenvalue */
/*           returned by DLAG2 is the Wilkinson shift (AEP p.512), */

	    d__1 = safmin * 100.;
	    dlag2_(&h__[ilast - 1 + (ilast - 1) * h_dim1], ldh, &t[ilast - 1 
		    + (ilast - 1) * t_dim1], ldt, &d__1, &s1, &s2, &wr, &wr2, 
		    &wi);

	    if ((d__1 = wr / s1 * t[ilast + ilast * t_dim1] - h__[ilast + 
		    ilast * h_dim1], Dymola_abs(d__1)) > (d__2 = wr2 / s2 * t[ilast 
		    + ilast * t_dim1] - h__[ilast + ilast * h_dim1], Dymola_abs(d__2)
		    )) {
		temp = wr;
		wr = wr2;
		wr2 = temp;
		temp = s1;
		s1 = s2;
		s2 = temp;
	    }
/* Computing MAX */
/* Computing MAX */
	    d__3 = 1., d__4 = Dymola_abs(wr), d__3 = Dymola_max(d__3,d__4), d__4 = Dymola_abs(wi);
	    d__1 = s1, d__2 = safmin * Dymola_max(d__3,d__4);
	    temp = Dymola_max(d__1,d__2);
	    if (wi != 0.) {
		goto L200;
	    }
	}

/*        Fiddle with shift to avoid overflow */

	temp = Dymola_min(ascale,1.) * (safmax * .5);
	if (s1 > temp) {
	    scale = temp / s1;
	} else {
	    scale = 1.;
	}

	temp = Dymola_min(bscale,1.) * (safmax * .5);
	if (Dymola_abs(wr) > temp) {
/* Computing MIN */
	    d__1 = scale, d__2 = temp / Dymola_abs(wr);
	    scale = Dymola_min(d__1,d__2);
	}
	s1 = scale * s1;
	wr = scale * wr;

/*        Now check for two consecutive small subdiagonals. */

	i__2 = ifirst + 1;
	for (j = ilast - 1; j >= i__2; --j) {
	    istart = j;
	    temp = (d__1 = s1 * h__[j + (j - 1) * h_dim1], Dymola_abs(d__1));
	    temp2 = (d__1 = s1 * h__[j + j * h_dim1] - wr * t[j + j * t_dim1],
		     Dymola_abs(d__1));
	    tempr = Dymola_max(temp,temp2);
	    if (tempr < 1. && tempr != 0.) {
		temp /= tempr;
		temp2 /= tempr;
	    }
	    if ((d__1 = ascale * h__[j + 1 + j * h_dim1] * temp, Dymola_abs(d__1)) <=
		     ascale * atol * temp2) {
		goto L130;
	    }
/* L120: */
	}

	istart = ifirst;
L130:

/*        Do an implicit single-shift QZ sweep. */

/*        Initial Q */

	temp = s1 * h__[istart + istart * h_dim1] - wr * t[istart + istart * 
		t_dim1];
	temp2 = s1 * h__[istart + 1 + istart * h_dim1];
	dlartg_(&temp, &temp2, &c__, &s, &tempr);

/*        Sweep */

	i__2 = ilast - 1;
	for (j = istart; j <= i__2; ++j) {
	    if (j > istart) {
		temp = h__[j + (j - 1) * h_dim1];
		dlartg_(&temp, &h__[j + 1 + (j - 1) * h_dim1], &c__, &s, &h__[
			j + (j - 1) * h_dim1]);
		h__[j + 1 + (j - 1) * h_dim1] = 0.;
	    }

	    i__3 = ilastm;
	    for (jc = j; jc <= i__3; ++jc) {
		temp = c__ * h__[j + jc * h_dim1] + s * h__[j + 1 + jc * 
			h_dim1];
		h__[j + 1 + jc * h_dim1] = -s * h__[j + jc * h_dim1] + c__ * 
			h__[j + 1 + jc * h_dim1];
		h__[j + jc * h_dim1] = temp;
		temp2 = c__ * t[j + jc * t_dim1] + s * t[j + 1 + jc * t_dim1];
		t[j + 1 + jc * t_dim1] = -s * t[j + jc * t_dim1] + c__ * t[j 
			+ 1 + jc * t_dim1];
		t[j + jc * t_dim1] = temp2;
/* L140: */
	    }
	    if (ilq) {
		i__3 = *n;
		for (jr = 1; jr <= i__3; ++jr) {
		    temp = c__ * q[jr + j * q_dim1] + s * q[jr + (j + 1) * 
			    q_dim1];
		    q[jr + (j + 1) * q_dim1] = -s * q[jr + j * q_dim1] + c__ *
			     q[jr + (j + 1) * q_dim1];
		    q[jr + j * q_dim1] = temp;
/* L150: */
		}
	    }

	    temp = t[j + 1 + (j + 1) * t_dim1];
	    dlartg_(&temp, &t[j + 1 + j * t_dim1], &c__, &s, &t[j + 1 + (j + 
		    1) * t_dim1]);
	    t[j + 1 + j * t_dim1] = 0.;

/* Computing MIN */
	    i__4 = j + 2;
	    i__3 = Dymola_min(i__4,ilast);
	    for (jr = ifrstm; jr <= i__3; ++jr) {
		temp = c__ * h__[jr + (j + 1) * h_dim1] + s * h__[jr + j * 
			h_dim1];
		h__[jr + j * h_dim1] = -s * h__[jr + (j + 1) * h_dim1] + c__ *
			 h__[jr + j * h_dim1];
		h__[jr + (j + 1) * h_dim1] = temp;
/* L160: */
	    }
	    i__3 = j;
	    for (jr = ifrstm; jr <= i__3; ++jr) {
		temp = c__ * t[jr + (j + 1) * t_dim1] + s * t[jr + j * t_dim1]
			;
		t[jr + j * t_dim1] = -s * t[jr + (j + 1) * t_dim1] + c__ * t[
			jr + j * t_dim1];
		t[jr + (j + 1) * t_dim1] = temp;
/* L170: */
	    }
	    if (ilz) {
		i__3 = *n;
		for (jr = 1; jr <= i__3; ++jr) {
		    temp = c__ * z__[jr + (j + 1) * z_dim1] + s * z__[jr + j *
			     z_dim1];
		    z__[jr + j * z_dim1] = -s * z__[jr + (j + 1) * z_dim1] + 
			    c__ * z__[jr + j * z_dim1];
		    z__[jr + (j + 1) * z_dim1] = temp;
/* L180: */
		}
	    }
/* L190: */
	}

	goto L350;

/*        Use Francis double-shift */

/*        Note: the Francis double-shift should work with real shifts, */
/*              but only if the block is at least 3x3. */
/*              This code may break if this point is reached with */
/*              a 2x2 block with real eigenvalues. */

L200:
	if (ifirst + 1 == ilast) {

/*           Special case -- 2x2 block with complex eigenvectors */

/*           Step 1: Standardize, that is, rotate so that */

/*                       ( B11  0  ) */
/*                   B = (         )  with B11 non-negative. */
/*                       (  0  B22 ) */

	    dlasv2_(&t[ilast - 1 + (ilast - 1) * t_dim1], &t[ilast - 1 + 
		    ilast * t_dim1], &t[ilast + ilast * t_dim1], &b22, &b11, &
		    sr, &cr, &sl, &cl);

	    if (b11 < 0.) {
		cr = -cr;
		sr = -sr;
		b11 = -b11;
		b22 = -b22;
	    }

	    i__2 = ilastm + 1 - ifirst;
	    drot_(&i__2, &h__[ilast - 1 + (ilast - 1) * h_dim1], ldh, &h__[
		    ilast + (ilast - 1) * h_dim1], ldh, &cl, &sl);
	    i__2 = ilast + 1 - ifrstm;
	    drot_(&i__2, &h__[ifrstm + (ilast - 1) * h_dim1], &c__1, &h__[
		    ifrstm + ilast * h_dim1], &c__1, &cr, &sr);

	    if (ilast < ilastm) {
		i__2 = ilastm - ilast;
		drot_(&i__2, &t[ilast - 1 + (ilast + 1) * t_dim1], ldt, &t[
			ilast + (ilast + 1) * t_dim1], ldt, &cl, &sl);
	    }
	    if (ifrstm < ilast - 1) {
		i__2 = ifirst - ifrstm;
		drot_(&i__2, &t[ifrstm + (ilast - 1) * t_dim1], &c__1, &t[
			ifrstm + ilast * t_dim1], &c__1, &cr, &sr);
	    }

	    if (ilq) {
		drot_(n, &q[(ilast - 1) * q_dim1 + 1], &c__1, &q[ilast * 
			q_dim1 + 1], &c__1, &cl, &sl);
	    }
	    if (ilz) {
		drot_(n, &z__[(ilast - 1) * z_dim1 + 1], &c__1, &z__[ilast * 
			z_dim1 + 1], &c__1, &cr, &sr);
	    }

	    t[ilast - 1 + (ilast - 1) * t_dim1] = b11;
	    t[ilast - 1 + ilast * t_dim1] = 0.;
	    t[ilast + (ilast - 1) * t_dim1] = 0.;
	    t[ilast + ilast * t_dim1] = b22;

/*           If B22 is negative, negate column ILAST */

	    if (b22 < 0.) {
		i__2 = ilast;
		for (j = ifrstm; j <= i__2; ++j) {
		    h__[j + ilast * h_dim1] = -h__[j + ilast * h_dim1];
		    t[j + ilast * t_dim1] = -t[j + ilast * t_dim1];
/* L210: */
		}

		if (ilz) {
		    i__2 = *n;
		    for (j = 1; j <= i__2; ++j) {
			z__[j + ilast * z_dim1] = -z__[j + ilast * z_dim1];
/* L220: */
		    }
		}
		b22 = -b22;
	    }

/*           Step 2: Compute ALPHAR, ALPHAI, and BETA (see refs.) */

/*           Recompute shift */

	    d__1 = safmin * 100.;
	    dlag2_(&h__[ilast - 1 + (ilast - 1) * h_dim1], ldh, &t[ilast - 1 
		    + (ilast - 1) * t_dim1], ldt, &d__1, &s1, &temp, &wr, &
		    temp2, &wi);

/*           If standardization has perturbed the shift onto real line, */
/*           do another (real single-shift) QR step. */

	    if (wi == 0.) {
		goto L350;
	    }
	    s1inv = 1. / s1;

/*           Do EISPACK (QZVAL) computation of alpha and beta */

	    a11 = h__[ilast - 1 + (ilast - 1) * h_dim1];
	    a21 = h__[ilast + (ilast - 1) * h_dim1];
	    a12 = h__[ilast - 1 + ilast * h_dim1];
	    a22 = h__[ilast + ilast * h_dim1];

/*           Compute complex Givens rotation on right */
/*           (Assume some element of C = (sA - wB) > unfl ) */
/*                            __ */
/*           (sA - wB) ( CZ   -SZ ) */
/*                     ( SZ    CZ ) */

	    c11r = s1 * a11 - wr * b11;
	    c11i = -wi * b11;
	    c12 = s1 * a12;
	    c21 = s1 * a21;
	    c22r = s1 * a22 - wr * b22;
	    c22i = -wi * b22;

	    if (Dymola_abs(c11r) + Dymola_abs(c11i) + Dymola_abs(c12) > Dymola_abs(c21) + Dymola_abs(c22r) + Dymola_abs(
		    c22i)) {
		t1 = dlapy3_(&c12, &c11r, &c11i);
		cz = c12 / t1;
		szr = -c11r / t1;
		szi = -c11i / t1;
	    } else {
		cz = dlapy2_(&c22r, &c22i);
		if (cz <= safmin) {
		    cz = 0.;
		    szr = 1.;
		    szi = 0.;
		} else {
		    tempr = c22r / cz;
		    tempi = c22i / cz;
		    t1 = dlapy2_(&cz, &c21);
		    cz /= t1;
		    szr = -c21 * tempr / t1;
		    szi = c21 * tempi / t1;
		}
	    }

/*           Compute Givens rotation on left */

/*           (  CQ   SQ ) */
/*           (  __      )  A or B */
/*           ( -SQ   CQ ) */

	    an = Dymola_abs(a11) + Dymola_abs(a12) + Dymola_abs(a21) + Dymola_abs(a22);
	    bn = Dymola_abs(b11) + Dymola_abs(b22);
	    wabs = Dymola_abs(wr) + Dymola_abs(wi);
	    if (s1 * an > wabs * bn) {
		cq = cz * b11;
		sqr = szr * b22;
		sqi = -szi * b22;
	    } else {
		a1r = cz * a11 + szr * a12;
		a1i = szi * a12;
		a2r = cz * a21 + szr * a22;
		a2i = szi * a22;
		cq = dlapy2_(&a1r, &a1i);
		if (cq <= safmin) {
		    cq = 0.;
		    sqr = 1.;
		    sqi = 0.;
		} else {
		    tempr = a1r / cq;
		    tempi = a1i / cq;
		    sqr = tempr * a2r + tempi * a2i;
		    sqi = tempi * a2r - tempr * a2i;
		}
	    }
	    t1 = dlapy3_(&cq, &sqr, &sqi);
	    cq /= t1;
	    sqr /= t1;
	    sqi /= t1;

/*           Compute diagonal elements of QBZ */

	    tempr = sqr * szr - sqi * szi;
	    tempi = sqr * szi + sqi * szr;
	    b1r = cq * cz * b11 + tempr * b22;
	    b1i = tempi * b22;
	    b1a = dlapy2_(&b1r, &b1i);
	    b2r = cq * cz * b22 + tempr * b11;
	    b2i = -tempi * b11;
	    b2a = dlapy2_(&b2r, &b2i);

/*           Normalize so beta > 0, and Im( alpha1 ) > 0 */

	    beta[ilast - 1] = b1a;
	    beta[ilast] = b2a;
	    alphar[ilast - 1] = wr * b1a * s1inv;
	    alphai[ilast - 1] = wi * b1a * s1inv;
	    alphar[ilast] = wr * b2a * s1inv;
	    alphai[ilast] = -(wi * b2a) * s1inv;

/*           Step 3: Go to next block -- exit if finished. */

	    ilast = ifirst - 1;
	    if (ilast < *ilo) {
		goto L380;
	    }

/*           Reset counters */

	    iiter = 0;
	    eshift = 0.;
	    if (! ilschr) {
		ilastm = ilast;
		if (ifrstm > ilast) {
		    ifrstm = *ilo;
		}
	    }
	    goto L350;
	} else {

/*           Usual case: 3x3 or larger block, using Francis implicit */
/*                       double-shift */

/*                                    2 */
/*           Eigenvalue equation is  w  - c w + d = 0, */

/*                                         -1 2        -1 */
/*           so compute 1st column of  (A B  )  - c A B   + d */
/*           using the formula in QZIT (from EISPACK) */

/*           We assume that the block is at least 3x3 */

	    ad11 = ascale * h__[ilast - 1 + (ilast - 1) * h_dim1] / (bscale * 
		    t[ilast - 1 + (ilast - 1) * t_dim1]);
	    ad21 = ascale * h__[ilast + (ilast - 1) * h_dim1] / (bscale * t[
		    ilast - 1 + (ilast - 1) * t_dim1]);
	    ad12 = ascale * h__[ilast - 1 + ilast * h_dim1] / (bscale * t[
		    ilast + ilast * t_dim1]);
	    ad22 = ascale * h__[ilast + ilast * h_dim1] / (bscale * t[ilast + 
		    ilast * t_dim1]);
	    u12 = t[ilast - 1 + ilast * t_dim1] / t[ilast + ilast * t_dim1];
	    ad11l = ascale * h__[ifirst + ifirst * h_dim1] / (bscale * t[
		    ifirst + ifirst * t_dim1]);
	    ad21l = ascale * h__[ifirst + 1 + ifirst * h_dim1] / (bscale * t[
		    ifirst + ifirst * t_dim1]);
	    ad12l = ascale * h__[ifirst + (ifirst + 1) * h_dim1] / (bscale * 
		    t[ifirst + 1 + (ifirst + 1) * t_dim1]);
	    ad22l = ascale * h__[ifirst + 1 + (ifirst + 1) * h_dim1] / (
		    bscale * t[ifirst + 1 + (ifirst + 1) * t_dim1]);
	    ad32l = ascale * h__[ifirst + 2 + (ifirst + 1) * h_dim1] / (
		    bscale * t[ifirst + 1 + (ifirst + 1) * t_dim1]);
	    u12l = t[ifirst + (ifirst + 1) * t_dim1] / t[ifirst + 1 + (ifirst 
		    + 1) * t_dim1];

	    v[0] = (ad11 - ad11l) * (ad22 - ad11l) - ad12 * ad21 + ad21 * u12 
		    * ad11l + (ad12l - ad11l * u12l) * ad21l;
	    v[1] = (ad22l - ad11l - ad21l * u12l - (ad11 - ad11l) - (ad22 - 
		    ad11l) + ad21 * u12) * ad21l;
	    v[2] = ad32l * ad21l;

	    istart = ifirst;

	    dlarfg_(&c__3, v, &v[1], &c__1, &tau);
	    v[0] = 1.;

/*           Sweep */

	    i__2 = ilast - 2;
	    for (j = istart; j <= i__2; ++j) {

/*              All but last elements: use 3x3 Householder transforms. */

/*              Zero (j-1)st column of A */

		if (j > istart) {
		    v[0] = h__[j + (j - 1) * h_dim1];
		    v[1] = h__[j + 1 + (j - 1) * h_dim1];
		    v[2] = h__[j + 2 + (j - 1) * h_dim1];

		    dlarfg_(&c__3, &h__[j + (j - 1) * h_dim1], &v[1], &c__1, &
			    tau);
		    v[0] = 1.;
		    h__[j + 1 + (j - 1) * h_dim1] = 0.;
		    h__[j + 2 + (j - 1) * h_dim1] = 0.;
		}

		i__3 = ilastm;
		for (jc = j; jc <= i__3; ++jc) {
		    temp = tau * (h__[j + jc * h_dim1] + v[1] * h__[j + 1 + 
			    jc * h_dim1] + v[2] * h__[j + 2 + jc * h_dim1]);
		    h__[j + jc * h_dim1] -= temp;
		    h__[j + 1 + jc * h_dim1] -= temp * v[1];
		    h__[j + 2 + jc * h_dim1] -= temp * v[2];
		    temp2 = tau * (t[j + jc * t_dim1] + v[1] * t[j + 1 + jc * 
			    t_dim1] + v[2] * t[j + 2 + jc * t_dim1]);
		    t[j + jc * t_dim1] -= temp2;
		    t[j + 1 + jc * t_dim1] -= temp2 * v[1];
		    t[j + 2 + jc * t_dim1] -= temp2 * v[2];
/* L230: */
		}
		if (ilq) {
		    i__3 = *n;
		    for (jr = 1; jr <= i__3; ++jr) {
			temp = tau * (q[jr + j * q_dim1] + v[1] * q[jr + (j + 
				1) * q_dim1] + v[2] * q[jr + (j + 2) * q_dim1]
				);
			q[jr + j * q_dim1] -= temp;
			q[jr + (j + 1) * q_dim1] -= temp * v[1];
			q[jr + (j + 2) * q_dim1] -= temp * v[2];
/* L240: */
		    }
		}

/*              Zero j-th column of B (see DLAGBC for details) */

/*              Swap rows to pivot */

		ilpivt = FALSE_;
/* Computing MAX */
		d__3 = (d__1 = t[j + 1 + (j + 1) * t_dim1], Dymola_abs(d__1)), d__4 =
			 (d__2 = t[j + 1 + (j + 2) * t_dim1], Dymola_abs(d__2));
		temp = Dymola_max(d__3,d__4);
/* Computing MAX */
		d__3 = (d__1 = t[j + 2 + (j + 1) * t_dim1], Dymola_abs(d__1)), d__4 =
			 (d__2 = t[j + 2 + (j + 2) * t_dim1], Dymola_abs(d__2));
		temp2 = Dymola_max(d__3,d__4);
		if (Dymola_max(temp,temp2) < safmin) {
		    scale = 0.;
		    u1 = 1.;
		    u2 = 0.;
		    goto L250;
		} else if (temp >= temp2) {
		    w11 = t[j + 1 + (j + 1) * t_dim1];
		    w21 = t[j + 2 + (j + 1) * t_dim1];
		    w12 = t[j + 1 + (j + 2) * t_dim1];
		    w22 = t[j + 2 + (j + 2) * t_dim1];
		    u1 = t[j + 1 + j * t_dim1];
		    u2 = t[j + 2 + j * t_dim1];
		} else {
		    w21 = t[j + 1 + (j + 1) * t_dim1];
		    w11 = t[j + 2 + (j + 1) * t_dim1];
		    w22 = t[j + 1 + (j + 2) * t_dim1];
		    w12 = t[j + 2 + (j + 2) * t_dim1];
		    u2 = t[j + 1 + j * t_dim1];
		    u1 = t[j + 2 + j * t_dim1];
		}

/*              Swap columns if nec. */

		if (Dymola_abs(w12) > Dymola_abs(w11)) {
		    ilpivt = TRUE_;
		    temp = w12;
		    temp2 = w22;
		    w12 = w11;
		    w22 = w21;
		    w11 = temp;
		    w21 = temp2;
		}

/*              LU-factor */

		temp = w21 / w11;
		u2 -= temp * u1;
		w22 -= temp * w12;
		w21 = 0.;

/*              Compute SCALE */

		scale = 1.;
		if (Dymola_abs(w22) < safmin) {
		    scale = 0.;
		    u2 = 1.;
		    u1 = -w12 / w11;
		    goto L250;
		}
		if (Dymola_abs(w22) < Dymola_abs(u2)) {
		    scale = (d__1 = w22 / u2, Dymola_abs(d__1));
		}
		if (Dymola_abs(w11) < Dymola_abs(u1)) {
/* Computing MIN */
		    d__2 = scale, d__3 = (d__1 = w11 / u1, Dymola_abs(d__1));
		    scale = Dymola_min(d__2,d__3);
		}

/*              Solve */

		u2 = scale * u2 / w22;
		u1 = (scale * u1 - w12 * u2) / w11;

L250:
		if (ilpivt) {
		    temp = u2;
		    u2 = u1;
		    u1 = temp;
		}

/*              Compute Householder Vector */

/* Computing 2nd power */
		d__1 = scale;
/* Computing 2nd power */
		d__2 = u1;
/* Computing 2nd power */
		d__3 = u2;
		t1 = sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3);
		tau = scale / t1 + 1.;
		vs = -1. / (scale + t1);
		v[0] = 1.;
		v[1] = vs * u1;
		v[2] = vs * u2;

/*              Apply transformations from the right. */

/* Computing MIN */
		i__4 = j + 3;
		i__3 = Dymola_min(i__4,ilast);
		for (jr = ifrstm; jr <= i__3; ++jr) {
		    temp = tau * (h__[jr + j * h_dim1] + v[1] * h__[jr + (j + 
			    1) * h_dim1] + v[2] * h__[jr + (j + 2) * h_dim1]);
		    h__[jr + j * h_dim1] -= temp;
		    h__[jr + (j + 1) * h_dim1] -= temp * v[1];
		    h__[jr + (j + 2) * h_dim1] -= temp * v[2];
/* L260: */
		}
		i__3 = j + 2;
		for (jr = ifrstm; jr <= i__3; ++jr) {
		    temp = tau * (t[jr + j * t_dim1] + v[1] * t[jr + (j + 1) *
			     t_dim1] + v[2] * t[jr + (j + 2) * t_dim1]);
		    t[jr + j * t_dim1] -= temp;
		    t[jr + (j + 1) * t_dim1] -= temp * v[1];
		    t[jr + (j + 2) * t_dim1] -= temp * v[2];
/* L270: */
		}
		if (ilz) {
		    i__3 = *n;
		    for (jr = 1; jr <= i__3; ++jr) {
			temp = tau * (z__[jr + j * z_dim1] + v[1] * z__[jr + (
				j + 1) * z_dim1] + v[2] * z__[jr + (j + 2) * 
				z_dim1]);
			z__[jr + j * z_dim1] -= temp;
			z__[jr + (j + 1) * z_dim1] -= temp * v[1];
			z__[jr + (j + 2) * z_dim1] -= temp * v[2];
/* L280: */
		    }
		}
		t[j + 1 + j * t_dim1] = 0.;
		t[j + 2 + j * t_dim1] = 0.;
/* L290: */
	    }

/*           Last elements: Use Givens rotations */

/*           Rotations from the left */

	    j = ilast - 1;
	    temp = h__[j + (j - 1) * h_dim1];
	    dlartg_(&temp, &h__[j + 1 + (j - 1) * h_dim1], &c__, &s, &h__[j + 
		    (j - 1) * h_dim1]);
	    h__[j + 1 + (j - 1) * h_dim1] = 0.;

	    i__2 = ilastm;
	    for (jc = j; jc <= i__2; ++jc) {
		temp = c__ * h__[j + jc * h_dim1] + s * h__[j + 1 + jc * 
			h_dim1];
		h__[j + 1 + jc * h_dim1] = -s * h__[j + jc * h_dim1] + c__ * 
			h__[j + 1 + jc * h_dim1];
		h__[j + jc * h_dim1] = temp;
		temp2 = c__ * t[j + jc * t_dim1] + s * t[j + 1 + jc * t_dim1];
		t[j + 1 + jc * t_dim1] = -s * t[j + jc * t_dim1] + c__ * t[j 
			+ 1 + jc * t_dim1];
		t[j + jc * t_dim1] = temp2;
/* L300: */
	    }
	    if (ilq) {
		i__2 = *n;
		for (jr = 1; jr <= i__2; ++jr) {
		    temp = c__ * q[jr + j * q_dim1] + s * q[jr + (j + 1) * 
			    q_dim1];
		    q[jr + (j + 1) * q_dim1] = -s * q[jr + j * q_dim1] + c__ *
			     q[jr + (j + 1) * q_dim1];
		    q[jr + j * q_dim1] = temp;
/* L310: */
		}
	    }

/*           Rotations from the right. */

	    temp = t[j + 1 + (j + 1) * t_dim1];
	    dlartg_(&temp, &t[j + 1 + j * t_dim1], &c__, &s, &t[j + 1 + (j + 
		    1) * t_dim1]);
	    t[j + 1 + j * t_dim1] = 0.;

	    i__2 = ilast;
	    for (jr = ifrstm; jr <= i__2; ++jr) {
		temp = c__ * h__[jr + (j + 1) * h_dim1] + s * h__[jr + j * 
			h_dim1];
		h__[jr + j * h_dim1] = -s * h__[jr + (j + 1) * h_dim1] + c__ *
			 h__[jr + j * h_dim1];
		h__[jr + (j + 1) * h_dim1] = temp;
/* L320: */
	    }
	    i__2 = ilast - 1;
	    for (jr = ifrstm; jr <= i__2; ++jr) {
		temp = c__ * t[jr + (j + 1) * t_dim1] + s * t[jr + j * t_dim1]
			;
		t[jr + j * t_dim1] = -s * t[jr + (j + 1) * t_dim1] + c__ * t[
			jr + j * t_dim1];
		t[jr + (j + 1) * t_dim1] = temp;
/* L330: */
	    }
	    if (ilz) {
		i__2 = *n;
		for (jr = 1; jr <= i__2; ++jr) {
		    temp = c__ * z__[jr + (j + 1) * z_dim1] + s * z__[jr + j *
			     z_dim1];
		    z__[jr + j * z_dim1] = -s * z__[jr + (j + 1) * z_dim1] + 
			    c__ * z__[jr + j * z_dim1];
		    z__[jr + (j + 1) * z_dim1] = temp;
/* L340: */
		}
	    }

/*           End of Double-Shift code */

	}

	goto L350;

/*        End of iteration loop */

L350:
/* L360: */
	;
    }

/*     Drop-through = non-convergence */

    *info = ilast;
    goto L420;

/*     Successful completion of all QZ steps */

L380:

/*     Set Eigenvalues 1:ILO-1 */

    i__1 = *ilo - 1;
    for (j = 1; j <= i__1; ++j) {
	if (t[j + j * t_dim1] < 0.) {
	    if (ilschr) {
		i__2 = j;
		for (jr = 1; jr <= i__2; ++jr) {
		    h__[jr + j * h_dim1] = -h__[jr + j * h_dim1];
		    t[jr + j * t_dim1] = -t[jr + j * t_dim1];
/* L390: */
		}
	    } else {
		h__[j + j * h_dim1] = -h__[j + j * h_dim1];
		t[j + j * t_dim1] = -t[j + j * t_dim1];
	    }
	    if (ilz) {
		i__2 = *n;
		for (jr = 1; jr <= i__2; ++jr) {
		    z__[jr + j * z_dim1] = -z__[jr + j * z_dim1];
/* L400: */
		}
	    }
	}
	alphar[j] = h__[j + j * h_dim1];
	alphai[j] = 0.;
	beta[j] = t[j + j * t_dim1];
/* L410: */
    }

/*     Normal Termination */

    *info = 0;

/*     Exit (other than argument error) -- return optimal workspace size */

L420:
    work[1] = (doublereal) (*n);
    return 0;

/*     End of DHGEQZ */

} /* dhgeqz_ */

/* Subroutine */ static int dtgevc_(char* side, char* howmny, logical* select, integer* n, doublereal* s, integer* lds, doublereal* p, integer* ldp, doublereal* vl, integer* ldvl, doublereal* vr, integer* ldvr, integer* mm, integer* m, doublereal* work, integer* info)
{
    /* System generated locals */
    integer p_dim1, p_offset, s_dim1, s_offset, vl_dim1, vl_offset, vr_dim1, 
	    vr_offset, i__1, i__2, i__3, i__4, i__5;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6;

    /* Local variables */
    integer i__, j, ja, jc, je, na, im, jr, jw, nw;
    doublereal big;
    logical lsa, lsb;
    doublereal ulp, sum[4]	/* was [2][2] */;
    integer ibeg, ieig, iend;
    doublereal dmin__, temp, xmax, sump[4]	/* was [2][2] */, sums[4]	
	    /* was [2][2] */;
    doublereal cim2a, cim2b, cre2a, cre2b, temp2, bdiag[2], acoef, scale;
    logical ilall;
    integer iside;
    doublereal sbeta;
    logical il2by2;
    integer iinfo;
    doublereal small;
    logical compl;
    doublereal anorm, bnorm;
    logical compr;
    doublereal temp2i;
    doublereal temp2r;
    logical ilabad, ilbbad;
    doublereal acoefa, bcoefa, cimaga, cimagb;
    logical ilback;
    doublereal bcoefi, ascale, bscale, creala, crealb;
    doublereal bcoefr, salfar, safmin;
    doublereal xscale, bignum;
    logical ilcomp, ilcplx;
    integer ihwmny;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */


/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode and Test the input parameters */

    /* Parameter adjustments */
    --select;
    s_dim1 = *lds;
    s_offset = 1 + s_dim1;
    s -= s_offset;
    p_dim1 = *ldp;
    p_offset = 1 + p_dim1;
    p -= p_offset;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --work;

    /* Function Body */
    if (lsame_(howmny, "A", (ftnlen)1, (ftnlen)1)) {
	ihwmny = 1;
	ilall = TRUE_;
	ilback = FALSE_;
    } else if (lsame_(howmny, "S", (ftnlen)1, (ftnlen)1)) {
	ihwmny = 2;
	ilall = FALSE_;
	ilback = FALSE_;
    } else if (lsame_(howmny, "B", (ftnlen)1, (ftnlen)1)) {
	ihwmny = 3;
	ilall = TRUE_;
	ilback = TRUE_;
    } else {
	ihwmny = -1;
	ilall = TRUE_;
    }

    if (lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
	iside = 1;
	compl = FALSE_;
	compr = TRUE_;
    } else if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {
	iside = 2;
	compl = TRUE_;
	compr = FALSE_;
    } else if (lsame_(side, "B", (ftnlen)1, (ftnlen)1)) {
	iside = 3;
	compl = TRUE_;
	compr = TRUE_;
    } else {
	iside = -1;
    }

    *info = 0;
    if (iside < 0) {
	*info = -1;
    } else if (ihwmny < 0) {
	*info = -2;
    } else if (*n < 0) {
	*info = -4;
    } else if (*lds < Dymola_max(1,*n)) {
	*info = -6;
    } else if (*ldp < Dymola_max(1,*n)) {
	*info = -8;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTGEVC", &i__1);
	return 0;
    }

/*     Count the number of eigenvectors to be computed */

    if (! ilall) {
	im = 0;
	ilcplx = FALSE_;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    if (ilcplx) {
		ilcplx = FALSE_;
		goto L10;
	    }
	    if (j < *n) {
		if (s[j + 1 + j * s_dim1] != 0.) {
		    ilcplx = TRUE_;
		}
	    }
	    if (ilcplx) {
		if (select[j] || select[j + 1]) {
		    im += 2;
		}
	    } else {
		if (select[j]) {
		    ++im;
		}
	    }
L10:
	    ;
	}
    } else {
	im = *n;
    }

/*     Check 2-by-2 diagonal blocks of A, B */

    ilabad = FALSE_;
    ilbbad = FALSE_;
    i__1 = *n - 1;
    for (j = 1; j <= i__1; ++j) {
	if (s[j + 1 + j * s_dim1] != 0.) {
	    if (p[j + j * p_dim1] == 0. || p[j + 1 + (j + 1) * p_dim1] == 0. 
		    || p[j + (j + 1) * p_dim1] != 0.) {
		ilbbad = TRUE_;
	    }
	    if (j < *n - 1) {
		if (s[j + 2 + (j + 1) * s_dim1] != 0.) {
		    ilabad = TRUE_;
		}
	    }
	}
/* L20: */
    }

    if (ilabad) {
	*info = -5;
    } else if (ilbbad) {
	*info = -7;
    } else if (compl && *ldvl < *n || *ldvl < 1) {
	*info = -10;
    } else if (compr && *ldvr < *n || *ldvr < 1) {
	*info = -12;
    } else if (*mm < im) {
	*info = -13;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTGEVC", &i__1);
	return 0;
    }

/*     Quick return if possible */

    *m = im;
    if (*n == 0) {
	return 0;
    }

/*     Machine Constants */

    safmin = dlamch_("Safe minimum");
    big = 1. / safmin;
    dlabad_(&safmin, &big);
    ulp = dlamch_("Epsilon") * dlamch_("Base");
    small = safmin * *n / ulp;
    big = 1. / small;
    bignum = 1. / (safmin * *n);

/*     Compute the 1-norm of each column of the strictly upper triangular */
/*     part (i.e., excluding all elements belonging to the diagonal */
/*     blocks) of A and B to check for possible overflow in the */
/*     triangular solver. */

    anorm = (d__1 = s[s_dim1 + 1], Dymola_abs(d__1));
    if (*n > 1) {
	anorm += (d__1 = s[s_dim1 + 2], Dymola_abs(d__1));
    }
    bnorm = (d__1 = p[p_dim1 + 1], Dymola_abs(d__1));
    work[1] = 0.;
    work[*n + 1] = 0.;

    i__1 = *n;
    for (j = 2; j <= i__1; ++j) {
	temp = 0.;
	temp2 = 0.;
	if (s[j + (j - 1) * s_dim1] == 0.) {
	    iend = j - 1;
	} else {
	    iend = j - 2;
	}
	i__2 = iend;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    temp += (d__1 = s[i__ + j * s_dim1], Dymola_abs(d__1));
	    temp2 += (d__1 = p[i__ + j * p_dim1], Dymola_abs(d__1));
/* L30: */
	}
	work[j] = temp;
	work[*n + j] = temp2;
/* Computing MIN */
	i__3 = j + 1;
	i__2 = Dymola_min(i__3,*n);
	for (i__ = iend + 1; i__ <= i__2; ++i__) {
	    temp += (d__1 = s[i__ + j * s_dim1], Dymola_abs(d__1));
	    temp2 += (d__1 = p[i__ + j * p_dim1], Dymola_abs(d__1));
/* L40: */
	}
	anorm = Dymola_max(anorm,temp);
	bnorm = Dymola_max(bnorm,temp2);
/* L50: */
    }

    ascale = 1. / Dymola_max(anorm,safmin);
    bscale = 1. / Dymola_max(bnorm,safmin);

/*     Left eigenvectors */

    if (compl) {
	ieig = 0;

/*        Main loop over eigenvalues */

	ilcplx = FALSE_;
	i__1 = *n;
	for (je = 1; je <= i__1; ++je) {

/*           Skip this iteration if (a) HOWMNY='S' and SELECT=.FALSE., or */
/*           (b) this would be the second of a complex pair. */
/*           Check for complex eigenvalue, so as to be sure of which */
/*           entry(-ies) of SELECT to look at. */

	    if (ilcplx) {
		ilcplx = FALSE_;
		goto L220;
	    }
	    nw = 1;
	    if (je < *n) {
		if (s[je + 1 + je * s_dim1] != 0.) {
		    ilcplx = TRUE_;
		    nw = 2;
		}
	    }
	    if (ilall) {
		ilcomp = TRUE_;
	    } else if (ilcplx) {
		ilcomp = select[je] || select[je + 1];
	    } else {
		ilcomp = select[je];
	    }
	    if (! ilcomp) {
		goto L220;
	    }

/*           Decide if (a) singular pencil, (b) real eigenvalue, or */
/*           (c) complex eigenvalue. */

	    if (! ilcplx) {
		if ((d__1 = s[je + je * s_dim1], Dymola_abs(d__1)) <= safmin && (
			d__2 = p[je + je * p_dim1], Dymola_abs(d__2)) <= safmin) {

/*                 Singular matrix pencil -- return unit eigenvector */

		    ++ieig;
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
			vl[jr + ieig * vl_dim1] = 0.;
/* L60: */
		    }
		    vl[ieig + ieig * vl_dim1] = 1.;
		    goto L220;
		}
	    }

/*           Clear vector */

	    i__2 = nw * *n;
	    for (jr = 1; jr <= i__2; ++jr) {
		work[(*n << 1) + jr] = 0.;
/* L70: */
	    }
/*                                                 T */
/*           Compute coefficients in  ( a A - b B )  y = 0 */
/*              a  is  ACOEF */
/*              b  is  BCOEFR + i*BCOEFI */

	    if (! ilcplx) {

/*              Real eigenvalue */

/* Computing MAX */
		d__3 = (d__1 = s[je + je * s_dim1], Dymola_abs(d__1)) * ascale, d__4 
			= (d__2 = p[je + je * p_dim1], Dymola_abs(d__2)) * bscale, 
			d__3 = Dymola_max(d__3,d__4);
		temp = 1. / Dymola_max(d__3,safmin);
		salfar = temp * s[je + je * s_dim1] * ascale;
		sbeta = temp * p[je + je * p_dim1] * bscale;
		acoef = sbeta * ascale;
		bcoefr = salfar * bscale;
		bcoefi = 0.;

/*              Scale to avoid underflow */

		scale = 1.;
		lsa = Dymola_abs(sbeta) >= safmin && Dymola_abs(acoef) < small;
		lsb = Dymola_abs(salfar) >= safmin && Dymola_abs(bcoefr) < small;
		if (lsa) {
		    scale = small / Dymola_abs(sbeta) * Dymola_min(anorm,big);
		}
		if (lsb) {
/* Computing MAX */
		    d__1 = scale, d__2 = small / Dymola_abs(salfar) * Dymola_min(bnorm,big);
		    scale = Dymola_max(d__1,d__2);
		}
		if (lsa || lsb) {
/* Computing MIN */
/* Computing MAX */
		    d__3 = 1., d__4 = Dymola_abs(acoef), d__3 = Dymola_max(d__3,d__4), d__4 
			    = Dymola_abs(bcoefr);
		    d__1 = scale, d__2 = 1. / (safmin * Dymola_max(d__3,d__4));
		    scale = Dymola_min(d__1,d__2);
		    if (lsa) {
			acoef = ascale * (scale * sbeta);
		    } else {
			acoef = scale * acoef;
		    }
		    if (lsb) {
			bcoefr = bscale * (scale * salfar);
		    } else {
			bcoefr = scale * bcoefr;
		    }
		}
		acoefa = Dymola_abs(acoef);
		bcoefa = Dymola_abs(bcoefr);

/*              First component is 1 */

		work[(*n << 1) + je] = 1.;
		xmax = 1.;
	    } else {

/*              Complex eigenvalue */

		d__1 = safmin * 100.;
		dlag2_(&s[je + je * s_dim1], lds, &p[je + je * p_dim1], ldp, &
			d__1, &acoef, &temp, &bcoefr, &temp2, &bcoefi);
		bcoefi = -bcoefi;
		if (bcoefi == 0.) {
		    *info = je;
		    return 0;
		}

/*              Scale to avoid over/underflow */

		acoefa = Dymola_abs(acoef);
		bcoefa = Dymola_abs(bcoefr) + Dymola_abs(bcoefi);
		scale = 1.;
		if (acoefa * ulp < safmin && acoefa >= safmin) {
		    scale = safmin / ulp / acoefa;
		}
		if (bcoefa * ulp < safmin && bcoefa >= safmin) {
/* Computing MAX */
		    d__1 = scale, d__2 = safmin / ulp / bcoefa;
		    scale = Dymola_max(d__1,d__2);
		}
		if (safmin * acoefa > ascale) {
		    scale = ascale / (safmin * acoefa);
		}
		if (safmin * bcoefa > bscale) {
/* Computing MIN */
		    d__1 = scale, d__2 = bscale / (safmin * bcoefa);
		    scale = Dymola_min(d__1,d__2);
		}
		if (scale != 1.) {
		    acoef = scale * acoef;
		    acoefa = Dymola_abs(acoef);
		    bcoefr = scale * bcoefr;
		    bcoefi = scale * bcoefi;
		    bcoefa = Dymola_abs(bcoefr) + Dymola_abs(bcoefi);
		}

/*              Compute first two components of eigenvector */

		temp = acoef * s[je + 1 + je * s_dim1];
		temp2r = acoef * s[je + je * s_dim1] - bcoefr * p[je + je * 
			p_dim1];
		temp2i = -bcoefi * p[je + je * p_dim1];
		if (Dymola_abs(temp) > Dymola_abs(temp2r) + Dymola_abs(temp2i)) {
		    work[(*n << 1) + je] = 1.;
		    work[*n * 3 + je] = 0.;
		    work[(*n << 1) + je + 1] = -temp2r / temp;
		    work[*n * 3 + je + 1] = -temp2i / temp;
		} else {
		    work[(*n << 1) + je + 1] = 1.;
		    work[*n * 3 + je + 1] = 0.;
		    temp = acoef * s[je + (je + 1) * s_dim1];
		    work[(*n << 1) + je] = (bcoefr * p[je + 1 + (je + 1) * 
			    p_dim1] - acoef * s[je + 1 + (je + 1) * s_dim1]) /
			     temp;
		    work[*n * 3 + je] = bcoefi * p[je + 1 + (je + 1) * p_dim1]
			     / temp;
		}
/* Computing MAX */
		d__5 = (d__1 = work[(*n << 1) + je], Dymola_abs(d__1)) + (d__2 = 
			work[*n * 3 + je], Dymola_abs(d__2)), d__6 = (d__3 = work[(*
			n << 1) + je + 1], Dymola_abs(d__3)) + (d__4 = work[*n * 3 + 
			je + 1], Dymola_abs(d__4));
		xmax = Dymola_max(d__5,d__6);
	    }

/* Computing MAX */
	    d__1 = ulp * acoefa * anorm, d__2 = ulp * bcoefa * bnorm, d__1 = 
		    Dymola_max(d__1,d__2);
	    dmin__ = Dymola_max(d__1,safmin);

/*                                           T */
/*           Triangular solve of  (a A - b B)  y = 0 */

/*                                   T */
/*           (rowwise in  (a A - b B) , or columnwise in (a A - b B) ) */

	    il2by2 = FALSE_;

	    i__2 = *n;
	    for (j = je + nw; j <= i__2; ++j) {
		if (il2by2) {
		    il2by2 = FALSE_;
		    goto L160;
		}

		na = 1;
		bdiag[0] = p[j + j * p_dim1];
		if (j < *n) {
		    if (s[j + 1 + j * s_dim1] != 0.) {
			il2by2 = TRUE_;
			bdiag[1] = p[j + 1 + (j + 1) * p_dim1];
			na = 2;
		    }
		}

/*              Check whether scaling is necessary for dot products */

		xscale = 1. / Dymola_max(1.,xmax);
/* Computing MAX */
		d__1 = work[j], d__2 = work[*n + j], d__1 = Dymola_max(d__1,d__2), 
			d__2 = acoefa * work[j] + bcoefa * work[*n + j];
		temp = Dymola_max(d__1,d__2);
		if (il2by2) {
/* Computing MAX */
		    d__1 = temp, d__2 = work[j + 1], d__1 = Dymola_max(d__1,d__2), 
			    d__2 = work[*n + j + 1], d__1 = Dymola_max(d__1,d__2), 
			    d__2 = acoefa * work[j + 1] + bcoefa * work[*n + 
			    j + 1];
		    temp = Dymola_max(d__1,d__2);
		}
		if (temp > bignum * xscale) {
		    i__3 = nw - 1;
		    for (jw = 0; jw <= i__3; ++jw) {
			i__4 = j - 1;
			for (jr = je; jr <= i__4; ++jr) {
			    work[(jw + 2) * *n + jr] = xscale * work[(jw + 2) 
				    * *n + jr];
/* L80: */
			}
/* L90: */
		    }
		    xmax *= xscale;
		}

/*              Compute dot products */

/*                    j-1 */
/*              SUM = sum  conjg( a*S(k,j) - b*P(k,j) )*x(k) */
/*                    k=je */

/*              To reduce the op count, this is done as */

/*              _        j-1                  _        j-1 */
/*              a*conjg( sum  S(k,j)*x(k) ) - b*conjg( sum  P(k,j)*x(k) ) */
/*                       k=je                          k=je */

/*              which may cause underflow problems if A or B are close */
/*              to underflow.  (E.g., less than SMALL.) */


		i__3 = nw;
		for (jw = 1; jw <= i__3; ++jw) {
		    i__4 = na;
		    for (ja = 1; ja <= i__4; ++ja) {
			sums[ja + (jw << 1) - 3] = 0.;
			sump[ja + (jw << 1) - 3] = 0.;

			i__5 = j - 1;
			for (jr = je; jr <= i__5; ++jr) {
			    sums[ja + (jw << 1) - 3] += s[jr + (j + ja - 1) * 
				    s_dim1] * work[(jw + 1) * *n + jr];
			    sump[ja + (jw << 1) - 3] += p[jr + (j + ja - 1) * 
				    p_dim1] * work[(jw + 1) * *n + jr];
/* L100: */
			}
/* L110: */
		    }
/* L120: */
		}

		i__3 = na;
		for (ja = 1; ja <= i__3; ++ja) {
		    if (ilcplx) {
			sum[ja - 1] = -acoef * sums[ja - 1] + bcoefr * sump[
				ja - 1] - bcoefi * sump[ja + 1];
			sum[ja + 1] = -acoef * sums[ja + 1] + bcoefr * sump[
				ja + 1] + bcoefi * sump[ja - 1];
		    } else {
			sum[ja - 1] = -acoef * sums[ja - 1] + bcoefr * sump[
				ja - 1];
		    }
/* L130: */
		}

/*                                  T */
/*              Solve  ( a A - b B )  y = SUM(,) */
/*              with scaling and perturbation of the denominator */

		dlaln2_(&c_true, &na, &nw, &dmin__, &acoef, &s[j + j * s_dim1]
			, lds, bdiag, &bdiag[1], sum, &c__2, &bcoefr, &bcoefi,
			 &work[(*n << 1) + j], n, &scale, &temp, &iinfo);
		if (scale < 1.) {
		    i__3 = nw - 1;
		    for (jw = 0; jw <= i__3; ++jw) {
			i__4 = j - 1;
			for (jr = je; jr <= i__4; ++jr) {
			    work[(jw + 2) * *n + jr] = scale * work[(jw + 2) *
				     *n + jr];
/* L140: */
			}
/* L150: */
		    }
		    xmax = scale * xmax;
		}
		xmax = Dymola_max(xmax,temp);
L160:
		;
	    }

/*           Copy eigenvector to VL, back transforming if */
/*           HOWMNY='B'. */

	    ++ieig;
	    if (ilback) {
		i__2 = nw - 1;
		for (jw = 0; jw <= i__2; ++jw) {
		    i__3 = *n + 1 - je;
		    dgemv_("N", n, &i__3, &c_b34, &vl[je * vl_dim1 + 1], ldvl,
			     &work[(jw + 2) * *n + je], &c__1, &c_b36_dtgevc, &work[(
			    jw + 4) * *n + 1], &c__1);
/* L170: */
		}
		dlacpy_(" ", n, &nw, &work[(*n << 2) + 1], n, &vl[je * 
			vl_dim1 + 1], ldvl);
		ibeg = 1;
	    } else {
		dlacpy_(" ", n, &nw, &work[(*n << 1) + 1], n, &vl[ieig * 
			vl_dim1 + 1], ldvl);
		ibeg = je;
	    }

/*           Scale eigenvector */

	    xmax = 0.;
	    if (ilcplx) {
		i__2 = *n;
		for (j = ibeg; j <= i__2; ++j) {
/* Computing MAX */
		    d__3 = xmax, d__4 = (d__1 = vl[j + ieig * vl_dim1], Dymola_abs(
			    d__1)) + (d__2 = vl[j + (ieig + 1) * vl_dim1], 
			    Dymola_abs(d__2));
		    xmax = Dymola_max(d__3,d__4);
/* L180: */
		}
	    } else {
		i__2 = *n;
		for (j = ibeg; j <= i__2; ++j) {
/* Computing MAX */
		    d__2 = xmax, d__3 = (d__1 = vl[j + ieig * vl_dim1], Dymola_abs(
			    d__1));
		    xmax = Dymola_max(d__2,d__3);
/* L190: */
		}
	    }

	    if (xmax > safmin) {
		xscale = 1. / xmax;

		i__2 = nw - 1;
		for (jw = 0; jw <= i__2; ++jw) {
		    i__3 = *n;
		    for (jr = ibeg; jr <= i__3; ++jr) {
			vl[jr + (ieig + jw) * vl_dim1] = xscale * vl[jr + (
				ieig + jw) * vl_dim1];
/* L200: */
		    }
/* L210: */
		}
	    }
	    ieig = ieig + nw - 1;

L220:
	    ;
	}
    }

/*     Right eigenvectors */

    if (compr) {
	ieig = im + 1;

/*        Main loop over eigenvalues */

	ilcplx = FALSE_;
	for (je = *n; je >= 1; --je) {

/*           Skip this iteration if (a) HOWMNY='S' and SELECT=.FALSE., or */
/*           (b) this would be the second of a complex pair. */
/*           Check for complex eigenvalue, so as to be sure of which */
/*           entry(-ies) of SELECT to look at -- if complex, SELECT(JE) */
/*           or SELECT(JE-1). */
/*           If this is a complex pair, the 2-by-2 diagonal block */
/*           corresponding to the eigenvalue is in rows/columns JE-1:JE */

	    if (ilcplx) {
		ilcplx = FALSE_;
		goto L500;
	    }
	    nw = 1;
	    if (je > 1) {
		if (s[je + (je - 1) * s_dim1] != 0.) {
		    ilcplx = TRUE_;
		    nw = 2;
		}
	    }
	    if (ilall) {
		ilcomp = TRUE_;
	    } else if (ilcplx) {
		ilcomp = select[je] || select[je - 1];
	    } else {
		ilcomp = select[je];
	    }
	    if (! ilcomp) {
		goto L500;
	    }

/*           Decide if (a) singular pencil, (b) real eigenvalue, or */
/*           (c) complex eigenvalue. */

	    if (! ilcplx) {
		if ((d__1 = s[je + je * s_dim1], Dymola_abs(d__1)) <= safmin && (
			d__2 = p[je + je * p_dim1], Dymola_abs(d__2)) <= safmin) {

/*                 Singular matrix pencil -- unit eigenvector */

		    --ieig;
		    i__1 = *n;
		    for (jr = 1; jr <= i__1; ++jr) {
			vr[jr + ieig * vr_dim1] = 0.;
/* L230: */
		    }
		    vr[ieig + ieig * vr_dim1] = 1.;
		    goto L500;
		}
	    }

/*           Clear vector */

	    i__1 = nw - 1;
	    for (jw = 0; jw <= i__1; ++jw) {
		i__2 = *n;
		for (jr = 1; jr <= i__2; ++jr) {
		    work[(jw + 2) * *n + jr] = 0.;
/* L240: */
		}
/* L250: */
	    }

/*           Compute coefficients in  ( a A - b B ) x = 0 */
/*              a  is  ACOEF */
/*              b  is  BCOEFR + i*BCOEFI */

	    if (! ilcplx) {

/*              Real eigenvalue */

/* Computing MAX */
		d__3 = (d__1 = s[je + je * s_dim1], Dymola_abs(d__1)) * ascale, d__4 
			= (d__2 = p[je + je * p_dim1], Dymola_abs(d__2)) * bscale, 
			d__3 = Dymola_max(d__3,d__4);
		temp = 1. / Dymola_max(d__3,safmin);
		salfar = temp * s[je + je * s_dim1] * ascale;
		sbeta = temp * p[je + je * p_dim1] * bscale;
		acoef = sbeta * ascale;
		bcoefr = salfar * bscale;
		bcoefi = 0.;

/*              Scale to avoid underflow */

		scale = 1.;
		lsa = Dymola_abs(sbeta) >= safmin && Dymola_abs(acoef) < small;
		lsb = Dymola_abs(salfar) >= safmin && Dymola_abs(bcoefr) < small;
		if (lsa) {
		    scale = small / Dymola_abs(sbeta) * Dymola_min(anorm,big);
		}
		if (lsb) {
/* Computing MAX */
		    d__1 = scale, d__2 = small / Dymola_abs(salfar) * Dymola_min(bnorm,big);
		    scale = Dymola_max(d__1,d__2);
		}
		if (lsa || lsb) {
/* Computing MIN */
/* Computing MAX */
		    d__3 = 1., d__4 = Dymola_abs(acoef), d__3 = Dymola_max(d__3,d__4), d__4 
			    = Dymola_abs(bcoefr);
		    d__1 = scale, d__2 = 1. / (safmin * Dymola_max(d__3,d__4));
		    scale = Dymola_min(d__1,d__2);
		    if (lsa) {
			acoef = ascale * (scale * sbeta);
		    } else {
			acoef = scale * acoef;
		    }
		    if (lsb) {
			bcoefr = bscale * (scale * salfar);
		    } else {
			bcoefr = scale * bcoefr;
		    }
		}
		acoefa = Dymola_abs(acoef);
		bcoefa = Dymola_abs(bcoefr);

/*              First component is 1 */

		work[(*n << 1) + je] = 1.;
		xmax = 1.;

/*              Compute contribution from column JE of A and B to sum */
/*              (See "Further Details", above.) */

		i__1 = je - 1;
		for (jr = 1; jr <= i__1; ++jr) {
		    work[(*n << 1) + jr] = bcoefr * p[jr + je * p_dim1] - 
			    acoef * s[jr + je * s_dim1];
/* L260: */
		}
	    } else {

/*              Complex eigenvalue */

		d__1 = safmin * 100.;
		dlag2_(&s[je - 1 + (je - 1) * s_dim1], lds, &p[je - 1 + (je - 
			1) * p_dim1], ldp, &d__1, &acoef, &temp, &bcoefr, &
			temp2, &bcoefi);
		if (bcoefi == 0.) {
		    *info = je - 1;
		    return 0;
		}

/*              Scale to avoid over/underflow */

		acoefa = Dymola_abs(acoef);
		bcoefa = Dymola_abs(bcoefr) + Dymola_abs(bcoefi);
		scale = 1.;
		if (acoefa * ulp < safmin && acoefa >= safmin) {
		    scale = safmin / ulp / acoefa;
		}
		if (bcoefa * ulp < safmin && bcoefa >= safmin) {
/* Computing MAX */
		    d__1 = scale, d__2 = safmin / ulp / bcoefa;
		    scale = Dymola_max(d__1,d__2);
		}
		if (safmin * acoefa > ascale) {
		    scale = ascale / (safmin * acoefa);
		}
		if (safmin * bcoefa > bscale) {
/* Computing MIN */
		    d__1 = scale, d__2 = bscale / (safmin * bcoefa);
		    scale = Dymola_min(d__1,d__2);
		}
		if (scale != 1.) {
		    acoef = scale * acoef;
		    acoefa = Dymola_abs(acoef);
		    bcoefr = scale * bcoefr;
		    bcoefi = scale * bcoefi;
		    bcoefa = Dymola_abs(bcoefr) + Dymola_abs(bcoefi);
		}

/*              Compute first two components of eigenvector */
/*              and contribution to sums */

		temp = acoef * s[je + (je - 1) * s_dim1];
		temp2r = acoef * s[je + je * s_dim1] - bcoefr * p[je + je * 
			p_dim1];
		temp2i = -bcoefi * p[je + je * p_dim1];
		if (Dymola_abs(temp) >= Dymola_abs(temp2r) + Dymola_abs(temp2i)) {
		    work[(*n << 1) + je] = 1.;
		    work[*n * 3 + je] = 0.;
		    work[(*n << 1) + je - 1] = -temp2r / temp;
		    work[*n * 3 + je - 1] = -temp2i / temp;
		} else {
		    work[(*n << 1) + je - 1] = 1.;
		    work[*n * 3 + je - 1] = 0.;
		    temp = acoef * s[je - 1 + je * s_dim1];
		    work[(*n << 1) + je] = (bcoefr * p[je - 1 + (je - 1) * 
			    p_dim1] - acoef * s[je - 1 + (je - 1) * s_dim1]) /
			     temp;
		    work[*n * 3 + je] = bcoefi * p[je - 1 + (je - 1) * p_dim1]
			     / temp;
		}

/* Computing MAX */
		d__5 = (d__1 = work[(*n << 1) + je], Dymola_abs(d__1)) + (d__2 = 
			work[*n * 3 + je], Dymola_abs(d__2)), d__6 = (d__3 = work[(*
			n << 1) + je - 1], Dymola_abs(d__3)) + (d__4 = work[*n * 3 + 
			je - 1], Dymola_abs(d__4));
		xmax = Dymola_max(d__5,d__6);

/*              Compute contribution from columns JE and JE-1 */
/*              of A and B to the sums. */

		creala = acoef * work[(*n << 1) + je - 1];
		cimaga = acoef * work[*n * 3 + je - 1];
		crealb = bcoefr * work[(*n << 1) + je - 1] - bcoefi * work[*n 
			* 3 + je - 1];
		cimagb = bcoefi * work[(*n << 1) + je - 1] + bcoefr * work[*n 
			* 3 + je - 1];
		cre2a = acoef * work[(*n << 1) + je];
		cim2a = acoef * work[*n * 3 + je];
		cre2b = bcoefr * work[(*n << 1) + je] - bcoefi * work[*n * 3 
			+ je];
		cim2b = bcoefi * work[(*n << 1) + je] + bcoefr * work[*n * 3 
			+ je];
		i__1 = je - 2;
		for (jr = 1; jr <= i__1; ++jr) {
		    work[(*n << 1) + jr] = -creala * s[jr + (je - 1) * s_dim1]
			     + crealb * p[jr + (je - 1) * p_dim1] - cre2a * s[
			    jr + je * s_dim1] + cre2b * p[jr + je * p_dim1];
		    work[*n * 3 + jr] = -cimaga * s[jr + (je - 1) * s_dim1] + 
			    cimagb * p[jr + (je - 1) * p_dim1] - cim2a * s[jr 
			    + je * s_dim1] + cim2b * p[jr + je * p_dim1];
/* L270: */
		}
	    }

/* Computing MAX */
	    d__1 = ulp * acoefa * anorm, d__2 = ulp * bcoefa * bnorm, d__1 = 
		    Dymola_max(d__1,d__2);
	    dmin__ = Dymola_max(d__1,safmin);

/*           Columnwise triangular solve of  (a A - b B)  x = 0 */

	    il2by2 = FALSE_;
	    for (j = je - nw; j >= 1; --j) {

/*              If a 2-by-2 block, is in position j-1:j, wait until */
/*              next iteration to process it (when it will be j:j+1) */

		if (! il2by2 && j > 1) {
		    if (s[j + (j - 1) * s_dim1] != 0.) {
			il2by2 = TRUE_;
			goto L370;
		    }
		}
		bdiag[0] = p[j + j * p_dim1];
		if (il2by2) {
		    na = 2;
		    bdiag[1] = p[j + 1 + (j + 1) * p_dim1];
		} else {
		    na = 1;
		}

/*              Compute x(j) (and x(j+1), if 2-by-2 block) */

		dlaln2_(&c_false, &na, &nw, &dmin__, &acoef, &s[j + j * 
			s_dim1], lds, bdiag, &bdiag[1], &work[(*n << 1) + j], 
			n, &bcoefr, &bcoefi, sum, &c__2, &scale, &temp, &
			iinfo);
		if (scale < 1.) {

		    i__1 = nw - 1;
		    for (jw = 0; jw <= i__1; ++jw) {
			i__2 = je;
			for (jr = 1; jr <= i__2; ++jr) {
			    work[(jw + 2) * *n + jr] = scale * work[(jw + 2) *
				     *n + jr];
/* L280: */
			}
/* L290: */
		    }
		}
/* Computing MAX */
		d__1 = scale * xmax;
		xmax = Dymola_max(d__1,temp);

		i__1 = nw;
		for (jw = 1; jw <= i__1; ++jw) {
		    i__2 = na;
		    for (ja = 1; ja <= i__2; ++ja) {
			work[(jw + 1) * *n + j + ja - 1] = sum[ja + (jw << 1) 
				- 3];
/* L300: */
		    }
/* L310: */
		}

/*              w = w + x(j)*(a S(*,j) - b P(*,j) ) with scaling */

		if (j > 1) {

/*                 Check whether scaling is necessary for sum. */

		    xscale = 1. / Dymola_max(1.,xmax);
		    temp = acoefa * work[j] + bcoefa * work[*n + j];
		    if (il2by2) {
/* Computing MAX */
			d__1 = temp, d__2 = acoefa * work[j + 1] + bcoefa * 
				work[*n + j + 1];
			temp = Dymola_max(d__1,d__2);
		    }
/* Computing MAX */
		    d__1 = Dymola_max(temp,acoefa);
		    temp = Dymola_max(d__1,bcoefa);
		    if (temp > bignum * xscale) {

			i__1 = nw - 1;
			for (jw = 0; jw <= i__1; ++jw) {
			    i__2 = je;
			    for (jr = 1; jr <= i__2; ++jr) {
				work[(jw + 2) * *n + jr] = xscale * work[(jw 
					+ 2) * *n + jr];
/* L320: */
			    }
/* L330: */
			}
			xmax *= xscale;
		    }

/*                 Compute the contributions of the off-diagonals of */
/*                 column j (and j+1, if 2-by-2 block) of A and B to the */
/*                 sums. */


		    i__1 = na;
		    for (ja = 1; ja <= i__1; ++ja) {
			if (ilcplx) {
			    creala = acoef * work[(*n << 1) + j + ja - 1];
			    cimaga = acoef * work[*n * 3 + j + ja - 1];
			    crealb = bcoefr * work[(*n << 1) + j + ja - 1] - 
				    bcoefi * work[*n * 3 + j + ja - 1];
			    cimagb = bcoefi * work[(*n << 1) + j + ja - 1] + 
				    bcoefr * work[*n * 3 + j + ja - 1];
			    i__2 = j - 1;
			    for (jr = 1; jr <= i__2; ++jr) {
				work[(*n << 1) + jr] = work[(*n << 1) + jr] - 
					creala * s[jr + (j + ja - 1) * s_dim1]
					 + crealb * p[jr + (j + ja - 1) * 
					p_dim1];
				work[*n * 3 + jr] = work[*n * 3 + jr] - 
					cimaga * s[jr + (j + ja - 1) * s_dim1]
					 + cimagb * p[jr + (j + ja - 1) * 
					p_dim1];
/* L340: */
			    }
			} else {
			    creala = acoef * work[(*n << 1) + j + ja - 1];
			    crealb = bcoefr * work[(*n << 1) + j + ja - 1];
			    i__2 = j - 1;
			    for (jr = 1; jr <= i__2; ++jr) {
				work[(*n << 1) + jr] = work[(*n << 1) + jr] - 
					creala * s[jr + (j + ja - 1) * s_dim1]
					 + crealb * p[jr + (j + ja - 1) * 
					p_dim1];
/* L350: */
			    }
			}
/* L360: */
		    }
		}

		il2by2 = FALSE_;
L370:
		;
	    }

/*           Copy eigenvector to VR, back transforming if */
/*           HOWMNY='B'. */

	    ieig -= nw;
	    if (ilback) {

		i__1 = nw - 1;
		for (jw = 0; jw <= i__1; ++jw) {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
			work[(jw + 4) * *n + jr] = work[(jw + 2) * *n + 1] * 
				vr[jr + vr_dim1];
/* L380: */
		    }

/*                 A series of compiler directives to defeat */
/*                 vectorization for the next loop */


		    i__2 = je;
		    for (jc = 2; jc <= i__2; ++jc) {
			i__3 = *n;
			for (jr = 1; jr <= i__3; ++jr) {
			    work[(jw + 4) * *n + jr] += work[(jw + 2) * *n + 
				    jc] * vr[jr + jc * vr_dim1];
/* L390: */
			}
/* L400: */
		    }
/* L410: */
		}

		i__1 = nw - 1;
		for (jw = 0; jw <= i__1; ++jw) {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
			vr[jr + (ieig + jw) * vr_dim1] = work[(jw + 4) * *n + 
				jr];
/* L420: */
		    }
/* L430: */
		}

		iend = *n;
	    } else {
		i__1 = nw - 1;
		for (jw = 0; jw <= i__1; ++jw) {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
			vr[jr + (ieig + jw) * vr_dim1] = work[(jw + 2) * *n + 
				jr];
/* L440: */
		    }
/* L450: */
		}

		iend = je;
	    }

/*           Scale eigenvector */

	    xmax = 0.;
	    if (ilcplx) {
		i__1 = iend;
		for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
		    d__3 = xmax, d__4 = (d__1 = vr[j + ieig * vr_dim1], Dymola_abs(
			    d__1)) + (d__2 = vr[j + (ieig + 1) * vr_dim1], 
			    Dymola_abs(d__2));
		    xmax = Dymola_max(d__3,d__4);
/* L460: */
		}
	    } else {
		i__1 = iend;
		for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
		    d__2 = xmax, d__3 = (d__1 = vr[j + ieig * vr_dim1], Dymola_abs(d__1));
		    xmax = Dymola_max(d__2,d__3);
/* L470: */
		}
	    }

	    if (xmax > safmin) {
		xscale = 1. / xmax;
		i__1 = nw - 1;
		for (jw = 0; jw <= i__1; ++jw) {
		    i__2 = iend;
		    for (jr = 1; jr <= i__2; ++jr) {
			vr[jr + (ieig + jw) * vr_dim1] = xscale * vr[jr + (
				ieig + jw) * vr_dim1];
/* L480: */
		    }
/* L490: */
		}
	    }
L500:
	    ;
	}
    }

    return 0;

/*     End of DTGEVC */

} /* dtgevc_ */

/* Subroutine */ static int dggbak_(char* job, char* side, integer* n, integer* ilo, integer* ihi, doublereal* lscale, doublereal* rscale, integer* m, doublereal* v, integer* ldv, integer* info)
{
    /* System generated locals */
    integer v_dim1, v_offset, i__1;

    /* Local variables */
    integer i__, k;
    logical leftv;
    logical rightv;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters */

    /* Parameter adjustments */
    --lscale;
    --rscale;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;

    /* Function Body */
    rightv = lsame_(side, "R", (ftnlen)1, (ftnlen)1);
    leftv = lsame_(side, "L", (ftnlen)1, (ftnlen)1);

    *info = 0;
    if (! lsame_(job, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(job, "P", (
	    ftnlen)1, (ftnlen)1) && ! lsame_(job, "S", (ftnlen)1, (ftnlen)1) 
	    && ! lsame_(job, "B", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! rightv && ! leftv) {
	*info = -2;
    } else if (*n < 0) {
	*info = -3;
    } else if (*ilo < 1) {
	*info = -4;
    } else if (*n == 0 && *ihi == 0 && *ilo != 1) {
	*info = -4;
    } else if (*n > 0 && (*ihi < *ilo || *ihi > Dymola_max(1,*n))) {
	*info = -5;
    } else if (*n == 0 && *ilo == 1 && *ihi != 0) {
	*info = -5;
    } else if (*m < 0) {
	*info = -8;
    } else if (*ldv < Dymola_max(1,*n)) {
	*info = -10;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGGBAK", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }
    if (*m == 0) {
	return 0;
    }
    if (lsame_(job, "N", (ftnlen)1, (ftnlen)1)) {
	return 0;
    }

    if (*ilo == *ihi) {
	goto L30;
    }

/*     Backward balance */

    if (lsame_(job, "S", (ftnlen)1, (ftnlen)1) || lsame_(job, "B", (ftnlen)1, 
	    (ftnlen)1)) {

/*        Backward transformation on right eigenvectors */

	if (rightv) {
	    i__1 = *ihi;
	    for (i__ = *ilo; i__ <= i__1; ++i__) {
		dscal_(m, &rscale[i__], &v[i__ + v_dim1], ldv);
/* L10: */
	    }
	}

/*        Backward transformation on left eigenvectors */

	if (leftv) {
	    i__1 = *ihi;
	    for (i__ = *ilo; i__ <= i__1; ++i__) {
		dscal_(m, &lscale[i__], &v[i__ + v_dim1], ldv);
/* L20: */
	    }
	}
    }

/*     Backward permutation */

L30:
    if (lsame_(job, "P", (ftnlen)1, (ftnlen)1) || lsame_(job, "B", (ftnlen)1, 
	    (ftnlen)1)) {

/*        Backward permutation on right eigenvectors */

	if (rightv) {
	    if (*ilo == 1) {
		goto L50;
	    }

	    for (i__ = *ilo - 1; i__ >= 1; --i__) {
		k = (integer) rscale[i__];
		if (k == i__) {
		    goto L40;
		}
		dswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
L40:
		;
	    }

L50:
	    if (*ihi == *n) {
		goto L70;
	    }
	    i__1 = *n;
	    for (i__ = *ihi + 1; i__ <= i__1; ++i__) {
		k = (integer) rscale[i__];
		if (k == i__) {
		    goto L60;
		}
		dswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
L60:
		;
	    }
	}

/*        Backward permutation on left eigenvectors */

L70:
	if (leftv) {
	    if (*ilo == 1) {
		goto L90;
	    }
	    for (i__ = *ilo - 1; i__ >= 1; --i__) {
		k = (integer) lscale[i__];
		if (k == i__) {
		    goto L80;
		}
		dswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
L80:
		;
	    }

L90:
	    if (*ihi == *n) {
		goto L110;
	    }
	    i__1 = *n;
	    for (i__ = *ihi + 1; i__ <= i__1; ++i__) {
		k = (integer) lscale[i__];
		if (k == i__) {
		    goto L100;
		}
		dswap_(m, &v[i__ + v_dim1], ldv, &v[k + v_dim1], ldv);
L100:
		;
	    }
	}
    }

L110:

    return 0;

/*     End of DGGBAK */

} /* dggbak_ */

static doublereal dlanhs_(char *norm, integer *n, doublereal *a, integer *lda, doublereal *work)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
    doublereal ret_val, d__1;

    /* Local variables */
    integer i__, j;
    doublereal sum, scale;
    doublereal value;

/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/* ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --work;

    /* Function Body */
    if (*n == 0) {
	value = 0.;
    } else if (lsame_(norm, "M", (ftnlen)1, (ftnlen)1)) {

/*        Find max(abs(A(i,j))). */

	value = 0.;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
	    i__3 = *n, i__4 = j + 1;
	    i__2 = Dymola_min(i__3,i__4);
	    for (i__ = 1; i__ <= i__2; ++i__) {
		sum = (d__1 = a[i__ + j * a_dim1], Dymola_abs(d__1));
		if (value < sum || disnan_(&sum)) {
		    value = sum;
		}
/* L10: */
	    }
/* L20: */
	}
    } else if (lsame_(norm, "O", (ftnlen)1, (ftnlen)1) || *(unsigned char *)
	    norm == '1') {

/*        Find norm1(A). */

	value = 0.;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    sum = 0.;
/* Computing MIN */
	    i__3 = *n, i__4 = j + 1;
	    i__2 = Dymola_min(i__3,i__4);
	    for (i__ = 1; i__ <= i__2; ++i__) {
		sum += (d__1 = a[i__ + j * a_dim1], Dymola_abs(d__1));
/* L30: */
	    }
	    if (value < sum || disnan_(&sum)) {
		value = sum;
	    }
/* L40: */
	}
    } else if (lsame_(norm, "I", (ftnlen)1, (ftnlen)1)) {

/*        Find normI(A). */

	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    work[i__] = 0.;
/* L50: */
	}
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
	    i__3 = *n, i__4 = j + 1;
	    i__2 = Dymola_min(i__3,i__4);
	    for (i__ = 1; i__ <= i__2; ++i__) {
		work[i__] += (d__1 = a[i__ + j * a_dim1], Dymola_abs(d__1));
/* L60: */
	    }
/* L70: */
	}
	value = 0.;
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    sum = work[i__];
	    if (value < sum || disnan_(&sum)) {
		value = sum;
	    }
/* L80: */
	}
    } else if (lsame_(norm, "F", (ftnlen)1, (ftnlen)1) || lsame_(norm, "E", (
	    ftnlen)1, (ftnlen)1)) {

/*        Find normF(A). */

	scale = 0.;
	sum = 1.;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
	    i__3 = *n, i__4 = j + 1;
	    i__2 = Dymola_min(i__3,i__4);
	    dlassq_(&i__2, &a[j * a_dim1 + 1], &c__1, &scale, &sum);
/* L90: */
	}
	value = scale * sqrt(sum);
    }

    ret_val = value;
    return ret_val;

/*     End of DLANHS */

} /* dlanhs_ */

/* Subroutine */ static int dlag2_(doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *safmin, doublereal *scale1, doublereal *scale2, doublereal *wr1, doublereal *wr2, doublereal *wi)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6;

    /* Local variables */
    doublereal r__, c1, c2, c3, c4, c5, s1, s2, a11, a12, a21, a22, b11, b12, 
	    b22, pp, qq, ss, as11, as12, as22, sum, abi22, diff, bmin, wbig, 
	    wabs, wdet, binv11, binv22, discr, anorm, bnorm, bsize, shift, 
	    rtmin, rtmax, wsize, ascale, bscale, wscale, safmax, wsmall;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    rtmin = sqrt(*safmin);
    rtmax = 1. / rtmin;
    safmax = 1. / *safmin;

/*     Scale A */

/* Computing MAX */
    d__5 = (d__1 = a[a_dim1 + 1], Dymola_abs(d__1)) + (d__2 = a[a_dim1 + 2], Dymola_abs(
	    d__2)), d__6 = (d__3 = a[(a_dim1 << 1) + 1], Dymola_abs(d__3)) + (d__4 = 
	    a[(a_dim1 << 1) + 2], Dymola_abs(d__4)), d__5 = Dymola_max(d__5,d__6);
    anorm = Dymola_max(d__5,*safmin);
    ascale = 1. / anorm;
    a11 = ascale * a[a_dim1 + 1];
    a21 = ascale * a[a_dim1 + 2];
    a12 = ascale * a[(a_dim1 << 1) + 1];
    a22 = ascale * a[(a_dim1 << 1) + 2];

/*     Perturb B if necessary to insure non-singularity */

    b11 = b[b_dim1 + 1];
    b12 = b[(b_dim1 << 1) + 1];
    b22 = b[(b_dim1 << 1) + 2];
/* Computing MAX */
    d__1 = Dymola_abs(b11), d__2 = Dymola_abs(b12), d__1 = Dymola_max(d__1,d__2), d__2 = Dymola_abs(b22), 
	    d__1 = Dymola_max(d__1,d__2);
    bmin = rtmin * Dymola_max(d__1,rtmin);
    if (Dymola_abs(b11) < bmin) {
	b11 = d_sign(&bmin, &b11);
    }
    if (Dymola_abs(b22) < bmin) {
	b22 = d_sign(&bmin, &b22);
    }

/*     Scale B */

/* Computing MAX */
    d__1 = Dymola_abs(b11), d__2 = Dymola_abs(b12) + Dymola_abs(b22), d__1 = Dymola_max(d__1,d__2);
    bnorm = Dymola_max(d__1,*safmin);
/* Computing MAX */
    d__1 = Dymola_abs(b11), d__2 = Dymola_abs(b22);
    bsize = Dymola_max(d__1,d__2);
    bscale = 1. / bsize;
    b11 *= bscale;
    b12 *= bscale;
    b22 *= bscale;

/*     Compute larger eigenvalue by method described by C. van Loan */

/*     ( AS is A shifted by -SHIFT*B ) */

    binv11 = 1. / b11;
    binv22 = 1. / b22;
    s1 = a11 * binv11;
    s2 = a22 * binv22;
    if (Dymola_abs(s1) <= Dymola_abs(s2)) {
	as12 = a12 - s1 * b12;
	as22 = a22 - s1 * b22;
	ss = a21 * (binv11 * binv22);
	abi22 = as22 * binv22 - ss * b12;
	pp = abi22 * .5;
	shift = s1;
    } else {
	as12 = a12 - s2 * b12;
	as11 = a11 - s2 * b11;
	ss = a21 * (binv11 * binv22);
	abi22 = -ss * b12;
	pp = (as11 * binv11 + abi22) * .5;
	shift = s2;
    }
    qq = ss * as12;
    if ((d__1 = pp * rtmin, Dymola_abs(d__1)) >= 1.) {
/* Computing 2nd power */
	d__1 = rtmin * pp;
	discr = d__1 * d__1 + qq * *safmin;
	r__ = sqrt((Dymola_abs(discr))) * rtmax;
    } else {
/* Computing 2nd power */
	d__1 = pp;
	if (d__1 * d__1 + Dymola_abs(qq) <= *safmin) {
/* Computing 2nd power */
	    d__1 = rtmax * pp;
	    discr = d__1 * d__1 + qq * safmax;
	    r__ = sqrt((Dymola_abs(discr))) * rtmin;
	} else {
/* Computing 2nd power */
	    d__1 = pp;
	    discr = d__1 * d__1 + qq;
	    r__ = sqrt((Dymola_abs(discr)));
	}
    }

/*     Note: the test of R in the following IF is to cover the case when */
/*           DISCR is small and negative and is flushed to zero during */
/*           the calculation of R.  On machines which have a consistent */
/*           flush-to-zero threshhold and handle numbers above that */
/*           threshhold correctly, it would not be necessary. */

    if (discr >= 0. || r__ == 0.) {
	sum = pp + d_sign(&r__, &pp);
	diff = pp - d_sign(&r__, &pp);
	wbig = shift + sum;

/*        Compute smaller eigenvalue */

	wsmall = shift + diff;
/* Computing MAX */
	d__1 = Dymola_abs(wsmall);
	if (Dymola_abs(wbig) * .5 > Dymola_max(d__1,*safmin)) {
	    wdet = (a11 * a22 - a12 * a21) * (binv11 * binv22);
	    wsmall = wdet / wbig;
	}

/*        Choose (real) eigenvalue closest to 2,2 element of A*B**(-1) */
/*        for WR1. */

	if (pp > abi22) {
	    *wr1 = Dymola_min(wbig,wsmall);
	    *wr2 = Dymola_max(wbig,wsmall);
	} else {
	    *wr1 = Dymola_max(wbig,wsmall);
	    *wr2 = Dymola_min(wbig,wsmall);
	}
	*wi = 0.;
    } else {

/*        Complex eigenvalues */

	*wr1 = shift + pp;
	*wr2 = *wr1;
	*wi = r__;
    }

/*     Further scaling to avoid underflow and overflow in computing */
/*     SCALE1 and overflow in computing w*B. */

/*     This scale factor (WSCALE) is bounded from above using C1 and C2, */
/*     and from below using C3 and C4. */
/*        C1 implements the condition  s A  must never overflow. */
/*        C2 implements the condition  w B  must never overflow. */
/*        C3, with C2, */
/*           implement the condition that s A - w B must never overflow. */
/*        C4 implements the condition  s    should not underflow. */
/*        C5 implements the condition  max(s,|w|) should be at least 2. */

    c1 = bsize * (*safmin * Dymola_max(1.,ascale));
    c2 = *safmin * Dymola_max(1.,bnorm);
    c3 = bsize * *safmin;
    if (ascale <= 1. && bsize <= 1.) {
/* Computing MIN */
	d__1 = 1., d__2 = ascale / *safmin * bsize;
	c4 = Dymola_min(d__1,d__2);
    } else {
	c4 = 1.;
    }
    if (ascale <= 1. || bsize <= 1.) {
/* Computing MIN */
	d__1 = 1., d__2 = ascale * bsize;
	c5 = Dymola_min(d__1,d__2);
    } else {
	c5 = 1.;
    }

/*     Scale first eigenvalue */

    wabs = Dymola_abs(*wr1) + Dymola_abs(*wi);
/* Computing MAX */
/* Computing MIN */
    d__3 = c4, d__4 = Dymola_max(wabs,c5) * .5;
    d__1 = Dymola_max(*safmin,c1), d__2 = (wabs * c2 + c3) * 1.0000100000000001, 
	    d__1 = Dymola_max(d__1,d__2), d__2 = Dymola_min(d__3,d__4);
    wsize = Dymola_max(d__1,d__2);
    if (wsize != 1.) {
	wscale = 1. / wsize;
	if (wsize > 1.) {
	    *scale1 = Dymola_max(ascale,bsize) * wscale * Dymola_min(ascale,bsize);
	} else {
	    *scale1 = Dymola_min(ascale,bsize) * wscale * Dymola_max(ascale,bsize);
	}
	*wr1 *= wscale;
	if (*wi != 0.) {
	    *wi *= wscale;
	    *wr2 = *wr1;
	    *scale2 = *scale1;
	}
    } else {
	*scale1 = ascale * bsize;
	*scale2 = *scale1;
    }

/*     Scale second eigenvalue (if real) */

    if (*wi == 0.) {
/* Computing MAX */
/* Computing MIN */
/* Computing MAX */
	d__5 = Dymola_abs(*wr2);
	d__3 = c4, d__4 = Dymola_max(d__5,c5) * .5;
	d__1 = Dymola_max(*safmin,c1), d__2 = (Dymola_abs(*wr2) * c2 + c3) * 
		1.0000100000000001, d__1 = Dymola_max(d__1,d__2), d__2 = Dymola_min(d__3,
		d__4);
	wsize = Dymola_max(d__1,d__2);
	if (wsize != 1.) {
	    wscale = 1. / wsize;
	    if (wsize > 1.) {
		*scale2 = Dymola_max(ascale,bsize) * wscale * Dymola_min(ascale,bsize);
	    } else {
		*scale2 = Dymola_min(ascale,bsize) * wscale * Dymola_max(ascale,bsize);
	    }
	    *wr2 *= wscale;
	} else {
	    *scale2 = ascale * bsize;
	}
    }

/*     End of DLAG2 */

    return 0;
} /* dlag2_ */

/* Subroutine */ static int dlasv2_(doublereal *f, doublereal *g, doublereal *h__, doublereal *ssmin, doublereal *ssmax, doublereal *snr, doublereal *csr, doublereal *snl, doublereal *csl)
{
    /* System generated locals */
    doublereal d__1;

    /* Local variables */
    doublereal a, d__, l, m, r__, s, t, fa, ga, ha, ft, gt, ht, mm, tt, clt, 
	    crt, slt, srt;
    integer pmax;
    doublereal temp;
    logical swap;
    doublereal tsign;
    logical gasmal;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */

/* ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    ft = *f;
    fa = Dymola_abs(ft);
    ht = *h__;
    ha = Dymola_abs(*h__);

/*     PMAX points to the maximum absolute element of matrix */
/*       PMAX = 1 if F largest in absolute values */
/*       PMAX = 2 if G largest in absolute values */
/*       PMAX = 3 if H largest in absolute values */

    pmax = 1;
    swap = ha > fa;
    if (swap) {
	pmax = 3;
	temp = ft;
	ft = ht;
	ht = temp;
	temp = fa;
	fa = ha;
	ha = temp;

/*        Now FA .ge. HA */

    }
    gt = *g;
    ga = Dymola_abs(gt);
    if (ga == 0.) {

/*        Diagonal matrix */

	*ssmin = ha;
	*ssmax = fa;
	clt = 1.;
	crt = 1.;
	slt = 0.;
	srt = 0.;
    } else {
	gasmal = TRUE_;
	if (ga > fa) {
	    pmax = 2;
	    if (fa / ga < dlamch_("EPS")) {

/*              Case of very large GA */

		gasmal = FALSE_;
		*ssmax = ga;
		if (ha > 1.) {
		    *ssmin = fa / (ga / ha);
		} else {
		    *ssmin = fa / ga * ha;
		}
		clt = 1.;
		slt = ht / gt;
		srt = 1.;
		crt = ft / gt;
	    }
	}
	if (gasmal) {

/*           Normal case */

	    d__ = fa - ha;
	    if (d__ == fa) {

/*              Copes with infinite F or H */

		l = 1.;
	    } else {
		l = d__ / fa;
	    }

/*           Note that 0 .le. L .le. 1 */

	    m = gt / ft;

/*           Note that abs(M) .le. 1/macheps */

	    t = 2. - l;

/*           Note that T .ge. 1 */

	    mm = m * m;
	    tt = t * t;
	    s = sqrt(tt + mm);

/*           Note that 1 .le. S .le. 1 + 1/macheps */

	    if (l == 0.) {
		r__ = Dymola_abs(m);
	    } else {
		r__ = sqrt(l * l + mm);
	    }

/*           Note that 0 .le. R .le. 1 + 1/macheps */

	    a = (s + r__) * .5;

/*           Note that 1 .le. A .le. 1 + abs(M) */

	    *ssmin = ha / a;
	    *ssmax = fa * a;
	    if (mm == 0.) {

/*              Note that M is very tiny */

		if (l == 0.) {
		    t = d_sign(&c_b3, &ft) * d_sign(&c_b4, &gt);
		} else {
		    t = gt / d_sign(&d__, &ft) + m / t;
		}
	    } else {
		t = (m / (s + t) + m / (r__ + l)) * (a + 1.);
	    }
	    l = sqrt(t * t + 4.);
	    crt = 2. / l;
	    srt = t / l;
	    clt = (crt + srt * m) / a;
	    slt = ht / ft * srt / a;
	}
    }
    if (swap) {
	*csl = srt;
	*snl = crt;
	*csr = slt;
	*snr = clt;
    } else {
	*csl = clt;
	*snl = slt;
	*csr = crt;
	*snr = srt;
    }

/*     Correct signs of SSMAX and SSMIN */

    if (pmax == 1) {
	tsign = d_sign(&c_b4, csr) * d_sign(&c_b4, csl) * d_sign(&c_b4, f);
    }
    if (pmax == 2) {
	tsign = d_sign(&c_b4, snr) * d_sign(&c_b4, csl) * d_sign(&c_b4, g);
    }
    if (pmax == 3) {
	tsign = d_sign(&c_b4, snr) * d_sign(&c_b4, snl) * d_sign(&c_b4, h__);
    }
    *ssmax = d_sign(ssmax, &tsign);
    d__1 = tsign * d_sign(&c_b4, f) * d_sign(&c_b4, h__);
    *ssmin = d_sign(ssmin, &d__1);
    return 0;

/*     End of DLASV2 */

} /* dlasv2_ */

static doublereal dlapy3_(doublereal *x, doublereal *y, doublereal *z__)
{
    /* System generated locals */
    doublereal ret_val, d__1, d__2, d__3;

    /* Local variables */
    doublereal w, xabs, yabs, zabs;

/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    xabs = Dymola_abs(*x);
    yabs = Dymola_abs(*y);
    zabs = Dymola_abs(*z__);
/* Computing MAX */
    d__1 = Dymola_max(xabs,yabs);
    w = Dymola_max(d__1,zabs);
    if (w == 0.) {
/*     W can be zero for max(0,nan,0) */
/*     adding all three entries together will make sure */
/*     NaN will not disappear. */
	ret_val = xabs + yabs + zabs;
    } else {
/* Computing 2nd power */
	d__1 = xabs / w;
/* Computing 2nd power */
	d__2 = yabs / w;
/* Computing 2nd power */
	d__3 = zabs / w;
	ret_val = w * sqrt(d__1 * d__1 + d__2 * d__2 + d__3 * d__3);
    }
    return ret_val;

/*     End of DLAPY3 */

} /* dlapy3_ */

/* Subroutine */ static int dgelsx_(integer* m, integer* n, integer* nrhs, doublereal* a, integer* lda, doublereal* b, integer* ldb, integer* jpvt, const doublereal* rcond, integer* rank, doublereal* work, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    integer i__, j, k;
    doublereal c1, c2, s1, s2, t1, t2;
    integer mn;
    doublereal anrm, bnrm, smin, smax;
    integer iascl, ibscl, ismin, ismax;
    doublereal bignum;
    doublereal sminpr, smaxpr, smlnum;


/*  -- LAPACK driver routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --jpvt;
    --work;

    /* Function Body */
    mn = Dymola_min(*m,*n);
    ismin = mn + 1;
    ismax = (mn << 1) + 1;

/*     Test the input arguments. */

    *info = 0;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*nrhs < 0) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -5;
    } else /* if(complicated condition) */ {
/* Computing MAX */
	i__1 = Dymola_max(1,*m);
	if (*ldb < Dymola_max(i__1,*n)) {
	    *info = -7;
	}
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGELSX", &i__1);
	return 0;
    }

/*     Quick return if possible */

/* Computing MIN */
    i__1 = Dymola_min(*m,*n);
    if (Dymola_min(i__1,*nrhs) == 0) {
	*rank = 0;
	return 0;
    }

/*     Get machine parameters */

    smlnum = dlamch_("S") / dlamch_("P");
    bignum = 1. / smlnum;
    dlabad_(&smlnum, &bignum);

/*     Scale A, B if max elements outside range [SMLNUM,BIGNUM] */

    anrm = dlange_("M", m, n, &a[a_offset], lda, &work[1]);
    iascl = 0;
    if (anrm > 0. && anrm < smlnum) {

/*        Scale matrix norm up to SMLNUM */

	dlascl_("G", &c__0, &c__0, &anrm, &smlnum, m, n, &a[a_offset], lda, 
		info);
	iascl = 1;
    } else if (anrm > bignum) {

/*        Scale matrix norm down to BIGNUM */

	dlascl_("G", &c__0, &c__0, &anrm, &bignum, m, n, &a[a_offset], lda, 
		info);
	iascl = 2;
    } else if (anrm == 0.) {

/*        Matrix all zero. Return zero solution. */

	i__1 = Dymola_max(*m,*n);
	dlaset_("F", &i__1, nrhs, &c_b13_dgelsx, &c_b13_dgelsx, &b[b_offset], ldb);
	*rank = 0;
	goto L100;
    }

    bnrm = dlange_("M", m, nrhs, &b[b_offset], ldb, &work[1]);
    ibscl = 0;
    if (bnrm > 0. && bnrm < smlnum) {

/*        Scale matrix norm up to SMLNUM */

	dlascl_("G", &c__0, &c__0, &bnrm, &smlnum, m, nrhs, &b[b_offset], ldb,
		 info);
	ibscl = 1;
    } else if (bnrm > bignum) {

/*        Scale matrix norm down to BIGNUM */

	dlascl_("G", &c__0, &c__0, &bnrm, &bignum, m, nrhs, &b[b_offset], ldb,
		 info);
	ibscl = 2;
    }

/*     Compute QR factorization with column pivoting of A: */
/*        A * P = Q * R */

    dgeqpf_(m, n, &a[a_offset], lda, &jpvt[1], &work[1], &work[mn + 1], info);

/*     workspace 3*N. Details of Householder rotations stored */
/*     in WORK(1:MN). */

/*     Determine RANK using incremental condition estimation */

    work[ismin] = 1.;
    work[ismax] = 1.;
    smax = (d__1 = a[a_dim1 + 1], Dymola_abs(d__1));
    smin = smax;
    if ((d__1 = a[a_dim1 + 1], Dymola_abs(d__1)) == 0.) {
	*rank = 0;
	i__1 = Dymola_max(*m,*n);
	dlaset_("F", &i__1, nrhs, &c_b13_dgelsx, &c_b13_dgelsx, &b[b_offset], ldb);
	goto L100;
    } else {
	*rank = 1;
    }

L10:
    if (*rank < mn) {
	i__ = *rank + 1;
	dlaic1_(&c__2, rank, &work[ismin], &smin, &a[i__ * a_dim1 + 1], &a[
		i__ + i__ * a_dim1], &sminpr, &s1, &c1);
	dlaic1_(&c__1, rank, &work[ismax], &smax, &a[i__ * a_dim1 + 1], &a[
		i__ + i__ * a_dim1], &smaxpr, &s2, &c2);

	if (smaxpr * *rcond <= sminpr) {
	    i__1 = *rank;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		work[ismin + i__ - 1] = s1 * work[ismin + i__ - 1];
		work[ismax + i__ - 1] = s2 * work[ismax + i__ - 1];
/* L20: */
	    }
	    work[ismin + *rank] = c1;
	    work[ismax + *rank] = c2;
	    smin = sminpr;
	    smax = smaxpr;
	    ++(*rank);
	    goto L10;
	}
    }

/*     Logically partition R = [ R11 R12 ] */
/*                             [  0  R22 ] */
/*     where R11 = R(1:RANK,1:RANK) */

/*     [R11,R12] = [ T11, 0 ] * Y */

    if (*rank < *n) {
	dtzrqf_(rank, n, &a[a_offset], lda, &work[mn + 1], info);
    }

/*     Details of Householder rotations stored in WORK(MN+1:2*MN) */

/*     B(1:M,1:NRHS) := Q**T * B(1:M,1:NRHS) */

    dorm2r_("Left", "Transpose", m, nrhs, &mn, &a[a_offset], lda, &work[1], &
	    b[b_offset], ldb, &work[(mn << 1) + 1], info);

/*     workspace NRHS */

/*     B(1:RANK,1:NRHS) := inv(T11) * B(1:RANK,1:NRHS) */

    dtrsm_("Left", "Upper", "No transpose", "Non-unit", rank, nrhs, &c_b36_dgelsx, &
	    a[a_offset], lda, &b[b_offset], ldb);

    i__1 = *n;
    for (i__ = *rank + 1; i__ <= i__1; ++i__) {
	i__2 = *nrhs;
	for (j = 1; j <= i__2; ++j) {
	    b[i__ + j * b_dim1] = 0.;
/* L30: */
	}
/* L40: */
    }

/*     B(1:N,1:NRHS) := Y**T * B(1:N,1:NRHS) */

    if (*rank < *n) {
	i__1 = *rank;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    i__2 = *n - *rank + 1;
	    dlatzm_("Left", &i__2, nrhs, &a[i__ + (*rank + 1) * a_dim1], lda, 
		    &work[mn + i__], &b[i__ + b_dim1], &b[*rank + 1 + b_dim1],
		     ldb, &work[(mn << 1) + 1]);
/* L50: */
	}
    }

/*     workspace NRHS */

/*     B(1:N,1:NRHS) := P * B(1:N,1:NRHS) */

    i__1 = *nrhs;
    for (j = 1; j <= i__1; ++j) {
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    work[(mn << 1) + i__] = 1.;
/* L60: */
	}
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    if (work[(mn << 1) + i__] == 1.) {
		if (jpvt[i__] != i__) {
		    k = i__;
		    t1 = b[k + j * b_dim1];
		    t2 = b[jpvt[k] + j * b_dim1];
L70:
		    b[jpvt[k] + j * b_dim1] = t1;
		    work[(mn << 1) + k] = 0.;
		    t1 = t2;
		    k = jpvt[k];
		    t2 = b[jpvt[k] + j * b_dim1];
		    if (jpvt[k] != i__) {
			goto L70;
		    }
		    b[i__ + j * b_dim1] = t1;
		    work[(mn << 1) + k] = 0.;
		}
	    }
/* L80: */
	}
/* L90: */
    }

/*     Undo scaling */

    if (iascl == 1) {
	dlascl_("G", &c__0, &c__0, &anrm, &smlnum, n, nrhs, &b[b_offset], ldb,
		 info);
	dlascl_("U", &c__0, &c__0, &smlnum, &anrm, rank, rank, &a[a_offset], 
		lda, info);
    } else if (iascl == 2) {
	dlascl_("G", &c__0, &c__0, &anrm, &bignum, n, nrhs, &b[b_offset], ldb,
		 info);
	dlascl_("U", &c__0, &c__0, &bignum, &anrm, rank, rank, &a[a_offset], 
		lda, info);
    }
    if (ibscl == 1) {
	dlascl_("G", &c__0, &c__0, &smlnum, &bnrm, n, nrhs, &b[b_offset], ldb,
		 info);
    } else if (ibscl == 2) {
	dlascl_("G", &c__0, &c__0, &bignum, &bnrm, n, nrhs, &b[b_offset], ldb,
		 info);
    }

L100:

    return 0;

/*     End of DGELSX */

} /* dgelsx_ */

/* Subroutine */ static int dgels_(const char* trans, integer* m, integer* n, const integer* nrhs, doublereal* a, integer* lda, doublereal* b, integer* ldb, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2;

    /* Local variables */
    integer i__, j, nb, mn;
    doublereal anrm, bnrm;
    integer brow;
    logical tpsd;
    integer iascl, ibscl;
    integer wsize;
    doublereal rwork[1];

    integer scllen;
    doublereal bignum;
    doublereal smlnum;
    logical lquery;

/*  -- LAPACK driver routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --work;

    /* Function Body */
    *info = 0;
    mn = Dymola_min(*m,*n);
    lquery = *lwork == -1;
    if (! (lsame_(trans, "N", (ftnlen)1, (ftnlen)1) || lsame_(trans, "T", (
	    ftnlen)1, (ftnlen)1))) {
	*info = -1;
    } else if (*m < 0) {
	*info = -2;
    } else if (*n < 0) {
	*info = -3;
    } else if (*nrhs < 0) {
	*info = -4;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -6;
    } else /* if(complicated condition) */ {
/* Computing MAX */
	i__1 = Dymola_max(1,*m);
	if (*ldb < Dymola_max(i__1,*n)) {
	    *info = -8;
	} else /* if(complicated condition) */ {
/* Computing MAX */
	    i__1 = 1, i__2 = mn + Dymola_max(mn,*nrhs);
	    if (*lwork < Dymola_max(i__1,i__2) && ! lquery) {
		*info = -10;
	    }
	}
    }

/*     Figure out optimal block size */

    if (*info == 0 || *info == -10) {

	tpsd = TRUE_;
	if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
	    tpsd = FALSE_;
	}

	if (*m >= *n) {
	    nb = ilaenv_(&c__1, "DGEQRF", " ", m, n, &c_n1, &c_n1);
	    if (tpsd) {
/* Computing MAX */
		i__1 = nb, i__2 = ilaenv_(&c__1, "DORMQR", "LN", m, nrhs, n, &
			c_n1);
		nb = Dymola_max(i__1,i__2);
	    } else {
/* Computing MAX */
		i__1 = nb, i__2 = ilaenv_(&c__1, "DORMQR", "LT", m, nrhs, n, &
			c_n1);
		nb = Dymola_max(i__1,i__2);
	    }
	} else {
	    nb = ilaenv_(&c__1, "DGELQF", " ", m, n, &c_n1, &c_n1);
	    if (tpsd) {
/* Computing MAX */
		i__1 = nb, i__2 = ilaenv_(&c__1, "DORMLQ", "LT", n, nrhs, m, &
			c_n1);
		nb = Dymola_max(i__1,i__2);
	    } else {
/* Computing MAX */
		i__1 = nb, i__2 = ilaenv_(&c__1, "DORMLQ", "LN", n, nrhs, m, &
			c_n1);
		nb = Dymola_max(i__1,i__2);
	    }
	}

/* Computing MAX */
	i__1 = 1, i__2 = mn + Dymola_max(mn,*nrhs) * nb;
	wsize = Dymola_max(i__1,i__2);
	work[1] = (doublereal) wsize;

    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGELS ", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

/* Computing MIN */
    i__1 = Dymola_min(*m,*n);
    if (Dymola_min(i__1,*nrhs) == 0) {
	i__1 = Dymola_max(*m,*n);
	dlaset_("Full", &i__1, (integer*) nrhs, &c_b33, &c_b33, &b[b_offset], ldb);
	return 0;
    }

/*     Get machine parameters */

    smlnum = dlamch_("S") / dlamch_("P");
    bignum = 1. / smlnum;
    dlabad_(&smlnum, &bignum);

/*     Scale A, B if max element outside range [SMLNUM,BIGNUM] */

    anrm = dlange_("M", m, n, &a[a_offset], lda, rwork);
    iascl = 0;
    if (anrm > 0. && anrm < smlnum) {

/*        Scale matrix norm up to SMLNUM */

	dlascl_("G", &c__0, &c__0, &anrm, &smlnum, m, n, &a[a_offset], lda, 
		info);
	iascl = 1;
    } else if (anrm > bignum) {

/*        Scale matrix norm down to BIGNUM */

	dlascl_("G", &c__0, &c__0, &anrm, &bignum, m, n, &a[a_offset], lda, 
		info);
	iascl = 2;
    } else if (anrm == 0.) {

/*        Matrix all zero. Return zero solution. */

	i__1 = Dymola_max(*m,*n);
	dlaset_("F", &i__1, (integer*) nrhs, &c_b33, &c_b33, &b[b_offset], ldb);
	goto L50;
    }

    brow = *m;
    if (tpsd) {
	brow = *n;
    }
    bnrm = dlange_("M", &brow, (integer*) nrhs, &b[b_offset], ldb, rwork);
    ibscl = 0;
    if (bnrm > 0. && bnrm < smlnum) {

/*        Scale matrix norm up to SMLNUM */

      dlascl_("G", &c__0, &c__0, &bnrm, &smlnum, &brow, (integer*) nrhs, &b[b_offset], 
		ldb, info);
	ibscl = 1;
    } else if (bnrm > bignum) {

/*        Scale matrix norm down to BIGNUM */

	dlascl_("G", &c__0, &c__0, &bnrm, &bignum, &brow, (integer*) nrhs, &b[b_offset], 
		ldb, info);
	ibscl = 2;
    }

    if (*m >= *n) {

/*        compute QR factorization of A */

	i__1 = *lwork - mn;
	dgeqrf_(m, n, &a[a_offset], lda, &work[1], &work[mn + 1], &i__1, info)
		;

/*        workspace at least N, optimally N*NB */

	if (! tpsd) {

/*           Least-Squares Problem min || A * X - B || */

/*           B(1:M,1:NRHS) := Q**T * B(1:M,1:NRHS) */

	    i__1 = *lwork - mn;
	    dormqr_("Left", "Transpose", m, (integer*) nrhs, n, &a[a_offset], lda, &work[
		    1], &b[b_offset], ldb, &work[mn + 1], &i__1, info);

/*           workspace at least NRHS, optimally NRHS*NB */

/*           B(1:N,1:NRHS) := inv(R) * B(1:N,1:NRHS) */

	    dtrtrs_("Upper", "No transpose", "Non-unit", n, (integer*) nrhs, &a[a_offset]
              , lda, &b[b_offset], ldb, info);

	    if (*info > 0) {
		return 0;
	    }

	    scllen = *n;

	} else {

/*           Overdetermined system of equations A**T * X = B */

/*           B(1:N,1:NRHS) := inv(R**T) * B(1:N,1:NRHS) */

	    dtrtrs_("Upper", "Transpose", "Non-unit", n, (integer*) nrhs, &a[a_offset], 
              lda, &b[b_offset], ldb, info);

	    if (*info > 0) {
		return 0;
	    }

/*           B(N+1:M,1:NRHS) = ZERO */

	    i__1 = *nrhs;
	    for (j = 1; j <= i__1; ++j) {
		i__2 = *m;
		for (i__ = *n + 1; i__ <= i__2; ++i__) {
		    b[i__ + j * b_dim1] = 0.;
/* L10: */
		}
/* L20: */
	    }

/*           B(1:M,1:NRHS) := Q(1:N,:) * B(1:N,1:NRHS) */

	    i__1 = *lwork - mn;
	    dormqr_("Left", "No transpose", m, (integer*) nrhs, n, &a[a_offset], lda, &
		    work[1], &b[b_offset], ldb, &work[mn + 1], &i__1, info);

/*           workspace at least NRHS, optimally NRHS*NB */

	    scllen = *m;

	}

    } else {

/*        Compute LQ factorization of A */

	i__1 = *lwork - mn;
	dgelqf_(m, n, &a[a_offset], lda, &work[1], &work[mn + 1], &i__1, info)
		;

/*        workspace at least M, optimally M*NB. */

	if (! tpsd) {

/*           underdetermined system of equations A * X = B */

/*           B(1:M,1:NRHS) := inv(L) * B(1:M,1:NRHS) */

    dtrtrs_("Lower", "No transpose", "Non-unit", m, (integer*) nrhs, &a[a_offset]
              , lda, &b[b_offset], ldb, info);

	    if (*info > 0) {
		return 0;
	    }

/*           B(M+1:N,1:NRHS) = 0 */

	    i__1 = *nrhs;
	    for (j = 1; j <= i__1; ++j) {
		i__2 = *n;
		for (i__ = *m + 1; i__ <= i__2; ++i__) {
		    b[i__ + j * b_dim1] = 0.;
/* L30: */
		}
/* L40: */
	    }

/*           B(1:N,1:NRHS) := Q(1:N,:)**T * B(1:M,1:NRHS) */

	    i__1 = *lwork - mn;
	    dormlq_("Left", "Transpose", n, (integer*) nrhs, m, &a[a_offset], lda, &work[
		    1], &b[b_offset], ldb, &work[mn + 1], &i__1, info);

/*           workspace at least NRHS, optimally NRHS*NB */

	    scllen = *n;

	} else {

/*           overdetermined system min || A**T * X - B || */

/*           B(1:N,1:NRHS) := Q * B(1:N,1:NRHS) */

	    i__1 = *lwork - mn;
	    dormlq_("Left", "No transpose", n, (integer*) nrhs, m, &a[a_offset], lda, &
		    work[1], &b[b_offset], ldb, &work[mn + 1], &i__1, info);

/*           workspace at least NRHS, optimally NRHS*NB */

/*           B(1:M,1:NRHS) := inv(L**T) * B(1:M,1:NRHS) */

	    dtrtrs_("Lower", "Transpose", "Non-unit", m, (integer*) nrhs, &a[a_offset], 
              lda, &b[b_offset], ldb, info);

	    if (*info > 0) {
		return 0;
	    }

	    scllen = *m;

	}

    }

/*     Undo scaling */

    if (iascl == 1) {
	dlascl_("G", &c__0, &c__0, &anrm, &smlnum, &scllen, (integer*) nrhs, &b[b_offset]
		, ldb, info);
    } else if (iascl == 2) {
	dlascl_("G", &c__0, &c__0, &anrm, &bignum, &scllen, (integer*) nrhs, &b[b_offset]
		, ldb, info);
    }
    if (ibscl == 1) {
	dlascl_("G", &c__0, &c__0, &smlnum, &bnrm, &scllen, (integer*) nrhs, &b[b_offset]
		, ldb, info);
    } else if (ibscl == 2) {
	dlascl_("G", &c__0, &c__0, &bignum, &bnrm, &scllen, (integer*) nrhs, &b[b_offset]
		, ldb, info);
    }

L50:
    work[1] = (doublereal) wsize;

    return 0;

/*     End of DGELS */

} /* dgels_ */

/* Subroutine */ static int dtrtrs_(char *uplo, char *trans, char *diag, integer *n, integer *nrhs, doublereal *a, integer *lda, doublereal *b, integer *ldb, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    logical nounit;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    *info = 0;
    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
	    ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
	    ftnlen)1)) {
	*info = -2;
    } else if (! nounit && ! lsame_(diag, "U", (ftnlen)1, (ftnlen)1)) {
	*info = -3;
    } else if (*n < 0) {
	*info = -4;
    } else if (*nrhs < 0) {
	*info = -5;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -7;
    } else if (*ldb < Dymola_max(1,*n)) {
	*info = -9;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTRTRS", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

/*     Check for singularity. */

    if (nounit) {
	i__1 = *n;
	for (*info = 1; *info <= i__1; ++(*info)) {
	    if (a[*info + *info * a_dim1] == 0.) {
		return 0;
	    }
/* L10: */
	}
    }
    *info = 0;

/*     Solve A * x = b  or  A**T * x = b. */

    dtrsm_("Left", uplo, trans, diag, n, nrhs, &c_b12, &a[a_offset], lda, &b[
	    b_offset], ldb);

    return 0;

/*     End of DTRTRS */

} /* dtrtrs_ */

/* Subroutine */ static int dgelqf_(integer* m, integer* n, doublereal* a, integer* lda, doublereal* tau, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    integer i__, k, ib, nb, nx, iws, nbmin, iinfo;
    integer ldwork, lwkopt;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    nb = ilaenv_(&c__1, "DGELQF", " ", m, n, &c_n1, &c_n1);
    lwkopt = *m * nb;
    work[1] = (doublereal) lwkopt;
    lquery = *lwork == -1;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -4;
    } else if (*lwork < Dymola_max(1,*m) && ! lquery) {
	*info = -7;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGELQF", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    k = Dymola_min(*m,*n);
    if (k == 0) {
	work[1] = 1.;
	return 0;
    }

    nbmin = 2;
    nx = 0;
    iws = *m;
    if (nb > 1 && nb < k) {

/*        Determine when to cross over from blocked to unblocked code. */

/* Computing MAX */
	i__1 = 0, i__2 = ilaenv_(&c__3, "DGELQF", " ", m, n, &c_n1, &c_n1);
	nx = Dymola_max(i__1,i__2);
	if (nx < k) {

/*           Determine if workspace is large enough for blocked code. */

	    ldwork = *m;
	    iws = ldwork * nb;
	    if (*lwork < iws) {

/*              Not enough workspace to use optimal NB:  reduce NB and */
/*              determine the minimum value of NB. */

		nb = *lwork / ldwork;
/* Computing MAX */
		i__1 = 2, i__2 = ilaenv_(&c__2, "DGELQF", " ", m, n, &c_n1, &
			c_n1);
		nbmin = Dymola_max(i__1,i__2);
	    }
	}
    }

    if (nb >= nbmin && nb < k && nx < k) {

/*        Use blocked code initially */

	i__1 = k - nx;
	i__2 = nb;
	for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
	    i__3 = k - i__ + 1;
	    ib = Dymola_min(i__3,nb);

/*           Compute the LQ factorization of the current block */
/*           A(i:i+ib-1,i:n) */

	    i__3 = *n - i__ + 1;
	    dgelq2_(&ib, &i__3, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[
		    1], &iinfo);
	    if (i__ + ib <= *m) {

/*              Form the triangular factor of the block reflector */
/*              H = H(i) H(i+1) . . . H(i+ib-1) */

		i__3 = *n - i__ + 1;
		dlarft_("Forward", "Rowwise", &i__3, &ib, &a[i__ + i__ * 
			a_dim1], lda, &tau[i__], &work[1], &ldwork);

/*              Apply H to A(i+ib:m,i:n) from the right */

		i__3 = *m - i__ - ib + 1;
		i__4 = *n - i__ + 1;
		dlarfb_("Right", "No transpose", "Forward", "Rowwise", &i__3, 
			&i__4, &ib, &a[i__ + i__ * a_dim1], lda, &work[1], &
			ldwork, &a[i__ + ib + i__ * a_dim1], lda, &work[ib + 
			1], &ldwork);
	    }
/* L10: */
	}
    } else {
	i__ = 1;
    }

/*     Use unblocked code to factor the last or only block. */

    if (i__ <= k) {
	i__2 = *m - i__ + 1;
	i__1 = *n - i__ + 1;
	dgelq2_(&i__2, &i__1, &a[i__ + i__ * a_dim1], lda, &tau[i__], &work[1]
		, &iinfo);
    }

    work[1] = (doublereal) iws;
    return 0;

/*     End of DGELQF */

} /* dgelqf_ */

/* Subroutine */ static int dormlq_(char* side, char* trans, integer* m, integer* n, integer* k, doublereal* a, integer* lda, doublereal* tau, doublereal* c__, integer* ldc, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4, 
	    i__5;
    char ch__1[2];

    /* Local variables */
    integer i__;
    doublereal t[4160]	/* was [65][64] */;
    integer i1, i2, i3, ib, ic, jc, nb, mi, ni, nq, nw, iws;
    logical left;
    integer nbmin, iinfo;
    logical notran;
    integer ldwork;
    char transt[1];
    integer lwkopt;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
    notran = lsame_(trans, "N", (ftnlen)1, (ftnlen)1);
    lquery = *lwork == -1;

/*     NQ is the order of Q and NW is the minimum dimension of WORK */

    if (left) {
	nq = *m;
	nw = *n;
    } else {
	nq = *n;
	nw = *m;
    }
    if (! left && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! notran && ! lsame_(trans, "T", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (*m < 0) {
	*info = -3;
    } else if (*n < 0) {
	*info = -4;
    } else if (*k < 0 || *k > nq) {
	*info = -5;
    } else if (*lda < Dymola_max(1,*k)) {
	*info = -7;
    } else if (*ldc < Dymola_max(1,*m)) {
	*info = -10;
    } else if (*lwork < Dymola_max(1,nw) && ! lquery) {
	*info = -12;
    }

    if (*info == 0) {

/*        Determine the block size.  NB may be at most NBMAX, where NBMAX */
/*        is used to define the local array T. */

/* Computing MIN */
/* Writing concatenation */
	i__3[0] = 1, a__1[0] = side;
	i__3[1] = 1, a__1[1] = trans;
	s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
	i__1 = 64, i__2 = ilaenv_(&c__1, "DORMLQ", ch__1, m, n, k, &c_n1);
	nb = Dymola_min(i__1,i__2);
	lwkopt = Dymola_max(1,nw) * nb;
	work[1] = (doublereal) lwkopt;
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DORMLQ", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0 || *k == 0) {
	work[1] = 1.;
	return 0;
    }

    nbmin = 2;
    ldwork = nw;
    if (nb > 1 && nb < *k) {
	iws = nw * nb;
	if (*lwork < iws) {
	    nb = *lwork / ldwork;
/* Computing MAX */
/* Writing concatenation */
	    i__3[0] = 1, a__1[0] = side;
	    i__3[1] = 1, a__1[1] = trans;
	    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
	    i__1 = 2, i__2 = ilaenv_(&c__2, "DORMLQ", ch__1, m, n, k, &c_n1);
	    nbmin = Dymola_max(i__1,i__2);
	}
    } else {
	iws = nw;
    }

    if (nb < nbmin || nb >= *k) {

/*        Use unblocked code */

	dorml2_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[
		c_offset], ldc, &work[1], &iinfo);
    } else {

/*        Use blocked code */

	if (left && notran || ! left && ! notran) {
	    i1 = 1;
	    i2 = *k;
	    i3 = nb;
	} else {
	    i1 = (*k - 1) / nb * nb + 1;
	    i2 = 1;
	    i3 = -nb;
	}

	if (left) {
	    ni = *n;
	    jc = 1;
	} else {
	    mi = *m;
	    ic = 1;
	}

	if (notran) {
	    *(unsigned char *)transt = 'T';
	} else {
	    *(unsigned char *)transt = 'N';
	}

	i__1 = i2;
	i__2 = i3;
	for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
	    i__4 = nb, i__5 = *k - i__ + 1;
	    ib = Dymola_min(i__4,i__5);

/*           Form the triangular factor of the block reflector */
/*           H = H(i) H(i+1) . . . H(i+ib-1) */

	    i__4 = nq - i__ + 1;
	    dlarft_("Forward", "Rowwise", &i__4, &ib, &a[i__ + i__ * a_dim1], 
		    lda, &tau[i__], t, &c__65);
	    if (left) {

/*              H or H**T is applied to C(i:m,1:n) */

		mi = *m - i__ + 1;
		ic = i__;
	    } else {

/*              H or H**T is applied to C(1:m,i:n) */

		ni = *n - i__ + 1;
		jc = i__;
	    }

/*           Apply H or H**T */

	    dlarfb_(side, transt, "Forward", "Rowwise", &mi, &ni, &ib, &a[i__ 
		    + i__ * a_dim1], lda, t, &c__65, &c__[ic + jc * c_dim1], 
		    ldc, &work[1], &ldwork);
/* L10: */
	}
    }
    work[1] = (doublereal) lwkopt;
    return 0;

/*     End of DORMLQ */

} /* dormlq_ */

/* Subroutine */ static int dgelq2_(integer* m, integer* n, doublereal* a, integer* lda, doublereal* tau, doublereal* work, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    integer i__, k;
    doublereal aii;

/*  -- LAPACK computational routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -4;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGELQ2", &i__1);
	return 0;
    }

    k = Dymola_min(*m,*n);

    i__1 = k;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*        Generate elementary reflector H(i) to annihilate A(i,i+1:n) */

	i__2 = *n - i__ + 1;
/* Computing MIN */
	i__3 = i__ + 1;
	dlarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[i__ + Dymola_min(i__3,*n) * a_dim1]
		, lda, &tau[i__]);
	if (i__ < *m) {

/*           Apply H(i) to A(i+1:m,i:n) from the right */

	    aii = a[i__ + i__ * a_dim1];
	    a[i__ + i__ * a_dim1] = 1.;
	    i__2 = *m - i__;
	    i__3 = *n - i__ + 1;
	    dlarf_("Right", &i__2, &i__3, &a[i__ + i__ * a_dim1], lda, &tau[
		    i__], &a[i__ + 1 + i__ * a_dim1], lda, &work[1]);
	    a[i__ + i__ * a_dim1] = aii;
	}
/* L10: */
    }
    return 0;

/*     End of DGELQ2 */

} /* dgelq2_ */

/* Subroutine */ static int dorml2_(char* side, char* trans, integer* m, integer* n, integer* k, doublereal* a, integer* lda, doublereal* tau, doublereal* c__, integer* ldc, doublereal* work, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2;

    /* Local variables */
    integer i__, i1, i2, i3, ic, jc, mi, ni, nq;
    doublereal aii;
    logical left;
    logical notran;


/*  -- LAPACK computational routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
    notran = lsame_(trans, "N", (ftnlen)1, (ftnlen)1);

/*     NQ is the order of Q */

    if (left) {
	nq = *m;
    } else {
	nq = *n;
    }
    if (! left && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! notran && ! lsame_(trans, "T", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (*m < 0) {
	*info = -3;
    } else if (*n < 0) {
	*info = -4;
    } else if (*k < 0 || *k > nq) {
	*info = -5;
    } else if (*lda < Dymola_max(1,*k)) {
	*info = -7;
    } else if (*ldc < Dymola_max(1,*m)) {
	*info = -10;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DORML2", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0 || *k == 0) {
	return 0;
    }

    if (left && notran || ! left && ! notran) {
	i1 = 1;
	i2 = *k;
	i3 = 1;
    } else {
	i1 = *k;
	i2 = 1;
	i3 = -1;
    }

    if (left) {
	ni = *n;
	jc = 1;
    } else {
	mi = *m;
	ic = 1;
    }

    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	if (left) {

/*           H(i) is applied to C(i:m,1:n) */

	    mi = *m - i__ + 1;
	    ic = i__;
	} else {

/*           H(i) is applied to C(1:m,i:n) */

	    ni = *n - i__ + 1;
	    jc = i__;
	}

/*        Apply H(i) */

	aii = a[i__ + i__ * a_dim1];
	a[i__ + i__ * a_dim1] = 1.;
	dlarf_(side, &mi, &ni, &a[i__ + i__ * a_dim1], lda, &tau[i__], &c__[
		ic + jc * c_dim1], ldc, &work[1]);
	a[i__ + i__ * a_dim1] = aii;
/* L10: */
    }
    return 0;

/*     End of DORML2 */

} /* dorml2_ */

/* Subroutine */ static int dgglse_(integer* m, integer* n, integer* p, doublereal* a, integer* lda, doublereal* b, integer* ldb, doublereal* c__, doublereal* d__, doublereal* x, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2;

    /* Local variables */
    integer nb, mn, nr, nb1, nb2, nb3, nb4, lopt;
    integer lwkmin;
    integer lwkopt;
    logical lquery;

/*  -- LAPACK driver routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --c__;
    --d__;
    --x;
    --work;

    /* Function Body */
    *info = 0;
    mn = Dymola_min(*m,*n);
    lquery = *lwork == -1;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*p < 0 || *p > *n || *p < *n - *m) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -5;
    } else if (*ldb < Dymola_max(1,*p)) {
	*info = -7;
    }

/*     Calculate workspace */

    if (*info == 0) {
	if (*n == 0) {
	    lwkmin = 1;
	    lwkopt = 1;
	} else {
	    nb1 = ilaenv_(&c__1, "DGEQRF", " ", m, n, &c_n1, &c_n1);
	    nb2 = ilaenv_(&c__1, "DGERQF", " ", m, n, &c_n1, &c_n1);
	    nb3 = ilaenv_(&c__1, "DORMQR", " ", m, n, p, &c_n1);
	    nb4 = ilaenv_(&c__1, "DORMRQ", " ", m, n, p, &c_n1);
/* Computing MAX */
	    i__1 = Dymola_max(nb1,nb2), i__1 = Dymola_max(i__1,nb3);
	    nb = Dymola_max(i__1,nb4);
	    lwkmin = *m + *n + *p;
	    lwkopt = *p + mn + Dymola_max(*m,*n) * nb;
	}
	work[1] = (doublereal) lwkopt;

	if (*lwork < lwkmin && ! lquery) {
	    *info = -12;
	}
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGGLSE", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

/*     Compute the GRQ factorization of matrices B and A: */

/*            B*Q**T = (  0  T12 ) P   Z**T*A*Q**T = ( R11 R12 ) N-P */
/*                        N-P  P                     (  0  R22 ) M+P-N */
/*                                                      N-P  P */

/*     where T12 and R11 are upper triangular, and Q and Z are */
/*     orthogonal. */

    i__1 = *lwork - *p - mn;
    dggrqf_(p, m, n, &b[b_offset], ldb, &work[1], &a[a_offset], lda, &work[*p 
	    + 1], &work[*p + mn + 1], &i__1, info);
    lopt = (integer) work[*p + mn + 1];

/*     Update c = Z**T *c = ( c1 ) N-P */
/*                          ( c2 ) M+P-N */

    i__1 = Dymola_max(1,*m);
    i__2 = *lwork - *p - mn;
    dormqr_("Left", "Transpose", m, &c__1, &mn, &a[a_offset], lda, &work[*p + 
	    1], &c__[1], &i__1, &work[*p + mn + 1], &i__2, info);
/* Computing MAX */
    i__1 = lopt, i__2 = (integer) work[*p + mn + 1];
    lopt = Dymola_max(i__1,i__2);

/*     Solve T12*x2 = d for x2 */

    if (*p > 0) {
	dtrtrs_("Upper", "No transpose", "Non-unit", p, &c__1, &b[(*n - *p + 
		1) * b_dim1 + 1], ldb, &d__[1], p, info);

	if (*info > 0) {
	    *info = 1;
	    return 0;
	}

/*        Put the solution in X */

	dcopy_(p, &d__[1], &c__1, &x[*n - *p + 1], &c__1);

/*        Update c1 */

	i__1 = *n - *p;
	dgemv_("No transpose", &i__1, p, &c_b31_dgglse, &a[(*n - *p + 1) * a_dim1 + 
		1], lda, &d__[1], &c__1, &c_b33_dggsle, &c__[1], &c__1);
    }

/*     Solve R11*x1 = c1 for x1 */

    if (*n > *p) {
	i__1 = *n - *p;
	i__2 = *n - *p;
	dtrtrs_("Upper", "No transpose", "Non-unit", &i__1, &c__1, &a[
		a_offset], lda, &c__[1], &i__2, info);

	if (*info > 0) {
	    *info = 2;
	    return 0;
	}

/*        Put the solutions in X */

	i__1 = *n - *p;
	dcopy_(&i__1, &c__[1], &c__1, &x[1], &c__1);
    }

/*     Compute the residual vector: */

    if (*m < *n) {
	nr = *m + *p - *n;
	if (nr > 0) {
	    i__1 = *n - *m;
	    dgemv_("No transpose", &nr, &i__1, &c_b31_dgglse, &a[*n - *p + 1 + (*m + 
		    1) * a_dim1], lda, &d__[nr + 1], &c__1, &c_b33_dggsle, &c__[*n - 
		    *p + 1], &c__1);
	}
    } else {
	nr = *p;
    }
    if (nr > 0) {
	dtrmv_("Upper", "No transpose", "Non unit", &nr, &a[*n - *p + 1 + (*n 
		- *p + 1) * a_dim1], lda, &d__[1], &c__1);
	daxpy_(&nr, &c_b31_dgglse, &d__[1], &c__1, &c__[*n - *p + 1], &c__1);
    }

/*     Backward transformation x = Q**T*x */

    i__1 = *lwork - *p - mn;
    dormrq_("Left", "Transpose", n, &c__1, p, &b[b_offset], ldb, &work[1], &x[
	    1], n, &work[*p + mn + 1], &i__1, info);
/* Computing MAX */
    i__1 = lopt, i__2 = (integer) work[*p + mn + 1];
    work[1] = (doublereal) (*p + mn + Dymola_max(i__1,i__2));

    return 0;

/*     End of DGGLSE */

} /* dgglse_ */

/* Subroutine */ static int dggrqf_(integer* m, integer* p, integer* n, doublereal* a, integer* lda, doublereal* taua, doublereal* b, integer* ldb, doublereal* taub, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3;

    /* Local variables */
    integer nb, nb1, nb2, nb3, lopt;
    integer lwkopt;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --taua;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --taub;
    --work;

    /* Function Body */
    *info = 0;
    nb1 = ilaenv_(&c__1, "DGERQF", " ", m, n, &c_n1, &c_n1);
    nb2 = ilaenv_(&c__1, "DGEQRF", " ", p, n, &c_n1, &c_n1);
    nb3 = ilaenv_(&c__1, "DORMRQ", " ", m, n, p, &c_n1);
/* Computing MAX */
    i__1 = Dymola_max(nb1,nb2);
    nb = Dymola_max(i__1,nb3);
/* Computing MAX */
    i__1 = Dymola_max(*n,*m);
    lwkopt = Dymola_max(i__1,*p) * nb;
    work[1] = (doublereal) lwkopt;
    lquery = *lwork == -1;
    if (*m < 0) {
	*info = -1;
    } else if (*p < 0) {
	*info = -2;
    } else if (*n < 0) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -5;
    } else if (*ldb < Dymola_max(1,*p)) {
	*info = -8;
    } else /* if(complicated condition) */ {
/* Computing MAX */
	i__1 = Dymola_max(1,*m), i__1 = Dymola_max(i__1,*p);
	if (*lwork < Dymola_max(i__1,*n) && ! lquery) {
	    *info = -11;
	}
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGGRQF", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     RQ factorization of M-by-N matrix A: A = R*Q */

    dgerqf_(m, n, &a[a_offset], lda, &taua[1], &work[1], lwork, info);
    lopt = (integer) work[1];

/*     Update B := B*Q**T */

    i__1 = Dymola_min(*m,*n);
/* Computing MAX */
    i__2 = 1, i__3 = *m - *n + 1;
    dormrq_("Right", "Transpose", p, n, &i__1, &a[Dymola_max(i__2,i__3) + a_dim1], 
	    lda, &taua[1], &b[b_offset], ldb, &work[1], lwork, info);
/* Computing MAX */
    i__1 = lopt, i__2 = (integer) work[1];
    lopt = Dymola_max(i__1,i__2);

/*     QR factorization of P-by-N matrix B: B = Z*T */

    dgeqrf_(p, n, &b[b_offset], ldb, &taub[1], &work[1], lwork, info);
/* Computing MAX */
    i__1 = lopt, i__2 = (integer) work[1];
    work[1] = (doublereal) Dymola_max(i__1,i__2);

    return 0;

/*     End of DGGRQF */

} /* dggrqf_ */

/* Subroutine */ static int dormrq_(char* side, char* trans, integer* m, integer* n, integer* k, doublereal* a, integer* lda, doublereal* tau, doublereal* c__, integer* ldc, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3[2], i__4, 
	    i__5;
    char ch__1[2];

    /* Local variables */
    integer i__;
    doublereal t[4160]	/* was [65][64] */;
    integer i1, i2, i3, ib, nb, mi, ni, nq, nw, iws;
    logical left;
    integer nbmin, iinfo;
    logical notran;
    integer ldwork;
    char transt[1];
    integer lwkopt;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
    notran = lsame_(trans, "N", (ftnlen)1, (ftnlen)1);
    lquery = *lwork == -1;

/*     NQ is the order of Q and NW is the minimum dimension of WORK */

    if (left) {
	nq = *m;
	nw = Dymola_max(1,*n);
    } else {
	nq = *n;
	nw = Dymola_max(1,*m);
    }
    if (! left && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! notran && ! lsame_(trans, "T", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (*m < 0) {
	*info = -3;
    } else if (*n < 0) {
	*info = -4;
    } else if (*k < 0 || *k > nq) {
	*info = -5;
    } else if (*lda < Dymola_max(1,*k)) {
	*info = -7;
    } else if (*ldc < Dymola_max(1,*m)) {
	*info = -10;
    }

    if (*info == 0) {
	if (*m == 0 || *n == 0) {
	    lwkopt = 1;
	} else {

/*           Determine the block size.  NB may be at most NBMAX, where */
/*           NBMAX is used to define the local array T. */

/* Computing MIN */
/* Writing concatenation */
	    i__3[0] = 1, a__1[0] = side;
	    i__3[1] = 1, a__1[1] = trans;
	    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
	    i__1 = 64, i__2 = ilaenv_(&c__1, "DORMRQ", ch__1, m, n, k, &c_n1);
	    nb = Dymola_min(i__1,i__2);
	    lwkopt = nw * nb;
	}
	work[1] = (doublereal) lwkopt;

	if (*lwork < nw && ! lquery) {
	    *info = -12;
	}
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DORMRQ", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {
	return 0;
    }

    nbmin = 2;
    ldwork = nw;
    if (nb > 1 && nb < *k) {
	iws = nw * nb;
	if (*lwork < iws) {
	    nb = *lwork / ldwork;
/* Computing MAX */
/* Writing concatenation */
	    i__3[0] = 1, a__1[0] = side;
	    i__3[1] = 1, a__1[1] = trans;
	    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)2);
	    i__1 = 2, i__2 = ilaenv_(&c__2, "DORMRQ", ch__1, m, n, k, &c_n1);
	    nbmin = Dymola_max(i__1,i__2);
	}
    } else {
	iws = nw;
    }

    if (nb < nbmin || nb >= *k) {

/*        Use unblocked code */

	dormr2_(side, trans, m, n, k, &a[a_offset], lda, &tau[1], &c__[
		c_offset], ldc, &work[1], &iinfo);
    } else {

/*        Use blocked code */

	if (left && ! notran || ! left && notran) {
	    i1 = 1;
	    i2 = *k;
	    i3 = nb;
	} else {
	    i1 = (*k - 1) / nb * nb + 1;
	    i2 = 1;
	    i3 = -nb;
	}

	if (left) {
	    ni = *n;
	} else {
	    mi = *m;
	}

	if (notran) {
	    *(unsigned char *)transt = 'T';
	} else {
	    *(unsigned char *)transt = 'N';
	}

	i__1 = i2;
	i__2 = i3;
	for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
/* Computing MIN */
	    i__4 = nb, i__5 = *k - i__ + 1;
	    ib = Dymola_min(i__4,i__5);

/*           Form the triangular factor of the block reflector */
/*           H = H(i+ib-1) . . . H(i+1) H(i) */

	    i__4 = nq - *k + i__ + ib - 1;
	    dlarft_("Backward", "Rowwise", &i__4, &ib, &a[i__ + a_dim1], lda, 
		    &tau[i__], t, &c__65);
	    if (left) {

/*              H or H**T is applied to C(1:m-k+i+ib-1,1:n) */

		mi = *m - *k + i__ + ib - 1;
	    } else {

/*              H or H**T is applied to C(1:m,1:n-k+i+ib-1) */

		ni = *n - *k + i__ + ib - 1;
	    }

/*           Apply H or H**T */

	    dlarfb_(side, transt, "Backward", "Rowwise", &mi, &ni, &ib, &a[
		    i__ + a_dim1], lda, t, &c__65, &c__[c_offset], ldc, &work[
		    1], &ldwork);
/* L10: */
	}
    }
    work[1] = (doublereal) lwkopt;
    return 0;

/*     End of DORMRQ */

} /* dormrq_ */

/* Subroutine */ static int dgerqf_(integer* m, integer* n, doublereal* a, integer* lda, doublereal* tau, doublereal* work, integer* lwork, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    integer i__, k, ib, nb, ki, kk, mu, nu, nx, iws, nbmin, iinfo;
    integer ldwork, lwkopt;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    lquery = *lwork == -1;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -4;
    }

    if (*info == 0) {
	k = Dymola_min(*m,*n);
	if (k == 0) {
	    lwkopt = 1;
	} else {
	    nb = ilaenv_(&c__1, "DGERQF", " ", m, n, &c_n1, &c_n1);
	    lwkopt = *m * nb;
	}
	work[1] = (doublereal) lwkopt;

	if (*lwork < Dymola_max(1,*m) && ! lquery) {
	    *info = -7;
	}
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGERQF", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (k == 0) {
	return 0;
    }

    nbmin = 2;
    nx = 1;
    iws = *m;
    if (nb > 1 && nb < k) {

/*        Determine when to cross over from blocked to unblocked code. */

/* Computing MAX */
	i__1 = 0, i__2 = ilaenv_(&c__3, "DGERQF", " ", m, n, &c_n1, &c_n1);
	nx = Dymola_max(i__1,i__2);
	if (nx < k) {

/*           Determine if workspace is large enough for blocked code. */

	    ldwork = *m;
	    iws = ldwork * nb;
	    if (*lwork < iws) {

/*              Not enough workspace to use optimal NB:  reduce NB and */
/*              determine the minimum value of NB. */

		nb = *lwork / ldwork;
/* Computing MAX */
		i__1 = 2, i__2 = ilaenv_(&c__2, "DGERQF", " ", m, n, &c_n1, &
			c_n1);
		nbmin = Dymola_max(i__1,i__2);
	    }
	}
    }

    if (nb >= nbmin && nb < k && nx < k) {

/*        Use blocked code initially. */
/*        The last kk rows are handled by the block method. */

	ki = (k - nx - 1) / nb * nb;
/* Computing MIN */
	i__1 = k, i__2 = ki + nb;
	kk = Dymola_min(i__1,i__2);

	i__1 = k - kk + 1;
	i__2 = -nb;
	for (i__ = k - kk + ki + 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ 
		+= i__2) {
/* Computing MIN */
	    i__3 = k - i__ + 1;
	    ib = Dymola_min(i__3,nb);

/*           Compute the RQ factorization of the current block */
/*           A(m-k+i:m-k+i+ib-1,1:n-k+i+ib-1) */

	    i__3 = *n - k + i__ + ib - 1;
	    dgerq2_(&ib, &i__3, &a[*m - k + i__ + a_dim1], lda, &tau[i__], &
		    work[1], &iinfo);
	    if (*m - k + i__ > 1) {

/*              Form the triangular factor of the block reflector */
/*              H = H(i+ib-1) . . . H(i+1) H(i) */

		i__3 = *n - k + i__ + ib - 1;
		dlarft_("Backward", "Rowwise", &i__3, &ib, &a[*m - k + i__ + 
			a_dim1], lda, &tau[i__], &work[1], &ldwork);

/*              Apply H to A(1:m-k+i-1,1:n-k+i+ib-1) from the right */

		i__3 = *m - k + i__ - 1;
		i__4 = *n - k + i__ + ib - 1;
		dlarfb_("Right", "No transpose", "Backward", "Rowwise", &i__3,
			 &i__4, &ib, &a[*m - k + i__ + a_dim1], lda, &work[1],
			 &ldwork, &a[a_offset], lda, &work[ib + 1], &ldwork);
	    }
/* L10: */
	}
	mu = *m - k + i__ + nb - 1;
	nu = *n - k + i__ + nb - 1;
    } else {
	mu = *m;
	nu = *n;
    }

/*     Use unblocked code to factor the last or only block */

    if (mu > 0 && nu > 0) {
	dgerq2_(&mu, &nu, &a[a_offset], lda, &tau[1], &work[1], &iinfo);
    }

    work[1] = (doublereal) iws;
    return 0;

/*     End of DGERQF */

} /* dgerqf_ */

/* Subroutine */ static int dormr2_(char* side, char* trans, integer* m, integer* n, integer* k, doublereal* a, integer* lda, doublereal* tau, doublereal* c__, integer* ldc, doublereal* work, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2;

    /* Local variables */
    integer i__, i1, i2, i3, mi, ni, nq;
    doublereal aii;
    logical left;
    logical notran;


/*  -- LAPACK computational routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
    notran = lsame_(trans, "N", (ftnlen)1, (ftnlen)1);

/*     NQ is the order of Q */

    if (left) {
	nq = *m;
    } else {
	nq = *n;
    }
    if (! left && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! notran && ! lsame_(trans, "T", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (*m < 0) {
	*info = -3;
    } else if (*n < 0) {
	*info = -4;
    } else if (*k < 0 || *k > nq) {
	*info = -5;
    } else if (*lda < Dymola_max(1,*k)) {
	*info = -7;
    } else if (*ldc < Dymola_max(1,*m)) {
	*info = -10;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DORMR2", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0 || *k == 0) {
	return 0;
    }

    if (left && ! notran || ! left && notran) {
	i1 = 1;
	i2 = *k;
	i3 = 1;
    } else {
	i1 = *k;
	i2 = 1;
	i3 = -1;
    }

    if (left) {
	ni = *n;
    } else {
	mi = *m;
    }

    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	if (left) {

/*           H(i) is applied to C(1:m-k+i,1:n) */

	    mi = *m - *k + i__;
	} else {

/*           H(i) is applied to C(1:m,1:n-k+i) */

	    ni = *n - *k + i__;
	}

/*        Apply H(i) */

	aii = a[i__ + (nq - *k + i__) * a_dim1];
	a[i__ + (nq - *k + i__) * a_dim1] = 1.;
	dlarf_(side, &mi, &ni, &a[i__ + a_dim1], lda, &tau[i__], &c__[
		c_offset], ldc, &work[1]);
	a[i__ + (nq - *k + i__) * a_dim1] = aii;
/* L10: */
    }
    return 0;

/*     End of DORMR2 */

} /* dormr2_ */

/* Subroutine */ static int dgerq2_(integer* m, integer* n, doublereal* a, integer* lda, doublereal* tau, doublereal* work, integer* info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    integer i__, k;
    doublereal aii;

/*  -- LAPACK computational routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -4;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGERQ2", &i__1);
	return 0;
    }

    k = Dymola_min(*m,*n);

    for (i__ = k; i__ >= 1; --i__) {

/*        Generate elementary reflector H(i) to annihilate */
/*        A(m-k+i,1:n-k+i-1) */

	i__1 = *n - k + i__;
	dlarfg_(&i__1, &a[*m - k + i__ + (*n - k + i__) * a_dim1], &a[*m - k 
		+ i__ + a_dim1], lda, &tau[i__]);

/*        Apply H(i) to A(1:m-k+i-1,1:n-k+i) from the right */

	aii = a[*m - k + i__ + (*n - k + i__) * a_dim1];
	a[*m - k + i__ + (*n - k + i__) * a_dim1] = 1.;
	i__1 = *m - k + i__ - 1;
	i__2 = *n - k + i__;
	dlarf_("Right", &i__1, &i__2, &a[*m - k + i__ + a_dim1], lda, &tau[
		i__], &a[a_offset], lda, &work[1]);
	a[*m - k + i__ + (*n - k + i__) * a_dim1] = aii;
/* L10: */
    }
    return 0;

/*     End of DGERQ2 */

} /* dgerq2_ */

/* Subroutine */ static int dgtsv_(const integer *n, const integer *nrhs, doublereal *dl, doublereal *d__, doublereal *du, doublereal *b, const integer *ldb, integer *info)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1, i__2;
    doublereal d__1, d__2;

    /* Local variables */
    integer i__, j;
    doublereal fact, temp;

/*  -- LAPACK driver routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    --dl;
    --d__;
    --du;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    *info = 0;
    if (*n < 0) {
	*info = -1;
    } else if (*nrhs < 0) {
	*info = -2;
    } else if (*ldb < Dymola_max(1,*n)) {
	*info = -7;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGTSV ", &i__1);
	return 0;
    }

    if (*n == 0) {
	return 0;
    }

    if (*nrhs == 1) {
	i__1 = *n - 2;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if ((d__1 = d__[i__], Dymola_abs(d__1)) >= (d__2 = dl[i__], Dymola_abs(d__2))) {

/*              No row interchange required */

		if (d__[i__] != 0.) {
		    fact = dl[i__] / d__[i__];
		    d__[i__ + 1] -= fact * du[i__];
		    b[i__ + 1 + b_dim1] -= fact * b[i__ + b_dim1];
		} else {
		    *info = i__;
		    return 0;
		}
		dl[i__] = 0.;
	    } else {

/*              Interchange rows I and I+1 */

		fact = d__[i__] / dl[i__];
		d__[i__] = dl[i__];
		temp = d__[i__ + 1];
		d__[i__ + 1] = du[i__] - fact * temp;
		dl[i__] = du[i__ + 1];
		du[i__ + 1] = -fact * dl[i__];
		du[i__] = temp;
		temp = b[i__ + b_dim1];
		b[i__ + b_dim1] = b[i__ + 1 + b_dim1];
		b[i__ + 1 + b_dim1] = temp - fact * b[i__ + 1 + b_dim1];
	    }
/* L10: */
	}
	if (*n > 1) {
	    i__ = *n - 1;
	    if ((d__1 = d__[i__], Dymola_abs(d__1)) >= (d__2 = dl[i__], Dymola_abs(d__2))) {
		if (d__[i__] != 0.) {
		    fact = dl[i__] / d__[i__];
		    d__[i__ + 1] -= fact * du[i__];
		    b[i__ + 1 + b_dim1] -= fact * b[i__ + b_dim1];
		} else {
		    *info = i__;
		    return 0;
		}
	    } else {
		fact = d__[i__] / dl[i__];
		d__[i__] = dl[i__];
		temp = d__[i__ + 1];
		d__[i__ + 1] = du[i__] - fact * temp;
		du[i__] = temp;
		temp = b[i__ + b_dim1];
		b[i__ + b_dim1] = b[i__ + 1 + b_dim1];
		b[i__ + 1 + b_dim1] = temp - fact * b[i__ + 1 + b_dim1];
	    }
	}
	if (d__[*n] == 0.) {
	    *info = *n;
	    return 0;
	}
    } else {
	i__1 = *n - 2;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if ((d__1 = d__[i__], Dymola_abs(d__1)) >= (d__2 = dl[i__], Dymola_abs(d__2))) {

/*              No row interchange required */

		if (d__[i__] != 0.) {
		    fact = dl[i__] / d__[i__];
		    d__[i__ + 1] -= fact * du[i__];
		    i__2 = *nrhs;
		    for (j = 1; j <= i__2; ++j) {
			b[i__ + 1 + j * b_dim1] -= fact * b[i__ + j * b_dim1];
/* L20: */
		    }
		} else {
		    *info = i__;
		    return 0;
		}
		dl[i__] = 0.;
	    } else {

/*              Interchange rows I and I+1 */

		fact = d__[i__] / dl[i__];
		d__[i__] = dl[i__];
		temp = d__[i__ + 1];
		d__[i__ + 1] = du[i__] - fact * temp;
		dl[i__] = du[i__ + 1];
		du[i__ + 1] = -fact * dl[i__];
		du[i__] = temp;
		i__2 = *nrhs;
		for (j = 1; j <= i__2; ++j) {
		    temp = b[i__ + j * b_dim1];
		    b[i__ + j * b_dim1] = b[i__ + 1 + j * b_dim1];
		    b[i__ + 1 + j * b_dim1] = temp - fact * b[i__ + 1 + j * 
			    b_dim1];
/* L30: */
		}
	    }
/* L40: */
	}
	if (*n > 1) {
	    i__ = *n - 1;
	    if ((d__1 = d__[i__], Dymola_abs(d__1)) >= (d__2 = dl[i__], Dymola_abs(d__2))) {
		if (d__[i__] != 0.) {
		    fact = dl[i__] / d__[i__];
		    d__[i__ + 1] -= fact * du[i__];
		    i__1 = *nrhs;
		    for (j = 1; j <= i__1; ++j) {
			b[i__ + 1 + j * b_dim1] -= fact * b[i__ + j * b_dim1];
/* L50: */
		    }
		} else {
		    *info = i__;
		    return 0;
		}
	    } else {
		fact = d__[i__] / dl[i__];
		d__[i__] = dl[i__];
		temp = d__[i__ + 1];
		d__[i__ + 1] = du[i__] - fact * temp;
		du[i__] = temp;
		i__1 = *nrhs;
		for (j = 1; j <= i__1; ++j) {
		    temp = b[i__ + j * b_dim1];
		    b[i__ + j * b_dim1] = b[i__ + 1 + j * b_dim1];
		    b[i__ + 1 + j * b_dim1] = temp - fact * b[i__ + 1 + j * 
			    b_dim1];
/* L60: */
		}
	    }
	}
	if (d__[*n] == 0.) {
	    *info = *n;
	    return 0;
	}
    }

/*     Back solve with the matrix U from the factorization. */

    if (*nrhs <= 2) {
	j = 1;
L70:
	b[*n + j * b_dim1] /= d__[*n];
	if (*n > 1) {
	    b[*n - 1 + j * b_dim1] = (b[*n - 1 + j * b_dim1] - du[*n - 1] * b[
		    *n + j * b_dim1]) / d__[*n - 1];
	}
	for (i__ = *n - 2; i__ >= 1; --i__) {
	    b[i__ + j * b_dim1] = (b[i__ + j * b_dim1] - du[i__] * b[i__ + 1 
		    + j * b_dim1] - dl[i__] * b[i__ + 2 + j * b_dim1]) / d__[
		    i__];
/* L80: */
	}
	if (j < *nrhs) {
	    ++j;
	    goto L70;
	}
    } else {
	i__1 = *nrhs;
	for (j = 1; j <= i__1; ++j) {
	    b[*n + j * b_dim1] /= d__[*n];
	    if (*n > 1) {
		b[*n - 1 + j * b_dim1] = (b[*n - 1 + j * b_dim1] - du[*n - 1] 
			* b[*n + j * b_dim1]) / d__[*n - 1];
	    }
	    for (i__ = *n - 2; i__ >= 1; --i__) {
		b[i__ + j * b_dim1] = (b[i__ + j * b_dim1] - du[i__] * b[i__ 
			+ 1 + j * b_dim1] - dl[i__] * b[i__ + 2 + j * b_dim1])
			 / d__[i__];
/* L90: */
	    }
/* L100: */
	}
    }

    return 0;

/*     End of DGTSV */

} /* dgtsv_ */

/* Subroutine */ static int dgetri_(const integer *n, doublereal *a, integer *lda, const integer *ipiv, doublereal *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    integer i__, j, jb, nb, jj, jp, nn, iws;
    integer nbmin;
    integer ldwork;
    integer lwkopt;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;
    --work;

    /* Function Body */
    *info = 0;
    nb = ilaenv_(&c__1, "DGETRI", " ", n, &c_n1, &c_n1, &c_n1);
    lwkopt = *n * nb;
    work[1] = (doublereal) lwkopt;
    lquery = *lwork == -1;
    if (*n < 0) {
	*info = -1;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -3;
    } else if (*lwork < Dymola_max(1,*n) && ! lquery) {
	*info = -6;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGETRI", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

/*     Form inv(U).  If INFO > 0 from DTRTRI, then U is singular, */
/*     and the inverse is not computed. */

    dtrtri_("Upper", "Non-unit", (integer*) n, &a[a_offset], lda, info);
    if (*info > 0) {
	return 0;
    }

    nbmin = 2;
    ldwork = *n;
    if (nb > 1 && nb < *n) {
/* Computing MAX */
	i__1 = ldwork * nb;
	iws = Dymola_max(i__1,1);
	if (*lwork < iws) {
	    nb = *lwork / ldwork;
/* Computing MAX */
	    i__1 = 2, i__2 = ilaenv_(&c__2, "DGETRI", " ", n, &c_n1, &c_n1, &
		    c_n1);
	    nbmin = Dymola_max(i__1,i__2);
	}
    } else {
	iws = *n;
    }

/*     Solve the equation inv(A)*L = inv(U) for inv(A). */

    if (nb < nbmin || nb >= *n) {

/*        Use unblocked code. */

	for (j = *n; j >= 1; --j) {

/*           Copy current column of L to WORK and replace with zeros. */

	    i__1 = *n;
	    for (i__ = j + 1; i__ <= i__1; ++i__) {
		work[i__] = a[i__ + j * a_dim1];
		a[i__ + j * a_dim1] = 0.;
/* L10: */
	    }

/*           Compute current column of inv(A). */

	    if (j < *n) {
		i__1 = *n - j;
		dgemv_("No transpose", (integer*) n, &i__1, &c_b20, &a[(j + 1) * a_dim1 
			+ 1], lda, &work[j + 1], &c__1, &c_b22, &a[j * a_dim1 
			+ 1], &c__1);
	    }
/* L20: */
	}
    } else {

/*        Use blocked code. */

	nn = (*n - 1) / nb * nb + 1;
	i__1 = -nb;
	for (j = nn; i__1 < 0 ? j >= 1 : j <= 1; j += i__1) {
/* Computing MIN */
	    i__2 = nb, i__3 = *n - j + 1;
	    jb = Dymola_min(i__2,i__3);

/*           Copy current block column of L to WORK and replace with */
/*           zeros. */

	    i__2 = j + jb - 1;
	    for (jj = j; jj <= i__2; ++jj) {
		i__3 = *n;
		for (i__ = jj + 1; i__ <= i__3; ++i__) {
		    work[i__ + (jj - j) * ldwork] = a[i__ + jj * a_dim1];
		    a[i__ + jj * a_dim1] = 0.;
/* L30: */
		}
/* L40: */
	    }

/*           Compute current block column of inv(A). */

	    if (j + jb <= *n) {
		i__2 = *n - j - jb + 1;
		dgemm_("No transpose", "No transpose", n, &jb, &i__2, &c_b20, 
			&a[(j + jb) * a_dim1 + 1], lda, &work[j + jb], &
			ldwork, &c_b22, &a[j * a_dim1 + 1], lda);
	    }
	    dtrsm_("Right", "Lower", "No transpose", "Unit", (integer*) n, &jb, &c_b22, &
		    work[j], &ldwork, &a[j * a_dim1 + 1], lda);
/* L50: */
	}
    }

/*     Apply column interchanges. */

    for (j = *n - 1; j >= 1; --j) {
	jp = ipiv[j];
	if (jp != j) {
	    dswap_(n, &a[j * a_dim1 + 1], &c__1, &a[jp * a_dim1 + 1], &c__1);
	}
/* L60: */
    }

    work[1] = (doublereal) iws;
    return 0;

/*     End of DGETRI */

} /* dgetri_ */

/* Subroutine */ static int dtrtri_(char *uplo, char *diag, integer *n, doublereal *a, integer *lda, integer *info)
{
    /* System generated locals */
    address a__1[2];
    integer a_dim1, a_offset, i__1, i__2[2], i__3, i__4, i__5;
    char ch__1[2];

    /* Local variables */
    integer j, jb, nb, nn;
    logical upper;
    logical nounit;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! nounit && ! lsame_(diag, "U", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (*n < 0) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -5;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTRTRI", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

/*     Check for singularity if non-unit. */

    if (nounit) {
	i__1 = *n;
	for (*info = 1; *info <= i__1; ++(*info)) {
	    if (a[*info + *info * a_dim1] == 0.) {
		return 0;
	    }
/* L10: */
	}
	*info = 0;
    }

/*     Determine the block size for this environment. */

/* Writing concatenation */
    i__2[0] = 1, a__1[0] = uplo;
    i__2[1] = 1, a__1[1] = diag;
    s_cat(ch__1, a__1, i__2, &c__2, (ftnlen)2);
    nb = ilaenv_(&c__1, "DTRTRI", ch__1, n, &c_n1, &c_n1, &c_n1);
    if (nb <= 1 || nb >= *n) {

/*        Use unblocked code */

	dtrti2_(uplo, diag, n, &a[a_offset], lda, info);
    } else {

/*        Use blocked code */

	if (upper) {

/*           Compute inverse of upper triangular matrix */

	    i__1 = *n;
	    i__3 = nb;
	    for (j = 1; i__3 < 0 ? j >= i__1 : j <= i__1; j += i__3) {
/* Computing MIN */
		i__4 = nb, i__5 = *n - j + 1;
		jb = Dymola_min(i__4,i__5);

/*              Compute rows 1:j-1 of current block column */

		i__4 = j - 1;
		dtrmm_("Left", "Upper", "No transpose", diag, &i__4, &jb, &
			c_b18_dtrtri, &a[a_offset], lda, &a[j * a_dim1 + 1], lda);
		i__4 = j - 1;
		dtrsm_("Right", "Upper", "No transpose", diag, &i__4, &jb, &
			c_b22_dtrtri, &a[j + j * a_dim1], lda, &a[j * a_dim1 + 1], 
			lda);

/*              Compute inverse of current diagonal block */

		dtrti2_("Upper", diag, &jb, &a[j + j * a_dim1], lda, info);
/* L20: */
	    }
	} else {

/*           Compute inverse of lower triangular matrix */

	    nn = (*n - 1) / nb * nb + 1;
	    i__3 = -nb;
	    for (j = nn; i__3 < 0 ? j >= 1 : j <= 1; j += i__3) {
/* Computing MIN */
		i__1 = nb, i__4 = *n - j + 1;
		jb = Dymola_min(i__1,i__4);
		if (j + jb <= *n) {

/*                 Compute rows j+jb:n of current block column */

		    i__1 = *n - j - jb + 1;
		    dtrmm_("Left", "Lower", "No transpose", diag, &i__1, &jb, 
			    &c_b18_dtrtri, &a[j + jb + (j + jb) * a_dim1], lda, &a[j 
			    + jb + j * a_dim1], lda);
		    i__1 = *n - j - jb + 1;
		    dtrsm_("Right", "Lower", "No transpose", diag, &i__1, &jb,
			     &c_b22_dtrtri, &a[j + j * a_dim1], lda, &a[j + jb + j * 
			    a_dim1], lda);
		}

/*              Compute inverse of current diagonal block */

		dtrti2_("Lower", diag, &jb, &a[j + j * a_dim1], lda, info);
/* L30: */
	    }
	}
    }

    return 0;

/*     End of DTRTRI */

} /* dtrtri_ */

/* Subroutine */ static int dtrti2_(char *uplo, char *diag, integer *n, doublereal *a, integer *lda, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    integer j;
    doublereal ajj;
    logical upper;
    logical nounit;


/*  -- LAPACK computational routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! nounit && ! lsame_(diag, "U", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (*n < 0) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -5;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTRTI2", &i__1);
	return 0;
    }

    if (upper) {

/*        Compute inverse of upper triangular matrix. */

	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    if (nounit) {
		a[j + j * a_dim1] = 1. / a[j + j * a_dim1];
		ajj = -a[j + j * a_dim1];
	    } else {
		ajj = -1.;
	    }

/*           Compute elements 1:j-1 of j-th column. */

	    i__2 = j - 1;
	    dtrmv_("Upper", "No transpose", diag, &i__2, &a[a_offset], lda, &
		    a[j * a_dim1 + 1], &c__1);
	    i__2 = j - 1;
	    dscal_(&i__2, &ajj, &a[j * a_dim1 + 1], &c__1);
/* L10: */
	}
    } else {

/*        Compute inverse of lower triangular matrix. */

	for (j = *n; j >= 1; --j) {
	    if (nounit) {
		a[j + j * a_dim1] = 1. / a[j + j * a_dim1];
		ajj = -a[j + j * a_dim1];
	    } else {
		ajj = -1.;
	    }
	    if (j < *n) {

/*              Compute elements j+1:n of j-th column. */

		i__1 = *n - j;
		dtrmv_("Lower", "No transpose", diag, &i__1, &a[j + 1 + (j + 
			1) * a_dim1], lda, &a[j + 1 + j * a_dim1], &c__1);
		i__1 = *n - j;
		dscal_(&i__1, &ajj, &a[j + 1 + j * a_dim1], &c__1);
	    }
/* L20: */
	}
    }

    return 0;

/*     End of DTRTI2 */

} /* dtrti2_ */

/* Subroutine */ static int dtrsen_(const char *job, const char *compq, const logical *select, integer *n, doublereal *t, integer *ldt, doublereal *q, integer *ldq, doublereal *wr, doublereal *wi, integer *m, doublereal *s, doublereal *sep, doublereal *work, integer *lwork, integer *iwork, integer *liwork, integer *info)
{
    /* System generated locals */
    integer q_dim1, q_offset, t_dim1, t_offset, i__1, i__2;
    doublereal d__1, d__2;

    /* Local variables */
    integer k, n1, n2, kk, nn, ks;
    doublereal est;
    integer kase;
    logical pair;
    integer ierr;
    logical swap;
    doublereal scale;
    integer isave[3], lwmin;
    logical wantq, wants;
    doublereal rnorm;
    logical wantbh;
    integer liwmin;
    logical wantsp, lquery;

/*  -- LAPACK computational routine (version 3.4.1) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     April 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode and test the input parameters */

    /* Parameter adjustments */
    --select;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --wr;
    --wi;
    --work;
    --iwork;

    /* Function Body */
    wantbh = lsame_(job, "B", (ftnlen)1, (ftnlen)1);
    wants = lsame_(job, "E", (ftnlen)1, (ftnlen)1) || wantbh;
    wantsp = lsame_(job, "V", (ftnlen)1, (ftnlen)1) || wantbh;
    wantq = lsame_(compq, "V", (ftnlen)1, (ftnlen)1);

    *info = 0;
    lquery = *lwork == -1;
    if (! lsame_(job, "N", (ftnlen)1, (ftnlen)1) && ! wants && ! wantsp) {
	*info = -1;
    } else if (! lsame_(compq, "N", (ftnlen)1, (ftnlen)1) && ! wantq) {
	*info = -2;
    } else if (*n < 0) {
	*info = -4;
    } else if (*ldt < Dymola_max(1,*n)) {
	*info = -6;
    } else if (*ldq < 1 || wantq && *ldq < *n) {
	*info = -8;
    } else {

/*        Set M to the dimension of the specified invariant subspace, */
/*        and test LWORK and LIWORK. */

	*m = 0;
	pair = FALSE_;
	i__1 = *n;
	for (k = 1; k <= i__1; ++k) {
	    if (pair) {
		pair = FALSE_;
	    } else {
		if (k < *n) {
		    if (t[k + 1 + k * t_dim1] == 0.) {
			if (select[k]) {
			    ++(*m);
			}
		    } else {
			pair = TRUE_;
			if (select[k] || select[k + 1]) {
			    *m += 2;
			}
		    }
		} else {
		    if (select[*n]) {
			++(*m);
		    }
		}
	    }
/* L10: */
	}

	n1 = *m;
	n2 = *n - *m;
	nn = n1 * n2;

	if (wantsp) {
/* Computing MAX */
	    i__1 = 1, i__2 = nn << 1;
	    lwmin = Dymola_max(i__1,i__2);
	    liwmin = Dymola_max(1,nn);
	} else if (lsame_(job, "N", (ftnlen)1, (ftnlen)1)) {
	    lwmin = Dymola_max(1,*n);
	    liwmin = 1;
	} else if (lsame_(job, "E", (ftnlen)1, (ftnlen)1)) {
	    lwmin = Dymola_max(1,nn);
	    liwmin = 1;
	}

	if (*lwork < lwmin && ! lquery) {
	    *info = -15;
	} else if (*liwork < liwmin && ! lquery) {
	    *info = -17;
	}
    }

    if (*info == 0) {
	work[1] = (doublereal) lwmin;
	iwork[1] = liwmin;
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTRSEN", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible. */

    if (*m == *n || *m == 0) {
	if (wants) {
	    *s = 1.;
	}
	if (wantsp) {
	    *sep = dlange_("1", n, n, &t[t_offset], ldt, &work[1]);
	}
	goto L40;
    }

/*     Collect the selected blocks at the top-left corner of T. */

    ks = 0;
    pair = FALSE_;
    i__1 = *n;
    for (k = 1; k <= i__1; ++k) {
	if (pair) {
	    pair = FALSE_;
	} else {
	    swap = select[k];
	    if (k < *n) {
		if (t[k + 1 + k * t_dim1] != 0.) {
		    pair = TRUE_;
		    swap = swap || select[k + 1];
		}
	    }
	    if (swap) {
		++ks;

/*              Swap the K-th block to position KS. */

		ierr = 0;
		kk = k;
		if (k != ks) {
      dtrexc_((char*) compq, n, &t[t_offset], ldt, &q[q_offset], ldq, &
			    kk, &ks, &work[1], &ierr);
		}
		if (ierr == 1 || ierr == 2) {

/*                 Blocks too close to swap: exit. */

		    *info = 1;
		    if (wants) {
			*s = 0.;
		    }
		    if (wantsp) {
			*sep = 0.;
		    }
		    goto L40;
		}
		if (pair) {
		    ++ks;
		}
	    }
	}
/* L20: */
    }

    if (wants) {

/*        Solve Sylvester equation for R: */

/*           T11*R - R*T22 = scale*T12 */

	dlacpy_("F", &n1, &n2, &t[(n1 + 1) * t_dim1 + 1], ldt, &work[1], &n1);
	dtrsyl_("N", "N", &c_n1, &n1, &n2, &t[t_offset], ldt, &t[n1 + 1 + (n1 
		+ 1) * t_dim1], ldt, &work[1], &n1, &scale, &ierr);

/*        Estimate the reciprocal of the condition number of the cluster */
/*        of eigenvalues. */

	rnorm = dlange_("F", &n1, &n2, &work[1], &n1, &work[1]);
	if (rnorm == 0.) {
	    *s = 1.;
	} else {
	    *s = scale / (sqrt(scale * scale / rnorm + rnorm) * sqrt(rnorm));
	}
    }

    if (wantsp) {

/*        Estimate sep(T11,T22). */

	est = 0.;
	kase = 0;
L30:
	dlacn2_(&nn, &work[nn + 1], &work[1], &iwork[1], &est, &kase, isave);
	if (kase != 0) {
	    if (kase == 1) {

/*              Solve  T11*R - R*T22 = scale*X. */

		dtrsyl_("N", "N", &c_n1, &n1, &n2, &t[t_offset], ldt, &t[n1 + 
			1 + (n1 + 1) * t_dim1], ldt, &work[1], &n1, &scale, &
			ierr);
	    } else {

/*              Solve T11**T*R - R*T22**T = scale*X. */

		dtrsyl_("T", "T", &c_n1, &n1, &n2, &t[t_offset], ldt, &t[n1 + 
			1 + (n1 + 1) * t_dim1], ldt, &work[1], &n1, &scale, &
			ierr);
	    }
	    goto L30;
	}

	*sep = scale / est;
    }

L40:

/*     Store the output eigenvalues in WR and WI. */

    i__1 = *n;
    for (k = 1; k <= i__1; ++k) {
	wr[k] = t[k + k * t_dim1];
	wi[k] = 0.;
/* L50: */
    }
    i__1 = *n - 1;
    for (k = 1; k <= i__1; ++k) {
	if (t[k + 1 + k * t_dim1] != 0.) {
	    wi[k] = sqrt((d__1 = t[k + (k + 1) * t_dim1], Dymola_abs(d__1))) * sqrt((
		    d__2 = t[k + 1 + k * t_dim1], Dymola_abs(d__2)));
	    wi[k + 1] = -wi[k];
	}
/* L60: */
    }

    work[1] = (doublereal) lwmin;
    iwork[1] = liwmin;

    return 0;

/*     End of DTRSEN */

} /* dtrsen_ */

/* Subroutine */ static int dtrsyl_(const char *trana, const char *tranb, const integer *isgn, integer *m, integer *n, const doublereal *a, integer *lda, const doublereal *b, integer *ldb, doublereal *c__, integer *ldc, doublereal *scale, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
	    i__3, i__4;
    doublereal d__1, d__2;

    /* Local variables */
    integer j, k, l;
    doublereal x[4]	/* was [2][2] */;
    integer k1, k2, l1, l2;
    doublereal a11, db, da11, vec[4]	/* was [2][2] */, dum[1], eps, sgn;
    integer ierr;
    doublereal smin, suml, sumr;
    integer knext, lnext;
    doublereal xnorm;
    doublereal scaloc;
    doublereal bignum;
    logical notrna, notrnb;
    doublereal smlnum;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode and Test input parameters */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;

    /* Function Body */
    notrna = lsame_(trana, "N", (ftnlen)1, (ftnlen)1);
    notrnb = lsame_(tranb, "N", (ftnlen)1, (ftnlen)1);

    *info = 0;
    if (! notrna && ! lsame_(trana, "T", (ftnlen)1, (ftnlen)1) && ! lsame_(
	    trana, "C", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! notrnb && ! lsame_(tranb, "T", (ftnlen)1, (ftnlen)1) && ! 
	    lsame_(tranb, "C", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (*isgn != 1 && *isgn != -1) {
	*info = -3;
    } else if (*m < 0) {
	*info = -4;
    } else if (*n < 0) {
	*info = -5;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -7;
    } else if (*ldb < Dymola_max(1,*n)) {
	*info = -9;
    } else if (*ldc < Dymola_max(1,*m)) {
	*info = -11;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTRSYL", &i__1);
	return 0;
    }

/*     Quick return if possible */

    *scale = 1.;
    if (*m == 0 || *n == 0) {
	return 0;
    }

/*     Set constants to control overflow */

    eps = dlamch_("P");
    smlnum = dlamch_("S");
    bignum = 1. / smlnum;
    dlabad_(&smlnum, &bignum);
    smlnum = smlnum * (doublereal) (*m * *n) / eps;
    bignum = 1. / smlnum;

/* Computing MAX */
    d__1 = smlnum, d__2 = eps * dlange_("M", m, m, &a[a_offset], lda, dum), d__1 = Dymola_max(d__1,d__2), d__2 = eps * dlange_("M", n, n, 
	    &b[b_offset], ldb, dum);
    smin = Dymola_max(d__1,d__2);

    sgn = (doublereal) (*isgn);

    if (notrna && notrnb) {

/*        Solve    A*X + ISGN*X*B = scale*C. */

/*        The (K,L)th block of X is determined starting from */
/*        bottom-left corner column by column by */

/*         A(K,K)*X(K,L) + ISGN*X(K,L)*B(L,L) = C(K,L) - R(K,L) */

/*        Where */
/*                  M                         L-1 */
/*        R(K,L) = SUM [A(K,I)*X(I,L)] + ISGN*SUM [X(K,J)*B(J,L)]. */
/*                I=K+1                       J=1 */

/*        Start column loop (index = L) */
/*        L1 (L2) : column index of the first (first) row of X(K,L). */

	lnext = 1;
	i__1 = *n;
	for (l = 1; l <= i__1; ++l) {
	    if (l < lnext) {
		goto L60;
	    }
	    if (l == *n) {
		l1 = l;
		l2 = l;
	    } else {
		if (b[l + 1 + l * b_dim1] != 0.) {
		    l1 = l;
		    l2 = l + 1;
		    lnext = l + 2;
		} else {
		    l1 = l;
		    l2 = l;
		    lnext = l + 1;
		}
	    }

/*           Start row loop (index = K) */
/*           K1 (K2): row index of the first (last) row of X(K,L). */

	    knext = *m;
	    for (k = *m; k >= 1; --k) {
		if (k > knext) {
		    goto L50;
		}
		if (k == 1) {
		    k1 = k;
		    k2 = k;
		} else {
		    if (a[k + (k - 1) * a_dim1] != 0.) {
			k1 = k - 1;
			k2 = k;
			knext = k - 2;
		    } else {
			k1 = k;
			k2 = k;
			knext = k - 1;
		    }
		}

		if (l1 == l2 && k1 == k2) {
		    i__2 = *m - k1;
/* Computing MIN */
		    i__3 = k1 + 1;
/* Computing MIN */
		    i__4 = k1 + 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k1 + Dymola_min(i__3,*m) * a_dim1], lda, &c__[Dymola_min(i__4,*m) + l1 * c_dim1], &c__1);
		    i__2 = l1 - 1;
		    sumr = ddot_(&i__2, &c__[k1 + c_dim1], ldc, (doublereal*) &b[l1 * 
			    b_dim1 + 1], &c__1);
		    vec[0] = c__[k1 + l1 * c_dim1] - (suml + sgn * sumr);
		    scaloc = 1.;

		    a11 = a[k1 + k1 * a_dim1] + sgn * b[l1 + l1 * b_dim1];
		    da11 = Dymola_abs(a11);
		    if (da11 <= smin) {
			a11 = smin;
			da11 = smin;
			*info = 1;
		    }
		    db = Dymola_abs(vec[0]);
		    if (da11 < 1. && db > 1.) {
			if (db > bignum * da11) {
			    scaloc = 1. / db;
			}
		    }
		    x[0] = vec[0] * scaloc / a11;

		    if (scaloc != 1.) {
			i__2 = *n;
			for (j = 1; j <= i__2; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L10: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];

		} else if (l1 == l2 && k1 != k2) {

		    i__2 = *m - k2;
/* Computing MIN */
		    i__3 = k2 + 1;
/* Computing MIN */
		    i__4 = k2 + 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k1 + Dymola_min(i__3,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__4,*m) + l1 * c_dim1], &c__1);
		    i__2 = l1 - 1;
		    sumr = ddot_(&i__2, &c__[k1 + c_dim1], ldc, (doublereal*) &b[l1 * 
			    b_dim1 + 1], &c__1);
		    vec[0] = c__[k1 + l1 * c_dim1] - (suml + sgn * sumr);

		    i__2 = *m - k2;
/* Computing MIN */
		    i__3 = k2 + 1;
/* Computing MIN */
		    i__4 = k2 + 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k2 + Dymola_min(i__3,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__4,*m) + l1 * c_dim1], &c__1);
		    i__2 = l1 - 1;
		    sumr = ddot_(&i__2, &c__[k2 + c_dim1], ldc, (doublereal*) &b[l1 * 
			    b_dim1 + 1], &c__1);
		    vec[1] = c__[k2 + l1 * c_dim1] - (suml + sgn * sumr);

		    d__1 = -sgn * b[l1 + l1 * b_dim1];
		    dlaln2_(&c_false, &c__2, &c__1, &smin, &c_b26, (doublereal*) &a[k1 + k1 
			    * a_dim1], lda, &c_b26, &c_b26, vec, &c__2, &d__1,
			     &c_b30, x, &c__2, &scaloc, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 1;
		    }

		    if (scaloc != 1.) {
			i__2 = *n;
			for (j = 1; j <= i__2; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L20: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];
		    c__[k2 + l1 * c_dim1] = x[1];

		} else if (l1 != l2 && k1 == k2) {

		    i__2 = *m - k1;
/* Computing MIN */
		    i__3 = k1 + 1;
/* Computing MIN */
		    i__4 = k1 + 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k1 + Dymola_min(i__3,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__4,*m) + l1 * c_dim1], &c__1);
		    i__2 = l1 - 1;
		    sumr = ddot_(&i__2, &c__[k1 + c_dim1], ldc, (doublereal*) &b[l1 * 
			    b_dim1 + 1], &c__1);
		    vec[0] = sgn * (c__[k1 + l1 * c_dim1] - (suml + sgn * 
			    sumr));

		    i__2 = *m - k1;
/* Computing MIN */
		    i__3 = k1 + 1;
/* Computing MIN */
		    i__4 = k1 + 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k1 + Dymola_min(i__3,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__4,*m) + l2 * c_dim1], &c__1);
		    i__2 = l1 - 1;
		    sumr = ddot_(&i__2, &c__[k1 + c_dim1], ldc, (doublereal*) &b[l2 * 
			    b_dim1 + 1], &c__1);
		    vec[1] = sgn * (c__[k1 + l2 * c_dim1] - (suml + sgn * 
			    sumr));

		    d__1 = -sgn * a[k1 + k1 * a_dim1];
		    dlaln2_(&c_true, &c__2, &c__1, &smin, &c_b26, (doublereal*) &b[l1 + l1 *
			     b_dim1], ldb, &c_b26, &c_b26, vec, &c__2, &d__1, 
			    &c_b30, x, &c__2, &scaloc, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 1;
		    }

		    if (scaloc != 1.) {
			i__2 = *n;
			for (j = 1; j <= i__2; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L30: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];
		    c__[k1 + l2 * c_dim1] = x[1];

		} else if (l1 != l2 && k1 != k2) {

		    i__2 = *m - k2;
/* Computing MIN */
		    i__3 = k2 + 1;
/* Computing MIN */
		    i__4 = k2 + 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k1 + Dymola_min(i__3,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__4,*m) + l1 * c_dim1], &c__1);
		    i__2 = l1 - 1;
		    sumr = ddot_(&i__2, &c__[k1 + c_dim1], ldc, (doublereal*) &b[l1 * 
			    b_dim1 + 1], &c__1);
		    vec[0] = c__[k1 + l1 * c_dim1] - (suml + sgn * sumr);

		    i__2 = *m - k2;
/* Computing MIN */
		    i__3 = k2 + 1;
/* Computing MIN */
		    i__4 = k2 + 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k1 + Dymola_min(i__3,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__4,*m) + l2 * c_dim1], &c__1);
		    i__2 = l1 - 1;
		    sumr = ddot_(&i__2, &c__[k1 + c_dim1], ldc, (doublereal*) &b[l2 * 
			    b_dim1 + 1], &c__1);
		    vec[2] = c__[k1 + l2 * c_dim1] - (suml + sgn * sumr);

		    i__2 = *m - k2;
/* Computing MIN */
		    i__3 = k2 + 1;
/* Computing MIN */
		    i__4 = k2 + 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k2 + Dymola_min(i__3,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__4,*m) + l1 * c_dim1], &c__1);
		    i__2 = l1 - 1;
		    sumr = ddot_(&i__2, &c__[k2 + c_dim1], ldc, (doublereal*) &b[l1 * 
			    b_dim1 + 1], &c__1);
		    vec[1] = c__[k2 + l1 * c_dim1] - (suml + sgn * sumr);

		    i__2 = *m - k2;
/* Computing MIN */
		    i__3 = k2 + 1;
/* Computing MIN */
		    i__4 = k2 + 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k2 + Dymola_min(i__3,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__4,*m) + l2 * c_dim1], &c__1);
		    i__2 = l1 - 1;
		    sumr = ddot_(&i__2, &c__[k2 + c_dim1], ldc, (doublereal*) &b[l2 * 
			    b_dim1 + 1], &c__1);
		    vec[3] = c__[k2 + l2 * c_dim1] - (suml + sgn * sumr);

		    dlasy2_(&c_false, &c_false, (integer*) isgn, &c__2, &c__2, (doublereal*) &a[k1 + 
			    k1 * a_dim1], lda, (doublereal*) &b[l1 + l1 * b_dim1], ldb, vec,
			     &c__2, &scaloc, x, &c__2, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 1;
		    }

		    if (scaloc != 1.) {
			i__2 = *n;
			for (j = 1; j <= i__2; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L40: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];
		    c__[k1 + l2 * c_dim1] = x[2];
		    c__[k2 + l1 * c_dim1] = x[1];
		    c__[k2 + l2 * c_dim1] = x[3];
		}

L50:
		;
	    }

L60:
	    ;
	}

    } else if (! notrna && notrnb) {

/*        Solve    A**T *X + ISGN*X*B = scale*C. */

/*        The (K,L)th block of X is determined starting from */
/*        upper-left corner column by column by */

/*          A(K,K)**T*X(K,L) + ISGN*X(K,L)*B(L,L) = C(K,L) - R(K,L) */

/*        Where */
/*                   K-1        T                    L-1 */
/*          R(K,L) = SUM [A(I,K)**T*X(I,L)] +ISGN*SUM [X(K,J)*B(J,L)] */
/*                   I=1                          J=1 */

/*        Start column loop (index = L) */
/*        L1 (L2): column index of the first (last) row of X(K,L) */

	lnext = 1;
	i__1 = *n;
	for (l = 1; l <= i__1; ++l) {
	    if (l < lnext) {
		goto L120;
	    }
	    if (l == *n) {
		l1 = l;
		l2 = l;
	    } else {
		if (b[l + 1 + l * b_dim1] != 0.) {
		    l1 = l;
		    l2 = l + 1;
		    lnext = l + 2;
		} else {
		    l1 = l;
		    l2 = l;
		    lnext = l + 1;
		}
	    }

/*           Start row loop (index = K) */
/*           K1 (K2): row index of the first (last) row of X(K,L) */

	    knext = 1;
	    i__2 = *m;
	    for (k = 1; k <= i__2; ++k) {
		if (k < knext) {
		    goto L110;
		}
		if (k == *m) {
		    k1 = k;
		    k2 = k;
		} else {
		    if (a[k + 1 + k * a_dim1] != 0.) {
			k1 = k;
			k2 = k + 1;
			knext = k + 2;
		    } else {
			k1 = k;
			k2 = k;
			knext = k + 1;
		    }
		}

		if (l1 == l2 && k1 == k2) {
		    i__3 = k1 - 1;
		    suml = ddot_(&i__3, (doublereal*) &a[k1 * a_dim1 + 1], &c__1, &c__[l1 * 
			    c_dim1 + 1], &c__1);
		    i__3 = l1 - 1;
		    sumr = ddot_(&i__3, &c__[k1 + c_dim1], ldc, (doublereal*) &b[l1 * 
			    b_dim1 + 1], &c__1);
		    vec[0] = c__[k1 + l1 * c_dim1] - (suml + sgn * sumr);
		    scaloc = 1.;

		    a11 = a[k1 + k1 * a_dim1] + sgn * b[l1 + l1 * b_dim1];
		    da11 = Dymola_abs(a11);
		    if (da11 <= smin) {
			a11 = smin;
			da11 = smin;
			*info = 1;
		    }
		    db = Dymola_abs(vec[0]);
		    if (da11 < 1. && db > 1.) {
			if (db > bignum * da11) {
			    scaloc = 1. / db;
			}
		    }
		    x[0] = vec[0] * scaloc / a11;

		    if (scaloc != 1.) {
			i__3 = *n;
			for (j = 1; j <= i__3; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L70: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];

		} else if (l1 == l2 && k1 != k2) {

		    i__3 = k1 - 1;
		    suml = ddot_(&i__3, (doublereal*) &a[k1 * a_dim1 + 1], &c__1, &c__[l1 * 
			    c_dim1 + 1], &c__1);
		    i__3 = l1 - 1;
		    sumr = ddot_(&i__3, &c__[k1 + c_dim1], ldc, (doublereal*) &b[l1 * 
			    b_dim1 + 1], &c__1);
		    vec[0] = c__[k1 + l1 * c_dim1] - (suml + sgn * sumr);

		    i__3 = k1 - 1;
		    suml = ddot_(&i__3, (doublereal*) &a[k2 * a_dim1 + 1], &c__1, &c__[l1 * 
			    c_dim1 + 1], &c__1);
		    i__3 = l1 - 1;
		    sumr = ddot_(&i__3, &c__[k2 + c_dim1], ldc, (doublereal*) &b[l1 * 
			    b_dim1 + 1], &c__1);
		    vec[1] = c__[k2 + l1 * c_dim1] - (suml + sgn * sumr);

		    d__1 = -sgn * b[l1 + l1 * b_dim1];
		    dlaln2_(&c_true, &c__2, &c__1, &smin, &c_b26, (doublereal*) &a[k1 + k1 *
			     a_dim1], lda, &c_b26, &c_b26, vec, &c__2, &d__1, 
			    &c_b30, x, &c__2, &scaloc, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 1;
		    }

		    if (scaloc != 1.) {
			i__3 = *n;
			for (j = 1; j <= i__3; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L80: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];
		    c__[k2 + l1 * c_dim1] = x[1];

		} else if (l1 != l2 && k1 == k2) {

		    i__3 = k1 - 1;
		    suml = ddot_(&i__3, (doublereal*) &a[k1 * a_dim1 + 1], &c__1, &c__[l1 * 
			    c_dim1 + 1], &c__1);
		    i__3 = l1 - 1;
		    sumr = ddot_(&i__3, &c__[k1 + c_dim1], ldc, (doublereal*) &b[l1 * 
			    b_dim1 + 1], &c__1);
		    vec[0] = sgn * (c__[k1 + l1 * c_dim1] - (suml + sgn * 
			    sumr));

		    i__3 = k1 - 1;
		    suml = ddot_(&i__3, (doublereal*) &a[k1 * a_dim1 + 1], &c__1, &c__[l2 * 
			    c_dim1 + 1], &c__1);
		    i__3 = l1 - 1;
		    sumr = ddot_(&i__3, &c__[k1 + c_dim1], ldc, (doublereal*) &b[l2 * 
			    b_dim1 + 1], &c__1);
		    vec[1] = sgn * (c__[k1 + l2 * c_dim1] - (suml + sgn * 
			    sumr));

		    d__1 = -sgn * a[k1 + k1 * a_dim1];
		    dlaln2_(&c_true, &c__2, &c__1, &smin, &c_b26, (doublereal*) &b[l1 + l1 *
			     b_dim1], ldb, &c_b26, &c_b26, vec, &c__2, &d__1, 
			    &c_b30, x, &c__2, &scaloc, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 1;
		    }

		    if (scaloc != 1.) {
			i__3 = *n;
			for (j = 1; j <= i__3; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L90: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];
		    c__[k1 + l2 * c_dim1] = x[1];

		} else if (l1 != l2 && k1 != k2) {

		    i__3 = k1 - 1;
		    suml = ddot_(&i__3, (doublereal*) &a[k1 * a_dim1 + 1], &c__1, &c__[l1 * 
			    c_dim1 + 1], &c__1);
		    i__3 = l1 - 1;
		    sumr = ddot_(&i__3, &c__[k1 + c_dim1], ldc, (doublereal*) &b[l1 * 
			    b_dim1 + 1], &c__1);
		    vec[0] = c__[k1 + l1 * c_dim1] - (suml + sgn * sumr);

		    i__3 = k1 - 1;
		    suml = ddot_(&i__3, (doublereal*) &a[k1 * a_dim1 + 1], &c__1, &c__[l2 * 
			    c_dim1 + 1], &c__1);
		    i__3 = l1 - 1;
		    sumr = ddot_(&i__3, &c__[k1 + c_dim1], ldc, (doublereal*) &b[l2 * 
			    b_dim1 + 1], &c__1);
		    vec[2] = c__[k1 + l2 * c_dim1] - (suml + sgn * sumr);

		    i__3 = k1 - 1;
		    suml = ddot_(&i__3, (doublereal*) &a[k2 * a_dim1 + 1], &c__1, &c__[l1 * 
			    c_dim1 + 1], &c__1);
		    i__3 = l1 - 1;
		    sumr = ddot_(&i__3, &c__[k2 + c_dim1], ldc, (doublereal*) &b[l1 * 
			    b_dim1 + 1], &c__1);
		    vec[1] = c__[k2 + l1 * c_dim1] - (suml + sgn * sumr);

		    i__3 = k1 - 1;
		    suml = ddot_(&i__3, (doublereal*) &a[k2 * a_dim1 + 1], &c__1, &c__[l2 * 
			    c_dim1 + 1], &c__1);
		    i__3 = l1 - 1;
		    sumr = ddot_(&i__3, &c__[k2 + c_dim1], ldc, (doublereal*) &b[l2 * 
			    b_dim1 + 1], &c__1);
		    vec[3] = c__[k2 + l2 * c_dim1] - (suml + sgn * sumr);

		    dlasy2_(&c_true, &c_false, (integer*) isgn, &c__2, &c__2, (doublereal*) &a[k1 + k1 
			    * a_dim1], lda, (doublereal*) &b[l1 + l1 * b_dim1], ldb, vec, &
			    c__2, &scaloc, x, &c__2, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 1;
		    }

		    if (scaloc != 1.) {
			i__3 = *n;
			for (j = 1; j <= i__3; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L100: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];
		    c__[k1 + l2 * c_dim1] = x[2];
		    c__[k2 + l1 * c_dim1] = x[1];
		    c__[k2 + l2 * c_dim1] = x[3];
		}

L110:
		;
	    }
L120:
	    ;
	}

    } else if (! notrna && ! notrnb) {

/*        Solve    A**T*X + ISGN*X*B**T = scale*C. */

/*        The (K,L)th block of X is determined starting from */
/*        top-right corner column by column by */

/*           A(K,K)**T*X(K,L) + ISGN*X(K,L)*B(L,L)**T = C(K,L) - R(K,L) */

/*        Where */
/*                     K-1                            N */
/*            R(K,L) = SUM [A(I,K)**T*X(I,L)] + ISGN*SUM [X(K,J)*B(L,J)**T]. */
/*                     I=1                          J=L+1 */

/*        Start column loop (index = L) */
/*        L1 (L2): column index of the first (last) row of X(K,L) */

	lnext = *n;
	for (l = *n; l >= 1; --l) {
	    if (l > lnext) {
		goto L180;
	    }
	    if (l == 1) {
		l1 = l;
		l2 = l;
	    } else {
		if (b[l + (l - 1) * b_dim1] != 0.) {
		    l1 = l - 1;
		    l2 = l;
		    lnext = l - 2;
		} else {
		    l1 = l;
		    l2 = l;
		    lnext = l - 1;
		}
	    }

/*           Start row loop (index = K) */
/*           K1 (K2): row index of the first (last) row of X(K,L) */

	    knext = 1;
	    i__1 = *m;
	    for (k = 1; k <= i__1; ++k) {
		if (k < knext) {
		    goto L170;
		}
		if (k == *m) {
		    k1 = k;
		    k2 = k;
		} else {
		    if (a[k + 1 + k * a_dim1] != 0.) {
			k1 = k;
			k2 = k + 1;
			knext = k + 2;
		    } else {
			k1 = k;
			k2 = k;
			knext = k + 1;
		    }
		}

		if (l1 == l2 && k1 == k2) {
		    i__2 = k1 - 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k1 * a_dim1 + 1], &c__1, &c__[l1 * 
			    c_dim1 + 1], &c__1);
		    i__2 = *n - l1;
/* Computing MIN */
		    i__3 = l1 + 1;
/* Computing MIN */
		    i__4 = l1 + 1;
		    sumr = ddot_(&i__2, &c__[k1 + Dymola_min(i__3,*n) * c_dim1], ldc,
			     (doublereal*) &b[l1 + Dymola_min(i__4,*n) * b_dim1], ldb);
		    vec[0] = c__[k1 + l1 * c_dim1] - (suml + sgn * sumr);
		    scaloc = 1.;

		    a11 = a[k1 + k1 * a_dim1] + sgn * b[l1 + l1 * b_dim1];
		    da11 = Dymola_abs(a11);
		    if (da11 <= smin) {
			a11 = smin;
			da11 = smin;
			*info = 1;
		    }
		    db = Dymola_abs(vec[0]);
		    if (da11 < 1. && db > 1.) {
			if (db > bignum * da11) {
			    scaloc = 1. / db;
			}
		    }
		    x[0] = vec[0] * scaloc / a11;

		    if (scaloc != 1.) {
			i__2 = *n;
			for (j = 1; j <= i__2; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L130: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];

		} else if (l1 == l2 && k1 != k2) {

		    i__2 = k1 - 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k1 * a_dim1 + 1], &c__1, &c__[l1 * 
			    c_dim1 + 1], &c__1);
		    i__2 = *n - l2;
/* Computing MIN */
		    i__3 = l2 + 1;
/* Computing MIN */
		    i__4 = l2 + 1;
		    sumr = ddot_(&i__2, &c__[k1 + Dymola_min(i__3,*n) * c_dim1], ldc,
			     (doublereal*) &b[l1 + Dymola_min(i__4,*n) * b_dim1], ldb);
		    vec[0] = c__[k1 + l1 * c_dim1] - (suml + sgn * sumr);

		    i__2 = k1 - 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k2 * a_dim1 + 1], &c__1, &c__[l1 * 
			    c_dim1 + 1], &c__1);
		    i__2 = *n - l2;
/* Computing MIN */
		    i__3 = l2 + 1;
/* Computing MIN */
		    i__4 = l2 + 1;
		    sumr = ddot_(&i__2, &c__[k2 + Dymola_min(i__3,*n) * c_dim1], ldc,
			     (doublereal*) &b[l1 + Dymola_min(i__4,*n) * b_dim1], ldb);
		    vec[1] = c__[k2 + l1 * c_dim1] - (suml + sgn * sumr);

		    d__1 = -sgn * b[l1 + l1 * b_dim1];
		    dlaln2_(&c_true, &c__2, &c__1, &smin, &c_b26, (doublereal*) &a[k1 + k1 *
			     a_dim1], lda, &c_b26, &c_b26, vec, &c__2, &d__1, 
			    &c_b30, x, &c__2, &scaloc, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 1;
		    }

		    if (scaloc != 1.) {
			i__2 = *n;
			for (j = 1; j <= i__2; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L140: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];
		    c__[k2 + l1 * c_dim1] = x[1];

		} else if (l1 != l2 && k1 == k2) {

		    i__2 = k1 - 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k1 * a_dim1 + 1], &c__1, &c__[l1 * 
			    c_dim1 + 1], &c__1);
		    i__2 = *n - l2;
/* Computing MIN */
		    i__3 = l2 + 1;
/* Computing MIN */
		    i__4 = l2 + 1;
		    sumr = ddot_(&i__2, &c__[k1 + Dymola_min(i__3,*n) * c_dim1], ldc,
			     (doublereal*) &b[l1 + Dymola_min(i__4,*n) * b_dim1], ldb);
		    vec[0] = sgn * (c__[k1 + l1 * c_dim1] - (suml + sgn * 
			    sumr));

		    i__2 = k1 - 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k1 * a_dim1 + 1], &c__1, &c__[l2 * 
			    c_dim1 + 1], &c__1);
		    i__2 = *n - l2;
/* Computing MIN */
		    i__3 = l2 + 1;
/* Computing MIN */
		    i__4 = l2 + 1;
		    sumr = ddot_(&i__2, &c__[k1 + Dymola_min(i__3,*n) * c_dim1], ldc,
			     (doublereal*) &b[l2 + Dymola_min(i__4,*n) * b_dim1], ldb);
		    vec[1] = sgn * (c__[k1 + l2 * c_dim1] - (suml + sgn * 
			    sumr));

		    d__1 = -sgn * a[k1 + k1 * a_dim1];
		    dlaln2_(&c_false, &c__2, &c__1, &smin, &c_b26, (doublereal*) &b[l1 + l1 
			    * b_dim1], ldb, &c_b26, &c_b26, vec, &c__2, &d__1,
			     &c_b30, x, &c__2, &scaloc, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 1;
		    }

		    if (scaloc != 1.) {
			i__2 = *n;
			for (j = 1; j <= i__2; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L150: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];
		    c__[k1 + l2 * c_dim1] = x[1];

		} else if (l1 != l2 && k1 != k2) {

		    i__2 = k1 - 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k1 * a_dim1 + 1], &c__1, &c__[l1 * 
			    c_dim1 + 1], &c__1);
		    i__2 = *n - l2;
/* Computing MIN */
		    i__3 = l2 + 1;
/* Computing MIN */
		    i__4 = l2 + 1;
		    sumr = ddot_(&i__2, &c__[k1 + Dymola_min(i__3,*n) * c_dim1], ldc,
			     (doublereal*) &b[l1 + Dymola_min(i__4,*n) * b_dim1], ldb);
		    vec[0] = c__[k1 + l1 * c_dim1] - (suml + sgn * sumr);

		    i__2 = k1 - 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k1 * a_dim1 + 1], &c__1, &c__[l2 * 
			    c_dim1 + 1], &c__1);
		    i__2 = *n - l2;
/* Computing MIN */
		    i__3 = l2 + 1;
/* Computing MIN */
		    i__4 = l2 + 1;
		    sumr = ddot_(&i__2, &c__[k1 + Dymola_min(i__3,*n) * c_dim1], ldc,
			     (doublereal*) &b[l2 + Dymola_min(i__4,*n) * b_dim1], ldb);
		    vec[2] = c__[k1 + l2 * c_dim1] - (suml + sgn * sumr);

		    i__2 = k1 - 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k2 * a_dim1 + 1], &c__1, &c__[l1 * 
			    c_dim1 + 1], &c__1);
		    i__2 = *n - l2;
/* Computing MIN */
		    i__3 = l2 + 1;
/* Computing MIN */
		    i__4 = l2 + 1;
		    sumr = ddot_(&i__2, &c__[k2 + Dymola_min(i__3,*n) * c_dim1], ldc,
			     (doublereal*) &b[l1 + Dymola_min(i__4,*n) * b_dim1], ldb);
		    vec[1] = c__[k2 + l1 * c_dim1] - (suml + sgn * sumr);

		    i__2 = k1 - 1;
		    suml = ddot_(&i__2, (doublereal*) &a[k2 * a_dim1 + 1], &c__1, &c__[l2 * 
			    c_dim1 + 1], &c__1);
		    i__2 = *n - l2;
/* Computing MIN */
		    i__3 = l2 + 1;
/* Computing MIN */
		    i__4 = l2 + 1;
		    sumr = ddot_(&i__2, &c__[k2 + Dymola_min(i__3,*n) * c_dim1], ldc,
			     (doublereal*) &b[l2 + Dymola_min(i__4,*n) * b_dim1], ldb);
		    vec[3] = c__[k2 + l2 * c_dim1] - (suml + sgn * sumr);

		    dlasy2_(&c_true, &c_true, (integer*) isgn, &c__2, &c__2, (doublereal*) &a[k1 + k1 *
			     a_dim1], lda, (doublereal*) &b[l1 + l1 * b_dim1], ldb, vec, &
			    c__2, &scaloc, x, &c__2, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 1;
		    }

		    if (scaloc != 1.) {
			i__2 = *n;
			for (j = 1; j <= i__2; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L160: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];
		    c__[k1 + l2 * c_dim1] = x[2];
		    c__[k2 + l1 * c_dim1] = x[1];
		    c__[k2 + l2 * c_dim1] = x[3];
		}

L170:
		;
	    }
L180:
	    ;
	}

    } else if (notrna && ! notrnb) {

/*        Solve    A*X + ISGN*X*B**T = scale*C. */

/*        The (K,L)th block of X is determined starting from */
/*        bottom-right corner column by column by */

/*            A(K,K)*X(K,L) + ISGN*X(K,L)*B(L,L)**T = C(K,L) - R(K,L) */

/*        Where */
/*                      M                          N */
/*            R(K,L) = SUM [A(K,I)*X(I,L)] + ISGN*SUM [X(K,J)*B(L,J)**T]. */
/*                    I=K+1                      J=L+1 */

/*        Start column loop (index = L) */
/*        L1 (L2): column index of the first (last) row of X(K,L) */

	lnext = *n;
	for (l = *n; l >= 1; --l) {
	    if (l > lnext) {
		goto L240;
	    }
	    if (l == 1) {
		l1 = l;
		l2 = l;
	    } else {
		if (b[l + (l - 1) * b_dim1] != 0.) {
		    l1 = l - 1;
		    l2 = l;
		    lnext = l - 2;
		} else {
		    l1 = l;
		    l2 = l;
		    lnext = l - 1;
		}
	    }

/*           Start row loop (index = K) */
/*           K1 (K2): row index of the first (last) row of X(K,L) */

	    knext = *m;
	    for (k = *m; k >= 1; --k) {
		if (k > knext) {
		    goto L230;
		}
		if (k == 1) {
		    k1 = k;
		    k2 = k;
		} else {
		    if (a[k + (k - 1) * a_dim1] != 0.) {
			k1 = k - 1;
			k2 = k;
			knext = k - 2;
		    } else {
			k1 = k;
			k2 = k;
			knext = k - 1;
		    }
		}

		if (l1 == l2 && k1 == k2) {
		    i__1 = *m - k1;
/* Computing MIN */
		    i__2 = k1 + 1;
/* Computing MIN */
		    i__3 = k1 + 1;
		    suml = ddot_(&i__1, (doublereal*) &a[k1 + Dymola_min(i__2,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__3,*m) + l1 * c_dim1], &c__1);
		    i__1 = *n - l1;
/* Computing MIN */
		    i__2 = l1 + 1;
/* Computing MIN */
		    i__3 = l1 + 1;
		    sumr = ddot_(&i__1, &c__[k1 + Dymola_min(i__2,*n) * c_dim1], ldc,
			     (doublereal*) &b[l1 + Dymola_min(i__3,*n) * b_dim1], ldb);
		    vec[0] = c__[k1 + l1 * c_dim1] - (suml + sgn * sumr);
		    scaloc = 1.;

		    a11 = a[k1 + k1 * a_dim1] + sgn * b[l1 + l1 * b_dim1];
		    da11 = Dymola_abs(a11);
		    if (da11 <= smin) {
			a11 = smin;
			da11 = smin;
			*info = 1;
		    }
		    db = Dymola_abs(vec[0]);
		    if (da11 < 1. && db > 1.) {
			if (db > bignum * da11) {
			    scaloc = 1. / db;
			}
		    }
		    x[0] = vec[0] * scaloc / a11;

		    if (scaloc != 1.) {
			i__1 = *n;
			for (j = 1; j <= i__1; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L190: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];

		} else if (l1 == l2 && k1 != k2) {

		    i__1 = *m - k2;
/* Computing MIN */
		    i__2 = k2 + 1;
/* Computing MIN */
		    i__3 = k2 + 1;
		    suml = ddot_(&i__1, (doublereal*) &a[k1 + Dymola_min(i__2,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__3,*m) + l1 * c_dim1], &c__1);
		    i__1 = *n - l2;
/* Computing MIN */
		    i__2 = l2 + 1;
/* Computing MIN */
		    i__3 = l2 + 1;
		    sumr = ddot_(&i__1, &c__[k1 + Dymola_min(i__2,*n) * c_dim1], ldc,
			     (doublereal*) &b[l1 + Dymola_min(i__3,*n) * b_dim1], ldb);
		    vec[0] = c__[k1 + l1 * c_dim1] - (suml + sgn * sumr);

		    i__1 = *m - k2;
/* Computing MIN */
		    i__2 = k2 + 1;
/* Computing MIN */
		    i__3 = k2 + 1;
		    suml = ddot_(&i__1, (doublereal*) &a[k2 + Dymola_min(i__2,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__3,*m) + l1 * c_dim1], &c__1);
		    i__1 = *n - l2;
/* Computing MIN */
		    i__2 = l2 + 1;
/* Computing MIN */
		    i__3 = l2 + 1;
		    sumr = ddot_(&i__1, &c__[k2 + Dymola_min(i__2,*n) * c_dim1], ldc,
			     (doublereal*) &b[l1 + Dymola_min(i__3,*n) * b_dim1], ldb);
		    vec[1] = c__[k2 + l1 * c_dim1] - (suml + sgn * sumr);

		    d__1 = -sgn * b[l1 + l1 * b_dim1];
		    dlaln2_(&c_false, &c__2, &c__1, &smin, &c_b26, (doublereal*) &a[k1 + k1 
			    * a_dim1], lda, &c_b26, &c_b26, vec, &c__2, &d__1,
			     &c_b30, x, &c__2, &scaloc, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 1;
		    }

		    if (scaloc != 1.) {
			i__1 = *n;
			for (j = 1; j <= i__1; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L200: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];
		    c__[k2 + l1 * c_dim1] = x[1];

		} else if (l1 != l2 && k1 == k2) {

		    i__1 = *m - k1;
/* Computing MIN */
		    i__2 = k1 + 1;
/* Computing MIN */
		    i__3 = k1 + 1;
		    suml = ddot_(&i__1, (doublereal*) &a[k1 + Dymola_min(i__2,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__3,*m) + l1 * c_dim1], &c__1);
		    i__1 = *n - l2;
/* Computing MIN */
		    i__2 = l2 + 1;
/* Computing MIN */
		    i__3 = l2 + 1;
		    sumr = ddot_(&i__1, &c__[k1 + Dymola_min(i__2,*n) * c_dim1], ldc,
			     (doublereal*) &b[l1 + Dymola_min(i__3,*n) * b_dim1], ldb);
		    vec[0] = sgn * (c__[k1 + l1 * c_dim1] - (suml + sgn * 
			    sumr));

		    i__1 = *m - k1;
/* Computing MIN */
		    i__2 = k1 + 1;
/* Computing MIN */
		    i__3 = k1 + 1;
		    suml = ddot_(&i__1, (doublereal*) &a[k1 + Dymola_min(i__2,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__3,*m) + l2 * c_dim1], &c__1);
		    i__1 = *n - l2;
/* Computing MIN */
		    i__2 = l2 + 1;
/* Computing MIN */
		    i__3 = l2 + 1;
		    sumr = ddot_(&i__1, &c__[k1 + Dymola_min(i__2,*n) * c_dim1], ldc,
			     (doublereal*) &b[l2 + Dymola_min(i__3,*n) * b_dim1], ldb);
		    vec[1] = sgn * (c__[k1 + l2 * c_dim1] - (suml + sgn * 
			    sumr));

		    d__1 = -sgn * a[k1 + k1 * a_dim1];
		    dlaln2_(&c_false, &c__2, &c__1, &smin, &c_b26, (doublereal*) &b[l1 + l1 
			    * b_dim1], ldb, &c_b26, &c_b26, vec, &c__2, &d__1,
			     &c_b30, x, &c__2, &scaloc, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 1;
		    }

		    if (scaloc != 1.) {
			i__1 = *n;
			for (j = 1; j <= i__1; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L210: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];
		    c__[k1 + l2 * c_dim1] = x[1];

		} else if (l1 != l2 && k1 != k2) {

		    i__1 = *m - k2;
/* Computing MIN */
		    i__2 = k2 + 1;
/* Computing MIN */
		    i__3 = k2 + 1;
		    suml = ddot_(&i__1, (doublereal*) &a[k1 + Dymola_min(i__2,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__3,*m) + l1 * c_dim1], &c__1);
		    i__1 = *n - l2;
/* Computing MIN */
		    i__2 = l2 + 1;
/* Computing MIN */
		    i__3 = l2 + 1;
		    sumr = ddot_(&i__1, &c__[k1 + Dymola_min(i__2,*n) * c_dim1], ldc,
			     (doublereal*) &b[l1 + Dymola_min(i__3,*n) * b_dim1], ldb);
		    vec[0] = c__[k1 + l1 * c_dim1] - (suml + sgn * sumr);

		    i__1 = *m - k2;
/* Computing MIN */
		    i__2 = k2 + 1;
/* Computing MIN */
		    i__3 = k2 + 1;
		    suml = ddot_(&i__1, (doublereal*) &a[k1 + Dymola_min(i__2,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__3,*m) + l2 * c_dim1], &c__1);
		    i__1 = *n - l2;
/* Computing MIN */
		    i__2 = l2 + 1;
/* Computing MIN */
		    i__3 = l2 + 1;
		    sumr = ddot_(&i__1, &c__[k1 + Dymola_min(i__2,*n) * c_dim1], ldc,
			     (doublereal*) &b[l2 + Dymola_min(i__3,*n) * b_dim1], ldb);
		    vec[2] = c__[k1 + l2 * c_dim1] - (suml + sgn * sumr);

		    i__1 = *m - k2;
/* Computing MIN */
		    i__2 = k2 + 1;
/* Computing MIN */
		    i__3 = k2 + 1;
		    suml = ddot_(&i__1, (doublereal*) &a[k2 + Dymola_min(i__2,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__3,*m) + l1 * c_dim1], &c__1);
		    i__1 = *n - l2;
/* Computing MIN */
		    i__2 = l2 + 1;
/* Computing MIN */
		    i__3 = l2 + 1;
		    sumr = ddot_(&i__1, &c__[k2 + Dymola_min(i__2,*n) * c_dim1], ldc,
			     (doublereal*) &b[l1 + Dymola_min(i__3,*n) * b_dim1], ldb);
		    vec[1] = c__[k2 + l1 * c_dim1] - (suml + sgn * sumr);

		    i__1 = *m - k2;
/* Computing MIN */
		    i__2 = k2 + 1;
/* Computing MIN */
		    i__3 = k2 + 1;
		    suml = ddot_(&i__1, (doublereal*) &a[k2 + Dymola_min(i__2,*m) * a_dim1], lda, &
			    c__[Dymola_min(i__3,*m) + l2 * c_dim1], &c__1);
		    i__1 = *n - l2;
/* Computing MIN */
		    i__2 = l2 + 1;
/* Computing MIN */
		    i__3 = l2 + 1;
		    sumr = ddot_(&i__1, &c__[k2 + Dymola_min(i__2,*n) * c_dim1], ldc,
			     (doublereal*) &b[l2 + Dymola_min(i__3,*n) * b_dim1], ldb);
		    vec[3] = c__[k2 + l2 * c_dim1] - (suml + sgn * sumr);

		    dlasy2_(&c_false, &c_true, (integer*) isgn, &c__2, &c__2, (doublereal*) &a[k1 + k1 
			    * a_dim1], lda, (doublereal*) &b[l1 + l1 * b_dim1], ldb, vec, &
			    c__2, &scaloc, x, &c__2, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 1;
		    }

		    if (scaloc != 1.) {
			i__1 = *n;
			for (j = 1; j <= i__1; ++j) {
			    dscal_(m, &scaloc, &c__[j * c_dim1 + 1], &c__1);
/* L220: */
			}
			*scale *= scaloc;
		    }
		    c__[k1 + l1 * c_dim1] = x[0];
		    c__[k1 + l2 * c_dim1] = x[2];
		    c__[k2 + l1 * c_dim1] = x[1];
		    c__[k2 + l2 * c_dim1] = x[3];
		}

L230:
		;
	    }
L240:
	    ;
	}

    }

    return 0;

/*     End of DTRSYL */

} /* dtrsyl_ */

/* Subroutine */ static int dgeevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, integer *n, doublereal *a, integer *lda, doublereal *wr, doublereal *wi, doublereal *vl, integer *ldvl, doublereal *vr, integer *ldvr, integer *ilo, integer *ihi, doublereal *scale, doublereal *abnrm, doublereal *rconde, doublereal *rcondv, doublereal *work, integer *lwork, integer *iwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, vl_dim1, vl_offset, vr_dim1, vr_offset, i__1, 
	    i__2, i__3;
    doublereal d__1, d__2;

    /* Local variables */
    integer i__, k;
    doublereal r__, cs, sn;
    char job[1];
    doublereal scl, dum[1], eps;
    char side[1];
    doublereal anrm;
    integer ierr, itau;
    integer iwrk, nout;
    integer icond;
    logical scalea;
    doublereal cscale;
    logical select[1];
    doublereal bignum;
    integer minwrk, maxwrk;
    logical wantvl, wntsnb;
    integer hswork;
    logical wntsne;
    doublereal smlnum;
    logical lquery, wantvr, wntsnn, wntsnv;


/*  -- LAPACK driver routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --wr;
    --wi;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --scale;
    --rconde;
    --rcondv;
    --work;
    --iwork;

    /* Function Body */
    *info = 0;
    lquery = *lwork == -1;
    wantvl = lsame_(jobvl, "V", (ftnlen)1, (ftnlen)1);
    wantvr = lsame_(jobvr, "V", (ftnlen)1, (ftnlen)1);
    wntsnn = lsame_(sense, "N", (ftnlen)1, (ftnlen)1);
    wntsne = lsame_(sense, "E", (ftnlen)1, (ftnlen)1);
    wntsnv = lsame_(sense, "V", (ftnlen)1, (ftnlen)1);
    wntsnb = lsame_(sense, "B", (ftnlen)1, (ftnlen)1);
    if (! (lsame_(balanc, "N", (ftnlen)1, (ftnlen)1) || lsame_(balanc, "S", (
	    ftnlen)1, (ftnlen)1) || lsame_(balanc, "P", (ftnlen)1, (ftnlen)1) 
	    || lsame_(balanc, "B", (ftnlen)1, (ftnlen)1))) {
	*info = -1;
    } else if (! wantvl && ! lsame_(jobvl, "N", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (! wantvr && ! lsame_(jobvr, "N", (ftnlen)1, (ftnlen)1)) {
	*info = -3;
    } else if (! (wntsnn || wntsne || wntsnb || wntsnv) || (wntsne || wntsnb) 
	    && ! (wantvl && wantvr)) {
	*info = -4;
    } else if (*n < 0) {
	*info = -5;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -7;
    } else if (*ldvl < 1 || wantvl && *ldvl < *n) {
	*info = -11;
    } else if (*ldvr < 1 || wantvr && *ldvr < *n) {
	*info = -13;
    }

/*     Compute workspace */
/*      (Note: Comments in the code beginning "Workspace:" describe the */
/*       minimal amount of workspace needed at that point in the code, */
/*       as well as the preferred amount for good performance. */
/*       NB refers to the optimal block size for the immediately */
/*       following subroutine, as returned by ILAENV. */
/*       HSWORK refers to the workspace preferred by DHSEQR, as */
/*       calculated below. HSWORK is computed assuming ILO=1 and IHI=N, */
/*       the worst case.) */

    if (*info == 0) {
	if (*n == 0) {
	    minwrk = 1;
	    maxwrk = 1;
	} else {
	    maxwrk = *n + *n * ilaenv_(&c__1, "DGEHRD", " ", n, &c__1, n, &
		    c__0);

	    if (wantvl) {
		dhseqr_("S", "V", n, &c__1, n, &a[a_offset], lda, &wr[1], &wi[
			1], &vl[vl_offset], ldvl, &work[1], &c_n1, info);
	    } else if (wantvr) {
		dhseqr_("S", "V", n, &c__1, n, &a[a_offset], lda, &wr[1], &wi[
			1], &vr[vr_offset], ldvr, &work[1], &c_n1, info);
	    } else {
		if (wntsnn) {
		    dhseqr_("E", "N", n, &c__1, n, &a[a_offset], lda, &wr[1], 
			    &wi[1], &vr[vr_offset], ldvr, &work[1], &c_n1, 
			    info);
		} else {
		    dhseqr_("S", "N", n, &c__1, n, &a[a_offset], lda, &wr[1], 
			    &wi[1], &vr[vr_offset], ldvr, &work[1], &c_n1, 
			    info);
		}
	    }
	    hswork = (integer) work[1];

	    if (! wantvl && ! wantvr) {
		minwrk = *n << 1;
		if (! wntsnn) {
/* Computing MAX */
		    i__1 = minwrk, i__2 = *n * *n + *n * 6;
		    minwrk = Dymola_max(i__1,i__2);
		}
		maxwrk = Dymola_max(maxwrk,hswork);
		if (! wntsnn) {
/* Computing MAX */
		    i__1 = maxwrk, i__2 = *n * *n + *n * 6;
		    maxwrk = Dymola_max(i__1,i__2);
		}
	    } else {
		minwrk = *n * 3;
		if (! wntsnn && ! wntsne) {
/* Computing MAX */
		    i__1 = minwrk, i__2 = *n * *n + *n * 6;
		    minwrk = Dymola_max(i__1,i__2);
		}
		maxwrk = Dymola_max(maxwrk,hswork);
/* Computing MAX */
		i__1 = maxwrk, i__2 = *n + (*n - 1) * ilaenv_(&c__1, "DORGHR",
			 " ", n, &c__1, n, &c_n1);
		maxwrk = Dymola_max(i__1,i__2);
		if (! wntsnn && ! wntsne) {
/* Computing MAX */
		    i__1 = maxwrk, i__2 = *n * *n + *n * 6;
		    maxwrk = Dymola_max(i__1,i__2);
		}
/* Computing MAX */
		i__1 = maxwrk, i__2 = *n * 3;
		maxwrk = Dymola_max(i__1,i__2);
	    }
	    maxwrk = Dymola_max(maxwrk,minwrk);
	}
	work[1] = (doublereal) maxwrk;

	if (*lwork < minwrk && ! lquery) {
	    *info = -21;
	}
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGEEVX", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

/*     Get machine constants */

    eps = dlamch_("P");
    smlnum = dlamch_("S");
    bignum = 1. / smlnum;
    dlabad_(&smlnum, &bignum);
    smlnum = sqrt(smlnum) / eps;
    bignum = 1. / smlnum;

/*     Scale A if max element outside range [SMLNUM,BIGNUM] */

    icond = 0;
    anrm = dlange_("M", n, n, &a[a_offset], lda, dum);
    scalea = FALSE_;
    if (anrm > 0. && anrm < smlnum) {
	scalea = TRUE_;
	cscale = smlnum;
    } else if (anrm > bignum) {
	scalea = TRUE_;
	cscale = bignum;
    }
    if (scalea) {
	dlascl_("G", &c__0, &c__0, &anrm, &cscale, n, n, &a[a_offset], lda, &
		ierr);
    }

/*     Balance the matrix and compute ABNRM */

    dgebal_((char*) balanc, n, &a[a_offset], lda, ilo, ihi, &scale[1], &ierr);
    *abnrm = dlange_("1", n, n, &a[a_offset], lda, dum);
    if (scalea) {
	dum[0] = *abnrm;
	dlascl_("G", &c__0, &c__0, &cscale, &anrm, &c__1, &c__1, dum, &c__1, &
		ierr);
	*abnrm = dum[0];
    }

/*     Reduce to upper Hessenberg form */
/*     (Workspace: need 2*N, prefer N+N*NB) */

    itau = 1;
    iwrk = itau + *n;
    i__1 = *lwork - iwrk + 1;
    dgehrd_(n, ilo, ihi, &a[a_offset], lda, &work[itau], &work[iwrk], &i__1, &
	    ierr);

    if (wantvl) {

/*        Want left eigenvectors */
/*        Copy Householder vectors to VL */

	*(unsigned char *)side = 'L';
	dlacpy_("L", n, n, &a[a_offset], lda, &vl[vl_offset], ldvl)
		;

/*        Generate orthogonal matrix in VL */
/*        (Workspace: need 2*N-1, prefer N+(N-1)*NB) */

	i__1 = *lwork - iwrk + 1;
	dorghr_(n, ilo, ihi, &vl[vl_offset], ldvl, &work[itau], &work[iwrk], &
		i__1, &ierr);

/*        Perform QR iteration, accumulating Schur vectors in VL */
/*        (Workspace: need 1, prefer HSWORK (see comments) ) */

	iwrk = itau;
	i__1 = *lwork - iwrk + 1;
	dhseqr_("S", "V", n, ilo, ihi, &a[a_offset], lda, &wr[1], &wi[1], &vl[
		vl_offset], ldvl, &work[iwrk], &i__1, info);

	if (wantvr) {

/*           Want left and right eigenvectors */
/*           Copy Schur vectors to VR */

	    *(unsigned char *)side = 'B';
	    dlacpy_("F", n, n, &vl[vl_offset], ldvl, &vr[vr_offset], ldvr);
	}

    } else if (wantvr) {

/*        Want right eigenvectors */
/*        Copy Householder vectors to VR */

	*(unsigned char *)side = 'R';
	dlacpy_("L", n, n, &a[a_offset], lda, &vr[vr_offset], ldvr)
		;

/*        Generate orthogonal matrix in VR */
/*        (Workspace: need 2*N-1, prefer N+(N-1)*NB) */

	i__1 = *lwork - iwrk + 1;
	dorghr_(n, ilo, ihi, &vr[vr_offset], ldvr, &work[itau], &work[iwrk], &
		i__1, &ierr);

/*        Perform QR iteration, accumulating Schur vectors in VR */
/*        (Workspace: need 1, prefer HSWORK (see comments) ) */

	iwrk = itau;
	i__1 = *lwork - iwrk + 1;
	dhseqr_("S", "V", n, ilo, ihi, &a[a_offset], lda, &wr[1], &wi[1], &vr[
		vr_offset], ldvr, &work[iwrk], &i__1, info);

    } else {

/*        Compute eigenvalues only */
/*        If condition numbers desired, compute Schur form */

	if (wntsnn) {
	    *(unsigned char *)job = 'E';
	} else {
	    *(unsigned char *)job = 'S';
	}

/*        (Workspace: need 1, prefer HSWORK (see comments) ) */

	iwrk = itau;
	i__1 = *lwork - iwrk + 1;
	dhseqr_(job, "N", n, ilo, ihi, &a[a_offset], lda, &wr[1], &wi[1], &vr[
		vr_offset], ldvr, &work[iwrk], &i__1, info);
    }

/*     If INFO > 0 from DHSEQR, then quit */

    if (*info > 0) {
	goto L50;
    }

    if (wantvl || wantvr) {

/*        Compute left and/or right eigenvectors */
/*        (Workspace: need 3*N) */

	dtrevc_(side, "B", select, n, &a[a_offset], lda, &vl[vl_offset], ldvl,
		 &vr[vr_offset], ldvr, n, &nout, &work[iwrk], &ierr);
    }

/*     Compute condition numbers if desired */
/*     (Workspace: need N*N+6*N unless SENSE = 'E') */

    if (! wntsnn) {
      dtrsna_((char*) sense, "A", select, n, &a[a_offset], lda, &vl[vl_offset], 
		ldvl, &vr[vr_offset], ldvr, &rconde[1], &rcondv[1], n, &nout, 
		&work[iwrk], n, &iwork[1], &icond);
    }

    if (wantvl) {

/*        Undo balancing of left eigenvectors */

      dgebak_((char*) balanc, "L", n, ilo, ihi, &scale[1], n, &vl[vl_offset], ldvl, 
		&ierr);

/*        Normalize left eigenvectors and make largest component real */

	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (wi[i__] == 0.) {
		scl = 1. / dnrm2_(n, &vl[i__ * vl_dim1 + 1], &c__1);
		dscal_(n, &scl, &vl[i__ * vl_dim1 + 1], &c__1);
	    } else if (wi[i__] > 0.) {
		d__1 = dnrm2_(n, &vl[i__ * vl_dim1 + 1], &c__1);
		d__2 = dnrm2_(n, &vl[(i__ + 1) * vl_dim1 + 1], &c__1);
		scl = 1. / dlapy2_(&d__1, &d__2);
		dscal_(n, &scl, &vl[i__ * vl_dim1 + 1], &c__1);
		dscal_(n, &scl, &vl[(i__ + 1) * vl_dim1 + 1], &c__1);
		i__2 = *n;
		for (k = 1; k <= i__2; ++k) {
/* Computing 2nd power */
		    d__1 = vl[k + i__ * vl_dim1];
/* Computing 2nd power */
		    d__2 = vl[k + (i__ + 1) * vl_dim1];
		    work[k] = d__1 * d__1 + d__2 * d__2;
/* L10: */
		}
		k = idamax_(n, &work[1], &c__1);
		dlartg_(&vl[k + i__ * vl_dim1], &vl[k + (i__ + 1) * vl_dim1], 
			&cs, &sn, &r__);
		drot_(n, &vl[i__ * vl_dim1 + 1], &c__1, &vl[(i__ + 1) * 
			vl_dim1 + 1], &c__1, &cs, &sn);
		vl[k + (i__ + 1) * vl_dim1] = 0.;
	    }
/* L20: */
	}
    }

    if (wantvr) {

/*        Undo balancing of right eigenvectors */

      dgebak_((char*) balanc, "R", n, ilo, ihi, &scale[1], n, &vr[vr_offset], ldvr, 
		&ierr);

/*        Normalize right eigenvectors and make largest component real */

	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (wi[i__] == 0.) {
		scl = 1. / dnrm2_(n, &vr[i__ * vr_dim1 + 1], &c__1);
		dscal_(n, &scl, &vr[i__ * vr_dim1 + 1], &c__1);
	    } else if (wi[i__] > 0.) {
		d__1 = dnrm2_(n, &vr[i__ * vr_dim1 + 1], &c__1);
		d__2 = dnrm2_(n, &vr[(i__ + 1) * vr_dim1 + 1], &c__1);
		scl = 1. / dlapy2_(&d__1, &d__2);
		dscal_(n, &scl, &vr[i__ * vr_dim1 + 1], &c__1);
		dscal_(n, &scl, &vr[(i__ + 1) * vr_dim1 + 1], &c__1);
		i__2 = *n;
		for (k = 1; k <= i__2; ++k) {
/* Computing 2nd power */
		    d__1 = vr[k + i__ * vr_dim1];
/* Computing 2nd power */
		    d__2 = vr[k + (i__ + 1) * vr_dim1];
		    work[k] = d__1 * d__1 + d__2 * d__2;
/* L30: */
		}
		k = idamax_(n, &work[1], &c__1);
		dlartg_(&vr[k + i__ * vr_dim1], &vr[k + (i__ + 1) * vr_dim1], 
			&cs, &sn, &r__);
		drot_(n, &vr[i__ * vr_dim1 + 1], &c__1, &vr[(i__ + 1) * 
			vr_dim1 + 1], &c__1, &cs, &sn);
		vr[k + (i__ + 1) * vr_dim1] = 0.;
	    }
/* L40: */
	}
    }

/*     Undo scaling if necessary */

L50:
    if (scalea) {
	i__1 = *n - *info;
/* Computing MAX */
	i__3 = *n - *info;
	i__2 = Dymola_max(i__3,1);
	dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wr[*info + 
		1], &i__2, &ierr);
	i__1 = *n - *info;
/* Computing MAX */
	i__3 = *n - *info;
	i__2 = Dymola_max(i__3,1);
	dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wi[*info + 
		1], &i__2, &ierr);
	if (*info == 0) {
	    if ((wntsnv || wntsnb) && icond == 0) {
		dlascl_("G", &c__0, &c__0, &cscale, &anrm, n, &c__1, &rcondv[
			1], n, &ierr);
	    }
	} else {
	    i__1 = *ilo - 1;
	    dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wr[1], 
		    n, &ierr);
	    i__1 = *ilo - 1;
	    dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wi[1], 
		    n, &ierr);
	}
    }

    work[1] = (doublereal) maxwrk;
    return 0;

/*     End of DGEEVX */

} /* dgeevx_ */

/* Subroutine */ static int dtrsna_(char *job, char *howmny, logical *select, integer *n, doublereal *t, integer *ldt, doublereal *vl, integer *ldvl, doublereal *vr, integer *ldvr, doublereal *s, doublereal *sep, integer *mm, integer *m, doublereal *work, integer *ldwork, integer *iwork, integer *info)
{
    /* System generated locals */
    integer t_dim1, t_offset, vl_dim1, vl_offset, vr_dim1, vr_offset, 
	    work_dim1, work_offset, i__1, i__2;
    doublereal d__1, d__2;

    /* Local variables */
    integer i__, j, k, n2;
    doublereal cs;
    integer nn, ks;
    doublereal sn, mu, eps, est;
    integer kase;
    doublereal cond;
    logical pair;
    integer ierr;
    doublereal dumm, prod;
    integer ifst;
    doublereal lnrm;
    integer ilst;
    doublereal rnrm;
    doublereal prod1, prod2, scale, delta;
    integer isave[3];
    logical wants;
    doublereal dummy[1];
    doublereal bignum;
    logical wantbh;
    logical somcon;
    doublereal smlnum;
    logical wantsp;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode and test the input parameters */

    /* Parameter adjustments */
    --select;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --s;
    --sep;
    work_dim1 = *ldwork;
    work_offset = 1 + work_dim1;
    work -= work_offset;
    --iwork;

    /* Function Body */
    wantbh = lsame_(job, "B", (ftnlen)1, (ftnlen)1);
    wants = lsame_(job, "E", (ftnlen)1, (ftnlen)1) || wantbh;
    wantsp = lsame_(job, "V", (ftnlen)1, (ftnlen)1) || wantbh;

    somcon = lsame_(howmny, "S", (ftnlen)1, (ftnlen)1);

    *info = 0;
    if (! wants && ! wantsp) {
	*info = -1;
    } else if (! lsame_(howmny, "A", (ftnlen)1, (ftnlen)1) && ! somcon) {
	*info = -2;
    } else if (*n < 0) {
	*info = -4;
    } else if (*ldt < Dymola_max(1,*n)) {
	*info = -6;
    } else if (*ldvl < 1 || wants && *ldvl < *n) {
	*info = -8;
    } else if (*ldvr < 1 || wants && *ldvr < *n) {
	*info = -10;
    } else {

/*        Set M to the number of eigenpairs for which condition numbers */
/*        are required, and test MM. */

	if (somcon) {
	    *m = 0;
	    pair = FALSE_;
	    i__1 = *n;
	    for (k = 1; k <= i__1; ++k) {
		if (pair) {
		    pair = FALSE_;
		} else {
		    if (k < *n) {
			if (t[k + 1 + k * t_dim1] == 0.) {
			    if (select[k]) {
				++(*m);
			    }
			} else {
			    pair = TRUE_;
			    if (select[k] || select[k + 1]) {
				*m += 2;
			    }
			}
		    } else {
			if (select[*n]) {
			    ++(*m);
			}
		    }
		}
/* L10: */
	    }
	} else {
	    *m = *n;
	}

	if (*mm < *m) {
	    *info = -13;
	} else if (*ldwork < 1 || wantsp && *ldwork < *n) {
	    *info = -16;
	}
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTRSNA", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

    if (*n == 1) {
	if (somcon) {
	    if (! select[1]) {
		return 0;
	    }
	}
	if (wants) {
	    s[1] = 1.;
	}
	if (wantsp) {
	    sep[1] = (d__1 = t[t_dim1 + 1], Dymola_abs(d__1));
	}
	return 0;
    }

/*     Get machine constants */

    eps = dlamch_("P");
    smlnum = dlamch_("S") / eps;
    bignum = 1. / smlnum;
    dlabad_(&smlnum, &bignum);

    ks = 0;
    pair = FALSE_;
    i__1 = *n;
    for (k = 1; k <= i__1; ++k) {

/*        Determine whether T(k,k) begins a 1-by-1 or 2-by-2 block. */

	if (pair) {
	    pair = FALSE_;
	    goto L60;
	} else {
	    if (k < *n) {
		pair = t[k + 1 + k * t_dim1] != 0.;
	    }
	}

/*        Determine whether condition numbers are required for the k-th */
/*        eigenpair. */

	if (somcon) {
	    if (pair) {
		if (! select[k] && ! select[k + 1]) {
		    goto L60;
		}
	    } else {
		if (! select[k]) {
		    goto L60;
		}
	    }
	}

	++ks;

	if (wants) {

/*           Compute the reciprocal condition number of the k-th */
/*           eigenvalue. */

	    if (! pair) {

/*              Real eigenvalue. */

		prod = ddot_(n, &vr[ks * vr_dim1 + 1], &c__1, &vl[ks * 
			vl_dim1 + 1], &c__1);
		rnrm = dnrm2_(n, &vr[ks * vr_dim1 + 1], &c__1);
		lnrm = dnrm2_(n, &vl[ks * vl_dim1 + 1], &c__1);
		s[ks] = Dymola_abs(prod) / (rnrm * lnrm);
	    } else {

/*              Complex eigenvalue. */

		prod1 = ddot_(n, &vr[ks * vr_dim1 + 1], &c__1, &vl[ks * 
			vl_dim1 + 1], &c__1);
		prod1 += ddot_(n, &vr[(ks + 1) * vr_dim1 + 1], &c__1, &vl[(ks 
			+ 1) * vl_dim1 + 1], &c__1);
		prod2 = ddot_(n, &vl[ks * vl_dim1 + 1], &c__1, &vr[(ks + 1) * 
			vr_dim1 + 1], &c__1);
		prod2 -= ddot_(n, &vl[(ks + 1) * vl_dim1 + 1], &c__1, &vr[ks *
			 vr_dim1 + 1], &c__1);
		d__1 = dnrm2_(n, &vr[ks * vr_dim1 + 1], &c__1);
		d__2 = dnrm2_(n, &vr[(ks + 1) * vr_dim1 + 1], &c__1);
		rnrm = dlapy2_(&d__1, &d__2);
		d__1 = dnrm2_(n, &vl[ks * vl_dim1 + 1], &c__1);
		d__2 = dnrm2_(n, &vl[(ks + 1) * vl_dim1 + 1], &c__1);
		lnrm = dlapy2_(&d__1, &d__2);
		cond = dlapy2_(&prod1, &prod2) / (rnrm * lnrm);
		s[ks] = cond;
		s[ks + 1] = cond;
	    }
	}

	if (wantsp) {

/*           Estimate the reciprocal condition number of the k-th */
/*           eigenvector. */

/*           Copy the matrix T to the array WORK and swap the diagonal */
/*           block beginning at T(k,k) to the (1,1) position. */

	    dlacpy_("Full", n, n, &t[t_offset], ldt, &work[work_offset], 
		    ldwork);
	    ifst = k;
	    ilst = 1;
	    dtrexc_("No Q", n, &work[work_offset], ldwork, dummy, &c__1, &
		    ifst, &ilst, &work[(*n + 1) * work_dim1 + 1], &ierr);

	    if (ierr == 1 || ierr == 2) {

/*              Could not swap because blocks not well separated */

		scale = 1.;
		est = bignum;
	    } else {

/*              Reordering successful */

		if (work[work_dim1 + 2] == 0.) {

/*                 Form C = T22 - lambda*I in WORK(2:N,2:N). */

		    i__2 = *n;
		    for (i__ = 2; i__ <= i__2; ++i__) {
			work[i__ + i__ * work_dim1] -= work[work_dim1 + 1];
/* L20: */
		    }
		    n2 = 1;
		    nn = *n - 1;
		} else {

/*                 Triangularize the 2 by 2 block by unitary */
/*                 transformation U = [  cs   i*ss ] */
/*                                    [ i*ss   cs  ]. */
/*                 such that the (1,1) position of WORK is complex */
/*                 eigenvalue lambda with positive imaginary part. (2,2) */
/*                 position of WORK is the complex eigenvalue lambda */
/*                 with negative imaginary  part. */

		    mu = sqrt((d__1 = work[(work_dim1 << 1) + 1], Dymola_abs(d__1))) 
			    * sqrt((d__2 = work[work_dim1 + 2], Dymola_abs(d__2)));
		    delta = dlapy2_(&mu, &work[work_dim1 + 2]);
		    cs = mu / delta;
		    sn = -work[work_dim1 + 2] / delta;

/*                 Form */

/*                 C**T = WORK(2:N,2:N) + i*[rwork(1) ..... rwork(n-1) ] */
/*                                          [   mu                     ] */
/*                                          [         ..               ] */
/*                                          [             ..           ] */
/*                                          [                  mu      ] */
/*                 where C**T is transpose of matrix C, */
/*                 and RWORK is stored starting in the N+1-st column of */
/*                 WORK. */

		    i__2 = *n;
		    for (j = 3; j <= i__2; ++j) {
			work[j * work_dim1 + 2] = cs * work[j * work_dim1 + 2]
				;
			work[j + j * work_dim1] -= work[work_dim1 + 1];
/* L30: */
		    }
		    work[(work_dim1 << 1) + 2] = 0.;

		    work[(*n + 1) * work_dim1 + 1] = mu * 2.;
		    i__2 = *n - 1;
		    for (i__ = 2; i__ <= i__2; ++i__) {
			work[i__ + (*n + 1) * work_dim1] = sn * work[(i__ + 1)
				 * work_dim1 + 1];
/* L40: */
		    }
		    n2 = 2;
		    nn = *n - 1 << 1;
		}

/*              Estimate norm(inv(C**T)) */

		est = 0.;
		kase = 0;
L50:
		dlacn2_(&nn, &work[(*n + 2) * work_dim1 + 1], &work[(*n + 4) *
			 work_dim1 + 1], &iwork[1], &est, &kase, isave);
		if (kase != 0) {
		    if (kase == 1) {
			if (n2 == 1) {

/*                       Real eigenvalue: solve C**T*x = scale*c. */

			    i__2 = *n - 1;
			    dlaqtr_(&c_true, &c_true, &i__2, &work[(work_dim1 
				    << 1) + 2], ldwork, dummy, &dumm, &scale, 
				    &work[(*n + 4) * work_dim1 + 1], &work[(*
				    n + 6) * work_dim1 + 1], &ierr);
			} else {

/*                       Complex eigenvalue: solve */
/*                       C**T*(p+iq) = scale*(c+id) in real arithmetic. */

			    i__2 = *n - 1;
			    dlaqtr_(&c_true, &c_false, &i__2, &work[(
				    work_dim1 << 1) + 2], ldwork, &work[(*n + 
				    1) * work_dim1 + 1], &mu, &scale, &work[(*
				    n + 4) * work_dim1 + 1], &work[(*n + 6) * 
				    work_dim1 + 1], &ierr);
			}
		    } else {
			if (n2 == 1) {

/*                       Real eigenvalue: solve C*x = scale*c. */

			    i__2 = *n - 1;
			    dlaqtr_(&c_false, &c_true, &i__2, &work[(
				    work_dim1 << 1) + 2], ldwork, dummy, &
				    dumm, &scale, &work[(*n + 4) * work_dim1 
				    + 1], &work[(*n + 6) * work_dim1 + 1], &
				    ierr);
			} else {

/*                       Complex eigenvalue: solve */
/*                       C*(p+iq) = scale*(c+id) in real arithmetic. */

			    i__2 = *n - 1;
			    dlaqtr_(&c_false, &c_false, &i__2, &work[(
				    work_dim1 << 1) + 2], ldwork, &work[(*n + 
				    1) * work_dim1 + 1], &mu, &scale, &work[(*
				    n + 4) * work_dim1 + 1], &work[(*n + 6) * 
				    work_dim1 + 1], &ierr);

			}
		    }

		    goto L50;
		}
	    }

	    sep[ks] = scale / Dymola_max(est,smlnum);
	    if (pair) {
		sep[ks + 1] = sep[ks];
	    }
	}

	if (pair) {
	    ++ks;
	}

L60:
	;
    }
    return 0;

/*     End of DTRSNA */

} /* dtrsna_ */

/* Subroutine */ static int dlaqtr_(logical *ltran, logical *lreal, integer *n, doublereal *t, integer *ldt, doublereal *b, doublereal *w, doublereal *scale, doublereal *x, doublereal *work, integer *info)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1, i__2;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6;

    /* Local variables */
    doublereal d__[4]	/* was [2][2] */;
    integer i__, j, k;
    doublereal v[4]	/* was [2][2] */, z__;
    integer j1, j2, n1, n2;
    doublereal si, xj, sr, rec, eps, tjj, tmp;
    integer ierr;
    doublereal smin, xmax;
    integer jnext;
    doublereal sminw, xnorm;
    doublereal scaloc;
    doublereal bignum;
    logical notran;
    doublereal smlnum;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/* ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Do not test the input parameters for errors */

    /* Parameter adjustments */
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --b;
    --x;
    --work;

    /* Function Body */
    notran = ! (*ltran);
    *info = 0;

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

/*     Set constants to control overflow */

    eps = dlamch_("P");
    smlnum = dlamch_("S") / eps;
    bignum = 1. / smlnum;

    xnorm = dlange_("M", n, n, &t[t_offset], ldt, d__);
    if (! (*lreal)) {
/* Computing MAX */
	d__1 = xnorm, d__2 = Dymola_abs(*w), d__1 = Dymola_max(d__1,d__2), d__2 = dlange_(
		"M", n, &c__1, &b[1], n, d__);
	xnorm = Dymola_max(d__1,d__2);
    }
/* Computing MAX */
    d__1 = smlnum, d__2 = eps * xnorm;
    smin = Dymola_max(d__1,d__2);

/*     Compute 1-norm of each column of strictly upper triangular */
/*     part of T to control overflow in triangular solver. */

    work[1] = 0.;
    i__1 = *n;
    for (j = 2; j <= i__1; ++j) {
	i__2 = j - 1;
	work[j] = dasum_(&i__2, &t[j * t_dim1 + 1], &c__1);
/* L10: */
    }

    if (! (*lreal)) {
	i__1 = *n;
	for (i__ = 2; i__ <= i__1; ++i__) {
	    work[i__] += (d__1 = b[i__], Dymola_abs(d__1));
/* L20: */
	}
    }

    n2 = *n << 1;
    n1 = *n;
    if (! (*lreal)) {
	n1 = n2;
    }
    k = idamax_(&n1, &x[1], &c__1);
    xmax = (d__1 = x[k], Dymola_abs(d__1));
    *scale = 1.;

    if (xmax > bignum) {
	*scale = bignum / xmax;
	dscal_(&n1, scale, &x[1], &c__1);
	xmax = bignum;
    }

    if (*lreal) {

	if (notran) {

/*           Solve T*p = scale*c */

	    jnext = *n;
	    for (j = *n; j >= 1; --j) {
		if (j > jnext) {
		    goto L30;
		}
		j1 = j;
		j2 = j;
		jnext = j - 1;
		if (j > 1) {
		    if (t[j + (j - 1) * t_dim1] != 0.) {
			j1 = j - 1;
			jnext = j - 2;
		    }
		}

		if (j1 == j2) {

/*                 Meet 1 by 1 diagonal block */

/*                 Scale to avoid overflow when computing */
/*                     x(j) = b(j)/T(j,j) */

		    xj = (d__1 = x[j1], Dymola_abs(d__1));
		    tjj = (d__1 = t[j1 + j1 * t_dim1], Dymola_abs(d__1));
		    tmp = t[j1 + j1 * t_dim1];
		    if (tjj < smin) {
			tmp = smin;
			tjj = smin;
			*info = 1;
		    }

		    if (xj == 0.) {
			goto L30;
		    }

		    if (tjj < 1.) {
			if (xj > bignum * tjj) {
			    rec = 1. / xj;
			    dscal_(n, &rec, &x[1], &c__1);
			    *scale *= rec;
			    xmax *= rec;
			}
		    }
		    x[j1] /= tmp;
		    xj = (d__1 = x[j1], Dymola_abs(d__1));

/*                 Scale x if necessary to avoid overflow when adding a */
/*                 multiple of column j1 of T. */

		    if (xj > 1.) {
			rec = 1. / xj;
			if (work[j1] > (bignum - xmax) * rec) {
			    dscal_(n, &rec, &x[1], &c__1);
			    *scale *= rec;
			}
		    }
		    if (j1 > 1) {
			i__1 = j1 - 1;
			d__1 = -x[j1];
			daxpy_(&i__1, &d__1, &t[j1 * t_dim1 + 1], &c__1, &x[1]
				, &c__1);
			i__1 = j1 - 1;
			k = idamax_(&i__1, &x[1], &c__1);
			xmax = (d__1 = x[k], Dymola_abs(d__1));
		    }

		} else {

/*                 Meet 2 by 2 diagonal block */

/*                 Call 2 by 2 linear system solve, to take */
/*                 care of possible overflow by scaling factor. */

		    d__[0] = x[j1];
		    d__[1] = x[j2];
		    dlaln2_(&c_false, &c__2, &c__1, &smin, &c_b21, &t[j1 + j1 
			    * t_dim1], ldt, &c_b21, &c_b21, d__, &c__2, &
			    c_b25_dlaqtr, &c_b25_dlaqtr, v, &c__2, &scaloc, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 2;
		    }

		    if (scaloc != 1.) {
			dscal_(n, &scaloc, &x[1], &c__1);
			*scale *= scaloc;
		    }
		    x[j1] = v[0];
		    x[j2] = v[1];

/*                 Scale V(1,1) (= X(J1)) and/or V(2,1) (=X(J2)) */
/*                 to avoid overflow in updating right-hand side. */

/* Computing MAX */
		    d__1 = Dymola_abs(v[0]), d__2 = Dymola_abs(v[1]);
		    xj = Dymola_max(d__1,d__2);
		    if (xj > 1.) {
			rec = 1. / xj;
/* Computing MAX */
			d__1 = work[j1], d__2 = work[j2];
			if (Dymola_max(d__1,d__2) > (bignum - xmax) * rec) {
			    dscal_(n, &rec, &x[1], &c__1);
			    *scale *= rec;
			}
		    }

/*                 Update right-hand side */

		    if (j1 > 1) {
			i__1 = j1 - 1;
			d__1 = -x[j1];
			daxpy_(&i__1, &d__1, &t[j1 * t_dim1 + 1], &c__1, &x[1]
				, &c__1);
			i__1 = j1 - 1;
			d__1 = -x[j2];
			daxpy_(&i__1, &d__1, &t[j2 * t_dim1 + 1], &c__1, &x[1]
				, &c__1);
			i__1 = j1 - 1;
			k = idamax_(&i__1, &x[1], &c__1);
			xmax = (d__1 = x[k], Dymola_abs(d__1));
		    }

		}

L30:
		;
	    }

	} else {

/*           Solve T**T*p = scale*c */

	    jnext = 1;
	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		if (j < jnext) {
		    goto L40;
		}
		j1 = j;
		j2 = j;
		jnext = j + 1;
		if (j < *n) {
		    if (t[j + 1 + j * t_dim1] != 0.) {
			j2 = j + 1;
			jnext = j + 2;
		    }
		}

		if (j1 == j2) {

/*                 1 by 1 diagonal block */

/*                 Scale if necessary to avoid overflow in forming the */
/*                 right-hand side element by inner product. */

		    xj = (d__1 = x[j1], Dymola_abs(d__1));
		    if (xmax > 1.) {
			rec = 1. / xmax;
			if (work[j1] > (bignum - xj) * rec) {
			    dscal_(n, &rec, &x[1], &c__1);
			    *scale *= rec;
			    xmax *= rec;
			}
		    }

		    i__2 = j1 - 1;
		    x[j1] -= ddot_(&i__2, &t[j1 * t_dim1 + 1], &c__1, &x[1], &
			    c__1);

		    xj = (d__1 = x[j1], Dymola_abs(d__1));
		    tjj = (d__1 = t[j1 + j1 * t_dim1], Dymola_abs(d__1));
		    tmp = t[j1 + j1 * t_dim1];
		    if (tjj < smin) {
			tmp = smin;
			tjj = smin;
			*info = 1;
		    }

		    if (tjj < 1.) {
			if (xj > bignum * tjj) {
			    rec = 1. / xj;
			    dscal_(n, &rec, &x[1], &c__1);
			    *scale *= rec;
			    xmax *= rec;
			}
		    }
		    x[j1] /= tmp;
/* Computing MAX */
		    d__2 = xmax, d__3 = (d__1 = x[j1], Dymola_abs(d__1));
		    xmax = Dymola_max(d__2,d__3);

		} else {

/*                 2 by 2 diagonal block */

/*                 Scale if necessary to avoid overflow in forming the */
/*                 right-hand side elements by inner product. */

/* Computing MAX */
		    d__3 = (d__1 = x[j1], Dymola_abs(d__1)), d__4 = (d__2 = x[j2], 
			    Dymola_abs(d__2));
		    xj = Dymola_max(d__3,d__4);
		    if (xmax > 1.) {
			rec = 1. / xmax;
/* Computing MAX */
			d__1 = work[j2], d__2 = work[j1];
			if (Dymola_max(d__1,d__2) > (bignum - xj) * rec) {
			    dscal_(n, &rec, &x[1], &c__1);
			    *scale *= rec;
			    xmax *= rec;
			}
		    }

		    i__2 = j1 - 1;
		    d__[0] = x[j1] - ddot_(&i__2, &t[j1 * t_dim1 + 1], &c__1, 
			    &x[1], &c__1);
		    i__2 = j1 - 1;
		    d__[1] = x[j2] - ddot_(&i__2, &t[j2 * t_dim1 + 1], &c__1, 
			    &x[1], &c__1);

		    dlaln2_(&c_true, &c__2, &c__1, &smin, &c_b21, &t[j1 + j1 *
			     t_dim1], ldt, &c_b21, &c_b21, d__, &c__2, &c_b25_dlaqtr,
			     &c_b25_dlaqtr, v, &c__2, &scaloc, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 2;
		    }

		    if (scaloc != 1.) {
			dscal_(n, &scaloc, &x[1], &c__1);
			*scale *= scaloc;
		    }
		    x[j1] = v[0];
		    x[j2] = v[1];
/* Computing MAX */
		    d__3 = (d__1 = x[j1], Dymola_abs(d__1)), d__4 = (d__2 = x[j2], 
			    Dymola_abs(d__2)), d__3 = Dymola_max(d__3,d__4);
		    xmax = Dymola_max(d__3,xmax);

		}
L40:
		;
	    }
	}

    } else {

/* Computing MAX */
	d__1 = eps * Dymola_abs(*w);
	sminw = Dymola_max(d__1,smin);
	if (notran) {

/*           Solve (T + iB)*(p+iq) = c+id */

	    jnext = *n;
	    for (j = *n; j >= 1; --j) {
		if (j > jnext) {
		    goto L70;
		}
		j1 = j;
		j2 = j;
		jnext = j - 1;
		if (j > 1) {
		    if (t[j + (j - 1) * t_dim1] != 0.) {
			j1 = j - 1;
			jnext = j - 2;
		    }
		}

		if (j1 == j2) {

/*                 1 by 1 diagonal block */

/*                 Scale if necessary to avoid overflow in division */

		    z__ = *w;
		    if (j1 == 1) {
			z__ = b[1];
		    }
		    xj = (d__1 = x[j1], Dymola_abs(d__1)) + (d__2 = x[*n + j1], Dymola_abs(
			    d__2));
		    tjj = (d__1 = t[j1 + j1 * t_dim1], Dymola_abs(d__1)) + Dymola_abs(z__);
		    tmp = t[j1 + j1 * t_dim1];
		    if (tjj < sminw) {
			tmp = sminw;
			tjj = sminw;
			*info = 1;
		    }

		    if (xj == 0.) {
			goto L70;
		    }

		    if (tjj < 1.) {
			if (xj > bignum * tjj) {
			    rec = 1. / xj;
			    dscal_(&n2, &rec, &x[1], &c__1);
			    *scale *= rec;
			    xmax *= rec;
			}
		    }
		    dladiv_(&x[j1], &x[*n + j1], &tmp, &z__, &sr, &si);
		    x[j1] = sr;
		    x[*n + j1] = si;
		    xj = (d__1 = x[j1], Dymola_abs(d__1)) + (d__2 = x[*n + j1], Dymola_abs(
			    d__2));

/*                 Scale x if necessary to avoid overflow when adding a */
/*                 multiple of column j1 of T. */

		    if (xj > 1.) {
			rec = 1. / xj;
			if (work[j1] > (bignum - xmax) * rec) {
			    dscal_(&n2, &rec, &x[1], &c__1);
			    *scale *= rec;
			}
		    }

		    if (j1 > 1) {
			i__1 = j1 - 1;
			d__1 = -x[j1];
			daxpy_(&i__1, &d__1, &t[j1 * t_dim1 + 1], &c__1, &x[1]
				, &c__1);
			i__1 = j1 - 1;
			d__1 = -x[*n + j1];
			daxpy_(&i__1, &d__1, &t[j1 * t_dim1 + 1], &c__1, &x[*
				n + 1], &c__1);

			x[1] += b[j1] * x[*n + j1];
			x[*n + 1] -= b[j1] * x[j1];

			xmax = 0.;
			i__1 = j1 - 1;
			for (k = 1; k <= i__1; ++k) {
/* Computing MAX */
			    d__3 = xmax, d__4 = (d__1 = x[k], Dymola_abs(d__1)) + (
				    d__2 = x[k + *n], Dymola_abs(d__2));
			    xmax = Dymola_max(d__3,d__4);
/* L50: */
			}
		    }

		} else {

/*                 Meet 2 by 2 diagonal block */

		    d__[0] = x[j1];
		    d__[1] = x[j2];
		    d__[2] = x[*n + j1];
		    d__[3] = x[*n + j2];
		    d__1 = -(*w);
		    dlaln2_(&c_false, &c__2, &c__2, &sminw, &c_b21, &t[j1 + 
			    j1 * t_dim1], ldt, &c_b21, &c_b21, d__, &c__2, &
			    c_b25_dlaqtr, &d__1, v, &c__2, &scaloc, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 2;
		    }

		    if (scaloc != 1.) {
			i__1 = *n << 1;
			dscal_(&i__1, &scaloc, &x[1], &c__1);
			*scale = scaloc * *scale;
		    }
		    x[j1] = v[0];
		    x[j2] = v[1];
		    x[*n + j1] = v[2];
		    x[*n + j2] = v[3];

/*                 Scale X(J1), .... to avoid overflow in */
/*                 updating right hand side. */

/* Computing MAX */
		    d__1 = Dymola_abs(v[0]) + Dymola_abs(v[2]), d__2 = Dymola_abs(v[1]) + Dymola_abs(v[3])
			    ;
		    xj = Dymola_max(d__1,d__2);
		    if (xj > 1.) {
			rec = 1. / xj;
/* Computing MAX */
			d__1 = work[j1], d__2 = work[j2];
			if (Dymola_max(d__1,d__2) > (bignum - xmax) * rec) {
			    dscal_(&n2, &rec, &x[1], &c__1);
			    *scale *= rec;
			}
		    }

/*                 Update the right-hand side. */

		    if (j1 > 1) {
			i__1 = j1 - 1;
			d__1 = -x[j1];
			daxpy_(&i__1, &d__1, &t[j1 * t_dim1 + 1], &c__1, &x[1]
				, &c__1);
			i__1 = j1 - 1;
			d__1 = -x[j2];
			daxpy_(&i__1, &d__1, &t[j2 * t_dim1 + 1], &c__1, &x[1]
				, &c__1);

			i__1 = j1 - 1;
			d__1 = -x[*n + j1];
			daxpy_(&i__1, &d__1, &t[j1 * t_dim1 + 1], &c__1, &x[*
				n + 1], &c__1);
			i__1 = j1 - 1;
			d__1 = -x[*n + j2];
			daxpy_(&i__1, &d__1, &t[j2 * t_dim1 + 1], &c__1, &x[*
				n + 1], &c__1);

			x[1] = x[1] + b[j1] * x[*n + j1] + b[j2] * x[*n + j2];
			x[*n + 1] = x[*n + 1] - b[j1] * x[j1] - b[j2] * x[j2];

			xmax = 0.;
			i__1 = j1 - 1;
			for (k = 1; k <= i__1; ++k) {
/* Computing MAX */
			    d__3 = (d__1 = x[k], Dymola_abs(d__1)) + (d__2 = x[k + *
				    n], Dymola_abs(d__2));
			    xmax = Dymola_max(d__3,xmax);
/* L60: */
			}
		    }

		}
L70:
		;
	    }

	} else {

/*           Solve (T + iB)**T*(p+iq) = c+id */

	    jnext = 1;
	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		if (j < jnext) {
		    goto L80;
		}
		j1 = j;
		j2 = j;
		jnext = j + 1;
		if (j < *n) {
		    if (t[j + 1 + j * t_dim1] != 0.) {
			j2 = j + 1;
			jnext = j + 2;
		    }
		}

		if (j1 == j2) {

/*                 1 by 1 diagonal block */

/*                 Scale if necessary to avoid overflow in forming the */
/*                 right-hand side element by inner product. */

		    xj = (d__1 = x[j1], Dymola_abs(d__1)) + (d__2 = x[j1 + *n], Dymola_abs(
			    d__2));
		    if (xmax > 1.) {
			rec = 1. / xmax;
			if (work[j1] > (bignum - xj) * rec) {
			    dscal_(&n2, &rec, &x[1], &c__1);
			    *scale *= rec;
			    xmax *= rec;
			}
		    }

		    i__2 = j1 - 1;
		    x[j1] -= ddot_(&i__2, &t[j1 * t_dim1 + 1], &c__1, &x[1], &
			    c__1);
		    i__2 = j1 - 1;
		    x[*n + j1] -= ddot_(&i__2, &t[j1 * t_dim1 + 1], &c__1, &x[
			    *n + 1], &c__1);
		    if (j1 > 1) {
			x[j1] -= b[j1] * x[*n + 1];
			x[*n + j1] += b[j1] * x[1];
		    }
		    xj = (d__1 = x[j1], Dymola_abs(d__1)) + (d__2 = x[j1 + *n], Dymola_abs(
			    d__2));

		    z__ = *w;
		    if (j1 == 1) {
			z__ = b[1];
		    }

/*                 Scale if necessary to avoid overflow in */
/*                 complex division */

		    tjj = (d__1 = t[j1 + j1 * t_dim1], Dymola_abs(d__1)) + Dymola_abs(z__);
		    tmp = t[j1 + j1 * t_dim1];
		    if (tjj < sminw) {
			tmp = sminw;
			tjj = sminw;
			*info = 1;
		    }

		    if (tjj < 1.) {
			if (xj > bignum * tjj) {
			    rec = 1. / xj;
			    dscal_(&n2, &rec, &x[1], &c__1);
			    *scale *= rec;
			    xmax *= rec;
			}
		    }
		    d__1 = -z__;
		    dladiv_(&x[j1], &x[*n + j1], &tmp, &d__1, &sr, &si);
		    x[j1] = sr;
		    x[j1 + *n] = si;
/* Computing MAX */
		    d__3 = (d__1 = x[j1], Dymola_abs(d__1)) + (d__2 = x[j1 + *n], 
			    Dymola_abs(d__2));
		    xmax = Dymola_max(d__3,xmax);

		} else {

/*                 2 by 2 diagonal block */

/*                 Scale if necessary to avoid overflow in forming the */
/*                 right-hand side element by inner product. */

/* Computing MAX */
		    d__5 = (d__1 = x[j1], Dymola_abs(d__1)) + (d__2 = x[*n + j1], 
			    Dymola_abs(d__2)), d__6 = (d__3 = x[j2], Dymola_abs(d__3)) + (
			    d__4 = x[*n + j2], Dymola_abs(d__4));
		    xj = Dymola_max(d__5,d__6);
		    if (xmax > 1.) {
			rec = 1. / xmax;
/* Computing MAX */
			d__1 = work[j1], d__2 = work[j2];
			if (Dymola_max(d__1,d__2) > (bignum - xj) / xmax) {
			    dscal_(&n2, &rec, &x[1], &c__1);
			    *scale *= rec;
			    xmax *= rec;
			}
		    }

		    i__2 = j1 - 1;
		    d__[0] = x[j1] - ddot_(&i__2, &t[j1 * t_dim1 + 1], &c__1, 
			    &x[1], &c__1);
		    i__2 = j1 - 1;
		    d__[1] = x[j2] - ddot_(&i__2, &t[j2 * t_dim1 + 1], &c__1, 
			    &x[1], &c__1);
		    i__2 = j1 - 1;
		    d__[2] = x[*n + j1] - ddot_(&i__2, &t[j1 * t_dim1 + 1], &
			    c__1, &x[*n + 1], &c__1);
		    i__2 = j1 - 1;
		    d__[3] = x[*n + j2] - ddot_(&i__2, &t[j2 * t_dim1 + 1], &
			    c__1, &x[*n + 1], &c__1);
		    d__[0] -= b[j1] * x[*n + 1];
		    d__[1] -= b[j2] * x[*n + 1];
		    d__[2] += b[j1] * x[1];
		    d__[3] += b[j2] * x[1];

		    dlaln2_(&c_true, &c__2, &c__2, &sminw, &c_b21, &t[j1 + j1 
			    * t_dim1], ldt, &c_b21, &c_b21, d__, &c__2, &
			    c_b25_dlaqtr, w, v, &c__2, &scaloc, &xnorm, &ierr);
		    if (ierr != 0) {
			*info = 2;
		    }

		    if (scaloc != 1.) {
			dscal_(&n2, &scaloc, &x[1], &c__1);
			*scale = scaloc * *scale;
		    }
		    x[j1] = v[0];
		    x[j2] = v[1];
		    x[*n + j1] = v[2];
		    x[*n + j2] = v[3];
/* Computing MAX */
		    d__5 = (d__1 = x[j1], Dymola_abs(d__1)) + (d__2 = x[*n + j1], 
			    Dymola_abs(d__2)), d__6 = (d__3 = x[j2], Dymola_abs(d__3)) + (
			    d__4 = x[*n + j2], Dymola_abs(d__4)), d__5 = Dymola_max(d__5,
			    d__6);
		    xmax = Dymola_max(d__5,xmax);

		}

L80:
		;
	    }

	}

    }

    return 0;

/*     End of DLAQTR */

} /* dlaqtr_ */

/* Subroutine */ static int dggev_(const char *jobvl, const char *jobvr, const integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *alphar, doublereal *alphai, doublereal *beta, doublereal *vl, integer *ldvl, doublereal *vr, integer *ldvr, doublereal *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, vl_dim1, vl_offset, vr_dim1, 
	    vr_offset, i__1, i__2;
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    integer jc, in, jr, ihi, ilo;
    doublereal eps;
    logical ilv;
    doublereal anrm, bnrm;
    integer ierr, itau;
    doublereal temp;
    logical ilvl, ilvr;
    integer iwrk;
    integer ileft, icols, irows;
    logical ilascl, ilbscl;
    logical ldumma[1];
    char chtemp[1];
    doublereal bignum;
    integer ijobvl, iright, ijobvr;
    doublereal anrmto, bnrmto;
    integer minwrk, maxwrk;
    doublereal smlnum;
    logical lquery;


/*  -- LAPACK driver routine (version 3.4.1) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     April 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --alphar;
    --alphai;
    --beta;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --work;

    /* Function Body */
    if (lsame_(jobvl, "N", (ftnlen)1, (ftnlen)1)) {
	ijobvl = 1;
	ilvl = FALSE_;
    } else if (lsame_(jobvl, "V", (ftnlen)1, (ftnlen)1)) {
	ijobvl = 2;
	ilvl = TRUE_;
    } else {
	ijobvl = -1;
	ilvl = FALSE_;
    }

    if (lsame_(jobvr, "N", (ftnlen)1, (ftnlen)1)) {
	ijobvr = 1;
	ilvr = FALSE_;
    } else if (lsame_(jobvr, "V", (ftnlen)1, (ftnlen)1)) {
	ijobvr = 2;
	ilvr = TRUE_;
    } else {
	ijobvr = -1;
	ilvr = FALSE_;
    }
    ilv = ilvl || ilvr;

/*     Test the input arguments */

    *info = 0;
    lquery = *lwork == -1;
    if (ijobvl <= 0) {
	*info = -1;
    } else if (ijobvr <= 0) {
	*info = -2;
    } else if (*n < 0) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -5;
    } else if (*ldb < Dymola_max(1,*n)) {
	*info = -7;
    } else if (*ldvl < 1 || ilvl && *ldvl < *n) {
	*info = -12;
    } else if (*ldvr < 1 || ilvr && *ldvr < *n) {
	*info = -14;
    }

/*     Compute workspace */
/*      (Note: Comments in the code beginning "Workspace:" describe the */
/*       minimal amount of workspace needed at that point in the code, */
/*       as well as the preferred amount for good performance. */
/*       NB refers to the optimal block size for the immediately */
/*       following subroutine, as returned by ILAENV. The workspace is */
/*       computed assuming ILO = 1 and IHI = N, the worst case.) */

    if (*info == 0) {
/* Computing MAX */
	i__1 = 1, i__2 = *n << 3;
	minwrk = Dymola_max(i__1,i__2);
/* Computing MAX */
	i__1 = 1, i__2 = *n * (ilaenv_(&c__1, "DGEQRF", " ", n, &c__1, n, &
		c__0) + 7);
	maxwrk = Dymola_max(i__1,i__2);
/* Computing MAX */
	i__1 = maxwrk, i__2 = *n * (ilaenv_(&c__1, "DORMQR", " ", n, &c__1, n,
		 &c__0) + 7);
	maxwrk = Dymola_max(i__1,i__2);
	if (ilvl) {
/* Computing MAX */
	    i__1 = maxwrk, i__2 = *n * (ilaenv_(&c__1, "DORGQR", " ", n, &
		    c__1, n, &c_n1) + 7);
	    maxwrk = Dymola_max(i__1,i__2);
	}
	work[1] = (doublereal) maxwrk;

	if (*lwork < minwrk && ! lquery) {
	    *info = -16;
	}
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGGEV ", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

/*     Get machine constants */

    eps = dlamch_("P");
    smlnum = dlamch_("S");
    bignum = 1. / smlnum;
    dlabad_(&smlnum, &bignum);
    smlnum = sqrt(smlnum) / eps;
    bignum = 1. / smlnum;

/*     Scale A if max element outside range [SMLNUM,BIGNUM] */

    anrm = dlange_("M", (integer*) n, (integer*) n, &a[a_offset], lda, &work[1]);
    ilascl = FALSE_;
    if (anrm > 0. && anrm < smlnum) {
	anrmto = smlnum;
	ilascl = TRUE_;
    } else if (anrm > bignum) {
	anrmto = bignum;
	ilascl = TRUE_;
    }
    if (ilascl) {
      dlascl_("G", &c__0, &c__0, &anrm, &anrmto, (integer*) n, (integer*) n, &a[a_offset], lda, &
		ierr);
    }

/*     Scale B if max element outside range [SMLNUM,BIGNUM] */

    bnrm = dlange_("M", (integer*) n, (integer*) n, &b[b_offset], ldb, &work[1]);
    ilbscl = FALSE_;
    if (bnrm > 0. && bnrm < smlnum) {
	bnrmto = smlnum;
	ilbscl = TRUE_;
    } else if (bnrm > bignum) {
	bnrmto = bignum;
	ilbscl = TRUE_;
    }
    if (ilbscl) {
	dlascl_("G", &c__0, &c__0, &bnrm, &bnrmto, (integer*) n, (integer*) n, &b[b_offset], ldb, &
		ierr);
    }

/*     Permute the matrices A, B to isolate eigenvalues if possible */
/*     (Workspace: need 6*N) */

    ileft = 1;
    iright = *n + 1;
    iwrk = iright + *n;
    dggbal_("P", (integer*) n, &a[a_offset], lda, &b[b_offset], ldb, &ilo, &ihi, &work[
	    ileft], &work[iright], &work[iwrk], &ierr);

/*     Reduce B to triangular form (QR decomposition of B) */
/*     (Workspace: need N, prefer N*NB) */

    irows = ihi + 1 - ilo;
    if (ilv) {
	icols = *n + 1 - ilo;
    } else {
	icols = irows;
    }
    itau = iwrk;
    iwrk = itau + irows;
    i__1 = *lwork + 1 - iwrk;
    dgeqrf_(&irows, &icols, &b[ilo + ilo * b_dim1], ldb, &work[itau], &work[
	    iwrk], &i__1, &ierr);

/*     Apply the orthogonal transformation to matrix A */
/*     (Workspace: need N, prefer N*NB) */

    i__1 = *lwork + 1 - iwrk;
    dormqr_("L", "T", &irows, &icols, &irows, &b[ilo + ilo * b_dim1], ldb, &
	    work[itau], &a[ilo + ilo * a_dim1], lda, &work[iwrk], &i__1, &
	    ierr);

/*     Initialize VL */
/*     (Workspace: need N, prefer N*NB) */

    if (ilvl) {
	dlaset_("Full", (integer*) n, (integer*) n, &c_b36_dggev, &c_b37, &vl[vl_offset], ldvl)
		;
	if (irows > 1) {
	    i__1 = irows - 1;
	    i__2 = irows - 1;
	    dlacpy_("L", &i__1, &i__2, &b[ilo + 1 + ilo * b_dim1], ldb, &vl[
		    ilo + 1 + ilo * vl_dim1], ldvl);
	}
	i__1 = *lwork + 1 - iwrk;
	dorgqr_(&irows, &irows, &irows, &vl[ilo + ilo * vl_dim1], ldvl, &work[
		itau], &work[iwrk], &i__1, &ierr);
    }

/*     Initialize VR */

    if (ilvr) {
      dlaset_("Full", (integer*) n, (integer*) n, &c_b36_dggev, &c_b37, &vr[vr_offset], ldvr);
    }

/*     Reduce to generalized Hessenberg form */
/*     (Workspace: none needed) */

    if (ilv) {

/*        Eigenvectors requested -- work on whole matrix. */

      dgghrd_((char*) jobvl, (char*) jobvr, (integer*) n, &ilo, &ihi, &a[a_offset], lda, &b[b_offset], 
		ldb, &vl[vl_offset], ldvl, &vr[vr_offset], ldvr, &ierr);
    } else {
	dgghrd_("N", "N", &irows, &c__1, &irows, &a[ilo + ilo * a_dim1], lda, 
		&b[ilo + ilo * b_dim1], ldb, &vl[vl_offset], ldvl, &vr[
		vr_offset], ldvr, &ierr);
    }

/*     Perform QZ algorithm (Compute eigenvalues, and optionally, the */
/*     Schur forms and Schur vectors) */
/*     (Workspace: need N) */

    iwrk = itau;
    if (ilv) {
	*(unsigned char *)chtemp = 'S';
    } else {
	*(unsigned char *)chtemp = 'E';
    }
    i__1 = *lwork + 1 - iwrk;
    dhgeqz_(chtemp, jobvl, jobvr, (integer*) n, &ilo, &ihi, &a[a_offset], lda, &b[
	    b_offset], ldb, &alphar[1], &alphai[1], &beta[1], &vl[vl_offset], 
	    ldvl, &vr[vr_offset], ldvr, &work[iwrk], &i__1, &ierr);
    if (ierr != 0) {
	if (ierr > 0 && ierr <= *n) {
	    *info = ierr;
	} else if (ierr > *n && ierr <= *n << 1) {
	    *info = ierr - *n;
	} else {
	    *info = *n + 1;
	}
	goto L110;
    }

/*     Compute Eigenvectors */
/*     (Workspace: need 6*N) */

    if (ilv) {
	if (ilvl) {
	    if (ilvr) {
		*(unsigned char *)chtemp = 'B';
	    } else {
		*(unsigned char *)chtemp = 'L';
	    }
	} else {
	    *(unsigned char *)chtemp = 'R';
	}
	dtgevc_(chtemp, "B", ldumma, (integer*) n, &a[a_offset], lda, &b[b_offset], ldb, 
		&vl[vl_offset], ldvl, &vr[vr_offset], ldvr, (integer*) n, &in, &work[
		iwrk], &ierr);
	if (ierr != 0) {
	    *info = *n + 2;
	    goto L110;
	}

/*        Undo balancing on VL and VR and normalization */
/*        (Workspace: none needed) */

	if (ilvl) {
	    dggbak_("P", "L", (integer*) n, &ilo, &ihi, &work[ileft], &work[iright], (integer*) n, &
		    vl[vl_offset], ldvl, &ierr);
	    i__1 = *n;
	    for (jc = 1; jc <= i__1; ++jc) {
		if (alphai[jc] < 0.) {
		    goto L50;
		}
		temp = 0.;
		if (alphai[jc] == 0.) {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
/* Computing MAX */
			d__2 = temp, d__3 = (d__1 = vl[jr + jc * vl_dim1], 
				Dymola_abs(d__1));
			temp = Dymola_max(d__2,d__3);
/* L10: */
		    }
		} else {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
/* Computing MAX */
			d__3 = temp, d__4 = (d__1 = vl[jr + jc * vl_dim1], 
				Dymola_abs(d__1)) + (d__2 = vl[jr + (jc + 1) * 
				vl_dim1], Dymola_abs(d__2));
			temp = Dymola_max(d__3,d__4);
/* L20: */
		    }
		}
		if (temp < smlnum) {
		    goto L50;
		}
		temp = 1. / temp;
		if (alphai[jc] == 0.) {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
			vl[jr + jc * vl_dim1] *= temp;
/* L30: */
		    }
		} else {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
			vl[jr + jc * vl_dim1] *= temp;
			vl[jr + (jc + 1) * vl_dim1] *= temp;
/* L40: */
		    }
		}
L50:
		;
	    }
	}
	if (ilvr) {
	    dggbak_("P", "R", (integer*) n, &ilo, &ihi, &work[ileft], &work[iright], (integer*) n, &
		    vr[vr_offset], ldvr, &ierr);
	    i__1 = *n;
	    for (jc = 1; jc <= i__1; ++jc) {
		if (alphai[jc] < 0.) {
		    goto L100;
		}
		temp = 0.;
		if (alphai[jc] == 0.) {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
/* Computing MAX */
			d__2 = temp, d__3 = (d__1 = vr[jr + jc * vr_dim1], 
				Dymola_abs(d__1));
			temp = Dymola_max(d__2,d__3);
/* L60: */
		    }
		} else {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
/* Computing MAX */
			d__3 = temp, d__4 = (d__1 = vr[jr + jc * vr_dim1], 
				Dymola_abs(d__1)) + (d__2 = vr[jr + (jc + 1) * 
				vr_dim1], Dymola_abs(d__2));
			temp = Dymola_max(d__3,d__4);
/* L70: */
		    }
		}
		if (temp < smlnum) {
		    goto L100;
		}
		temp = 1. / temp;
		if (alphai[jc] == 0.) {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
			vr[jr + jc * vr_dim1] *= temp;
/* L80: */
		    }
		} else {
		    i__2 = *n;
		    for (jr = 1; jr <= i__2; ++jr) {
			vr[jr + jc * vr_dim1] *= temp;
			vr[jr + (jc + 1) * vr_dim1] *= temp;
/* L90: */
		    }
		}
L100:
		;
	    }
	}

/*        End of eigenvector calculation */

    }

/*     Undo scaling if necessary */

L110:

    if (ilascl) {
      dlascl_("G", &c__0, &c__0, &anrmto, &anrm, (integer*) n, &c__1, &alphar[1], (integer*) n, &
		ierr);
	dlascl_("G", &c__0, &c__0, &anrmto, &anrm, (integer*) n, &c__1, &alphai[1], (integer*) n, &
		ierr);
    }

    if (ilbscl) {
	dlascl_("G", &c__0, &c__0, &bnrmto, &bnrm, (integer*) n, &c__1, &beta[1], (integer*) n, &
		ierr);
    }

    work[1] = (doublereal) maxwrk;
    return 0;

/*     End of DGGEV */

} /* dggev_ */

/* Subroutine */ static int dggevx_(const char *balanc, const char *jobvl, const char *jobvr, const char *sense, integer *n, const doublereal *a, integer *lda, const doublereal *b, integer *ldb, doublereal *alphar, doublereal *alphai, doublereal *beta, doublereal *vl, integer *ldvl, doublereal *vr, integer *ldvr, integer *ilo, integer *ihi, doublereal *lscale, doublereal *rscale, doublereal *abnrm, doublereal *bbnrm, doublereal *rconde, doublereal *rcondv, doublereal *work, integer *lwork, integer *iwork, logical *bwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, vl_dim1, vl_offset, vr_dim1, 
	    vr_offset, i__1, i__2;
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    integer i__, j, m, jc, in, mm, jr;
    doublereal eps;
    logical ilv, pair;
    doublereal anrm, bnrm;
    integer ierr, itau;
    doublereal temp;
    logical ilvl, ilvr;
    integer iwrk, iwrk1;
    integer icols;
    logical noscl;
    integer irows;
    logical ilascl, ilbscl;
    logical ldumma[1];
    char chtemp[1];
    doublereal bignum;
    integer ijobvl;
    integer ijobvr;
    logical wantsb;
    doublereal anrmto;
    logical wantse;
    doublereal bnrmto;
    integer minwrk, maxwrk;
    logical wantsn;
    doublereal smlnum;
    logical lquery, wantsv;


/*  -- LAPACK driver routine (version 3.4.1) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     April 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --alphar;
    --alphai;
    --beta;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --lscale;
    --rscale;
    --rconde;
    --rcondv;
    --work;
    --iwork;
    --bwork;

    /* Function Body */
    if (lsame_(jobvl, "N", (ftnlen)1, (ftnlen)1)) {
	ijobvl = 1;
	ilvl = FALSE_;
    } else if (lsame_(jobvl, "V", (ftnlen)1, (ftnlen)1)) {
	ijobvl = 2;
	ilvl = TRUE_;
    } else {
	ijobvl = -1;
	ilvl = FALSE_;
    }

    if (lsame_(jobvr, "N", (ftnlen)1, (ftnlen)1)) {
	ijobvr = 1;
	ilvr = FALSE_;
    } else if (lsame_(jobvr, "V", (ftnlen)1, (ftnlen)1)) {
	ijobvr = 2;
	ilvr = TRUE_;
    } else {
	ijobvr = -1;
	ilvr = FALSE_;
    }
    ilv = ilvl || ilvr;

    noscl = lsame_(balanc, "N", (ftnlen)1, (ftnlen)1) || lsame_(balanc, "P", (
	    ftnlen)1, (ftnlen)1);
    wantsn = lsame_(sense, "N", (ftnlen)1, (ftnlen)1);
    wantse = lsame_(sense, "E", (ftnlen)1, (ftnlen)1);
    wantsv = lsame_(sense, "V", (ftnlen)1, (ftnlen)1);
    wantsb = lsame_(sense, "B", (ftnlen)1, (ftnlen)1);

/*     Test the input arguments */

    *info = 0;
    lquery = *lwork == -1;
    if (! (lsame_(balanc, "N", (ftnlen)1, (ftnlen)1) || lsame_(balanc, "S", (
	    ftnlen)1, (ftnlen)1) || lsame_(balanc, "P", (ftnlen)1, (ftnlen)1) 
	    || lsame_(balanc, "B", (ftnlen)1, (ftnlen)1))) {
	*info = -1;
    } else if (ijobvl <= 0) {
	*info = -2;
    } else if (ijobvr <= 0) {
	*info = -3;
    } else if (! (wantsn || wantse || wantsb || wantsv)) {
	*info = -4;
    } else if (*n < 0) {
	*info = -5;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -7;
    } else if (*ldb < Dymola_max(1,*n)) {
	*info = -9;
    } else if (*ldvl < 1 || ilvl && *ldvl < *n) {
	*info = -14;
    } else if (*ldvr < 1 || ilvr && *ldvr < *n) {
	*info = -16;
    }

/*     Compute workspace */
/*      (Note: Comments in the code beginning "Workspace:" describe the */
/*       minimal amount of workspace needed at that point in the code, */
/*       as well as the preferred amount for good performance. */
/*       NB refers to the optimal block size for the immediately */
/*       following subroutine, as returned by ILAENV. The workspace is */
/*       computed assuming ILO = 1 and IHI = N, the worst case.) */

    if (*info == 0) {
	if (*n == 0) {
	    minwrk = 1;
	    maxwrk = 1;
	} else {
	    if (noscl && ! ilv) {
		minwrk = *n << 1;
	    } else {
		minwrk = *n * 6;
	    }
	    if (wantse || wantsb) {
		minwrk = *n * 10;
	    }
	    if (wantsv || wantsb) {
/* Computing MAX */
		i__1 = minwrk, i__2 = (*n << 1) * (*n + 4) + 16;
		minwrk = Dymola_max(i__1,i__2);
	    }
	    maxwrk = minwrk;
/* Computing MAX */
	    i__1 = maxwrk, i__2 = *n + *n * ilaenv_(&c__1, "DGEQRF", " ", n, &
		    c__1, n, &c__0);
	    maxwrk = Dymola_max(i__1,i__2);
/* Computing MAX */
	    i__1 = maxwrk, i__2 = *n + *n * ilaenv_(&c__1, "DORMQR", " ", n, &
		    c__1, n, &c__0);
	    maxwrk = Dymola_max(i__1,i__2);
	    if (ilvl) {
/* Computing MAX */
		i__1 = maxwrk, i__2 = *n + *n * ilaenv_(&c__1, "DORGQR", 
			" ", n, &c__1, n, &c__0);
		maxwrk = Dymola_max(i__1,i__2);
	    }
	}
	work[1] = (doublereal) maxwrk;

	if (*lwork < minwrk && ! lquery) {
	    *info = -26;
	}
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGGEVX", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }


/*     Get machine constants */

    eps = dlamch_("P");
    smlnum = dlamch_("S");
    bignum = 1. / smlnum;
    dlabad_(&smlnum, &bignum);
    smlnum = sqrt(smlnum) / eps;
    bignum = 1. / smlnum;

/*     Scale A if max element outside range [SMLNUM,BIGNUM] */

    anrm = dlange_("M", n, n, &a[a_offset], lda, &work[1]);
    ilascl = FALSE_;
    if (anrm > 0. && anrm < smlnum) {
	anrmto = smlnum;
	ilascl = TRUE_;
    } else if (anrm > bignum) {
	anrmto = bignum;
	ilascl = TRUE_;
    }
    if (ilascl) {
      dlascl_("G", &c__0, &c__0, &anrm, &anrmto, n, n, (doublereal*) &a[a_offset], lda, &
		ierr);
    }

/*     Scale B if max element outside range [SMLNUM,BIGNUM] */

    bnrm = dlange_("M", n, n, &b[b_offset], ldb, &work[1]);
    ilbscl = FALSE_;
    if (bnrm > 0. && bnrm < smlnum) {
	bnrmto = smlnum;
	ilbscl = TRUE_;
    } else if (bnrm > bignum) {
	bnrmto = bignum;
	ilbscl = TRUE_;
    }
    if (ilbscl) {
      dlascl_("G", &c__0, &c__0, &bnrm, &bnrmto, n, n, (doublereal*) &b[b_offset], ldb, &
		ierr);
    }

/*     Permute and/or balance the matrix pair (A,B) */
/*     (Workspace: need 6*N if BALANC = 'S' or 'B', 1 otherwise) */

    dggbal_((char*) balanc, n, (doublereal*) &a[a_offset], lda, (doublereal*) &b[b_offset], ldb, ilo, ihi, &
	    lscale[1], &rscale[1], &work[1], &ierr);

/*     Compute ABNRM and BBNRM */

    *abnrm = dlange_("1", n, n, &a[a_offset], lda, &work[1]);
    if (ilascl) {
	work[1] = *abnrm;
	dlascl_("G", &c__0, &c__0, &anrmto, &anrm, &c__1, &c__1, (doublereal*) &work[1], &
		c__1, &ierr);
	*abnrm = work[1];
    }

    *bbnrm = dlange_("1", n, n, &b[b_offset], ldb, &work[1]);
    if (ilbscl) {
	work[1] = *bbnrm;
	dlascl_("G", &c__0, &c__0, &bnrmto, &bnrm, &c__1, &c__1, &work[1], &
		c__1, &ierr);
	*bbnrm = work[1];
    }

/*     Reduce B to triangular form (QR decomposition of B) */
/*     (Workspace: need N, prefer N*NB ) */

    irows = *ihi + 1 - *ilo;
    if (ilv || ! wantsn) {
	icols = *n + 1 - *ilo;
    } else {
	icols = irows;
    }
    itau = 1;
    iwrk = itau + irows;
    i__1 = *lwork + 1 - iwrk;
    dgeqrf_(&irows, &icols, (doublereal*) &b[*ilo + *ilo * b_dim1], ldb, &work[itau], &work[
	    iwrk], &i__1, &ierr);

/*     Apply the orthogonal transformation to A */
/*     (Workspace: need N, prefer N*NB) */

    i__1 = *lwork + 1 - iwrk;
    dormqr_("L", "T", &irows, &icols, &irows, &b[*ilo + *ilo * b_dim1], ldb, &
	    work[itau], (doublereal*) &a[*ilo + *ilo * a_dim1], lda, &work[iwrk], &i__1, &
	    ierr);

/*     Initialize VL and/or VR */
/*     (Workspace: need N, prefer N*NB) */

    if (ilvl) {
	dlaset_("Full", n, n, &c_b59, &c_b60, &vl[vl_offset], ldvl)
		;
	if (irows > 1) {
	    i__1 = irows - 1;
	    i__2 = irows - 1;
	    dlacpy_("L", &i__1, &i__2, (doublereal*) &b[*ilo + 1 + *ilo * b_dim1], ldb, &vl[
		    *ilo + 1 + *ilo * vl_dim1], ldvl);
	}
	i__1 = *lwork + 1 - iwrk;
	dorgqr_(&irows, &irows, &irows, &vl[*ilo + *ilo * vl_dim1], ldvl, &
		work[itau], &work[iwrk], &i__1, &ierr);
    }

    if (ilvr) {
	dlaset_("Full", n, n, &c_b59, &c_b60, &vr[vr_offset], ldvr)
		;
    }

/*     Reduce to generalized Hessenberg form */
/*     (Workspace: none needed) */

    if (ilv || ! wantsn) {

/*        Eigenvectors requested -- work on whole matrix. */

      dgghrd_((char*) jobvl, (char*) jobvr, n, ilo, ihi, (doublereal*) &a[a_offset], lda, (doublereal*) &b[b_offset], 
		ldb, &vl[vl_offset], ldvl, &vr[vr_offset], ldvr, &ierr);
    } else {
	dgghrd_("N", "N", &irows, &c__1, &irows, (doublereal*) &a[*ilo + *ilo * a_dim1], 
		lda, (doublereal*) &b[*ilo + *ilo * b_dim1], ldb, &vl[vl_offset], ldvl, &vr[
		vr_offset], ldvr, &ierr);
    }

/*     Perform QZ algorithm (Compute eigenvalues, and optionally, the */
/*     Schur forms and Schur vectors) */
/*     (Workspace: need N) */

    if (ilv || ! wantsn) {
	*(unsigned char *)chtemp = 'S';
    } else {
	*(unsigned char *)chtemp = 'E';
    }

    dhgeqz_(chtemp, jobvl, jobvr, n, ilo, ihi, (doublereal*) &a[a_offset], lda, (doublereal*) &b[b_offset]
	    , ldb, &alphar[1], &alphai[1], &beta[1], &vl[vl_offset], ldvl, &
	    vr[vr_offset], ldvr, &work[1], lwork, &ierr);
    if (ierr != 0) {
	if (ierr > 0 && ierr <= *n) {
	    *info = ierr;
	} else if (ierr > *n && ierr <= *n << 1) {
	    *info = ierr - *n;
	} else {
	    *info = *n + 1;
	}
	goto L130;
    }

/*     Compute Eigenvectors and estimate condition numbers if desired */
/*     (Workspace: DTGEVC: need 6*N */
/*                 DTGSNA: need 2*N*(N+2)+16 if SENSE = 'V' or 'B', */
/*                         need N otherwise ) */

    if (ilv || ! wantsn) {
	if (ilv) {
	    if (ilvl) {
		if (ilvr) {
		    *(unsigned char *)chtemp = 'B';
		} else {
		    *(unsigned char *)chtemp = 'L';
		}
	    } else {
		*(unsigned char *)chtemp = 'R';
	    }

	    dtgevc_(chtemp, "B", ldumma, n, (doublereal*) &a[a_offset], lda, (doublereal*) &b[b_offset], 
		    ldb, &vl[vl_offset], ldvl, &vr[vr_offset], ldvr, n, &in, &
		    work[1], &ierr);
	    if (ierr != 0) {
		*info = *n + 2;
		goto L130;
	    }
	}

	if (! wantsn) {

/*           compute eigenvectors (DTGEVC) and estimate condition */
/*           numbers (DTGSNA). Note that the definition of the condition */
/*           number is not invariant under transformation (u,v) to */
/*           (Q*u, Z*v), where (u,v) are eigenvectors of the generalized */
/*           Schur form (S,T), Q and Z are orthogonal matrices. In order */
/*           to avoid using extra 2*N*N workspace, we have to recalculate */
/*           eigenvectors and estimate one condition numbers at a time. */

	    pair = FALSE_;
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {

		if (pair) {
		    pair = FALSE_;
		    goto L20;
		}
		mm = 1;
		if (i__ < *n) {
		    if (a[i__ + 1 + i__ * a_dim1] != 0.) {
			pair = TRUE_;
			mm = 2;
		    }
		}

		i__2 = *n;
		for (j = 1; j <= i__2; ++j) {
		    bwork[j] = FALSE_;
/* L10: */
		}
		if (mm == 1) {
		    bwork[i__] = TRUE_;
		} else if (mm == 2) {
		    bwork[i__] = TRUE_;
		    bwork[i__ + 1] = TRUE_;
		}

		iwrk = mm * *n + 1;
		iwrk1 = iwrk + mm * *n;

/*              Compute a pair of left and right eigenvectors. */
/*              (compute workspace: need up to 4*N + 6*N) */

		if (wantse || wantsb) {
		    dtgevc_("B", "S", &bwork[1], n, (doublereal*) &a[a_offset], lda, (doublereal*) &b[
			    b_offset], ldb, &work[1], n, &work[iwrk], n, &mm, 
			    &m, &work[iwrk1], &ierr);
		    if (ierr != 0) {
			*info = *n + 2;
			goto L130;
		    }
		}

		i__2 = *lwork - iwrk1 + 1;
		dtgsna_((char*) sense, "S", &bwork[1], n, (doublereal*) &a[a_offset], lda, (doublereal*) &b[b_offset], ldb, &work[1], n, &work[iwrk], n, &rconde[
			i__], &rcondv[i__], &mm, &m, &work[iwrk1], &i__2, &
			iwork[1], &ierr);

L20:
		;
	    }
	}
    }

/*     Undo balancing on VL and VR and normalization */
/*     (Workspace: none needed) */

    if (ilvl) {
      dggbak_((char*) balanc, "L", n, ilo, ihi, &lscale[1], &rscale[1], n, &vl[
		vl_offset], ldvl, &ierr);

	i__1 = *n;
	for (jc = 1; jc <= i__1; ++jc) {
	    if (alphai[jc] < 0.) {
		goto L70;
	    }
	    temp = 0.;
	    if (alphai[jc] == 0.) {
		i__2 = *n;
		for (jr = 1; jr <= i__2; ++jr) {
/* Computing MAX */
		    d__2 = temp, d__3 = (d__1 = vl[jr + jc * vl_dim1], Dymola_abs(
			    d__1));
		    temp = Dymola_max(d__2,d__3);
/* L30: */
		}
	    } else {
		i__2 = *n;
		for (jr = 1; jr <= i__2; ++jr) {
/* Computing MAX */
		    d__3 = temp, d__4 = (d__1 = vl[jr + jc * vl_dim1], Dymola_abs(
			    d__1)) + (d__2 = vl[jr + (jc + 1) * vl_dim1], Dymola_abs(
			    d__2));
		    temp = Dymola_max(d__3,d__4);
/* L40: */
		}
	    }
	    if (temp < smlnum) {
		goto L70;
	    }
	    temp = 1. / temp;
	    if (alphai[jc] == 0.) {
		i__2 = *n;
		for (jr = 1; jr <= i__2; ++jr) {
		    vl[jr + jc * vl_dim1] *= temp;
/* L50: */
		}
	    } else {
		i__2 = *n;
		for (jr = 1; jr <= i__2; ++jr) {
		    vl[jr + jc * vl_dim1] *= temp;
		    vl[jr + (jc + 1) * vl_dim1] *= temp;
/* L60: */
		}
	    }
L70:
	    ;
	}
    }
    if (ilvr) {
      dggbak_((char*) balanc, "R", n, ilo, ihi, &lscale[1], &rscale[1], n, &vr[
		vr_offset], ldvr, &ierr);
	i__1 = *n;
	for (jc = 1; jc <= i__1; ++jc) {
	    if (alphai[jc] < 0.) {
		goto L120;
	    }
	    temp = 0.;
	    if (alphai[jc] == 0.) {
		i__2 = *n;
		for (jr = 1; jr <= i__2; ++jr) {
/* Computing MAX */
		    d__2 = temp, d__3 = (d__1 = vr[jr + jc * vr_dim1], Dymola_abs(
			    d__1));
		    temp = Dymola_max(d__2,d__3);
/* L80: */
		}
	    } else {
		i__2 = *n;
		for (jr = 1; jr <= i__2; ++jr) {
/* Computing MAX */
		    d__3 = temp, d__4 = (d__1 = vr[jr + jc * vr_dim1], Dymola_abs(
			    d__1)) + (d__2 = vr[jr + (jc + 1) * vr_dim1], Dymola_abs(
			    d__2));
		    temp = Dymola_max(d__3,d__4);
/* L90: */
		}
	    }
	    if (temp < smlnum) {
		goto L120;
	    }
	    temp = 1. / temp;
	    if (alphai[jc] == 0.) {
		i__2 = *n;
		for (jr = 1; jr <= i__2; ++jr) {
		    vr[jr + jc * vr_dim1] *= temp;
/* L100: */
		}
	    } else {
		i__2 = *n;
		for (jr = 1; jr <= i__2; ++jr) {
		    vr[jr + jc * vr_dim1] *= temp;
		    vr[jr + (jc + 1) * vr_dim1] *= temp;
/* L110: */
		}
	    }
L120:
	    ;
	}
    }

/*     Undo scaling if necessary */

L130:

    if (ilascl) {
	dlascl_("G", &c__0, &c__0, &anrmto, &anrm, n, &c__1, &alphar[1], n, &
		ierr);
	dlascl_("G", &c__0, &c__0, &anrmto, &anrm, n, &c__1, &alphai[1], n, &
		ierr);
    }

    if (ilbscl) {
	dlascl_("G", &c__0, &c__0, &bnrmto, &bnrm, n, &c__1, &beta[1], n, &
		ierr);
    }

    work[1] = (doublereal) maxwrk;
    return 0;

/*     End of DGGEVX */

} /* dggevx_ */

/* Subroutine */ static int dtgsna_(char *job, char *howmny, logical *select, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *vl, integer *ldvl, doublereal *vr, integer *ldvr, doublereal *s, doublereal *dif, integer *mm, integer *m, doublereal *work, integer *lwork, integer *iwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, vl_dim1, vl_offset, vr_dim1, 
	    vr_offset, i__1, i__2;
    doublereal d__1, d__2;

    /* Local variables */
    integer i__, k;
    doublereal c1, c2;
    integer n1, n2, ks, iz;
    doublereal eps, beta, cond;
    logical pair;
    integer ierr;
    doublereal uhav, uhbv;
    integer ifst;
    doublereal lnrm;
    integer ilst;
    doublereal rnrm;
    doublereal root1, root2, scale;
    doublereal uhavi, uhbvi, tmpii;
    integer lwmin;
    logical wants;
    doublereal tmpir, tmpri, dummy[1], tmprr;
    doublereal dummy1[1];
    doublereal alphai, alphar;
    logical wantbh, wantdf, somcon;
    doublereal alprqt;
    doublereal smlnum;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode and test the input parameters */

    /* Parameter adjustments */
    --select;
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    vl_dim1 = *ldvl;
    vl_offset = 1 + vl_dim1;
    vl -= vl_offset;
    vr_dim1 = *ldvr;
    vr_offset = 1 + vr_dim1;
    vr -= vr_offset;
    --s;
    --dif;
    --work;
    --iwork;

    /* Function Body */
    wantbh = lsame_(job, "B", (ftnlen)1, (ftnlen)1);
    wants = lsame_(job, "E", (ftnlen)1, (ftnlen)1) || wantbh;
    wantdf = lsame_(job, "V", (ftnlen)1, (ftnlen)1) || wantbh;

    somcon = lsame_(howmny, "S", (ftnlen)1, (ftnlen)1);

    *info = 0;
    lquery = *lwork == -1;

    if (! wants && ! wantdf) {
	*info = -1;
    } else if (! lsame_(howmny, "A", (ftnlen)1, (ftnlen)1) && ! somcon) {
	*info = -2;
    } else if (*n < 0) {
	*info = -4;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -6;
    } else if (*ldb < Dymola_max(1,*n)) {
	*info = -8;
    } else if (wants && *ldvl < *n) {
	*info = -10;
    } else if (wants && *ldvr < *n) {
	*info = -12;
    } else {

/*        Set M to the number of eigenpairs for which condition numbers */
/*        are required, and test MM. */

	if (somcon) {
	    *m = 0;
	    pair = FALSE_;
	    i__1 = *n;
	    for (k = 1; k <= i__1; ++k) {
		if (pair) {
		    pair = FALSE_;
		} else {
		    if (k < *n) {
			if (a[k + 1 + k * a_dim1] == 0.) {
			    if (select[k]) {
				++(*m);
			    }
			} else {
			    pair = TRUE_;
			    if (select[k] || select[k + 1]) {
				*m += 2;
			    }
			}
		    } else {
			if (select[*n]) {
			    ++(*m);
			}
		    }
		}
/* L10: */
	    }
	} else {
	    *m = *n;
	}

	if (*n == 0) {
	    lwmin = 1;
	} else if (lsame_(job, "V", (ftnlen)1, (ftnlen)1) || lsame_(job, 
		"B", (ftnlen)1, (ftnlen)1)) {
	    lwmin = (*n << 1) * (*n + 2) + 16;
	} else {
	    lwmin = *n;
	}
	work[1] = (doublereal) lwmin;

	if (*mm < *m) {
	    *info = -15;
	} else if (*lwork < lwmin && ! lquery) {
	    *info = -18;
	}
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTGSNA", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

/*     Get machine constants */

    eps = dlamch_("P");
    smlnum = dlamch_("S") / eps;
    ks = 0;
    pair = FALSE_;

    i__1 = *n;
    for (k = 1; k <= i__1; ++k) {

/*        Determine whether A(k,k) begins a 1-by-1 or 2-by-2 block. */

	if (pair) {
	    pair = FALSE_;
	    goto L20;
	} else {
	    if (k < *n) {
		pair = a[k + 1 + k * a_dim1] != 0.;
	    }
	}

/*        Determine whether condition numbers are required for the k-th */
/*        eigenpair. */

	if (somcon) {
	    if (pair) {
		if (! select[k] && ! select[k + 1]) {
		    goto L20;
		}
	    } else {
		if (! select[k]) {
		    goto L20;
		}
	    }
	}

	++ks;

	if (wants) {

/*           Compute the reciprocal condition number of the k-th */
/*           eigenvalue. */

	    if (pair) {

/*              Complex eigenvalue pair. */

		d__1 = dnrm2_(n, &vr[ks * vr_dim1 + 1], &c__1);
		d__2 = dnrm2_(n, &vr[(ks + 1) * vr_dim1 + 1], &c__1);
		rnrm = dlapy2_(&d__1, &d__2);
		d__1 = dnrm2_(n, &vl[ks * vl_dim1 + 1], &c__1);
		d__2 = dnrm2_(n, &vl[(ks + 1) * vl_dim1 + 1], &c__1);
		lnrm = dlapy2_(&d__1, &d__2);
		dgemv_("N", n, n, &c_b19_dtgsna, &a[a_offset], lda, &vr[ks * vr_dim1 
			+ 1], &c__1, &c_b21_dtgsna, &work[1], &c__1);
		tmprr = ddot_(n, &work[1], &c__1, &vl[ks * vl_dim1 + 1], &
			c__1);
		tmpri = ddot_(n, &work[1], &c__1, &vl[(ks + 1) * vl_dim1 + 1],
			 &c__1);
		dgemv_("N", n, n, &c_b19_dtgsna, &a[a_offset], lda, &vr[(ks + 1) * 
			vr_dim1 + 1], &c__1, &c_b21_dtgsna, &work[1], &c__1);
		tmpii = ddot_(n, &work[1], &c__1, &vl[(ks + 1) * vl_dim1 + 1],
			 &c__1);
		tmpir = ddot_(n, &work[1], &c__1, &vl[ks * vl_dim1 + 1], &
			c__1);
		uhav = tmprr + tmpii;
		uhavi = tmpir - tmpri;
		dgemv_("N", n, n, &c_b19_dtgsna, &b[b_offset], ldb, &vr[ks * vr_dim1 
			+ 1], &c__1, &c_b21_dtgsna, &work[1], &c__1);
		tmprr = ddot_(n, &work[1], &c__1, &vl[ks * vl_dim1 + 1], &
			c__1);
		tmpri = ddot_(n, &work[1], &c__1, &vl[(ks + 1) * vl_dim1 + 1],
			 &c__1);
		dgemv_("N", n, n, &c_b19_dtgsna, &b[b_offset], ldb, &vr[(ks + 1) * 
			vr_dim1 + 1], &c__1, &c_b21_dtgsna, &work[1], &c__1);
		tmpii = ddot_(n, &work[1], &c__1, &vl[(ks + 1) * vl_dim1 + 1],
			 &c__1);
		tmpir = ddot_(n, &work[1], &c__1, &vl[ks * vl_dim1 + 1], &
			c__1);
		uhbv = tmprr + tmpii;
		uhbvi = tmpir - tmpri;
		uhav = dlapy2_(&uhav, &uhavi);
		uhbv = dlapy2_(&uhbv, &uhbvi);
		cond = dlapy2_(&uhav, &uhbv);
		s[ks] = cond / (rnrm * lnrm);
		s[ks + 1] = s[ks];

	    } else {

/*              Real eigenvalue. */

		rnrm = dnrm2_(n, &vr[ks * vr_dim1 + 1], &c__1);
		lnrm = dnrm2_(n, &vl[ks * vl_dim1 + 1], &c__1);
		dgemv_("N", n, n, &c_b19_dtgsna, &a[a_offset], lda, &vr[ks * vr_dim1 
			+ 1], &c__1, &c_b21_dtgsna, &work[1], &c__1);
		uhav = ddot_(n, &work[1], &c__1, &vl[ks * vl_dim1 + 1], &c__1)
			;
		dgemv_("N", n, n, &c_b19_dtgsna, &b[b_offset], ldb, &vr[ks * vr_dim1 
			+ 1], &c__1, &c_b21_dtgsna, &work[1], &c__1);
		uhbv = ddot_(n, &work[1], &c__1, &vl[ks * vl_dim1 + 1], &c__1)
			;
		cond = dlapy2_(&uhav, &uhbv);
		if (cond == 0.) {
		    s[ks] = -1.;
		} else {
		    s[ks] = cond / (rnrm * lnrm);
		}
	    }
	}

	if (wantdf) {
	    if (*n == 1) {
		dif[ks] = dlapy2_(&a[a_dim1 + 1], &b[b_dim1 + 1]);
		goto L20;
	    }

/*           Estimate the reciprocal condition number of the k-th */
/*           eigenvectors. */
	    if (pair) {

/*              Copy the  2-by 2 pencil beginning at (A(k,k), B(k, k)). */
/*              Compute the eigenvalue(s) at position K. */

		work[1] = a[k + k * a_dim1];
		work[2] = a[k + 1 + k * a_dim1];
		work[3] = a[k + (k + 1) * a_dim1];
		work[4] = a[k + 1 + (k + 1) * a_dim1];
		work[5] = b[k + k * b_dim1];
		work[6] = b[k + 1 + k * b_dim1];
		work[7] = b[k + (k + 1) * b_dim1];
		work[8] = b[k + 1 + (k + 1) * b_dim1];
		d__1 = smlnum * eps;
		dlag2_(&work[1], &c__2, &work[5], &c__2, &d__1, &beta, dummy1,
			 &alphar, dummy, &alphai);
		alprqt = 1.;
		c1 = (alphar * alphar + alphai * alphai + beta * beta) * 2.;
		c2 = beta * 4. * beta * alphai * alphai;
		root1 = c1 + sqrt(c1 * c1 - c2 * 4.);
		root2 = c2 / root1;
		root1 /= 2.;
/* Computing MIN */
		d__1 = sqrt(root1), d__2 = sqrt(root2);
		cond = Dymola_min(d__1,d__2);
	    }

/*           Copy the matrix (A, B) to the array WORK and swap the */
/*           diagonal block beginning at A(k,k) to the (1,1) position. */

	    dlacpy_("Full", n, n, &a[a_offset], lda, &work[1], n);
	    dlacpy_("Full", n, n, &b[b_offset], ldb, &work[*n * *n + 1], n);
	    ifst = k;
	    ilst = 1;

	    i__2 = *lwork - (*n << 1) * *n;
	    dtgexc_(&c_false, &c_false, n, &work[1], n, &work[*n * *n + 1], n,
		     dummy, &c__1, dummy1, &c__1, &ifst, &ilst, &work[(*n * *
		    n << 1) + 1], &i__2, &ierr);

	    if (ierr > 0) {

/*              Ill-conditioned problem - swap rejected. */

		dif[ks] = 0.;
	    } else {

/*              Reordering successful, solve generalized Sylvester */
/*              equation for R and L, */
/*                         A22 * R - L * A11 = A12 */
/*                         B22 * R - L * B11 = B12, */
/*              and compute estimate of Difl((A11,B11), (A22, B22)). */

		n1 = 1;
		if (work[2] != 0.) {
		    n1 = 2;
		}
		n2 = *n - n1;
		if (n2 == 0) {
		    dif[ks] = cond;
		} else {
		    i__ = *n * *n + 1;
		    iz = (*n << 1) * *n + 1;
		    i__2 = *lwork - (*n << 1) * *n;
		    dtgsyl_("N", &c__3, &n2, &n1, &work[*n * n1 + n1 + 1], n, 
			    &work[1], n, &work[n1 + 1], n, &work[*n * n1 + n1 
			    + i__], n, &work[i__], n, &work[n1 + i__], n, &
			    scale, &dif[ks], &work[iz + 1], &i__2, &iwork[1], 
			    &ierr);

		    if (pair) {
/* Computing MIN */
			d__1 = Dymola_max(1.,alprqt) * dif[ks];
			dif[ks] = Dymola_min(d__1,cond);
		    }
		}
	    }
	    if (pair) {
		dif[ks + 1] = dif[ks];
	    }
	}
	if (pair) {
	    ++ks;
	}

L20:
	;
    }
    work[1] = (doublereal) lwmin;
    return 0;

/*     End of DTGSNA */

} /* dtgsna_ */

/* Subroutine */ static int dtgexc_(logical *wantq, logical *wantz, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *q, integer *ldq, doublereal *z__, integer *ldz, integer *ifst, integer *ilst, doublereal *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, q_dim1, q_offset, z_dim1, 
	    z_offset, i__1;

    /* Local variables */
    integer nbf, nbl, here, lwmin;
    integer nbnext;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode and test input arguments. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --work;

    /* Function Body */
    *info = 0;
    lquery = *lwork == -1;
    if (*n < 0) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -5;
    } else if (*ldb < Dymola_max(1,*n)) {
	*info = -7;
    } else if (*ldq < 1 || *wantq && *ldq < Dymola_max(1,*n)) {
	*info = -9;
    } else if (*ldz < 1 || *wantz && *ldz < Dymola_max(1,*n)) {
	*info = -11;
    } else if (*ifst < 1 || *ifst > *n) {
	*info = -12;
    } else if (*ilst < 1 || *ilst > *n) {
	*info = -13;
    }

    if (*info == 0) {
	if (*n <= 1) {
	    lwmin = 1;
	} else {
	    lwmin = (*n << 2) + 16;
	}
	work[1] = (doublereal) lwmin;

	if (*lwork < lwmin && ! lquery) {
	    *info = -15;
	}
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTGEXC", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*n <= 1) {
	return 0;
    }

/*     Determine the first row of the specified block and find out */
/*     if it is 1-by-1 or 2-by-2. */

    if (*ifst > 1) {
	if (a[*ifst + (*ifst - 1) * a_dim1] != 0.) {
	    --(*ifst);
	}
    }
    nbf = 1;
    if (*ifst < *n) {
	if (a[*ifst + 1 + *ifst * a_dim1] != 0.) {
	    nbf = 2;
	}
    }

/*     Determine the first row of the final block */
/*     and find out if it is 1-by-1 or 2-by-2. */

    if (*ilst > 1) {
	if (a[*ilst + (*ilst - 1) * a_dim1] != 0.) {
	    --(*ilst);
	}
    }
    nbl = 1;
    if (*ilst < *n) {
	if (a[*ilst + 1 + *ilst * a_dim1] != 0.) {
	    nbl = 2;
	}
    }
    if (*ifst == *ilst) {
	return 0;
    }

    if (*ifst < *ilst) {

/*        Update ILST. */

	if (nbf == 2 && nbl == 1) {
	    --(*ilst);
	}
	if (nbf == 1 && nbl == 2) {
	    ++(*ilst);
	}

	here = *ifst;

L10:

/*        Swap with next one below. */

	if (nbf == 1 || nbf == 2) {

/*           Current block either 1-by-1 or 2-by-2. */

	    nbnext = 1;
	    if (here + nbf + 1 <= *n) {
		if (a[here + nbf + 1 + (here + nbf) * a_dim1] != 0.) {
		    nbnext = 2;
		}
	    }
	    dtgex2_(wantq, wantz, n, &a[a_offset], lda, &b[b_offset], ldb, &q[
		    q_offset], ldq, &z__[z_offset], ldz, &here, &nbf, &nbnext,
		     &work[1], lwork, info);
	    if (*info != 0) {
		*ilst = here;
		return 0;
	    }
	    here += nbnext;

/*           Test if 2-by-2 block breaks into two 1-by-1 blocks. */

	    if (nbf == 2) {
		if (a[here + 1 + here * a_dim1] == 0.) {
		    nbf = 3;
		}
	    }

	} else {

/*           Current block consists of two 1-by-1 blocks, each of which */
/*           must be swapped individually. */

	    nbnext = 1;
	    if (here + 3 <= *n) {
		if (a[here + 3 + (here + 2) * a_dim1] != 0.) {
		    nbnext = 2;
		}
	    }
	    i__1 = here + 1;
	    dtgex2_(wantq, wantz, n, &a[a_offset], lda, &b[b_offset], ldb, &q[
		    q_offset], ldq, &z__[z_offset], ldz, &i__1, &c__1, &
		    nbnext, &work[1], lwork, info);
	    if (*info != 0) {
		*ilst = here;
		return 0;
	    }
	    if (nbnext == 1) {

/*              Swap two 1-by-1 blocks. */

		dtgex2_(wantq, wantz, n, &a[a_offset], lda, &b[b_offset], ldb,
			 &q[q_offset], ldq, &z__[z_offset], ldz, &here, &c__1,
			 &c__1, &work[1], lwork, info);
		if (*info != 0) {
		    *ilst = here;
		    return 0;
		}
		++here;

	    } else {

/*              Recompute NBNEXT in case of 2-by-2 split. */

		if (a[here + 2 + (here + 1) * a_dim1] == 0.) {
		    nbnext = 1;
		}
		if (nbnext == 2) {

/*                 2-by-2 block did not split. */

		    dtgex2_(wantq, wantz, n, &a[a_offset], lda, &b[b_offset], 
			    ldb, &q[q_offset], ldq, &z__[z_offset], ldz, &
			    here, &c__1, &nbnext, &work[1], lwork, info);
		    if (*info != 0) {
			*ilst = here;
			return 0;
		    }
		    here += 2;
		} else {

/*                 2-by-2 block did split. */

		    dtgex2_(wantq, wantz, n, &a[a_offset], lda, &b[b_offset], 
			    ldb, &q[q_offset], ldq, &z__[z_offset], ldz, &
			    here, &c__1, &c__1, &work[1], lwork, info);
		    if (*info != 0) {
			*ilst = here;
			return 0;
		    }
		    ++here;
		    dtgex2_(wantq, wantz, n, &a[a_offset], lda, &b[b_offset], 
			    ldb, &q[q_offset], ldq, &z__[z_offset], ldz, &
			    here, &c__1, &c__1, &work[1], lwork, info);
		    if (*info != 0) {
			*ilst = here;
			return 0;
		    }
		    ++here;
		}

	    }
	}
	if (here < *ilst) {
	    goto L10;
	}
    } else {
	here = *ifst;

L20:

/*        Swap with next one below. */

	if (nbf == 1 || nbf == 2) {

/*           Current block either 1-by-1 or 2-by-2. */

	    nbnext = 1;
	    if (here >= 3) {
		if (a[here - 1 + (here - 2) * a_dim1] != 0.) {
		    nbnext = 2;
		}
	    }
	    i__1 = here - nbnext;
	    dtgex2_(wantq, wantz, n, &a[a_offset], lda, &b[b_offset], ldb, &q[
		    q_offset], ldq, &z__[z_offset], ldz, &i__1, &nbnext, &nbf,
		     &work[1], lwork, info);
	    if (*info != 0) {
		*ilst = here;
		return 0;
	    }
	    here -= nbnext;

/*           Test if 2-by-2 block breaks into two 1-by-1 blocks. */

	    if (nbf == 2) {
		if (a[here + 1 + here * a_dim1] == 0.) {
		    nbf = 3;
		}
	    }

	} else {

/*           Current block consists of two 1-by-1 blocks, each of which */
/*           must be swapped individually. */

	    nbnext = 1;
	    if (here >= 3) {
		if (a[here - 1 + (here - 2) * a_dim1] != 0.) {
		    nbnext = 2;
		}
	    }
	    i__1 = here - nbnext;
	    dtgex2_(wantq, wantz, n, &a[a_offset], lda, &b[b_offset], ldb, &q[
		    q_offset], ldq, &z__[z_offset], ldz, &i__1, &nbnext, &
		    c__1, &work[1], lwork, info);
	    if (*info != 0) {
		*ilst = here;
		return 0;
	    }
	    if (nbnext == 1) {

/*              Swap two 1-by-1 blocks. */

		dtgex2_(wantq, wantz, n, &a[a_offset], lda, &b[b_offset], ldb,
			 &q[q_offset], ldq, &z__[z_offset], ldz, &here, &
			nbnext, &c__1, &work[1], lwork, info);
		if (*info != 0) {
		    *ilst = here;
		    return 0;
		}
		--here;
	    } else {

/*             Recompute NBNEXT in case of 2-by-2 split. */

		if (a[here + (here - 1) * a_dim1] == 0.) {
		    nbnext = 1;
		}
		if (nbnext == 2) {

/*                 2-by-2 block did not split. */

		    i__1 = here - 1;
		    dtgex2_(wantq, wantz, n, &a[a_offset], lda, &b[b_offset], 
			    ldb, &q[q_offset], ldq, &z__[z_offset], ldz, &
			    i__1, &c__2, &c__1, &work[1], lwork, info);
		    if (*info != 0) {
			*ilst = here;
			return 0;
		    }
		    here += -2;
		} else {

/*                 2-by-2 block did split. */

		    dtgex2_(wantq, wantz, n, &a[a_offset], lda, &b[b_offset], 
			    ldb, &q[q_offset], ldq, &z__[z_offset], ldz, &
			    here, &c__1, &c__1, &work[1], lwork, info);
		    if (*info != 0) {
			*ilst = here;
			return 0;
		    }
		    --here;
		    dtgex2_(wantq, wantz, n, &a[a_offset], lda, &b[b_offset], 
			    ldb, &q[q_offset], ldq, &z__[z_offset], ldz, &
			    here, &c__1, &c__1, &work[1], lwork, info);
		    if (*info != 0) {
			*ilst = here;
			return 0;
		    }
		    --here;
		}
	    }
	}
	if (here > *ilst) {
	    goto L20;
	}
    }
    *ilst = here;
    work[1] = (doublereal) lwmin;
    return 0;

/*     End of DTGEXC */

} /* dtgexc_ */

/* Subroutine */ static int dtgsyl_(char *trans, integer *ijob, integer *m, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *c__, integer *ldc, doublereal *d__, integer *ldd, doublereal *e, integer *lde, doublereal *f, integer *ldf, doublereal *scale, doublereal *dif, doublereal *work, integer *lwork, integer *iwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, d_dim1, 
	    d_offset, e_dim1, e_offset, f_dim1, f_offset, i__1, i__2, i__3, 
	    i__4;

    /* Local variables */
    integer i__, j, k, p, q, ie, je, mb, nb, is, js, pq;
    doublereal dsum;
    integer ppqq;
    integer ifunc, linfo, lwmin;
    doublereal scale2;
    doublereal dscale, scaloc;
    integer iround;
    logical notran;
    integer isolve;
    logical lquery;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */
/*  Replaced various illegal calls to DCOPY by calls to DLASET. */
/*  Sven Hammarling, 1/5/02. */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode and test input parameters */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    e_dim1 = *lde;
    e_offset = 1 + e_dim1;
    e -= e_offset;
    f_dim1 = *ldf;
    f_offset = 1 + f_dim1;
    f -= f_offset;
    --work;
    --iwork;

    /* Function Body */
    *info = 0;
    notran = lsame_(trans, "N", (ftnlen)1, (ftnlen)1);
    lquery = *lwork == -1;

    if (! notran && ! lsame_(trans, "T", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (notran) {
	if (*ijob < 0 || *ijob > 4) {
	    *info = -2;
	}
    }
    if (*info == 0) {
	if (*m <= 0) {
	    *info = -3;
	} else if (*n <= 0) {
	    *info = -4;
	} else if (*lda < Dymola_max(1,*m)) {
	    *info = -6;
	} else if (*ldb < Dymola_max(1,*n)) {
	    *info = -8;
	} else if (*ldc < Dymola_max(1,*m)) {
	    *info = -10;
	} else if (*ldd < Dymola_max(1,*m)) {
	    *info = -12;
	} else if (*lde < Dymola_max(1,*n)) {
	    *info = -14;
	} else if (*ldf < Dymola_max(1,*m)) {
	    *info = -16;
	}
    }

    if (*info == 0) {
	if (notran) {
	    if (*ijob == 1 || *ijob == 2) {
/* Computing MAX */
		i__1 = 1, i__2 = (*m << 1) * *n;
		lwmin = Dymola_max(i__1,i__2);
	    } else {
		lwmin = 1;
	    }
	} else {
	    lwmin = 1;
	}
	work[1] = (doublereal) lwmin;

	if (*lwork < lwmin && ! lquery) {
	    *info = -20;
	}
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTGSYL", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {
	*scale = 1.;
	if (notran) {
	    if (*ijob != 0) {
		*dif = 0.;
	    }
	}
	return 0;
    }

/*     Determine optimal block sizes MB and NB */

    mb = ilaenv_(&c__2, "DTGSYL", trans, m, n, &c_n1, &c_n1);
    nb = ilaenv_(&c__5, "DTGSYL", trans, m, n, &c_n1, &c_n1);

    isolve = 1;
    ifunc = 0;
    if (notran) {
	if (*ijob >= 3) {
	    ifunc = *ijob - 2;
	    dlaset_("F", m, n, &c_b14_dtgsyl, &c_b14_dtgsyl, &c__[c_offset], ldc)
		    ;
	    dlaset_("F", m, n, &c_b14_dtgsyl, &c_b14_dtgsyl, &f[f_offset], ldf);
	} else if (*ijob >= 1) {
	    isolve = 2;
	}
    }

    if (mb <= 1 && nb <= 1 || mb >= *m && nb >= *n) {

	i__1 = isolve;
	for (iround = 1; iround <= i__1; ++iround) {

/*           Use unblocked Level 2 solver */

	    dscale = 0.;
	    dsum = 1.;
	    pq = 0;
	    dtgsy2_(trans, &ifunc, m, n, &a[a_offset], lda, &b[b_offset], ldb,
		     &c__[c_offset], ldc, &d__[d_offset], ldd, &e[e_offset], 
		    lde, &f[f_offset], ldf, scale, &dsum, &dscale, &iwork[1], 
		    &pq, info);
	    if (dscale != 0.) {
		if (*ijob == 1 || *ijob == 3) {
		    *dif = sqrt((doublereal) ((*m << 1) * *n)) / (dscale * 
			    sqrt(dsum));
		} else {
		    *dif = sqrt((doublereal) pq) / (dscale * sqrt(dsum));
		}
	    }

	    if (isolve == 2 && iround == 1) {
		if (notran) {
		    ifunc = *ijob;
		}
		scale2 = *scale;
		dlacpy_("F", m, n, &c__[c_offset], ldc, &work[1], m);
		dlacpy_("F", m, n, &f[f_offset], ldf, &work[*m * *n + 1], m);
		dlaset_("F", m, n, &c_b14_dtgsyl, &c_b14_dtgsyl, &c__[c_offset], ldc);
		dlaset_("F", m, n, &c_b14_dtgsyl, &c_b14_dtgsyl, &f[f_offset], ldf);
	    } else if (isolve == 2 && iround == 2) {
		dlacpy_("F", m, n, &work[1], m, &c__[c_offset], ldc);
		dlacpy_("F", m, n, &work[*m * *n + 1], m, &f[f_offset], ldf);
		*scale = scale2;
	    }
/* L30: */
	}

	return 0;
    }

/*     Determine block structure of A */

    p = 0;
    i__ = 1;
L40:
    if (i__ > *m) {
	goto L50;
    }
    ++p;
    iwork[p] = i__;
    i__ += mb;
    if (i__ >= *m) {
	goto L50;
    }
    if (a[i__ + (i__ - 1) * a_dim1] != 0.) {
	++i__;
    }
    goto L40;
L50:

    iwork[p + 1] = *m + 1;
    if (iwork[p] == iwork[p + 1]) {
	--p;
    }

/*     Determine block structure of B */

    q = p + 1;
    j = 1;
L60:
    if (j > *n) {
	goto L70;
    }
    ++q;
    iwork[q] = j;
    j += nb;
    if (j >= *n) {
	goto L70;
    }
    if (b[j + (j - 1) * b_dim1] != 0.) {
	++j;
    }
    goto L60;
L70:

    iwork[q + 1] = *n + 1;
    if (iwork[q] == iwork[q + 1]) {
	--q;
    }

    if (notran) {

	i__1 = isolve;
	for (iround = 1; iround <= i__1; ++iround) {

/*           Solve (I, J)-subsystem */
/*               A(I, I) * R(I, J) - L(I, J) * B(J, J) = C(I, J) */
/*               D(I, I) * R(I, J) - L(I, J) * E(J, J) = F(I, J) */
/*           for I = P, P - 1,..., 1; J = 1, 2,..., Q */

	    dscale = 0.;
	    dsum = 1.;
	    pq = 0;
	    *scale = 1.;
	    i__2 = q;
	    for (j = p + 2; j <= i__2; ++j) {
		js = iwork[j];
		je = iwork[j + 1] - 1;
		nb = je - js + 1;
		for (i__ = p; i__ >= 1; --i__) {
		    is = iwork[i__];
		    ie = iwork[i__ + 1] - 1;
		    mb = ie - is + 1;
		    ppqq = 0;
		    dtgsy2_(trans, &ifunc, &mb, &nb, &a[is + is * a_dim1], 
			    lda, &b[js + js * b_dim1], ldb, &c__[is + js * 
			    c_dim1], ldc, &d__[is + is * d_dim1], ldd, &e[js 
			    + js * e_dim1], lde, &f[is + js * f_dim1], ldf, &
			    scaloc, &dsum, &dscale, &iwork[q + 2], &ppqq, &
			    linfo);
		    if (linfo > 0) {
			*info = linfo;
		    }

		    pq += ppqq;
		    if (scaloc != 1.) {
			i__3 = js - 1;
			for (k = 1; k <= i__3; ++k) {
			    dscal_(m, &scaloc, &c__[k * c_dim1 + 1], &c__1);
			    dscal_(m, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L80: */
			}
			i__3 = je;
			for (k = js; k <= i__3; ++k) {
			    i__4 = is - 1;
			    dscal_(&i__4, &scaloc, &c__[k * c_dim1 + 1], &
				    c__1);
			    i__4 = is - 1;
			    dscal_(&i__4, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L90: */
			}
			i__3 = je;
			for (k = js; k <= i__3; ++k) {
			    i__4 = *m - ie;
			    dscal_(&i__4, &scaloc, &c__[ie + 1 + k * c_dim1], 
				    &c__1);
			    i__4 = *m - ie;
			    dscal_(&i__4, &scaloc, &f[ie + 1 + k * f_dim1], &
				    c__1);
/* L100: */
			}
			i__3 = *n;
			for (k = je + 1; k <= i__3; ++k) {
			    dscal_(m, &scaloc, &c__[k * c_dim1 + 1], &c__1);
			    dscal_(m, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L110: */
			}
			*scale *= scaloc;
		    }

/*                 Substitute R(I, J) and L(I, J) into remaining */
/*                 equation. */

		    if (i__ > 1) {
			i__3 = is - 1;
			dgemm_("N", "N", &i__3, &nb, &mb, &c_b51, &a[is * 
				a_dim1 + 1], lda, &c__[is + js * c_dim1], ldc,
				 &c_b52, &c__[js * c_dim1 + 1], ldc);
			i__3 = is - 1;
			dgemm_("N", "N", &i__3, &nb, &mb, &c_b51, &d__[is * 
				d_dim1 + 1], ldd, &c__[is + js * c_dim1], ldc,
				 &c_b52, &f[js * f_dim1 + 1], ldf);
		    }
		    if (j < q) {
			i__3 = *n - je;
			dgemm_("N", "N", &mb, &i__3, &nb, &c_b52, &f[is + js *
				 f_dim1], ldf, &b[js + (je + 1) * b_dim1], 
				ldb, &c_b52, &c__[is + (je + 1) * c_dim1], 
				ldc);
			i__3 = *n - je;
			dgemm_("N", "N", &mb, &i__3, &nb, &c_b52, &f[is + js *
				 f_dim1], ldf, &e[js + (je + 1) * e_dim1], 
				lde, &c_b52, &f[is + (je + 1) * f_dim1], ldf);
		    }
/* L120: */
		}
/* L130: */
	    }
	    if (dscale != 0.) {
		if (*ijob == 1 || *ijob == 3) {
		    *dif = sqrt((doublereal) ((*m << 1) * *n)) / (dscale * 
			    sqrt(dsum));
		} else {
		    *dif = sqrt((doublereal) pq) / (dscale * sqrt(dsum));
		}
	    }
	    if (isolve == 2 && iround == 1) {
		if (notran) {
		    ifunc = *ijob;
		}
		scale2 = *scale;
		dlacpy_("F", m, n, &c__[c_offset], ldc, &work[1], m);
		dlacpy_("F", m, n, &f[f_offset], ldf, &work[*m * *n + 1], m);
		dlaset_("F", m, n, &c_b14_dtgsyl, &c_b14_dtgsyl, &c__[c_offset], ldc);
		dlaset_("F", m, n, &c_b14_dtgsyl, &c_b14_dtgsyl, &f[f_offset], ldf);
	    } else if (isolve == 2 && iround == 2) {
		dlacpy_("F", m, n, &work[1], m, &c__[c_offset], ldc);
		dlacpy_("F", m, n, &work[*m * *n + 1], m, &f[f_offset], ldf);
		*scale = scale2;
	    }
/* L150: */
	}

    } else {

/*        Solve transposed (I, J)-subsystem */
/*             A(I, I)**T * R(I, J)  + D(I, I)**T * L(I, J)  =  C(I, J) */
/*             R(I, J)  * B(J, J)**T + L(I, J)  * E(J, J)**T = -F(I, J) */
/*        for I = 1,2,..., P; J = Q, Q-1,..., 1 */

	*scale = 1.;
	i__1 = p;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    is = iwork[i__];
	    ie = iwork[i__ + 1] - 1;
	    mb = ie - is + 1;
	    i__2 = p + 2;
	    for (j = q; j >= i__2; --j) {
		js = iwork[j];
		je = iwork[j + 1] - 1;
		nb = je - js + 1;
		dtgsy2_(trans, &ifunc, &mb, &nb, &a[is + is * a_dim1], lda, &
			b[js + js * b_dim1], ldb, &c__[is + js * c_dim1], ldc,
			 &d__[is + is * d_dim1], ldd, &e[js + js * e_dim1], 
			lde, &f[is + js * f_dim1], ldf, &scaloc, &dsum, &
			dscale, &iwork[q + 2], &ppqq, &linfo);
		if (linfo > 0) {
		    *info = linfo;
		}
		if (scaloc != 1.) {
		    i__3 = js - 1;
		    for (k = 1; k <= i__3; ++k) {
			dscal_(m, &scaloc, &c__[k * c_dim1 + 1], &c__1);
			dscal_(m, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L160: */
		    }
		    i__3 = je;
		    for (k = js; k <= i__3; ++k) {
			i__4 = is - 1;
			dscal_(&i__4, &scaloc, &c__[k * c_dim1 + 1], &c__1);
			i__4 = is - 1;
			dscal_(&i__4, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L170: */
		    }
		    i__3 = je;
		    for (k = js; k <= i__3; ++k) {
			i__4 = *m - ie;
			dscal_(&i__4, &scaloc, &c__[ie + 1 + k * c_dim1], &
				c__1);
			i__4 = *m - ie;
			dscal_(&i__4, &scaloc, &f[ie + 1 + k * f_dim1], &c__1)
				;
/* L180: */
		    }
		    i__3 = *n;
		    for (k = je + 1; k <= i__3; ++k) {
			dscal_(m, &scaloc, &c__[k * c_dim1 + 1], &c__1);
			dscal_(m, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L190: */
		    }
		    *scale *= scaloc;
		}

/*              Substitute R(I, J) and L(I, J) into remaining equation. */

		if (j > p + 2) {
		    i__3 = js - 1;
		    dgemm_("N", "T", &mb, &i__3, &nb, &c_b52, &c__[is + js * 
			    c_dim1], ldc, &b[js * b_dim1 + 1], ldb, &c_b52, &
			    f[is + f_dim1], ldf);
		    i__3 = js - 1;
		    dgemm_("N", "T", &mb, &i__3, &nb, &c_b52, &f[is + js * 
			    f_dim1], ldf, &e[js * e_dim1 + 1], lde, &c_b52, &
			    f[is + f_dim1], ldf);
		}
		if (i__ < p) {
		    i__3 = *m - ie;
		    dgemm_("T", "N", &i__3, &nb, &mb, &c_b51, &a[is + (ie + 1)
			     * a_dim1], lda, &c__[is + js * c_dim1], ldc, &
			    c_b52, &c__[ie + 1 + js * c_dim1], ldc);
		    i__3 = *m - ie;
		    dgemm_("T", "N", &i__3, &nb, &mb, &c_b51, &d__[is + (ie + 
			    1) * d_dim1], ldd, &f[is + js * f_dim1], ldf, &
			    c_b52, &c__[ie + 1 + js * c_dim1], ldc);
		}
/* L200: */
	    }
/* L210: */
	}

    }

    work[1] = (doublereal) lwmin;

    return 0;

/*     End of DTGSYL */

} /* dtgsyl_ */

/* Subroutine */ static int dtgex2_(logical *wantq, logical *wantz, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *q, integer *ldq, doublereal *z__, integer *ldz, integer *j1, integer *n1, integer *n2, doublereal *work, integer *lwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, q_dim1, q_offset, z_dim1, 
	    z_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    doublereal f, g;
    integer i__, m;
    doublereal s[16]	/* was [4][4] */, t[16]	/* was [4][4] */, be[2], ai[2]
	    , ar[2], sa, sb, li[16]	/* was [4][4] */, ir[16]	/* 
	    was [4][4] */, ss, ws, eps;
    logical weak;
    doublereal ddum;
    integer idum;
    doublereal taul[4], dsum;
    doublereal taur[4], scpy[16]	/* was [4][4] */, tcpy[16]	/* 
	    was [4][4] */;
    doublereal scale, bqra21, brqa21;
    doublereal licop[16]	/* was [4][4] */;
    integer linfo;
    doublereal ircop[16]	/* was [4][4] */, dnorm;
    integer iwork[4];
    doublereal dscale;
    logical dtrong;
    doublereal thresh, smlnum;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */
/*  Replaced various illegal calls to DCOPY by calls to DLASET, or by DO */
/*  loops. Sven Hammarling, 1/5/02. */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --work;

    /* Function Body */
    *info = 0;

/*     Quick return if possible */

    if (*n <= 1 || *n1 <= 0 || *n2 <= 0) {
	return 0;
    }
    if (*n1 > *n || *j1 + *n1 > *n) {
	return 0;
    }
    m = *n1 + *n2;
/* Computing MAX */
    i__1 = 1, i__2 = *n * m, i__1 = Dymola_max(i__1,i__2), i__2 = m * m << 1;
    if (*lwork < Dymola_max(i__1,i__2)) {
	*info = -16;
/* Computing MAX */
	i__1 = 1, i__2 = *n * m, i__1 = Dymola_max(i__1,i__2), i__2 = m * m << 1;
	work[1] = (doublereal) Dymola_max(i__1,i__2);
	return 0;
    }

    weak = FALSE_;
    dtrong = FALSE_;

/*     Make a local copy of selected block */

    dlaset_("Full", &c__4, &c__4, &c_b5_dtgex2, &c_b5_dtgex2, li, &c__4);
    dlaset_("Full", &c__4, &c__4, &c_b5_dtgex2, &c_b5_dtgex2, ir, &c__4);
    dlacpy_("Full", &m, &m, &a[*j1 + *j1 * a_dim1], lda, s, &c__4);
    dlacpy_("Full", &m, &m, &b[*j1 + *j1 * b_dim1], ldb, t, &c__4);

/*     Compute threshold for testing acceptance of swapping. */

    eps = dlamch_("P");
    smlnum = dlamch_("S") / eps;
    dscale = 0.;
    dsum = 1.;
    dlacpy_("Full", &m, &m, s, &c__4, &work[1], &m);
    i__1 = m * m;
    dlassq_(&i__1, &work[1], &c__1, &dscale, &dsum);
    dlacpy_("Full", &m, &m, t, &c__4, &work[1], &m);
    i__1 = m * m;
    dlassq_(&i__1, &work[1], &c__1, &dscale, &dsum);
    dnorm = dscale * sqrt(dsum);

/*     THRES has been changed from */
/*        THRESH = MAX( TEN*EPS*SA, SMLNUM ) */
/*     to */
/*        THRESH = MAX( TWENTY*EPS*SA, SMLNUM ) */
/*     on 04/01/10. */
/*     "Bug" reported by Ondra Kamenik, confirmed by Julie Langou, fixed by */
/*     Jim Demmel and Guillaume Revy. See forum post 1783. */

/* Computing MAX */
    d__1 = eps * 20. * dnorm;
    thresh = Dymola_max(d__1,smlnum);

    if (m == 2) {

/*        CASE 1: Swap 1-by-1 and 1-by-1 blocks. */

/*        Compute orthogonal QL and RQ that swap 1-by-1 and 1-by-1 blocks */
/*        using Givens rotations and perform the swap tentatively. */

	f = s[5] * t[0] - t[5] * s[0];
	g = s[5] * t[4] - t[5] * s[4];
	sb = Dymola_abs(t[5]);
	sa = Dymola_abs(s[5]);
	dlartg_(&f, &g, &ir[4], ir, &ddum);
	ir[1] = -ir[4];
	ir[5] = ir[0];
	drot_(&c__2, s, &c__1, &s[4], &c__1, ir, &ir[1]);
	drot_(&c__2, t, &c__1, &t[4], &c__1, ir, &ir[1]);
	if (sa >= sb) {
	    dlartg_(s, &s[1], li, &li[1], &ddum);
	} else {
	    dlartg_(t, &t[1], li, &li[1], &ddum);
	}
	drot_(&c__2, s, &c__4, &s[1], &c__4, li, &li[1]);
	drot_(&c__2, t, &c__4, &t[1], &c__4, li, &li[1]);
	li[5] = li[0];
	li[4] = -li[1];

/*        Weak stability test: */
/*           |S21| + |T21| <= O(EPS * F-norm((S, T))) */

	ws = Dymola_abs(s[1]) + Dymola_abs(t[1]);
	weak = ws <= thresh;
	if (! weak) {
	    goto L70;
	}

	if (TRUE_) {

/*           Strong stability test: */
/*             F-norm((A-QL**T*S*QR, B-QL**T*T*QR)) <= O(EPS*F-norm((A,B))) */

	    dlacpy_("Full", &m, &m, &a[*j1 + *j1 * a_dim1], lda, &work[m * m 
		    + 1], &m);
	    dgemm_("N", "N", &m, &m, &m, &c_b42, li, &c__4, s, &c__4, &c_b5_dtgex2, &
		    work[1], &m);
	    dgemm_("N", "T", &m, &m, &m, &c_b48, &work[1], &m, ir, &c__4, &
		    c_b42, &work[m * m + 1], &m);
	    dscale = 0.;
	    dsum = 1.;
	    i__1 = m * m;
	    dlassq_(&i__1, &work[m * m + 1], &c__1, &dscale, &dsum);

	    dlacpy_("Full", &m, &m, &b[*j1 + *j1 * b_dim1], ldb, &work[m * m 
		    + 1], &m);
	    dgemm_("N", "N", &m, &m, &m, &c_b42, li, &c__4, t, &c__4, &c_b5_dtgex2, &
		    work[1], &m);
	    dgemm_("N", "T", &m, &m, &m, &c_b48, &work[1], &m, ir, &c__4, &
		    c_b42, &work[m * m + 1], &m);
	    i__1 = m * m;
	    dlassq_(&i__1, &work[m * m + 1], &c__1, &dscale, &dsum);
	    ss = dscale * sqrt(dsum);
	    dtrong = ss <= thresh;
	    if (! dtrong) {
		goto L70;
	    }
	}

/*        Update (A(J1:J1+M-1, M+J1:N), B(J1:J1+M-1, M+J1:N)) and */
/*               (A(1:J1-1, J1:J1+M), B(1:J1-1, J1:J1+M)). */

	i__1 = *j1 + 1;
	drot_(&i__1, &a[*j1 * a_dim1 + 1], &c__1, &a[(*j1 + 1) * a_dim1 + 1], 
		&c__1, ir, &ir[1]);
	i__1 = *j1 + 1;
	drot_(&i__1, &b[*j1 * b_dim1 + 1], &c__1, &b[(*j1 + 1) * b_dim1 + 1], 
		&c__1, ir, &ir[1]);
	i__1 = *n - *j1 + 1;
	drot_(&i__1, &a[*j1 + *j1 * a_dim1], lda, &a[*j1 + 1 + *j1 * a_dim1], 
		lda, li, &li[1]);
	i__1 = *n - *j1 + 1;
	drot_(&i__1, &b[*j1 + *j1 * b_dim1], ldb, &b[*j1 + 1 + *j1 * b_dim1], 
		ldb, li, &li[1]);

/*        Set  N1-by-N2 (2,1) - blocks to ZERO. */

	a[*j1 + 1 + *j1 * a_dim1] = 0.;
	b[*j1 + 1 + *j1 * b_dim1] = 0.;

/*        Accumulate transformations into Q and Z if requested. */

	if (*wantz) {
	    drot_(n, &z__[*j1 * z_dim1 + 1], &c__1, &z__[(*j1 + 1) * z_dim1 + 
		    1], &c__1, ir, &ir[1]);
	}
	if (*wantq) {
	    drot_(n, &q[*j1 * q_dim1 + 1], &c__1, &q[(*j1 + 1) * q_dim1 + 1], 
		    &c__1, li, &li[1]);
	}

/*        Exit with INFO = 0 if swap was successfully performed. */

	return 0;

    } else {

/*        CASE 2: Swap 1-by-1 and 2-by-2 blocks, or 2-by-2 */
/*                and 2-by-2 blocks. */

/*        Solve the generalized Sylvester equation */
/*                 S11 * R - L * S22 = SCALE * S12 */
/*                 T11 * R - L * T22 = SCALE * T12 */
/*        for R and L. Solutions in LI and IR. */

	dlacpy_("Full", n1, n2, &t[(*n1 + 1 << 2) - 4], &c__4, li, &c__4);
	dlacpy_("Full", n1, n2, &s[(*n1 + 1 << 2) - 4], &c__4, &ir[*n2 + 1 + (
		*n1 + 1 << 2) - 5], &c__4);
	dtgsy2_("N", &c__0, n1, n2, s, &c__4, &s[*n1 + 1 + (*n1 + 1 << 2) - 5]
		, &c__4, &ir[*n2 + 1 + (*n1 + 1 << 2) - 5], &c__4, t, &c__4, &
		t[*n1 + 1 + (*n1 + 1 << 2) - 5], &c__4, li, &c__4, &scale, &
		dsum, &dscale, iwork, &idum, &linfo);

/*        Compute orthogonal matrix QL: */

/*                    QL**T * LI = [ TL ] */
/*                                 [ 0  ] */
/*        where */
/*                    LI =  [      -L              ] */
/*                          [ SCALE * identity(N2) ] */

	i__1 = *n2;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    dscal_(n1, &c_b48, &li[(i__ << 2) - 4], &c__1);
	    li[*n1 + i__ + (i__ << 2) - 5] = scale;
/* L10: */
	}
	dgeqr2_(&m, n2, li, &c__4, taul, &work[1], &linfo);
	if (linfo != 0) {
	    goto L70;
	}
	dorg2r_(&m, &m, n2, li, &c__4, taul, &work[1], &linfo);
	if (linfo != 0) {
	    goto L70;
	}

/*        Compute orthogonal matrix RQ: */

/*                    IR * RQ**T =   [ 0  TR], */

/*         where IR = [ SCALE * identity(N1), R ] */

	i__1 = *n1;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    ir[*n2 + i__ + (i__ << 2) - 5] = scale;
/* L20: */
	}
	dgerq2_(n1, &m, &ir[*n2], &c__4, taur, &work[1], &linfo);
	if (linfo != 0) {
	    goto L70;
	}
	dorgr2_(&m, &m, n1, ir, &c__4, taur, &work[1], &linfo);
	if (linfo != 0) {
	    goto L70;
	}

/*        Perform the swapping tentatively: */

	dgemm_("T", "N", &m, &m, &m, &c_b42, li, &c__4, s, &c__4, &c_b5_dtgex2, &
		work[1], &m);
	dgemm_("N", "T", &m, &m, &m, &c_b42, &work[1], &m, ir, &c__4, &c_b5_dtgex2, 
		s, &c__4);
	dgemm_("T", "N", &m, &m, &m, &c_b42, li, &c__4, t, &c__4, &c_b5_dtgex2, &
		work[1], &m);
	dgemm_("N", "T", &m, &m, &m, &c_b42, &work[1], &m, ir, &c__4, &c_b5_dtgex2, 
		t, &c__4);
	dlacpy_("F", &m, &m, s, &c__4, scpy, &c__4);
	dlacpy_("F", &m, &m, t, &c__4, tcpy, &c__4);
	dlacpy_("F", &m, &m, ir, &c__4, ircop, &c__4);
	dlacpy_("F", &m, &m, li, &c__4, licop, &c__4);

/*        Triangularize the B-part by an RQ factorization. */
/*        Apply transformation (from left) to A-part, giving S. */

	dgerq2_(&m, &m, t, &c__4, taur, &work[1], &linfo);
	if (linfo != 0) {
	    goto L70;
	}
	dormr2_("R", "T", &m, &m, &m, t, &c__4, taur, s, &c__4, &work[1], &
		linfo);
	if (linfo != 0) {
	    goto L70;
	}
	dormr2_("L", "N", &m, &m, &m, t, &c__4, taur, ir, &c__4, &work[1], &
		linfo);
	if (linfo != 0) {
	    goto L70;
	}

/*        Compute F-norm(S21) in BRQA21. (T21 is 0.) */

	dscale = 0.;
	dsum = 1.;
	i__1 = *n2;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    dlassq_(n1, &s[*n2 + 1 + (i__ << 2) - 5], &c__1, &dscale, &dsum);
/* L30: */
	}
	brqa21 = dscale * sqrt(dsum);

/*        Triangularize the B-part by a QR factorization. */
/*        Apply transformation (from right) to A-part, giving S. */

	dgeqr2_(&m, &m, tcpy, &c__4, taul, &work[1], &linfo);
	if (linfo != 0) {
	    goto L70;
	}
	dorm2r_("L", "T", &m, &m, &m, tcpy, &c__4, taul, scpy, &c__4, &work[1]
		, info);
	dorm2r_("R", "N", &m, &m, &m, tcpy, &c__4, taul, licop, &c__4, &work[
		1], info);
	if (linfo != 0) {
	    goto L70;
	}

/*        Compute F-norm(S21) in BQRA21. (T21 is 0.) */

	dscale = 0.;
	dsum = 1.;
	i__1 = *n2;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    dlassq_(n1, &scpy[*n2 + 1 + (i__ << 2) - 5], &c__1, &dscale, &
		    dsum);
/* L40: */
	}
	bqra21 = dscale * sqrt(dsum);

/*        Decide which method to use. */
/*          Weak stability test: */
/*             F-norm(S21) <= O(EPS * F-norm((S, T))) */

	if (bqra21 <= brqa21 && bqra21 <= thresh) {
	    dlacpy_("F", &m, &m, scpy, &c__4, s, &c__4);
	    dlacpy_("F", &m, &m, tcpy, &c__4, t, &c__4);
	    dlacpy_("F", &m, &m, ircop, &c__4, ir, &c__4);
	    dlacpy_("F", &m, &m, licop, &c__4, li, &c__4);
	} else if (brqa21 >= thresh) {
	    goto L70;
	}

/*        Set lower triangle of B-part to zero */

	i__1 = m - 1;
	i__2 = m - 1;
	dlaset_("Lower", &i__1, &i__2, &c_b5_dtgex2, &c_b5_dtgex2, &t[1], &c__4);

	if (TRUE_) {

/*           Strong stability test: */
/*              F-norm((A-QL*S*QR**T, B-QL*T*QR**T)) <= O(EPS*F-norm((A,B))) */

	    dlacpy_("Full", &m, &m, &a[*j1 + *j1 * a_dim1], lda, &work[m * m 
		    + 1], &m);
	    dgemm_("N", "N", &m, &m, &m, &c_b42, li, &c__4, s, &c__4, &c_b5_dtgex2, &
		    work[1], &m);
	    dgemm_("N", "N", &m, &m, &m, &c_b48, &work[1], &m, ir, &c__4, &
		    c_b42, &work[m * m + 1], &m);
	    dscale = 0.;
	    dsum = 1.;
	    i__1 = m * m;
	    dlassq_(&i__1, &work[m * m + 1], &c__1, &dscale, &dsum);

	    dlacpy_("Full", &m, &m, &b[*j1 + *j1 * b_dim1], ldb, &work[m * m 
		    + 1], &m);
	    dgemm_("N", "N", &m, &m, &m, &c_b42, li, &c__4, t, &c__4, &c_b5_dtgex2, &
		    work[1], &m);
	    dgemm_("N", "N", &m, &m, &m, &c_b48, &work[1], &m, ir, &c__4, &
		    c_b42, &work[m * m + 1], &m);
	    i__1 = m * m;
	    dlassq_(&i__1, &work[m * m + 1], &c__1, &dscale, &dsum);
	    ss = dscale * sqrt(dsum);
	    dtrong = ss <= thresh;
	    if (! dtrong) {
		goto L70;
	    }

	}

/*        If the swap is accepted ("weakly" and "strongly"), apply the */
/*        transformations and set N1-by-N2 (2,1)-block to zero. */

	dlaset_("Full", n1, n2, &c_b5_dtgex2, &c_b5_dtgex2, &s[*n2], &c__4);

/*        copy back M-by-M diagonal block starting at index J1 of (A, B) */

	dlacpy_("F", &m, &m, s, &c__4, &a[*j1 + *j1 * a_dim1], lda)
		;
	dlacpy_("F", &m, &m, t, &c__4, &b[*j1 + *j1 * b_dim1], ldb)
		;
	dlaset_("Full", &c__4, &c__4, &c_b5_dtgex2, &c_b5_dtgex2, t, &c__4);

/*        Standardize existing 2-by-2 blocks. */

	i__1 = m * m;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    work[i__] = 0.;
/* L50: */
	}
	work[1] = 1.;
	t[0] = 1.;
	idum = *lwork - m * m - 2;
	if (*n2 > 1) {
	    dlagv2_(&a[*j1 + *j1 * a_dim1], lda, &b[*j1 + *j1 * b_dim1], ldb, 
		    ar, ai, be, &work[1], &work[2], t, &t[1]);
	    work[m + 1] = -work[2];
	    work[m + 2] = work[1];
	    t[*n2 + (*n2 << 2) - 5] = t[0];
	    t[4] = -t[1];
	}
	work[m * m] = 1.;
	t[m + (m << 2) - 5] = 1.;

	if (*n1 > 1) {
	    dlagv2_(&a[*j1 + *n2 + (*j1 + *n2) * a_dim1], lda, &b[*j1 + *n2 + 
		    (*j1 + *n2) * b_dim1], ldb, taur, taul, &work[m * m + 1], 
		    &work[*n2 * m + *n2 + 1], &work[*n2 * m + *n2 + 2], &t[*
		    n2 + 1 + (*n2 + 1 << 2) - 5], &t[m + (m - 1 << 2) - 5]);
	    work[m * m] = work[*n2 * m + *n2 + 1];
	    work[m * m - 1] = -work[*n2 * m + *n2 + 2];
	    t[m + (m << 2) - 5] = t[*n2 + 1 + (*n2 + 1 << 2) - 5];
	    t[m - 1 + (m << 2) - 5] = -t[m + (m - 1 << 2) - 5];
	}
	dgemm_("T", "N", n2, n1, n2, &c_b42, &work[1], &m, &a[*j1 + (*j1 + *
		n2) * a_dim1], lda, &c_b5_dtgex2, &work[m * m + 1], n2);
	dlacpy_("Full", n2, n1, &work[m * m + 1], n2, &a[*j1 + (*j1 + *n2) * 
		a_dim1], lda);
	dgemm_("T", "N", n2, n1, n2, &c_b42, &work[1], &m, &b[*j1 + (*j1 + *
		n2) * b_dim1], ldb, &c_b5_dtgex2, &work[m * m + 1], n2);
	dlacpy_("Full", n2, n1, &work[m * m + 1], n2, &b[*j1 + (*j1 + *n2) * 
		b_dim1], ldb);
	dgemm_("N", "N", &m, &m, &m, &c_b42, li, &c__4, &work[1], &m, &c_b5_dtgex2, &
		work[m * m + 1], &m);
	dlacpy_("Full", &m, &m, &work[m * m + 1], &m, li, &c__4);
	dgemm_("N", "N", n2, n1, n1, &c_b42, &a[*j1 + (*j1 + *n2) * a_dim1], 
		lda, &t[*n2 + 1 + (*n2 + 1 << 2) - 5], &c__4, &c_b5_dtgex2, &work[1],
		 n2);
	dlacpy_("Full", n2, n1, &work[1], n2, &a[*j1 + (*j1 + *n2) * a_dim1], 
		lda);
	dgemm_("N", "N", n2, n1, n1, &c_b42, &b[*j1 + (*j1 + *n2) * b_dim1], 
		ldb, &t[*n2 + 1 + (*n2 + 1 << 2) - 5], &c__4, &c_b5_dtgex2, &work[1],
		 n2);
	dlacpy_("Full", n2, n1, &work[1], n2, &b[*j1 + (*j1 + *n2) * b_dim1], 
		ldb);
	dgemm_("T", "N", &m, &m, &m, &c_b42, ir, &c__4, t, &c__4, &c_b5_dtgex2, &
		work[1], &m);
	dlacpy_("Full", &m, &m, &work[1], &m, ir, &c__4);

/*        Accumulate transformations into Q and Z if requested. */

	if (*wantq) {
	    dgemm_("N", "N", n, &m, &m, &c_b42, &q[*j1 * q_dim1 + 1], ldq, li,
		     &c__4, &c_b5_dtgex2, &work[1], n);
	    dlacpy_("Full", n, &m, &work[1], n, &q[*j1 * q_dim1 + 1], ldq);

	}

	if (*wantz) {
	    dgemm_("N", "N", n, &m, &m, &c_b42, &z__[*j1 * z_dim1 + 1], ldz, 
		    ir, &c__4, &c_b5_dtgex2, &work[1], n);
	    dlacpy_("Full", n, &m, &work[1], n, &z__[*j1 * z_dim1 + 1], ldz);

	}

/*        Update (A(J1:J1+M-1, M+J1:N), B(J1:J1+M-1, M+J1:N)) and */
/*                (A(1:J1-1, J1:J1+M), B(1:J1-1, J1:J1+M)). */

	i__ = *j1 + m;
	if (i__ <= *n) {
	    i__1 = *n - i__ + 1;
	    dgemm_("T", "N", &m, &i__1, &m, &c_b42, li, &c__4, &a[*j1 + i__ * 
		    a_dim1], lda, &c_b5_dtgex2, &work[1], &m);
	    i__1 = *n - i__ + 1;
	    dlacpy_("Full", &m, &i__1, &work[1], &m, &a[*j1 + i__ * a_dim1], 
		    lda);
	    i__1 = *n - i__ + 1;
	    dgemm_("T", "N", &m, &i__1, &m, &c_b42, li, &c__4, &b[*j1 + i__ * 
		    b_dim1], lda, &c_b5_dtgex2, &work[1], &m);
	    i__1 = *n - i__ + 1;
	    dlacpy_("Full", &m, &i__1, &work[1], &m, &b[*j1 + i__ * b_dim1], 
		    ldb);
	}
	i__ = *j1 - 1;
	if (i__ > 0) {
	    dgemm_("N", "N", &i__, &m, &m, &c_b42, &a[*j1 * a_dim1 + 1], lda, 
		    ir, &c__4, &c_b5_dtgex2, &work[1], &i__);
	    dlacpy_("Full", &i__, &m, &work[1], &i__, &a[*j1 * a_dim1 + 1], 
		    lda);
	    dgemm_("N", "N", &i__, &m, &m, &c_b42, &b[*j1 * b_dim1 + 1], ldb, 
		    ir, &c__4, &c_b5_dtgex2, &work[1], &i__);
	    dlacpy_("Full", &i__, &m, &work[1], &i__, &b[*j1 * b_dim1 + 1], 
		    ldb);
	}

/*        Exit with INFO = 0 if swap was successfully performed. */

	return 0;

    }

/*     Exit with INFO = 1 if swap was rejected. */

L70:

    *info = 1;
    return 0;

/*     End of DTGEX2 */

} /* dtgex2_ */

/* Subroutine */ static int dtgsy2_(char *trans, integer *ijob, integer *m, integer *n, doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *c__, integer *ldc, doublereal *d__, integer *ldd, doublereal *e, integer *lde, doublereal *f, integer *ldf, doublereal *scale, doublereal *rdsum, doublereal *rdscal, integer *iwork, integer *pq, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, d_dim1, 
	    d_offset, e_dim1, e_offset, f_dim1, f_offset, i__1, i__2, i__3;

    /* Local variables */
    integer i__, j, k, p, q;
    doublereal z__[64]	/* was [8][8] */;
    integer ie, je, mb, nb, ii, jj, is, js;
    doublereal rhs[8];
    integer isp1, jsp1;
    integer ierr, zdim, ipiv[8], jpiv[8];
    doublereal alpha;
    doublereal scaloc;
    logical notran;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */
/*  Replaced various illegal calls to DCOPY by calls to DLASET. */
/*  Sven Hammarling, 27/5/02. */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Decode and test input parameters */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    e_dim1 = *lde;
    e_offset = 1 + e_dim1;
    e -= e_offset;
    f_dim1 = *ldf;
    f_offset = 1 + f_dim1;
    f -= f_offset;
    --iwork;

    /* Function Body */
    *info = 0;
    ierr = 0;
    notran = lsame_(trans, "N", (ftnlen)1, (ftnlen)1);
    if (! notran && ! lsame_(trans, "T", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (notran) {
	if (*ijob < 0 || *ijob > 2) {
	    *info = -2;
	}
    }
    if (*info == 0) {
	if (*m <= 0) {
	    *info = -3;
	} else if (*n <= 0) {
	    *info = -4;
	} else if (*lda < Dymola_max(1,*m)) {
	    *info = -5;
	} else if (*ldb < Dymola_max(1,*n)) {
	    *info = -8;
	} else if (*ldc < Dymola_max(1,*m)) {
	    *info = -10;
	} else if (*ldd < Dymola_max(1,*m)) {
	    *info = -12;
	} else if (*lde < Dymola_max(1,*n)) {
	    *info = -14;
	} else if (*ldf < Dymola_max(1,*m)) {
	    *info = -16;
	}
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTGSY2", &i__1);
	return 0;
    }

/*     Determine block structure of A */

    *pq = 0;
    p = 0;
    i__ = 1;
L10:
    if (i__ > *m) {
	goto L20;
    }
    ++p;
    iwork[p] = i__;
    if (i__ == *m) {
	goto L20;
    }
    if (a[i__ + 1 + i__ * a_dim1] != 0.) {
	i__ += 2;
    } else {
	++i__;
    }
    goto L10;
L20:
    iwork[p + 1] = *m + 1;

/*     Determine block structure of B */

    q = p + 1;
    j = 1;
L30:
    if (j > *n) {
	goto L40;
    }
    ++q;
    iwork[q] = j;
    if (j == *n) {
	goto L40;
    }
    if (b[j + 1 + j * b_dim1] != 0.) {
	j += 2;
    } else {
	++j;
    }
    goto L30;
L40:
    iwork[q + 1] = *n + 1;
    *pq = p * (q - p - 1);

    if (notran) {

/*        Solve (I, J) - subsystem */
/*           A(I, I) * R(I, J) - L(I, J) * B(J, J) = C(I, J) */
/*           D(I, I) * R(I, J) - L(I, J) * E(J, J) = F(I, J) */
/*        for I = P, P - 1, ..., 1; J = 1, 2, ..., Q */

	*scale = 1.;
	scaloc = 1.;
	i__1 = q;
	for (j = p + 2; j <= i__1; ++j) {
	    js = iwork[j];
	    jsp1 = js + 1;
	    je = iwork[j + 1] - 1;
	    nb = je - js + 1;
	    for (i__ = p; i__ >= 1; --i__) {

		is = iwork[i__];
		isp1 = is + 1;
		ie = iwork[i__ + 1] - 1;
		mb = ie - is + 1;
		zdim = mb * nb << 1;

		if (mb == 1 && nb == 1) {

/*                 Build a 2-by-2 system Z * x = RHS */

		    z__[0] = a[is + is * a_dim1];
		    z__[1] = d__[is + is * d_dim1];
		    z__[8] = -b[js + js * b_dim1];
		    z__[9] = -e[js + js * e_dim1];

/*                 Set up right hand side(s) */

		    rhs[0] = c__[is + js * c_dim1];
		    rhs[1] = f[is + js * f_dim1];

/*                 Solve Z * x = RHS */

		    dgetc2_(&zdim, z__, &c__8, ipiv, jpiv, &ierr);
		    if (ierr > 0) {
			*info = ierr;
		    }

		    if (*ijob == 0) {
			dgesc2_(&zdim, z__, &c__8, rhs, ipiv, jpiv, &scaloc);
			if (scaloc != 1.) {
			    i__2 = *n;
			    for (k = 1; k <= i__2; ++k) {
				dscal_(m, &scaloc, &c__[k * c_dim1 + 1], &
					c__1);
				dscal_(m, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L50: */
			    }
			    *scale *= scaloc;
			}
		    } else {
			dlatdf_(ijob, &zdim, z__, &c__8, rhs, rdsum, rdscal, 
				ipiv, jpiv);
		    }

/*                 Unpack solution vector(s) */

		    c__[is + js * c_dim1] = rhs[0];
		    f[is + js * f_dim1] = rhs[1];

/*                 Substitute R(I, J) and L(I, J) into remaining */
/*                 equation. */

		    if (i__ > 1) {
			alpha = -rhs[0];
			i__2 = is - 1;
			daxpy_(&i__2, &alpha, &a[is * a_dim1 + 1], &c__1, &
				c__[js * c_dim1 + 1], &c__1);
			i__2 = is - 1;
			daxpy_(&i__2, &alpha, &d__[is * d_dim1 + 1], &c__1, &
				f[js * f_dim1 + 1], &c__1);
		    }
		    if (j < q) {
			i__2 = *n - je;
			daxpy_(&i__2, &rhs[1], &b[js + (je + 1) * b_dim1], 
				ldb, &c__[is + (je + 1) * c_dim1], ldc);
			i__2 = *n - je;
			daxpy_(&i__2, &rhs[1], &e[js + (je + 1) * e_dim1], 
				lde, &f[is + (je + 1) * f_dim1], ldf);
		    }

		} else if (mb == 1 && nb == 2) {

/*                 Build a 4-by-4 system Z * x = RHS */

		    z__[0] = a[is + is * a_dim1];
		    z__[1] = 0.;
		    z__[2] = d__[is + is * d_dim1];
		    z__[3] = 0.;

		    z__[8] = 0.;
		    z__[9] = a[is + is * a_dim1];
		    z__[10] = 0.;
		    z__[11] = d__[is + is * d_dim1];

		    z__[16] = -b[js + js * b_dim1];
		    z__[17] = -b[js + jsp1 * b_dim1];
		    z__[18] = -e[js + js * e_dim1];
		    z__[19] = -e[js + jsp1 * e_dim1];

		    z__[24] = -b[jsp1 + js * b_dim1];
		    z__[25] = -b[jsp1 + jsp1 * b_dim1];
		    z__[26] = 0.;
		    z__[27] = -e[jsp1 + jsp1 * e_dim1];

/*                 Set up right hand side(s) */

		    rhs[0] = c__[is + js * c_dim1];
		    rhs[1] = c__[is + jsp1 * c_dim1];
		    rhs[2] = f[is + js * f_dim1];
		    rhs[3] = f[is + jsp1 * f_dim1];

/*                 Solve Z * x = RHS */

		    dgetc2_(&zdim, z__, &c__8, ipiv, jpiv, &ierr);
		    if (ierr > 0) {
			*info = ierr;
		    }

		    if (*ijob == 0) {
			dgesc2_(&zdim, z__, &c__8, rhs, ipiv, jpiv, &scaloc);
			if (scaloc != 1.) {
			    i__2 = *n;
			    for (k = 1; k <= i__2; ++k) {
				dscal_(m, &scaloc, &c__[k * c_dim1 + 1], &
					c__1);
				dscal_(m, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L60: */
			    }
			    *scale *= scaloc;
			}
		    } else {
			dlatdf_(ijob, &zdim, z__, &c__8, rhs, rdsum, rdscal, 
				ipiv, jpiv);
		    }

/*                 Unpack solution vector(s) */

		    c__[is + js * c_dim1] = rhs[0];
		    c__[is + jsp1 * c_dim1] = rhs[1];
		    f[is + js * f_dim1] = rhs[2];
		    f[is + jsp1 * f_dim1] = rhs[3];

/*                 Substitute R(I, J) and L(I, J) into remaining */
/*                 equation. */

		    if (i__ > 1) {
			i__2 = is - 1;
			dger_(&i__2, &nb, &c_b27_dtgsy2, &a[is * a_dim1 + 1], &c__1, 
				rhs, &c__1, &c__[js * c_dim1 + 1], ldc);
			i__2 = is - 1;
			dger_(&i__2, &nb, &c_b27_dtgsy2, &d__[is * d_dim1 + 1], &
				c__1, rhs, &c__1, &f[js * f_dim1 + 1], ldf);
		    }
		    if (j < q) {
			i__2 = *n - je;
			daxpy_(&i__2, &rhs[2], &b[js + (je + 1) * b_dim1], 
				ldb, &c__[is + (je + 1) * c_dim1], ldc);
			i__2 = *n - je;
			daxpy_(&i__2, &rhs[2], &e[js + (je + 1) * e_dim1], 
				lde, &f[is + (je + 1) * f_dim1], ldf);
			i__2 = *n - je;
			daxpy_(&i__2, &rhs[3], &b[jsp1 + (je + 1) * b_dim1], 
				ldb, &c__[is + (je + 1) * c_dim1], ldc);
			i__2 = *n - je;
			daxpy_(&i__2, &rhs[3], &e[jsp1 + (je + 1) * e_dim1], 
				lde, &f[is + (je + 1) * f_dim1], ldf);
		    }

		} else if (mb == 2 && nb == 1) {

/*                 Build a 4-by-4 system Z * x = RHS */

		    z__[0] = a[is + is * a_dim1];
		    z__[1] = a[isp1 + is * a_dim1];
		    z__[2] = d__[is + is * d_dim1];
		    z__[3] = 0.;

		    z__[8] = a[is + isp1 * a_dim1];
		    z__[9] = a[isp1 + isp1 * a_dim1];
		    z__[10] = d__[is + isp1 * d_dim1];
		    z__[11] = d__[isp1 + isp1 * d_dim1];

		    z__[16] = -b[js + js * b_dim1];
		    z__[17] = 0.;
		    z__[18] = -e[js + js * e_dim1];
		    z__[19] = 0.;

		    z__[24] = 0.;
		    z__[25] = -b[js + js * b_dim1];
		    z__[26] = 0.;
		    z__[27] = -e[js + js * e_dim1];

/*                 Set up right hand side(s) */

		    rhs[0] = c__[is + js * c_dim1];
		    rhs[1] = c__[isp1 + js * c_dim1];
		    rhs[2] = f[is + js * f_dim1];
		    rhs[3] = f[isp1 + js * f_dim1];

/*                 Solve Z * x = RHS */

		    dgetc2_(&zdim, z__, &c__8, ipiv, jpiv, &ierr);
		    if (ierr > 0) {
			*info = ierr;
		    }
		    if (*ijob == 0) {
			dgesc2_(&zdim, z__, &c__8, rhs, ipiv, jpiv, &scaloc);
			if (scaloc != 1.) {
			    i__2 = *n;
			    for (k = 1; k <= i__2; ++k) {
				dscal_(m, &scaloc, &c__[k * c_dim1 + 1], &
					c__1);
				dscal_(m, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L70: */
			    }
			    *scale *= scaloc;
			}
		    } else {
			dlatdf_(ijob, &zdim, z__, &c__8, rhs, rdsum, rdscal, 
				ipiv, jpiv);
		    }

/*                 Unpack solution vector(s) */

		    c__[is + js * c_dim1] = rhs[0];
		    c__[isp1 + js * c_dim1] = rhs[1];
		    f[is + js * f_dim1] = rhs[2];
		    f[isp1 + js * f_dim1] = rhs[3];

/*                 Substitute R(I, J) and L(I, J) into remaining */
/*                 equation. */

		    if (i__ > 1) {
			i__2 = is - 1;
			dgemv_("N", &i__2, &mb, &c_b27_dtgsy2, &a[is * a_dim1 + 1], 
				lda, rhs, &c__1, &c_b42, &c__[js * c_dim1 + 1]
				, &c__1);
			i__2 = is - 1;
			dgemv_("N", &i__2, &mb, &c_b27_dtgsy2, &d__[is * d_dim1 + 1],
				 ldd, rhs, &c__1, &c_b42, &f[js * f_dim1 + 1],
				 &c__1);
		    }
		    if (j < q) {
			i__2 = *n - je;
			dger_(&mb, &i__2, &c_b42, &rhs[2], &c__1, &b[js + (je 
				+ 1) * b_dim1], ldb, &c__[is + (je + 1) * 
				c_dim1], ldc);
			i__2 = *n - je;
			dger_(&mb, &i__2, &c_b42, &rhs[2], &c__1, &e[js + (je 
				+ 1) * e_dim1], lde, &f[is + (je + 1) * 
				f_dim1], ldf);
		    }

		} else if (mb == 2 && nb == 2) {

/*                 Build an 8-by-8 system Z * x = RHS */

		    dlaset_("F", &c__8, &c__8, &c_b56, &c_b56, z__, &c__8);

		    z__[0] = a[is + is * a_dim1];
		    z__[1] = a[isp1 + is * a_dim1];
		    z__[4] = d__[is + is * d_dim1];

		    z__[8] = a[is + isp1 * a_dim1];
		    z__[9] = a[isp1 + isp1 * a_dim1];
		    z__[12] = d__[is + isp1 * d_dim1];
		    z__[13] = d__[isp1 + isp1 * d_dim1];

		    z__[18] = a[is + is * a_dim1];
		    z__[19] = a[isp1 + is * a_dim1];
		    z__[22] = d__[is + is * d_dim1];

		    z__[26] = a[is + isp1 * a_dim1];
		    z__[27] = a[isp1 + isp1 * a_dim1];
		    z__[30] = d__[is + isp1 * d_dim1];
		    z__[31] = d__[isp1 + isp1 * d_dim1];

		    z__[32] = -b[js + js * b_dim1];
		    z__[34] = -b[js + jsp1 * b_dim1];
		    z__[36] = -e[js + js * e_dim1];
		    z__[38] = -e[js + jsp1 * e_dim1];

		    z__[41] = -b[js + js * b_dim1];
		    z__[43] = -b[js + jsp1 * b_dim1];
		    z__[45] = -e[js + js * e_dim1];
		    z__[47] = -e[js + jsp1 * e_dim1];

		    z__[48] = -b[jsp1 + js * b_dim1];
		    z__[50] = -b[jsp1 + jsp1 * b_dim1];
		    z__[54] = -e[jsp1 + jsp1 * e_dim1];

		    z__[57] = -b[jsp1 + js * b_dim1];
		    z__[59] = -b[jsp1 + jsp1 * b_dim1];
		    z__[63] = -e[jsp1 + jsp1 * e_dim1];

/*                 Set up right hand side(s) */

		    k = 1;
		    ii = mb * nb + 1;
		    i__2 = nb - 1;
		    for (jj = 0; jj <= i__2; ++jj) {
			dcopy_(&mb, &c__[is + (js + jj) * c_dim1], &c__1, &
				rhs[k - 1], &c__1);
			dcopy_(&mb, &f[is + (js + jj) * f_dim1], &c__1, &rhs[
				ii - 1], &c__1);
			k += mb;
			ii += mb;
/* L80: */
		    }

/*                 Solve Z * x = RHS */

		    dgetc2_(&zdim, z__, &c__8, ipiv, jpiv, &ierr);
		    if (ierr > 0) {
			*info = ierr;
		    }
		    if (*ijob == 0) {
			dgesc2_(&zdim, z__, &c__8, rhs, ipiv, jpiv, &scaloc);
			if (scaloc != 1.) {
			    i__2 = *n;
			    for (k = 1; k <= i__2; ++k) {
				dscal_(m, &scaloc, &c__[k * c_dim1 + 1], &
					c__1);
				dscal_(m, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L90: */
			    }
			    *scale *= scaloc;
			}
		    } else {
			dlatdf_(ijob, &zdim, z__, &c__8, rhs, rdsum, rdscal, 
				ipiv, jpiv);
		    }

/*                 Unpack solution vector(s) */

		    k = 1;
		    ii = mb * nb + 1;
		    i__2 = nb - 1;
		    for (jj = 0; jj <= i__2; ++jj) {
			dcopy_(&mb, &rhs[k - 1], &c__1, &c__[is + (js + jj) * 
				c_dim1], &c__1);
			dcopy_(&mb, &rhs[ii - 1], &c__1, &f[is + (js + jj) * 
				f_dim1], &c__1);
			k += mb;
			ii += mb;
/* L100: */
		    }

/*                 Substitute R(I, J) and L(I, J) into remaining */
/*                 equation. */

		    if (i__ > 1) {
			i__2 = is - 1;
			dgemm_("N", "N", &i__2, &nb, &mb, &c_b27_dtgsy2, &a[is * 
				a_dim1 + 1], lda, rhs, &mb, &c_b42, &c__[js * 
				c_dim1 + 1], ldc);
			i__2 = is - 1;
			dgemm_("N", "N", &i__2, &nb, &mb, &c_b27_dtgsy2, &d__[is * 
				d_dim1 + 1], ldd, rhs, &mb, &c_b42, &f[js * 
				f_dim1 + 1], ldf);
		    }
		    if (j < q) {
			k = mb * nb + 1;
			i__2 = *n - je;
			dgemm_("N", "N", &mb, &i__2, &nb, &c_b42, &rhs[k - 1],
				 &mb, &b[js + (je + 1) * b_dim1], ldb, &c_b42,
				 &c__[is + (je + 1) * c_dim1], ldc);
			i__2 = *n - je;
			dgemm_("N", "N", &mb, &i__2, &nb, &c_b42, &rhs[k - 1],
				 &mb, &e[js + (je + 1) * e_dim1], lde, &c_b42,
				 &f[is + (je + 1) * f_dim1], ldf);
		    }

		}

/* L110: */
	    }
/* L120: */
	}
    } else {

/*        Solve (I, J) - subsystem */
/*             A(I, I)**T * R(I, J) + D(I, I)**T * L(J, J)  =  C(I, J) */
/*             R(I, I)  * B(J, J) + L(I, J)  * E(J, J)  = -F(I, J) */
/*        for I = 1, 2, ..., P, J = Q, Q - 1, ..., 1 */

	*scale = 1.;
	scaloc = 1.;
	i__1 = p;
	for (i__ = 1; i__ <= i__1; ++i__) {

	    is = iwork[i__];
	    isp1 = is + 1;
	    ie = iwork[i__ + 1] - 1;
	    mb = ie - is + 1;
	    i__2 = p + 2;
	    for (j = q; j >= i__2; --j) {

		js = iwork[j];
		jsp1 = js + 1;
		je = iwork[j + 1] - 1;
		nb = je - js + 1;
		zdim = mb * nb << 1;
		if (mb == 1 && nb == 1) {

/*                 Build a 2-by-2 system Z**T * x = RHS */

		    z__[0] = a[is + is * a_dim1];
		    z__[1] = -b[js + js * b_dim1];
		    z__[8] = d__[is + is * d_dim1];
		    z__[9] = -e[js + js * e_dim1];

/*                 Set up right hand side(s) */

		    rhs[0] = c__[is + js * c_dim1];
		    rhs[1] = f[is + js * f_dim1];

/*                 Solve Z**T * x = RHS */

		    dgetc2_(&zdim, z__, &c__8, ipiv, jpiv, &ierr);
		    if (ierr > 0) {
			*info = ierr;
		    }

		    dgesc2_(&zdim, z__, &c__8, rhs, ipiv, jpiv, &scaloc);
		    if (scaloc != 1.) {
			i__3 = *n;
			for (k = 1; k <= i__3; ++k) {
			    dscal_(m, &scaloc, &c__[k * c_dim1 + 1], &c__1);
			    dscal_(m, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L130: */
			}
			*scale *= scaloc;
		    }

/*                 Unpack solution vector(s) */

		    c__[is + js * c_dim1] = rhs[0];
		    f[is + js * f_dim1] = rhs[1];

/*                 Substitute R(I, J) and L(I, J) into remaining */
/*                 equation. */

		    if (j > p + 2) {
			alpha = rhs[0];
			i__3 = js - 1;
			daxpy_(&i__3, &alpha, &b[js * b_dim1 + 1], &c__1, &f[
				is + f_dim1], ldf);
			alpha = rhs[1];
			i__3 = js - 1;
			daxpy_(&i__3, &alpha, &e[js * e_dim1 + 1], &c__1, &f[
				is + f_dim1], ldf);
		    }
		    if (i__ < p) {
			alpha = -rhs[0];
			i__3 = *m - ie;
			daxpy_(&i__3, &alpha, &a[is + (ie + 1) * a_dim1], lda,
				 &c__[ie + 1 + js * c_dim1], &c__1);
			alpha = -rhs[1];
			i__3 = *m - ie;
			daxpy_(&i__3, &alpha, &d__[is + (ie + 1) * d_dim1], 
				ldd, &c__[ie + 1 + js * c_dim1], &c__1);
		    }

		} else if (mb == 1 && nb == 2) {

/*                 Build a 4-by-4 system Z**T * x = RHS */

		    z__[0] = a[is + is * a_dim1];
		    z__[1] = 0.;
		    z__[2] = -b[js + js * b_dim1];
		    z__[3] = -b[jsp1 + js * b_dim1];

		    z__[8] = 0.;
		    z__[9] = a[is + is * a_dim1];
		    z__[10] = -b[js + jsp1 * b_dim1];
		    z__[11] = -b[jsp1 + jsp1 * b_dim1];

		    z__[16] = d__[is + is * d_dim1];
		    z__[17] = 0.;
		    z__[18] = -e[js + js * e_dim1];
		    z__[19] = 0.;

		    z__[24] = 0.;
		    z__[25] = d__[is + is * d_dim1];
		    z__[26] = -e[js + jsp1 * e_dim1];
		    z__[27] = -e[jsp1 + jsp1 * e_dim1];

/*                 Set up right hand side(s) */

		    rhs[0] = c__[is + js * c_dim1];
		    rhs[1] = c__[is + jsp1 * c_dim1];
		    rhs[2] = f[is + js * f_dim1];
		    rhs[3] = f[is + jsp1 * f_dim1];

/*                 Solve Z**T * x = RHS */

		    dgetc2_(&zdim, z__, &c__8, ipiv, jpiv, &ierr);
		    if (ierr > 0) {
			*info = ierr;
		    }
		    dgesc2_(&zdim, z__, &c__8, rhs, ipiv, jpiv, &scaloc);
		    if (scaloc != 1.) {
			i__3 = *n;
			for (k = 1; k <= i__3; ++k) {
			    dscal_(m, &scaloc, &c__[k * c_dim1 + 1], &c__1);
			    dscal_(m, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L140: */
			}
			*scale *= scaloc;
		    }

/*                 Unpack solution vector(s) */

		    c__[is + js * c_dim1] = rhs[0];
		    c__[is + jsp1 * c_dim1] = rhs[1];
		    f[is + js * f_dim1] = rhs[2];
		    f[is + jsp1 * f_dim1] = rhs[3];

/*                 Substitute R(I, J) and L(I, J) into remaining */
/*                 equation. */

		    if (j > p + 2) {
			i__3 = js - 1;
			daxpy_(&i__3, rhs, &b[js * b_dim1 + 1], &c__1, &f[is 
				+ f_dim1], ldf);
			i__3 = js - 1;
			daxpy_(&i__3, &rhs[1], &b[jsp1 * b_dim1 + 1], &c__1, &
				f[is + f_dim1], ldf);
			i__3 = js - 1;
			daxpy_(&i__3, &rhs[2], &e[js * e_dim1 + 1], &c__1, &f[
				is + f_dim1], ldf);
			i__3 = js - 1;
			daxpy_(&i__3, &rhs[3], &e[jsp1 * e_dim1 + 1], &c__1, &
				f[is + f_dim1], ldf);
		    }
		    if (i__ < p) {
			i__3 = *m - ie;
			dger_(&i__3, &nb, &c_b27_dtgsy2, &a[is + (ie + 1) * a_dim1], 
				lda, rhs, &c__1, &c__[ie + 1 + js * c_dim1], 
				ldc);
			i__3 = *m - ie;
			dger_(&i__3, &nb, &c_b27_dtgsy2, &d__[is + (ie + 1) * d_dim1]
				, ldd, &rhs[2], &c__1, &c__[ie + 1 + js * 
				c_dim1], ldc);
		    }

		} else if (mb == 2 && nb == 1) {

/*                 Build a 4-by-4 system Z**T * x = RHS */

		    z__[0] = a[is + is * a_dim1];
		    z__[1] = a[is + isp1 * a_dim1];
		    z__[2] = -b[js + js * b_dim1];
		    z__[3] = 0.;

		    z__[8] = a[isp1 + is * a_dim1];
		    z__[9] = a[isp1 + isp1 * a_dim1];
		    z__[10] = 0.;
		    z__[11] = -b[js + js * b_dim1];

		    z__[16] = d__[is + is * d_dim1];
		    z__[17] = d__[is + isp1 * d_dim1];
		    z__[18] = -e[js + js * e_dim1];
		    z__[19] = 0.;

		    z__[24] = 0.;
		    z__[25] = d__[isp1 + isp1 * d_dim1];
		    z__[26] = 0.;
		    z__[27] = -e[js + js * e_dim1];

/*                 Set up right hand side(s) */

		    rhs[0] = c__[is + js * c_dim1];
		    rhs[1] = c__[isp1 + js * c_dim1];
		    rhs[2] = f[is + js * f_dim1];
		    rhs[3] = f[isp1 + js * f_dim1];

/*                 Solve Z**T * x = RHS */

		    dgetc2_(&zdim, z__, &c__8, ipiv, jpiv, &ierr);
		    if (ierr > 0) {
			*info = ierr;
		    }

		    dgesc2_(&zdim, z__, &c__8, rhs, ipiv, jpiv, &scaloc);
		    if (scaloc != 1.) {
			i__3 = *n;
			for (k = 1; k <= i__3; ++k) {
			    dscal_(m, &scaloc, &c__[k * c_dim1 + 1], &c__1);
			    dscal_(m, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L150: */
			}
			*scale *= scaloc;
		    }

/*                 Unpack solution vector(s) */

		    c__[is + js * c_dim1] = rhs[0];
		    c__[isp1 + js * c_dim1] = rhs[1];
		    f[is + js * f_dim1] = rhs[2];
		    f[isp1 + js * f_dim1] = rhs[3];

/*                 Substitute R(I, J) and L(I, J) into remaining */
/*                 equation. */

		    if (j > p + 2) {
			i__3 = js - 1;
			dger_(&mb, &i__3, &c_b42, rhs, &c__1, &b[js * b_dim1 
				+ 1], &c__1, &f[is + f_dim1], ldf);
			i__3 = js - 1;
			dger_(&mb, &i__3, &c_b42, &rhs[2], &c__1, &e[js * 
				e_dim1 + 1], &c__1, &f[is + f_dim1], ldf);
		    }
		    if (i__ < p) {
			i__3 = *m - ie;
			dgemv_("T", &mb, &i__3, &c_b27_dtgsy2, &a[is + (ie + 1) * 
				a_dim1], lda, rhs, &c__1, &c_b42, &c__[ie + 1 
				+ js * c_dim1], &c__1);
			i__3 = *m - ie;
			dgemv_("T", &mb, &i__3, &c_b27_dtgsy2, &d__[is + (ie + 1) * 
				d_dim1], ldd, &rhs[2], &c__1, &c_b42, &c__[ie 
				+ 1 + js * c_dim1], &c__1);
		    }

		} else if (mb == 2 && nb == 2) {

/*                 Build an 8-by-8 system Z**T * x = RHS */

		    dlaset_("F", &c__8, &c__8, &c_b56, &c_b56, z__, &c__8);

		    z__[0] = a[is + is * a_dim1];
		    z__[1] = a[is + isp1 * a_dim1];
		    z__[4] = -b[js + js * b_dim1];
		    z__[6] = -b[jsp1 + js * b_dim1];

		    z__[8] = a[isp1 + is * a_dim1];
		    z__[9] = a[isp1 + isp1 * a_dim1];
		    z__[13] = -b[js + js * b_dim1];
		    z__[15] = -b[jsp1 + js * b_dim1];

		    z__[18] = a[is + is * a_dim1];
		    z__[19] = a[is + isp1 * a_dim1];
		    z__[20] = -b[js + jsp1 * b_dim1];
		    z__[22] = -b[jsp1 + jsp1 * b_dim1];

		    z__[26] = a[isp1 + is * a_dim1];
		    z__[27] = a[isp1 + isp1 * a_dim1];
		    z__[29] = -b[js + jsp1 * b_dim1];
		    z__[31] = -b[jsp1 + jsp1 * b_dim1];

		    z__[32] = d__[is + is * d_dim1];
		    z__[33] = d__[is + isp1 * d_dim1];
		    z__[36] = -e[js + js * e_dim1];

		    z__[41] = d__[isp1 + isp1 * d_dim1];
		    z__[45] = -e[js + js * e_dim1];

		    z__[50] = d__[is + is * d_dim1];
		    z__[51] = d__[is + isp1 * d_dim1];
		    z__[52] = -e[js + jsp1 * e_dim1];
		    z__[54] = -e[jsp1 + jsp1 * e_dim1];

		    z__[59] = d__[isp1 + isp1 * d_dim1];
		    z__[61] = -e[js + jsp1 * e_dim1];
		    z__[63] = -e[jsp1 + jsp1 * e_dim1];

/*                 Set up right hand side(s) */

		    k = 1;
		    ii = mb * nb + 1;
		    i__3 = nb - 1;
		    for (jj = 0; jj <= i__3; ++jj) {
			dcopy_(&mb, &c__[is + (js + jj) * c_dim1], &c__1, &
				rhs[k - 1], &c__1);
			dcopy_(&mb, &f[is + (js + jj) * f_dim1], &c__1, &rhs[
				ii - 1], &c__1);
			k += mb;
			ii += mb;
/* L160: */
		    }


/*                 Solve Z**T * x = RHS */

		    dgetc2_(&zdim, z__, &c__8, ipiv, jpiv, &ierr);
		    if (ierr > 0) {
			*info = ierr;
		    }

		    dgesc2_(&zdim, z__, &c__8, rhs, ipiv, jpiv, &scaloc);
		    if (scaloc != 1.) {
			i__3 = *n;
			for (k = 1; k <= i__3; ++k) {
			    dscal_(m, &scaloc, &c__[k * c_dim1 + 1], &c__1);
			    dscal_(m, &scaloc, &f[k * f_dim1 + 1], &c__1);
/* L170: */
			}
			*scale *= scaloc;
		    }

/*                 Unpack solution vector(s) */

		    k = 1;
		    ii = mb * nb + 1;
		    i__3 = nb - 1;
		    for (jj = 0; jj <= i__3; ++jj) {
			dcopy_(&mb, &rhs[k - 1], &c__1, &c__[is + (js + jj) * 
				c_dim1], &c__1);
			dcopy_(&mb, &rhs[ii - 1], &c__1, &f[is + (js + jj) * 
				f_dim1], &c__1);
			k += mb;
			ii += mb;
/* L180: */
		    }

/*                 Substitute R(I, J) and L(I, J) into remaining */
/*                 equation. */

		    if (j > p + 2) {
			i__3 = js - 1;
			dgemm_("N", "T", &mb, &i__3, &nb, &c_b42, &c__[is + 
				js * c_dim1], ldc, &b[js * b_dim1 + 1], ldb, &
				c_b42, &f[is + f_dim1], ldf);
			i__3 = js - 1;
			dgemm_("N", "T", &mb, &i__3, &nb, &c_b42, &f[is + js *
				 f_dim1], ldf, &e[js * e_dim1 + 1], lde, &
				c_b42, &f[is + f_dim1], ldf);
		    }
		    if (i__ < p) {
			i__3 = *m - ie;
			dgemm_("T", "N", &i__3, &nb, &mb, &c_b27_dtgsy2, &a[is + (ie 
				+ 1) * a_dim1], lda, &c__[is + js * c_dim1], 
				ldc, &c_b42, &c__[ie + 1 + js * c_dim1], ldc);
			i__3 = *m - ie;
			dgemm_("T", "N", &i__3, &nb, &mb, &c_b27_dtgsy2, &d__[is + (
				ie + 1) * d_dim1], ldd, &f[is + js * f_dim1], 
				ldf, &c_b42, &c__[ie + 1 + js * c_dim1], ldc);
		    }

		}

/* L190: */
	    }
/* L200: */
	}

    }
    return 0;

/*     End of DTGSY2 */

} /* dtgsy2_ */

/* Subroutine */ static int dorgr2_(integer *m, integer *n, integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublereal d__1;

    /* Local variables */
    integer i__, j, l, ii;

/*  -- LAPACK computational routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
	*info = -1;
    } else if (*n < *m) {
	*info = -2;
    } else if (*k < 0 || *k > *m) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -5;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DORGR2", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*m <= 0) {
	return 0;
    }

    if (*k < *m) {

/*        Initialise rows 1:m-k to rows of the unit matrix */

	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *m - *k;
	    for (l = 1; l <= i__2; ++l) {
		a[l + j * a_dim1] = 0.;
/* L10: */
	    }
	    if (j > *n - *m && j <= *n - *k) {
		a[*m - *n + j + j * a_dim1] = 1.;
	    }
/* L20: */
	}
    }

    i__1 = *k;
    for (i__ = 1; i__ <= i__1; ++i__) {
	ii = *m - *k + i__;

/*        Apply H(i) to A(1:m-k+i,1:n-k+i) from the right */

	a[ii + (*n - *m + ii) * a_dim1] = 1.;
	i__2 = ii - 1;
	i__3 = *n - *m + ii;
	dlarf_("Right", &i__2, &i__3, &a[ii + a_dim1], lda, &tau[i__], &a[
		a_offset], lda, &work[1]);
	i__2 = *n - *m + ii - 1;
	d__1 = -tau[i__];
	dscal_(&i__2, &d__1, &a[ii + a_dim1], lda);
	a[ii + (*n - *m + ii) * a_dim1] = 1. - tau[i__];

/*        Set A(m-k+i,n-k+i+1:n) to zero */

	i__2 = *n;
	for (l = *n - *m + ii + 1; l <= i__2; ++l) {
	    a[ii + l * a_dim1] = 0.;
/* L30: */
	}
/* L40: */
    }
    return 0;

/*     End of DORGR2 */

} /* dorgr2_ */

/* Subroutine */ static int dlagv2_(doublereal *a, integer *lda, doublereal *b, integer *ldb, doublereal *alphar, doublereal *alphai, doublereal *beta, doublereal *csl, doublereal *snl, doublereal *csr, doublereal *snr)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset;
    doublereal d__1, d__2, d__3, d__4, d__5, d__6;

    /* Local variables */
    doublereal r__, t, h1, h2, h3, wi, qq, rr, wr1, wr2, ulp;
    doublereal anorm, bnorm, scale1, scale2;
    doublereal ascale, bscale;
    doublereal safmin;

/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --alphar;
    --alphai;
    --beta;

    /* Function Body */
    safmin = dlamch_("S");
    ulp = dlamch_("P");

/*     Scale A */

/* Computing MAX */
    d__5 = (d__1 = a[a_dim1 + 1], Dymola_abs(d__1)) + (d__2 = a[a_dim1 + 2], Dymola_abs(
	    d__2)), d__6 = (d__3 = a[(a_dim1 << 1) + 1], Dymola_abs(d__3)) + (d__4 = 
	    a[(a_dim1 << 1) + 2], Dymola_abs(d__4)), d__5 = Dymola_max(d__5,d__6);
    anorm = Dymola_max(d__5,safmin);
    ascale = 1. / anorm;
    a[a_dim1 + 1] = ascale * a[a_dim1 + 1];
    a[(a_dim1 << 1) + 1] = ascale * a[(a_dim1 << 1) + 1];
    a[a_dim1 + 2] = ascale * a[a_dim1 + 2];
    a[(a_dim1 << 1) + 2] = ascale * a[(a_dim1 << 1) + 2];

/*     Scale B */

/* Computing MAX */
    d__4 = (d__3 = b[b_dim1 + 1], Dymola_abs(d__3)), d__5 = (d__1 = b[(b_dim1 << 1) 
	    + 1], Dymola_abs(d__1)) + (d__2 = b[(b_dim1 << 1) + 2], Dymola_abs(d__2)), d__4 
	    = Dymola_max(d__4,d__5);
    bnorm = Dymola_max(d__4,safmin);
    bscale = 1. / bnorm;
    b[b_dim1 + 1] = bscale * b[b_dim1 + 1];
    b[(b_dim1 << 1) + 1] = bscale * b[(b_dim1 << 1) + 1];
    b[(b_dim1 << 1) + 2] = bscale * b[(b_dim1 << 1) + 2];

/*     Check if A can be deflated */

    if ((d__1 = a[a_dim1 + 2], Dymola_abs(d__1)) <= ulp) {
	*csl = 1.;
	*snl = 0.;
	*csr = 1.;
	*snr = 0.;
	a[a_dim1 + 2] = 0.;
	b[b_dim1 + 2] = 0.;
	wi = 0.;

/*     Check if B is singular */

    } else if ((d__1 = b[b_dim1 + 1], Dymola_abs(d__1)) <= ulp) {
	dlartg_(&a[a_dim1 + 1], &a[a_dim1 + 2], csl, snl, &r__);
	*csr = 1.;
	*snr = 0.;
	drot_(&c__2, &a[a_dim1 + 1], lda, &a[a_dim1 + 2], lda, csl, snl);
	drot_(&c__2, &b[b_dim1 + 1], ldb, &b[b_dim1 + 2], ldb, csl, snl);
	a[a_dim1 + 2] = 0.;
	b[b_dim1 + 1] = 0.;
	b[b_dim1 + 2] = 0.;
	wi = 0.;

    } else if ((d__1 = b[(b_dim1 << 1) + 2], Dymola_abs(d__1)) <= ulp) {
	dlartg_(&a[(a_dim1 << 1) + 2], &a[a_dim1 + 2], csr, snr, &t);
	*snr = -(*snr);
	drot_(&c__2, &a[a_dim1 + 1], &c__1, &a[(a_dim1 << 1) + 1], &c__1, csr,
		 snr);
	drot_(&c__2, &b[b_dim1 + 1], &c__1, &b[(b_dim1 << 1) + 1], &c__1, csr,
		 snr);
	*csl = 1.;
	*snl = 0.;
	a[a_dim1 + 2] = 0.;
	b[b_dim1 + 2] = 0.;
	b[(b_dim1 << 1) + 2] = 0.;
	wi = 0.;

    } else {

/*        B is nonsingular, first compute the eigenvalues of (A,B) */

	dlag2_(&a[a_offset], lda, &b[b_offset], ldb, &safmin, &scale1, &
		scale2, &wr1, &wr2, &wi);

	if (wi == 0.) {

/*           two real eigenvalues, compute s*A-w*B */

	    h1 = scale1 * a[a_dim1 + 1] - wr1 * b[b_dim1 + 1];
	    h2 = scale1 * a[(a_dim1 << 1) + 1] - wr1 * b[(b_dim1 << 1) + 1];
	    h3 = scale1 * a[(a_dim1 << 1) + 2] - wr1 * b[(b_dim1 << 1) + 2];

	    rr = dlapy2_(&h1, &h2);
	    d__1 = scale1 * a[a_dim1 + 2];
	    qq = dlapy2_(&d__1, &h3);

	    if (rr > qq) {

/*              find right rotation matrix to zero 1,1 element of */
/*              (sA - wB) */

		dlartg_(&h2, &h1, csr, snr, &t);

	    } else {

/*              find right rotation matrix to zero 2,1 element of */
/*              (sA - wB) */

		d__1 = scale1 * a[a_dim1 + 2];
		dlartg_(&h3, &d__1, csr, snr, &t);

	    }

	    *snr = -(*snr);
	    drot_(&c__2, &a[a_dim1 + 1], &c__1, &a[(a_dim1 << 1) + 1], &c__1, 
		    csr, snr);
	    drot_(&c__2, &b[b_dim1 + 1], &c__1, &b[(b_dim1 << 1) + 1], &c__1, 
		    csr, snr);

/*           compute inf norms of A and B */

/* Computing MAX */
	    d__5 = (d__1 = a[a_dim1 + 1], Dymola_abs(d__1)) + (d__2 = a[(a_dim1 << 1)
		     + 1], Dymola_abs(d__2)), d__6 = (d__3 = a[a_dim1 + 2], Dymola_abs(d__3)
		    ) + (d__4 = a[(a_dim1 << 1) + 2], Dymola_abs(d__4));
	    h1 = Dymola_max(d__5,d__6);
/* Computing MAX */
	    d__5 = (d__1 = b[b_dim1 + 1], Dymola_abs(d__1)) + (d__2 = b[(b_dim1 << 1)
		     + 1], Dymola_abs(d__2)), d__6 = (d__3 = b[b_dim1 + 2], Dymola_abs(d__3)
		    ) + (d__4 = b[(b_dim1 << 1) + 2], Dymola_abs(d__4));
	    h2 = Dymola_max(d__5,d__6);

	    if (scale1 * h1 >= Dymola_abs(wr1) * h2) {

/*              find left rotation matrix Q to zero out B(2,1) */

		dlartg_(&b[b_dim1 + 1], &b[b_dim1 + 2], csl, snl, &r__);

	    } else {

/*              find left rotation matrix Q to zero out A(2,1) */

		dlartg_(&a[a_dim1 + 1], &a[a_dim1 + 2], csl, snl, &r__);

	    }

	    drot_(&c__2, &a[a_dim1 + 1], lda, &a[a_dim1 + 2], lda, csl, snl);
	    drot_(&c__2, &b[b_dim1 + 1], ldb, &b[b_dim1 + 2], ldb, csl, snl);

	    a[a_dim1 + 2] = 0.;
	    b[b_dim1 + 2] = 0.;

	} else {

/*           a pair of complex conjugate eigenvalues */
/*           first compute the SVD of the matrix B */

	    dlasv2_(&b[b_dim1 + 1], &b[(b_dim1 << 1) + 1], &b[(b_dim1 << 1) + 
		    2], &r__, &t, snr, csr, snl, csl);

/*           Form (A,B) := Q(A,B)Z**T where Q is left rotation matrix and */
/*           Z is right rotation matrix computed from DLASV2 */

	    drot_(&c__2, &a[a_dim1 + 1], lda, &a[a_dim1 + 2], lda, csl, snl);
	    drot_(&c__2, &b[b_dim1 + 1], ldb, &b[b_dim1 + 2], ldb, csl, snl);
	    drot_(&c__2, &a[a_dim1 + 1], &c__1, &a[(a_dim1 << 1) + 1], &c__1, 
		    csr, snr);
	    drot_(&c__2, &b[b_dim1 + 1], &c__1, &b[(b_dim1 << 1) + 1], &c__1, 
		    csr, snr);

	    b[b_dim1 + 2] = 0.;
	    b[(b_dim1 << 1) + 1] = 0.;

	}

    }

/*     Unscaling */

    a[a_dim1 + 1] = anorm * a[a_dim1 + 1];
    a[a_dim1 + 2] = anorm * a[a_dim1 + 2];
    a[(a_dim1 << 1) + 1] = anorm * a[(a_dim1 << 1) + 1];
    a[(a_dim1 << 1) + 2] = anorm * a[(a_dim1 << 1) + 2];
    b[b_dim1 + 1] = bnorm * b[b_dim1 + 1];
    b[b_dim1 + 2] = bnorm * b[b_dim1 + 2];
    b[(b_dim1 << 1) + 1] = bnorm * b[(b_dim1 << 1) + 1];
    b[(b_dim1 << 1) + 2] = bnorm * b[(b_dim1 << 1) + 2];

    if (wi == 0.) {
	alphar[1] = a[a_dim1 + 1];
	alphar[2] = a[(a_dim1 << 1) + 2];
	alphai[1] = 0.;
	alphai[2] = 0.;
	beta[1] = b[b_dim1 + 1];
	beta[2] = b[(b_dim1 << 1) + 2];
    } else {
	alphar[1] = anorm * wr1 / scale1 / bnorm;
	alphai[1] = anorm * wi / scale1 / bnorm;
	alphar[2] = alphar[1];
	alphai[2] = -alphai[1];
	beta[1] = 1.;
	beta[2] = 1.;
    }

    return 0;

/*     End of DLAGV2 */

} /* dlagv2_ */

/* Subroutine */ static int dgetc2_(integer *n, doublereal *a, integer *lda, integer *ipiv, integer *jpiv, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublereal d__1;

    /* Local variables */
    integer i__, j, ip, jp;
    doublereal eps;
    integer ipv, jpv;
    doublereal smin, xmax;
    doublereal bignum, smlnum;


/*  -- LAPACK auxiliary routine (version 3.5.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2013 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Set constants to control overflow */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;
    --jpiv;

    /* Function Body */
    *info = 0;
    eps = dlamch_("P");
    smlnum = dlamch_("S") / eps;
    bignum = 1. / smlnum;
    dlabad_(&smlnum, &bignum);

/*     Factorize A using complete pivoting. */
/*     Set pivots less than SMIN to SMIN. */

    i__1 = *n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*        Find max element in matrix A */

	xmax = 0.;
	i__2 = *n;
	for (ip = i__; ip <= i__2; ++ip) {
	    i__3 = *n;
	    for (jp = i__; jp <= i__3; ++jp) {
		if ((d__1 = a[ip + jp * a_dim1], Dymola_abs(d__1)) >= xmax) {
		    xmax = (d__1 = a[ip + jp * a_dim1], Dymola_abs(d__1));
		    ipv = ip;
		    jpv = jp;
		}
/* L10: */
	    }
/* L20: */
	}
	if (i__ == 1) {
/* Computing MAX */
	    d__1 = eps * xmax;
	    smin = Dymola_max(d__1,smlnum);
	}

/*        Swap rows */

	if (ipv != i__) {
	    dswap_(n, &a[ipv + a_dim1], lda, &a[i__ + a_dim1], lda);
	}
	ipiv[i__] = ipv;

/*        Swap columns */

	if (jpv != i__) {
	    dswap_(n, &a[jpv * a_dim1 + 1], &c__1, &a[i__ * a_dim1 + 1], &
		    c__1);
	}
	jpiv[i__] = jpv;

/*        Check for singularity */

	if ((d__1 = a[i__ + i__ * a_dim1], Dymola_abs(d__1)) < smin) {
	    *info = i__;
	    a[i__ + i__ * a_dim1] = smin;
	}
	i__2 = *n;
	for (j = i__ + 1; j <= i__2; ++j) {
	    a[j + i__ * a_dim1] /= a[i__ + i__ * a_dim1];
/* L30: */
	}
	i__2 = *n - i__;
	i__3 = *n - i__;
	dger_(&i__2, &i__3, &c_b10_gdetc2, &a[i__ + 1 + i__ * a_dim1], &c__1, &a[i__ 
		+ (i__ + 1) * a_dim1], lda, &a[i__ + 1 + (i__ + 1) * a_dim1], 
		lda);
/* L40: */
    }

    if ((d__1 = a[*n + *n * a_dim1], Dymola_abs(d__1)) < smin) {
	*info = *n;
	a[*n + *n * a_dim1] = smin;
    }

/*     Set last pivots to N */

    ipiv[*n] = *n;
    jpiv[*n] = *n;

    return 0;

/*     End of DGETC2 */

} /* dgetc2_ */

/* Subroutine */ static int dgesc2_(integer *n, doublereal *a, integer *lda, doublereal *rhs, integer *ipiv, integer *jpiv, doublereal *scale)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal d__1, d__2;

    /* Local variables */
    integer i__, j;
    doublereal eps, temp;
    doublereal bignum;
    doublereal smlnum;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*      Set constant to control owerflow */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --rhs;
    --ipiv;
    --jpiv;

    /* Function Body */
    eps = dlamch_("P");
    smlnum = dlamch_("S") / eps;
    bignum = 1. / smlnum;
    dlabad_(&smlnum, &bignum);

/*     Apply permutations IPIV to RHS */

    i__1 = *n - 1;
    dlaswp_(&c__1, &rhs[1], lda, &c__1, &i__1, &ipiv[1], &c__1);

/*     Solve for L part */

    i__1 = *n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = *n;
	for (j = i__ + 1; j <= i__2; ++j) {
	    rhs[j] -= a[j + i__ * a_dim1] * rhs[i__];
/* L10: */
	}
/* L20: */
    }

/*     Solve for U part */

    *scale = 1.;

/*     Check for scaling */

    i__ = idamax_(n, &rhs[1], &c__1);
    if (smlnum * 2. * (d__1 = rhs[i__], Dymola_abs(d__1)) > (d__2 = a[*n + *n * 
	    a_dim1], Dymola_abs(d__2))) {
	temp = .5 / (d__1 = rhs[i__], Dymola_abs(d__1));
	dscal_(n, &temp, &rhs[1], &c__1);
	*scale *= temp;
    }

    for (i__ = *n; i__ >= 1; --i__) {
	temp = 1. / a[i__ + i__ * a_dim1];
	rhs[i__] *= temp;
	i__1 = *n;
	for (j = i__ + 1; j <= i__1; ++j) {
	    rhs[i__] -= rhs[j] * (a[i__ + j * a_dim1] * temp);
/* L30: */
	}
/* L40: */
    }

/*     Apply permutations JPIV to the solution (RHS) */

    i__1 = *n - 1;
    dlaswp_(&c__1, &rhs[1], lda, &c__1, &i__1, &jpiv[1], &c_n1);
    return 0;

/*     End of DGESC2 */

} /* dgesc2_ */

/* Subroutine */ static int dlatdf_(integer *ijob, integer *n, doublereal *z__, integer *ldz, doublereal *rhs, doublereal *rdsum, doublereal *rdscal, integer *ipiv, integer *jpiv)
{
    /* System generated locals */
    integer z_dim1, z_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    integer i__, j, k;
    doublereal bm, bp, xm[8], xp[8];
    integer info;
    doublereal temp, work[32];
    doublereal pmone;
    doublereal sminu;
    integer iwork[8];
    doublereal splus;

/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --rhs;
    --ipiv;
    --jpiv;

    /* Function Body */
    if (*ijob != 2) {

/*        Apply permutations IPIV to RHS */

	i__1 = *n - 1;
	dlaswp_(&c__1, &rhs[1], ldz, &c__1, &i__1, &ipiv[1], &c__1);

/*        Solve for L-part choosing RHS either to +1 or -1. */

	pmone = -1.;

	i__1 = *n - 1;
	for (j = 1; j <= i__1; ++j) {
	    bp = rhs[j] + 1.;
	    bm = rhs[j] - 1.;
	    splus = 1.;

/*           Look-ahead for L-part RHS(1:N-1) = + or -1, SPLUS and */
/*           SMIN computed more efficiently than in BSOLVE [1]. */

	    i__2 = *n - j;
	    splus += ddot_(&i__2, &z__[j + 1 + j * z_dim1], &c__1, &z__[j + 1 
		    + j * z_dim1], &c__1);
	    i__2 = *n - j;
	    sminu = ddot_(&i__2, &z__[j + 1 + j * z_dim1], &c__1, &rhs[j + 1],
		     &c__1);
	    splus *= rhs[j];
	    if (splus > sminu) {
		rhs[j] = bp;
	    } else if (sminu > splus) {
		rhs[j] = bm;
	    } else {

/*              In this case the updating sums are equal and we can */
/*              choose RHS(J) +1 or -1. The first time this happens */
/*              we choose -1, thereafter +1. This is a simple way to */
/*              get good estimates of matrices like Byers well-known */
/*              example (see [1]). (Not done in BSOLVE.) */

		rhs[j] += pmone;
		pmone = 1.;
	    }

/*           Compute the remaining r.h.s. */

	    temp = -rhs[j];
	    i__2 = *n - j;
	    daxpy_(&i__2, &temp, &z__[j + 1 + j * z_dim1], &c__1, &rhs[j + 1],
		     &c__1);

/* L10: */
	}

/*        Solve for U-part, look-ahead for RHS(N) = +-1. This is not done */
/*        in BSOLVE and will hopefully give us a better estimate because */
/*        any ill-conditioning of the original matrix is transfered to U */
/*        and not to L. U(N, N) is an approximation to sigma_min(LU). */

	i__1 = *n - 1;
	dcopy_(&i__1, &rhs[1], &c__1, xp, &c__1);
	xp[*n - 1] = rhs[*n] + 1.;
	rhs[*n] += -1.;
	splus = 0.;
	sminu = 0.;
	for (i__ = *n; i__ >= 1; --i__) {
	    temp = 1. / z__[i__ + i__ * z_dim1];
	    xp[i__ - 1] *= temp;
	    rhs[i__] *= temp;
	    i__1 = *n;
	    for (k = i__ + 1; k <= i__1; ++k) {
		xp[i__ - 1] -= xp[k - 1] * (z__[i__ + k * z_dim1] * temp);
		rhs[i__] -= rhs[k] * (z__[i__ + k * z_dim1] * temp);
/* L20: */
	    }
	    splus += (d__1 = xp[i__ - 1], Dymola_abs(d__1));
	    sminu += (d__1 = rhs[i__], Dymola_abs(d__1));
/* L30: */
	}
	if (splus > sminu) {
	    dcopy_(n, xp, &c__1, &rhs[1], &c__1);
	}

/*        Apply the permutations JPIV to the computed solution (RHS) */

	i__1 = *n - 1;
	dlaswp_(&c__1, &rhs[1], ldz, &c__1, &i__1, &jpiv[1], &c_n1);

/*        Compute the sum of squares */

	dlassq_(n, &rhs[1], &c__1, rdscal, rdsum);

    } else {

/*        IJOB = 2, Compute approximate nullvector XM of Z */

	dgecon_("I", n, &z__[z_offset], ldz, &c_b23, &temp, work, iwork, &
		info);
	dcopy_(n, &work[*n], &c__1, xm, &c__1);

/*        Compute RHS */

	i__1 = *n - 1;
	dlaswp_(&c__1, xm, ldz, &c__1, &i__1, &ipiv[1], &c_n1);
	temp = 1. / sqrt(ddot_(n, xm, &c__1, xm, &c__1));
	dscal_(n, &temp, xm, &c__1);
	dcopy_(n, xm, &c__1, xp, &c__1);
	daxpy_(n, &c_b23, &rhs[1], &c__1, xp, &c__1);
	daxpy_(n, &c_b37_dlatdf, xm, &c__1, &rhs[1], &c__1);
	dgesc2_(n, &z__[z_offset], ldz, &rhs[1], &ipiv[1], &jpiv[1], &temp);
	dgesc2_(n, &z__[z_offset], ldz, xp, &ipiv[1], &jpiv[1], &temp);
	if (dasum_(n, xp, &c__1) > dasum_(n, &rhs[1], &c__1)) {
	    dcopy_(n, xp, &c__1, &rhs[1], &c__1);
	}

/*        Compute the sum of squares */

	dlassq_(n, &rhs[1], &c__1, rdscal, rdsum);

    }

    return 0;

/*     End of DLATDF */

} /* dlatdf_ */

/* Subroutine */ static int dpotrf_(const char *uplo, integer *n, doublereal *a, integer *lda, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    integer j, jb, nb;
    logical upper;

/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -4;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DPOTRF", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

/*     Determine the block size for this environment. */

    nb = ilaenv_(&c__1, "DPOTRF", uplo, n, &c_n1, &c_n1, &c_n1);
    if (nb <= 1 || nb >= *n) {

/*        Use unblocked code. */

      dpotf2_((char*) uplo, n, &a[a_offset], lda, info);
    } else {

/*        Use blocked code. */

	if (upper) {

/*           Compute the Cholesky factorization A = U**T*U. */

	    i__1 = *n;
	    i__2 = nb;
	    for (j = 1; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*              Update and factorize the current diagonal block and test */
/*              for non-positive-definiteness. */

/* Computing MIN */
		i__3 = nb, i__4 = *n - j + 1;
		jb = Dymola_min(i__3,i__4);
		i__3 = j - 1;
		dsyrk_("Upper", "Transpose", &jb, &i__3, &c_b13_dpotrf, &a[j * 
			a_dim1 + 1], lda, &c_b14, &a[j + j * a_dim1], lda);
		dpotf2_("Upper", &jb, &a[j + j * a_dim1], lda, info);
		if (*info != 0) {
		    goto L30;
		}
		if (j + jb <= *n) {

/*                 Compute the current block row. */

		    i__3 = *n - j - jb + 1;
		    i__4 = j - 1;
		    dgemm_("Transpose", "No transpose", &jb, &i__3, &i__4, &
			    c_b13_dpotrf, &a[j * a_dim1 + 1], lda, &a[(j + jb) * 
			    a_dim1 + 1], lda, &c_b14, &a[j + (j + jb) * 
			    a_dim1], lda);
		    i__3 = *n - j - jb + 1;
		    dtrsm_("Left", "Upper", "Transpose", "Non-unit", &jb, &
			    i__3, &c_b14, &a[j + j * a_dim1], lda, &a[j + (j 
			    + jb) * a_dim1], lda);
		}
/* L10: */
	    }

	} else {

/*           Compute the Cholesky factorization A = L*L**T. */

	    i__2 = *n;
	    i__1 = nb;
	    for (j = 1; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*              Update and factorize the current diagonal block and test */
/*              for non-positive-definiteness. */

/* Computing MIN */
		i__3 = nb, i__4 = *n - j + 1;
		jb = Dymola_min(i__3,i__4);
		i__3 = j - 1;
		dsyrk_("Lower", "No transpose", &jb, &i__3, &c_b13_dpotrf, &a[j + 
			a_dim1], lda, &c_b14, &a[j + j * a_dim1], lda);
		dpotf2_("Lower", &jb, &a[j + j * a_dim1], lda, info);
		if (*info != 0) {
		    goto L30;
		}
		if (j + jb <= *n) {

/*                 Compute the current block column. */

		    i__3 = *n - j - jb + 1;
		    i__4 = j - 1;
		    dgemm_("No transpose", "Transpose", &i__3, &jb, &i__4, &
			    c_b13_dpotrf, &a[j + jb + a_dim1], lda, &a[j + a_dim1], 
			    lda, &c_b14, &a[j + jb + j * a_dim1], lda);
		    i__3 = *n - j - jb + 1;
		    dtrsm_("Right", "Lower", "Transpose", "Non-unit", &i__3, &
			    jb, &c_b14, &a[j + j * a_dim1], lda, &a[j + jb + 
			    j * a_dim1], lda);
		}
/* L20: */
	    }
	}
    }
    goto L40;

L30:
    *info = *info + j - 1;

L40:
    return 0;

/*     End of DPOTRF */

} /* dpotrf_ */

/* Subroutine */ static int dpotf2_(char *uplo, integer *n, doublereal *a, integer *lda, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublereal d__1;

    /* Local variables */
    integer j;
    doublereal ajj;
    logical upper;

/*  -- LAPACK computational routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -4;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DPOTF2", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

    if (upper) {

/*        Compute the Cholesky factorization A = U**T *U. */

	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {

/*           Compute U(J,J) and test for non-positive-definiteness. */

	    i__2 = j - 1;
	    ajj = a[j + j * a_dim1] - ddot_(&i__2, &a[j * a_dim1 + 1], &c__1, 
		    &a[j * a_dim1 + 1], &c__1);
	    if (ajj <= 0. || disnan_(&ajj)) {
		a[j + j * a_dim1] = ajj;
		goto L30;
	    }
	    ajj = sqrt(ajj);
	    a[j + j * a_dim1] = ajj;

/*           Compute elements J+1:N of row J. */

	    if (j < *n) {
		i__2 = j - 1;
		i__3 = *n - j;
		dgemv_("Transpose", &i__2, &i__3, &c_b10_dpotf2, &a[(j + 1) * a_dim1 
			+ 1], lda, &a[j * a_dim1 + 1], &c__1, &c_b12, &a[j + (
			j + 1) * a_dim1], lda);
		i__2 = *n - j;
		d__1 = 1. / ajj;
		dscal_(&i__2, &d__1, &a[j + (j + 1) * a_dim1], lda);
	    }
/* L10: */
	}
    } else {

/*        Compute the Cholesky factorization A = L*L**T. */

	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {

/*           Compute L(J,J) and test for non-positive-definiteness. */

	    i__2 = j - 1;
	    ajj = a[j + j * a_dim1] - ddot_(&i__2, &a[j + a_dim1], lda, &a[j 
		    + a_dim1], lda);
	    if (ajj <= 0. || disnan_(&ajj)) {
		a[j + j * a_dim1] = ajj;
		goto L30;
	    }
	    ajj = sqrt(ajj);
	    a[j + j * a_dim1] = ajj;

/*           Compute elements J+1:N of column J. */

	    if (j < *n) {
		i__2 = *n - j;
		i__3 = j - 1;
		dgemv_("No transpose", &i__2, &i__3, &c_b10_dpotf2, &a[j + 1 + 
			a_dim1], lda, &a[j + a_dim1], lda, &c_b12, &a[j + 1 + 
			j * a_dim1], &c__1);
		i__2 = *n - j;
		d__1 = 1. / ajj;
		dscal_(&i__2, &d__1, &a[j + 1 + j * a_dim1], &c__1);
	    }
/* L20: */
	}
    }
    goto L40;

L30:
    *info = j;

L40:
    return 0;

/*     End of DPOTF2 */

} /* dpotf2_ */

/* Subroutine */ static int dsyrk_(char *uplo, char *trans, integer *n, integer *k, doublereal *alpha, doublereal *a, integer *lda, doublereal *beta, doublereal *c__, integer *ldc)
{
    /* System generated locals */
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2, i__3;

    /* Local variables */
    integer i__, j, l, info;
    doublereal temp;
    integer nrowa;
    logical upper;

/*  -- Reference BLAS level3 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Parameters .. */
/*     .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;

    /* Function Body */
    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
	nrowa = *n;
    } else {
	nrowa = *k;
    }
    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);

    info = 0;
    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
	info = 1;
    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
	    ftnlen)1)) {
	info = 2;
    } else if (*n < 0) {
	info = 3;
    } else if (*k < 0) {
	info = 4;
    } else if (*lda < Dymola_max(1,nrowa)) {
	info = 7;
    } else if (*ldc < Dymola_max(1,*n)) {
	info = 10;
    }
    if (info != 0) {
	xerbla_("DSYRK ", &info);
	return 0;
    }

/*     Quick return if possible. */

    if (*n == 0 || (*alpha == 0. || *k == 0) && *beta == 1.) {
	return 0;
    }

/*     And when  alpha.eq.zero. */

    if (*alpha == 0.) {
	if (upper) {
	    if (*beta == 0.) {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = j;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] = 0.;
/* L10: */
		    }
/* L20: */
		}
	    } else {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = j;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] = *beta * c__[i__ + j * c_dim1];
/* L30: */
		    }
/* L40: */
		}
	    }
	} else {
	    if (*beta == 0.) {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = *n;
		    for (i__ = j; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] = 0.;
/* L50: */
		    }
/* L60: */
		}
	    } else {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = *n;
		    for (i__ = j; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] = *beta * c__[i__ + j * c_dim1];
/* L70: */
		    }
/* L80: */
		}
	    }
	}
	return 0;
    }

/*     Start the operations. */

    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {

/*        Form  C := alpha*A*A**T + beta*C. */

	if (upper) {
	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		if (*beta == 0.) {
		    i__2 = j;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] = 0.;
/* L90: */
		    }
		} else if (*beta != 1.) {
		    i__2 = j;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] = *beta * c__[i__ + j * c_dim1];
/* L100: */
		    }
		}
		i__2 = *k;
		for (l = 1; l <= i__2; ++l) {
		    if (a[j + l * a_dim1] != 0.) {
			temp = *alpha * a[j + l * a_dim1];
			i__3 = j;
			for (i__ = 1; i__ <= i__3; ++i__) {
			    c__[i__ + j * c_dim1] += temp * a[i__ + l * 
				    a_dim1];
/* L110: */
			}
		    }
/* L120: */
		}
/* L130: */
	    }
	} else {
	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		if (*beta == 0.) {
		    i__2 = *n;
		    for (i__ = j; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] = 0.;
/* L140: */
		    }
		} else if (*beta != 1.) {
		    i__2 = *n;
		    for (i__ = j; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] = *beta * c__[i__ + j * c_dim1];
/* L150: */
		    }
		}
		i__2 = *k;
		for (l = 1; l <= i__2; ++l) {
		    if (a[j + l * a_dim1] != 0.) {
			temp = *alpha * a[j + l * a_dim1];
			i__3 = *n;
			for (i__ = j; i__ <= i__3; ++i__) {
			    c__[i__ + j * c_dim1] += temp * a[i__ + l * 
				    a_dim1];
/* L160: */
			}
		    }
/* L170: */
		}
/* L180: */
	    }
	}
    } else {

/*        Form  C := alpha*A**T*A + beta*C. */

	if (upper) {
	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		i__2 = j;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    temp = 0.;
		    i__3 = *k;
		    for (l = 1; l <= i__3; ++l) {
			temp += a[l + i__ * a_dim1] * a[l + j * a_dim1];
/* L190: */
		    }
		    if (*beta == 0.) {
			c__[i__ + j * c_dim1] = *alpha * temp;
		    } else {
			c__[i__ + j * c_dim1] = *alpha * temp + *beta * c__[
				i__ + j * c_dim1];
		    }
/* L200: */
		}
/* L210: */
	    }
	} else {
	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		i__2 = *n;
		for (i__ = j; i__ <= i__2; ++i__) {
		    temp = 0.;
		    i__3 = *k;
		    for (l = 1; l <= i__3; ++l) {
			temp += a[l + i__ * a_dim1] * a[l + j * a_dim1];
/* L220: */
		    }
		    if (*beta == 0.) {
			c__[i__ + j * c_dim1] = *alpha * temp;
		    } else {
			c__[i__ + j * c_dim1] = *alpha * temp + *beta * c__[
				i__ + j * c_dim1];
		    }
/* L230: */
		}
/* L240: */
	    }
	}
    }

    return 0;

/*     End of DSYRK . */

} /* dsyrk_ */

/* Subroutine */ static int dgees_(char *jobvs, char *sort, L_fp select, integer *n, doublereal *a, integer *lda, integer *sdim, doublereal *wr, doublereal *wi, doublereal *vs, integer *ldvs, doublereal *work, integer *lwork, logical *bwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, vs_dim1, vs_offset, i__1, i__2, i__3;

    /* Local variables */
    integer i__;
    doublereal s;
    integer i1, i2, ip, ihi, ilo;
    doublereal dum[1], eps, sep;
    integer ibal;
    doublereal anrm;
    integer idum[1], ierr, itau, iwrk, inxt, icond, ieval;
    logical cursl;
    logical lst2sl, scalea;
    doublereal cscale;
    doublereal bignum;
    logical lastsl;
    integer minwrk, maxwrk;
    doublereal smlnum;
    integer hswork;
    logical wantst, lquery, wantvs;


/*  -- LAPACK driver routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */
/*     .. Function Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --wr;
    --wi;
    vs_dim1 = *ldvs;
    vs_offset = 1 + vs_dim1;
    vs -= vs_offset;
    --work;
    --bwork;

    /* Function Body */
    *info = 0;
    lquery = *lwork == -1;
    wantvs = lsame_(jobvs, "V", (ftnlen)1, (ftnlen)1);
    wantst = lsame_(sort, "S", (ftnlen)1, (ftnlen)1);
    if (! wantvs && ! lsame_(jobvs, "N", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! wantst && ! lsame_(sort, "N", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (*n < 0) {
	*info = -4;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -6;
    } else if (*ldvs < 1 || wantvs && *ldvs < *n) {
	*info = -11;
    }

/*     Compute workspace */
/*      (Note: Comments in the code beginning "Workspace:" describe the */
/*       minimal amount of workspace needed at that point in the code, */
/*       as well as the preferred amount for good performance. */
/*       NB refers to the optimal block size for the immediately */
/*       following subroutine, as returned by ILAENV. */
/*       HSWORK refers to the workspace preferred by DHSEQR, as */
/*       calculated below. HSWORK is computed assuming ILO=1 and IHI=N, */
/*       the worst case.) */

    if (*info == 0) {
	if (*n == 0) {
	    minwrk = 1;
	    maxwrk = 1;
	} else {
	    maxwrk = (*n << 1) + *n * ilaenv_(&c__1, "DGEHRD", " ", n, &c__1, 
		    n, &c__0);
	    minwrk = *n * 3;

	    dhseqr_("S", jobvs, n, &c__1, n, &a[a_offset], lda, &wr[1], &wi[1]
		    , &vs[vs_offset], ldvs, &work[1], &c_n1, &ieval);
	    hswork = (integer) work[1];

	    if (! wantvs) {
/* Computing MAX */
		i__1 = maxwrk, i__2 = *n + hswork;
		maxwrk = Dymola_max(i__1,i__2);
	    } else {
/* Computing MAX */
		i__1 = maxwrk, i__2 = (*n << 1) + (*n - 1) * ilaenv_(&c__1, 
			"DORGHR", " ", n, &c__1, n, &c_n1);
		maxwrk = Dymola_max(i__1,i__2);
/* Computing MAX */
		i__1 = maxwrk, i__2 = *n + hswork;
		maxwrk = Dymola_max(i__1,i__2);
	    }
	}
	work[1] = (doublereal) maxwrk;

	if (*lwork < minwrk && ! lquery) {
	    *info = -13;
	}
    }

    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGEES ", &i__1);
	return 0;
    } else if (lquery) {
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	*sdim = 0;
	return 0;
    }

/*     Get machine constants */

    eps = dlamch_("P");
    smlnum = dlamch_("S");
    bignum = 1. / smlnum;
    dlabad_(&smlnum, &bignum);
    smlnum = sqrt(smlnum) / eps;
    bignum = 1. / smlnum;

/*     Scale A if max element outside range [SMLNUM,BIGNUM] */

    anrm = dlange_("M", n, n, &a[a_offset], lda, dum);
    scalea = FALSE_;
    if (anrm > 0. && anrm < smlnum) {
	scalea = TRUE_;
	cscale = smlnum;
    } else if (anrm > bignum) {
	scalea = TRUE_;
	cscale = bignum;
    }
    if (scalea) {
	dlascl_("G", &c__0, &c__0, &anrm, &cscale, n, n, &a[a_offset], lda, &
		ierr);
    }

/*     Permute the matrix to make it more nearly triangular */
/*     (Workspace: need N) */

    ibal = 1;
    dgebal_("P", n, &a[a_offset], lda, &ilo, &ihi, &work[ibal], &ierr);

/*     Reduce to upper Hessenberg form */
/*     (Workspace: need 3*N, prefer 2*N+N*NB) */

    itau = *n + ibal;
    iwrk = *n + itau;
    i__1 = *lwork - iwrk + 1;
    dgehrd_(n, &ilo, &ihi, &a[a_offset], lda, &work[itau], &work[iwrk], &i__1,
	     &ierr);

    if (wantvs) {

/*        Copy Householder vectors to VS */

	dlacpy_("L", n, n, &a[a_offset], lda, &vs[vs_offset], ldvs)
		;

/*        Generate orthogonal matrix in VS */
/*        (Workspace: need 3*N-1, prefer 2*N+(N-1)*NB) */

	i__1 = *lwork - iwrk + 1;
	dorghr_(n, &ilo, &ihi, &vs[vs_offset], ldvs, &work[itau], &work[iwrk],
		 &i__1, &ierr);
    }

    *sdim = 0;

/*     Perform QR iteration, accumulating Schur vectors in VS if desired */
/*     (Workspace: need N+1, prefer N+HSWORK (see comments) ) */

    iwrk = itau;
    i__1 = *lwork - iwrk + 1;
    dhseqr_("S", jobvs, n, &ilo, &ihi, &a[a_offset], lda, &wr[1], &wi[1], &vs[
	    vs_offset], ldvs, &work[iwrk], &i__1, &ieval);
    if (ieval > 0) {
	*info = ieval;
    }

/*     Sort eigenvalues if desired */

    if (wantst && *info == 0) {
	if (scalea) {
	    dlascl_("G", &c__0, &c__0, &cscale, &anrm, n, &c__1, &wr[1], n, &
		    ierr);
	    dlascl_("G", &c__0, &c__0, &cscale, &anrm, n, &c__1, &wi[1], n, &
		    ierr);
	}
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    bwork[i__] = (*select)(&wr[i__], &wi[i__]);
/* L10: */
	}

/*        Reorder eigenvalues and transform Schur vectors */
/*        (Workspace: none needed) */

	i__1 = *lwork - iwrk + 1;
	dtrsen_("N", jobvs, &bwork[1], n, &a[a_offset], lda, &vs[vs_offset], 
		ldvs, &wr[1], &wi[1], sdim, &s, &sep, &work[iwrk], &i__1, 
		idum, &c__1, &icond);
	if (icond > 0) {
	    *info = *n + icond;
	}
    }

    if (wantvs) {

/*        Undo balancing */
/*        (Workspace: need N) */

	dgebak_("P", "R", n, &ilo, &ihi, &work[ibal], n, &vs[vs_offset], ldvs,
		 &ierr);
    }

    if (scalea) {

/*        Undo scaling for the Schur form of A */

	dlascl_("H", &c__0, &c__0, &cscale, &anrm, n, n, &a[a_offset], lda, &
		ierr);
	i__1 = *lda + 1;
	dcopy_(n, &a[a_offset], &i__1, &wr[1], &c__1);
	if (cscale == smlnum) {

/*           If scaling back towards underflow, adjust WI if an */
/*           offdiagonal element of a 2-by-2 block in the Schur form */
/*           underflows. */

	    if (ieval > 0) {
		i1 = ieval + 1;
		i2 = ihi - 1;
		i__1 = ilo - 1;
/* Computing MAX */
		i__3 = ilo - 1;
		i__2 = Dymola_max(i__3,1);
		dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wi[
			1], &i__2, &ierr);
	    } else if (wantst) {
		i1 = 1;
		i2 = *n - 1;
	    } else {
		i1 = ilo;
		i2 = ihi - 1;
	    }
	    inxt = i1 - 1;
	    i__1 = i2;
	    for (i__ = i1; i__ <= i__1; ++i__) {
		if (i__ < inxt) {
		    goto L20;
		}
		if (wi[i__] == 0.) {
		    inxt = i__ + 1;
		} else {
		    if (a[i__ + 1 + i__ * a_dim1] == 0.) {
			wi[i__] = 0.;
			wi[i__ + 1] = 0.;
		    } else if (a[i__ + 1 + i__ * a_dim1] != 0. && a[i__ + (
			    i__ + 1) * a_dim1] == 0.) {
			wi[i__] = 0.;
			wi[i__ + 1] = 0.;
			if (i__ > 1) {
			    i__2 = i__ - 1;
			    dswap_(&i__2, &a[i__ * a_dim1 + 1], &c__1, &a[(
				    i__ + 1) * a_dim1 + 1], &c__1);
			}
			if (*n > i__ + 1) {
			    i__2 = *n - i__ - 1;
			    dswap_(&i__2, &a[i__ + (i__ + 2) * a_dim1], lda, &
				    a[i__ + 1 + (i__ + 2) * a_dim1], lda);
			}
			if (wantvs) {
			    dswap_(n, &vs[i__ * vs_dim1 + 1], &c__1, &vs[(i__ 
				    + 1) * vs_dim1 + 1], &c__1);
			}
			a[i__ + (i__ + 1) * a_dim1] = a[i__ + 1 + i__ * 
				a_dim1];
			a[i__ + 1 + i__ * a_dim1] = 0.;
		    }
		    inxt = i__ + 2;
		}
L20:
		;
	    }
	}

/*        Undo scaling for the imaginary part of the eigenvalues */

	i__1 = *n - ieval;
/* Computing MAX */
	i__3 = *n - ieval;
	i__2 = Dymola_max(i__3,1);
	dlascl_("G", &c__0, &c__0, &cscale, &anrm, &i__1, &c__1, &wi[ieval + 
		1], &i__2, &ierr);
    }

    if (wantst && *info == 0) {

/*        Check if reordering successful */

	lastsl = TRUE_;
	lst2sl = TRUE_;
	*sdim = 0;
	ip = 0;
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    cursl = (*select)(&wr[i__], &wi[i__]);
	    if (wi[i__] == 0.) {
		if (cursl) {
		    ++(*sdim);
		}
		ip = 0;
		if (cursl && ! lastsl) {
		    *info = *n + 2;
		}
	    } else {
		if (ip == 1) {

/*                 Last eigenvalue of conjugate pair */

		    cursl = cursl || lastsl;
		    lastsl = cursl;
		    if (cursl) {
			*sdim += 2;
		    }
		    ip = -1;
		    if (cursl && ! lst2sl) {
			*info = *n + 2;
		    }
		} else {

/*                 First eigenvalue of conjugate pair */

		    ip = 1;
		}
	    }
	    lst2sl = lastsl;
	    lastsl = cursl;
/* L30: */
	}
    }

    work[1] = (doublereal) maxwrk;
    return 0;

/*     End of DGEES */

} /* dgees_ */

/* Subroutine */ static int dladiv1_(doublereal *a, doublereal *b, doublereal *c__, doublereal *d__, doublereal *p, doublereal *q)
{
    doublereal r__, t;

/*  -- LAPACK auxiliary routine (version 3.5.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     January 2013 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */

/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    r__ = *d__ / *c__;
    t = 1. / (*c__ + *d__ * r__);
    *p = dladiv2_(a, b, c__, d__, &r__, &t);
    *a = -(*a);
    *q = dladiv2_(b, a, c__, d__, &r__, &t);

    return 0;

/*     End of DLADIV1 */

} /* dladiv1_ */

static doublereal dladiv2_(doublereal *a, doublereal *b, doublereal *c__, doublereal *d__, doublereal *r__, doublereal *t)
{
    /* System generated locals */
    doublereal ret_val;

    /* Local variables */
    doublereal br;


/*  -- LAPACK auxiliary routine (version 3.5.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     January 2013 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */

/*     .. Local Scalars .. */
/*     .. */
/*     .. Executable Statements .. */

    if (*r__ != 0.) {
	br = *b * *r__;
	if (br != 0.) {
	    ret_val = (*a + br) * *t;
	} else {
	    ret_val = *a * *t + *b * *t * *r__;
	}
    } else {
	ret_val = (*a + *d__ * (*b / *c__)) * *t;
    }

    return ret_val;

/*     End of DLADIV12 */

} /* dladiv2_ */

#endif /* DYMOSIM */

/* end: functions merely for Modelica.Math.Matrices.LAPACK functions */

/* Subroutine */ DYMOLA_STATIC int dgesv_(const integer *n, const integer *nrhs, doublereal *a, integer *lda, integer *ipiv, doublereal *b, integer *ldb, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1;

/*  -- LAPACK driver routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    *info = 0;
    if (*n < 0) {
	*info = -1;
    } else if (*nrhs < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -4;
    } else if (*ldb < Dymola_max(1,*n)) {
	*info = -7;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGESV ", &i__1);
	return 0;
    }

/*     Compute the LU factorization of A. */

    dgetrf_(n, n, &a[a_offset], lda, &ipiv[1], info);
    if (*info == 0) {

/*        Solve the system A*X = B, overwriting B with X. */

	dgetrs_("No transpose", n, nrhs, &a[a_offset], lda, &ipiv[1], &b[
		b_offset], ldb, info);
    }
    return 0;

/*     End of DGESV */

} /* dgesv_ */

/* Subroutine */ static int dlacn2_(integer *n, doublereal *v, doublereal *x, integer *isgn, doublereal *est, integer *kase, integer *isave)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Local variables */
    integer i__;
    doublereal temp;
    extern doublereal dasum_(integer *, doublereal *, integer *);
    integer jlast;
    extern integer idamax_(integer *, doublereal *, integer *);
    doublereal altsgn, estold;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    --isave;
    --isgn;
    --x;
    --v;

    /* Function Body */
    if (*kase == 0) {
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    x[i__] = 1. / (doublereal) (*n);
/* L10: */
	}
	*kase = 1;
	isave[1] = 1;
	return 0;
    }

    switch (isave[1]) {
	case 1:  goto L20;
	case 2:  goto L40;
	case 3:  goto L70;
	case 4:  goto L110;
	case 5:  goto L140;
    }

/*     ................ ENTRY   (ISAVE( 1 ) = 1) */
/*     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X. */

L20:
    if (*n == 1) {
	v[1] = x[1];
	*est = Dymola_abs(v[1]);
/*        ... QUIT */
	goto L150;
    }
    *est = dasum_(n, &x[1], &c__1);

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	x[i__] = d_sign(&c_b11, &x[i__]);
	isgn[i__] = i_dnnt(&x[i__]);
/* L30: */
    }
    *kase = 2;
    isave[1] = 2;
    return 0;

/*     ................ ENTRY   (ISAVE( 1 ) = 2) */
/*     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY TRANSPOSE(A)*X. */

L40:
    isave[2] = idamax_(n, &x[1], &c__1);
    isave[3] = 2;

/*     MAIN LOOP - ITERATIONS 2,3,...,ITMAX. */

L50:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	x[i__] = 0.;
/* L60: */
    }
    x[isave[2]] = 1.;
    *kase = 1;
    isave[1] = 3;
    return 0;

/*     ................ ENTRY   (ISAVE( 1 ) = 3) */
/*     X HAS BEEN OVERWRITTEN BY A*X. */

L70:
    dcopy_(n, &x[1], &c__1, &v[1], &c__1);
    estold = *est;
    *est = dasum_(n, &v[1], &c__1);
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	d__1 = d_sign(&c_b11, &x[i__]);
	if (i_dnnt(&d__1) != isgn[i__]) {
	    goto L90;
	}
/* L80: */
    }
/*     REPEATED SIGN VECTOR DETECTED, HENCE ALGORITHM HAS CONVERGED. */
    goto L120;

L90:
/*     TEST FOR CYCLING. */
    if (*est <= estold) {
	goto L120;
    }

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	x[i__] = d_sign(&c_b11, &x[i__]);
	isgn[i__] = i_dnnt(&x[i__]);
/* L100: */
    }
    *kase = 2;
    isave[1] = 4;
    return 0;

/*     ................ ENTRY   (ISAVE( 1 ) = 4) */
/*     X HAS BEEN OVERWRITTEN BY TRANSPOSE(A)*X. */

L110:
    jlast = isave[2];
    isave[2] = idamax_(n, &x[1], &c__1);
    if (x[jlast] != (d__1 = x[isave[2]], Dymola_abs(d__1)) && isave[3] < 5) {
	++isave[3];
	goto L50;
    }

/*     ITERATION COMPLETE.  FINAL STAGE. */

L120:
    altsgn = 1.;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	x[i__] = altsgn * ((doublereal) (i__ - 1) / (doublereal) (*n - 1) + 
		1.);
	altsgn = -altsgn;
/* L130: */
    }
    *kase = 1;
    isave[1] = 5;
    return 0;

/*     ................ ENTRY   (ISAVE( 1 ) = 5) */
/*     X HAS BEEN OVERWRITTEN BY A*X. */

L140:
    temp = dasum_(n, &x[1], &c__1) / (doublereal) (*n * 3) * 2.;
    if (temp > *est) {
	dcopy_(n, &x[1], &c__1, &v[1], &c__1);
	*est = temp;
    }

L150:
    *kase = 0;
    return 0;

/*     End of DLACN2 */

} /* dlacn2_ */

static logical disnan_(doublereal *din)
{
    /* System generated locals */
    logical ret_val;

    /* Local variables */
    extern logical dlaisnan_(doublereal *, doublereal *);


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  ===================================================================== */

/*  .. External Functions .. */
/*  .. */
/*  .. Executable Statements .. */
    ret_val = dlaisnan_(din, din);
    return ret_val;
} /* disnan_ */

static logical dlaisnan_(doublereal *din1, doublereal *din2)
{
    /* System generated locals */
    logical ret_val;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  ===================================================================== */

/*  .. Executable Statements .. */
    ret_val = *din1 != *din2;
    return ret_val;
} /* dlaisnan_ */

/* Subroutine */ static int dtbsv_(char *uplo, char *trans, char *diag, integer *n, integer *k, doublereal *a, integer *lda, doublereal *x, integer *incx)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    integer i__, j, l, ix, jx, kx, info;
    doublereal temp;
    integer kplus1;
    logical nounit;

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  Purpose */
/*  ======= */

/*  DTBSV  solves one of the systems of equations */

/*     A*x = b,   or   A'*x = b, */

/*  where b and x are n element vectors and A is an n by n unit, or */
/*  non-unit, upper or lower triangular band matrix, with ( k + 1 ) */
/*  diagonals. */

/*  No test for singularity or near-singularity is included in this */
/*  routine. Such tests must be performed before calling this routine. */

/*  Arguments */
/*  ========== */

/*  UPLO   - CHARACTER*1. */
/*           On entry, UPLO specifies whether the matrix is an upper or */
/*           lower triangular matrix as follows: */

/*              UPLO = 'U' or 'u'   A is an upper triangular matrix. */

/*              UPLO = 'L' or 'l'   A is a lower triangular matrix. */

/*           Unchanged on exit. */

/*  TRANS  - CHARACTER*1. */
/*           On entry, TRANS specifies the equations to be solved as */
/*           follows: */

/*              TRANS = 'N' or 'n'   A*x = b. */

/*              TRANS = 'T' or 't'   A'*x = b. */

/*              TRANS = 'C' or 'c'   A'*x = b. */

/*           Unchanged on exit. */

/*  DIAG   - CHARACTER*1. */
/*           On entry, DIAG specifies whether or not A is unit */
/*           triangular as follows: */

/*              DIAG = 'U' or 'u'   A is assumed to be unit triangular. */

/*              DIAG = 'N' or 'n'   A is not assumed to be unit */
/*                                  triangular. */

/*           Unchanged on exit. */

/*  N      - INTEGER. */
/*           On entry, N specifies the order of the matrix A. */
/*           N must be at least zero. */
/*           Unchanged on exit. */

/*  K      - INTEGER. */
/*           On entry with UPLO = 'U' or 'u', K specifies the number of */
/*           super-diagonals of the matrix A. */
/*           On entry with UPLO = 'L' or 'l', K specifies the number of */
/*           sub-diagonals of the matrix A. */
/*           K must satisfy  0 .le. K. */
/*           Unchanged on exit. */

/*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ). */
/*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 ) */
/*           by n part of the array A must contain the upper triangular */
/*           band part of the matrix of coefficients, supplied column by */
/*           column, with the leading diagonal of the matrix in row */
/*           ( k + 1 ) of the array, the first super-diagonal starting at */
/*           position 2 in row k, and so on. The top left k by k triangle */
/*           of the array A is not referenced. */
/*           The following program segment will transfer an upper */
/*           triangular band matrix from conventional full matrix storage */
/*           to band storage: */

/*                 DO 20, J = 1, N */
/*                    M = K + 1 - J */
/*                    DO 10, I = MAX( 1, J - K ), J */
/*                       A( M + I, J ) = matrix( I, J ) */
/*              10    CONTINUE */
/*              20 CONTINUE */

/*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) */
/*           by n part of the array A must contain the lower triangular */
/*           band part of the matrix of coefficients, supplied column by */
/*           column, with the leading diagonal of the matrix in row 1 of */
/*           the array, the first sub-diagonal starting at position 1 in */
/*           row 2, and so on. The bottom right k by k triangle of the */
/*           array A is not referenced. */
/*           The following program segment will transfer a lower */
/*           triangular band matrix from conventional full matrix storage */
/*           to band storage: */

/*                 DO 20, J = 1, N */
/*                    M = 1 - J */
/*                    DO 10, I = J, MIN( N, J + K ) */
/*                       A( M + I, J ) = matrix( I, J ) */
/*              10    CONTINUE */
/*              20 CONTINUE */

/*           Note that when DIAG = 'U' or 'u' the elements of the array A */
/*           corresponding to the diagonal elements of the matrix are not */
/*           referenced, but are assumed to be unity. */
/*           Unchanged on exit. */

/*  LDA    - INTEGER. */
/*           On entry, LDA specifies the first dimension of A as declared */
/*           in the calling (sub) program. LDA must be at least */
/*           ( k + 1 ). */
/*           Unchanged on exit. */

/*  X      - DOUBLE PRECISION array of dimension at least */
/*           ( 1 + ( n - 1 )*Dymola_abs( INCX ) ). */
/*           Before entry, the incremented array X must contain the n */
/*           element right-hand side vector b. On exit, X is overwritten */
/*           with the solution vector x. */

/*  INCX   - INTEGER. */
/*           On entry, INCX specifies the increment for the elements of */
/*           X. INCX must not be zero. */
/*           Unchanged on exit. */


/*  Level 2 Blas routine. */

/*  -- Written on 22-October-1986. */
/*     Jack Dongarra, Argonne National Lab. */
/*     Jeremy Du Croz, Nag Central Office. */
/*     Sven Hammarling, Nag Central Office. */
/*     Richard Hanson, Sandia National Labs. */


/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --x;

    /* Function Body */
    info = 0;
    if (! lsame_(uplo, "U", 1, 1) && ! lsame_(uplo, "L", 1, 1)) {
	info = 1;
    } else if (! lsame_(trans, "N", 1, 1) && ! lsame_(trans, 
	    "T", 1, 1) && ! lsame_(trans, "C", 1, 1)) {
	info = 2;
    } else if (! lsame_(diag, "U", 1, 1) && ! lsame_(diag, 
	    "N", 1, 1)) {
	info = 3;
    } else if (*n < 0) {
	info = 4;
    } else if (*k < 0) {
	info = 5;
    } else if (*lda < *k + 1) {
	info = 7;
    } else if (*incx == 0) {
	info = 9;
    }
    if (info != 0) {
	xerbla_("DTBSV ", &info);
	return 0;
    }

/*     Quick return if possible. */

    if (*n == 0) {
	return 0;
    }

    nounit = lsame_(diag, "N", 1, 1);

/*     Set up the start point in X if the increment is not unity. This */
/*     will be  ( N - 1 )*INCX  too small for descending loops. */

    if (*incx <= 0) {
	kx = 1 - (*n - 1) * *incx;
    } else if (*incx != 1) {
	kx = 1;
    }

/*     Start the operations. In this version the elements of A are */
/*     accessed by sequentially with one pass through A. */

    if (lsame_(trans, "N", 1, 1)) {

/*        Form  x := inv( A )*x. */

	if (lsame_(uplo, "U", 1, 1)) {
	    kplus1 = *k + 1;
	    if (*incx == 1) {
		for (j = *n; j >= 1; --j) {
		    if (x[j] != 0.) {
			l = kplus1 - j;
			if (nounit) {
			    x[j] /= a[kplus1 + j * a_dim1];
			}
			temp = x[j];
/* Computing MAX */
			i__2 = 1, i__3 = j - *k;
			i__1 = Dymola_max(i__2,i__3);
			for (i__ = j - 1; i__ >= i__1; --i__) {
			    x[i__] -= temp * a[l + i__ + j * a_dim1];
/* L10: */
			}
		    }
/* L20: */
		}
	    } else {
		kx += (*n - 1) * *incx;
		jx = kx;
		for (j = *n; j >= 1; --j) {
		    kx -= *incx;
		    if (x[jx] != 0.) {
			ix = kx;
			l = kplus1 - j;
			if (nounit) {
			    x[jx] /= a[kplus1 + j * a_dim1];
			}
			temp = x[jx];
/* Computing MAX */
			i__2 = 1, i__3 = j - *k;
			i__1 = Dymola_max(i__2,i__3);
			for (i__ = j - 1; i__ >= i__1; --i__) {
			    x[ix] -= temp * a[l + i__ + j * a_dim1];
			    ix -= *incx;
/* L30: */
			}
		    }
		    jx -= *incx;
/* L40: */
		}
	    }
	} else {
	    if (*incx == 1) {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    if (x[j] != 0.) {
			l = 1 - j;
			if (nounit) {
			    x[j] /= a[j * a_dim1 + 1];
			}
			temp = x[j];
/* Computing MIN */
			i__3 = *n, i__4 = j + *k;
			i__2 = Dymola_min(i__3,i__4);
			for (i__ = j + 1; i__ <= i__2; ++i__) {
			    x[i__] -= temp * a[l + i__ + j * a_dim1];
/* L50: */
			}
		    }
/* L60: */
		}
	    } else {
		jx = kx;
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    kx += *incx;
		    if (x[jx] != 0.) {
			ix = kx;
			l = 1 - j;
			if (nounit) {
			    x[jx] /= a[j * a_dim1 + 1];
			}
			temp = x[jx];
/* Computing MIN */
			i__3 = *n, i__4 = j + *k;
			i__2 = Dymola_min(i__3,i__4);
			for (i__ = j + 1; i__ <= i__2; ++i__) {
			    x[ix] -= temp * a[l + i__ + j * a_dim1];
			    ix += *incx;
/* L70: */
			}
		    }
		    jx += *incx;
/* L80: */
		}
	    }
	}
    } else {

/*        Form  x := inv( A')*x. */

	if (lsame_(uplo, "U", 1, 1)) {
	    kplus1 = *k + 1;
	    if (*incx == 1) {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    temp = x[j];
		    l = kplus1 - j;
/* Computing MAX */
		    i__2 = 1, i__3 = j - *k;
		    i__4 = j - 1;
		    for (i__ = Dymola_max(i__2,i__3); i__ <= i__4; ++i__) {
			temp -= a[l + i__ + j * a_dim1] * x[i__];
/* L90: */
		    }
		    if (nounit) {
			temp /= a[kplus1 + j * a_dim1];
		    }
		    x[j] = temp;
/* L100: */
		}
	    } else {
		jx = kx;
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    temp = x[jx];
		    ix = kx;
		    l = kplus1 - j;
/* Computing MAX */
		    i__4 = 1, i__2 = j - *k;
		    i__3 = j - 1;
		    for (i__ = Dymola_max(i__4,i__2); i__ <= i__3; ++i__) {
			temp -= a[l + i__ + j * a_dim1] * x[ix];
			ix += *incx;
/* L110: */
		    }
		    if (nounit) {
			temp /= a[kplus1 + j * a_dim1];
		    }
		    x[jx] = temp;
		    jx += *incx;
		    if (j > *k) {
			kx += *incx;
		    }
/* L120: */
		}
	    }
	} else {
	    if (*incx == 1) {
		for (j = *n; j >= 1; --j) {
		    temp = x[j];
		    l = 1 - j;
/* Computing MIN */
		    i__1 = *n, i__3 = j + *k;
		    i__4 = j + 1;
		    for (i__ = Dymola_min(i__1,i__3); i__ >= i__4; --i__) {
			temp -= a[l + i__ + j * a_dim1] * x[i__];
/* L130: */
		    }
		    if (nounit) {
			temp /= a[j * a_dim1 + 1];
		    }
		    x[j] = temp;
/* L140: */
		}
	    } else {
		kx += (*n - 1) * *incx;
		jx = kx;
		for (j = *n; j >= 1; --j) {
		    temp = x[jx];
		    ix = kx;
		    l = 1 - j;
/* Computing MIN */
		    i__4 = *n, i__1 = j + *k;
		    i__3 = j + 1;
		    for (i__ = Dymola_min(i__4,i__1); i__ >= i__3; --i__) {
			temp -= a[l + i__ + j * a_dim1] * x[ix];
			ix -= *incx;
/* L150: */
		    }
		    if (nounit) {
			temp /= a[j * a_dim1 + 1];
		    }
		    x[jx] = temp;
		    jx -= *incx;
		    if (*n - j >= *k) {
			kx -= *incx;
		    }
/* L160: */
		}
	    }
	}
    }

    return 0;

/*     End of DTBSV . */

} /* dtbsv_ */


static integer ieeeck_(integer *ispec, real *zero, real *one)
{
    /* System generated locals */
    integer ret_val;

    /* Local variables */
    real nan1, nan2, nan3, nan4, nan5, nan6, neginf, posinf, negzro, newzro;


/*  -- LAPACK auxiliary routine (version 3.2) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. */
/*     November 2006 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  Purpose */
/*  ======= */

/*  IEEECK is called from the ILAENV to verify that Infinity and */
/*  possibly NaN arithmetic is safe (i.e. will not trap). */

/*  Arguments */
/*  ========= */

/*  ISPEC   (input) INTEGER */
/*          Specifies whether to test just for inifinity arithmetic */
/*          or whether to test for infinity and NaN arithmetic. */
/*          = 0: Verify infinity arithmetic only. */
/*          = 1: Verify infinity and NaN arithmetic. */

/*  ZERO    (input) REAL */
/*          Must contain the value 0.0 */
/*          This is passed to prevent the compiler from optimizing */
/*          away this code. */

/*  ONE     (input) REAL */
/*          Must contain the value 1.0 */
/*          This is passed to prevent the compiler from optimizing */
/*          away this code. */

/*  RETURN VALUE:  INTEGER */
/*          = 0:  Arithmetic failed to produce the correct answers */
/*          = 1:  Arithmetic produced the correct answers */

/*     .. Local Scalars .. */
/*     .. */
/*     .. Executable Statements .. */
    ret_val = 1;

    posinf = *one / *zero;
    if (posinf <= *one) {
	ret_val = 0;
	return ret_val;
    }

    neginf = -(*one) / *zero;
    if (neginf >= *zero) {
	ret_val = 0;
	return ret_val;
    }

    negzro = *one / (neginf + *one);
    if (negzro != *zero) {
	ret_val = 0;
	return ret_val;
    }

    neginf = *one / negzro;
    if (neginf >= *zero) {
	ret_val = 0;
	return ret_val;
    }

    newzro = negzro + *zero;
    if (newzro != *zero) {
	ret_val = 0;
	return ret_val;
    }

    posinf = *one / newzro;
    if (posinf <= *one) {
	ret_val = 0;
	return ret_val;
    }

    neginf *= posinf;
    if (neginf >= *zero) {
	ret_val = 0;
	return ret_val;
    }

    posinf *= posinf;
    if (posinf <= *one) {
	ret_val = 0;
	return ret_val;
    }




/*     Return if we were only asked to check infinity arithmetic */

    if (*ispec == 0) {
	return ret_val;
    }

    nan1 = posinf + neginf;

    nan2 = posinf / neginf;

    nan3 = posinf / posinf;

    nan4 = posinf * *zero;

    nan5 = neginf * negzro;

    nan6 = nan5 * 0.f;

    if (nan1 == nan1) {
	ret_val = 0;
	return ret_val;
    }

    if (nan2 == nan2) {
	ret_val = 0;
	return ret_val;
    }

    if (nan3 == nan3) {
	ret_val = 0;
	return ret_val;
    }

    if (nan4 == nan4) {
	ret_val = 0;
	return ret_val;
    }

    if (nan5 == nan5) {
	ret_val = 0;
	return ret_val;
    }

    if (nan6 == nan6) {
	ret_val = 0;
	return ret_val;
    }

    return ret_val;
} /* ieeeck_ */

static integer iladlc_(integer *m, integer *n, doublereal *a, integer *lda)
{
    /* System generated locals */
    integer a_dim1, a_offset, ret_val, i__1;

    /* Local variables */
    integer i__;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Quick test for the common case where one corner is non-zero. */
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    if (*n == 0) {
	ret_val = *n;
    } else if (a[*n * a_dim1 + 1] != 0. || a[*m + *n * a_dim1] != 0.) {
	ret_val = *n;
    } else {
/*     Now scan each column from the end, returning with the first non-zero. */
	for (ret_val = *n; ret_val >= 1; --ret_val) {
	    i__1 = *m;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		if (a[i__ + ret_val * a_dim1] != 0.) {
		    return ret_val;
		}
	    }
	}
    }
    return ret_val;
} /* iladlc_ */

static integer iladlr_(integer *m, integer *n, doublereal *a, integer *lda)
{
    /* System generated locals */
    integer a_dim1, a_offset, ret_val, i__1;

    /* Local variables */
    integer i__, j;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Quick test for the common case where one corner is non-zero. */
    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    if (*m == 0) {
	ret_val = *m;
    } else if (a[*m + a_dim1] != 0. || a[*m + *n * a_dim1] != 0.) {
	ret_val = *m;
    } else {
/*     Scan up each column tracking the last zero row seen. */
	ret_val = 0;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__ = *m;
	    while(a[Dymola_max(i__,1) + j * a_dim1] == 0. && i__ >= 1) {
		--i__;
	    }
	    ret_val = Dymola_max(ret_val,i__);
	}
    }
    return ret_val;
} /* iladlr_ */

static integer iparmq_(integer *ispec, char *name__, char *opts, integer *n, integer 
	*ilo, integer *ihi, integer *lwork)
{
    /* System generated locals */
    integer ret_val, i__1, i__2;
    real r__1;

    /* Local variables */
    integer nh, ns;


/*  -- LAPACK auxiliary routine (version 3.2) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. */
/*     November 2006 */

/*     .. Scalar Arguments .. */

/*  Purpose */
/*  ======= */

/*       This program sets problem and machine dependent parameters */
/*       useful for xHSEQR and its subroutines. It is called whenever */
/*       ILAENV is called with 12 <= ISPEC <= 16 */

/*  Arguments */
/*  ========= */

/*       ISPEC  (input) integer scalar */
/*              ISPEC specifies which tunable parameter IPARMQ should */
/*              return. */

/*              ISPEC=12: (INMIN)  Matrices of order nmin or less */
/*                        are sent directly to xLAHQR, the implicit */
/*                        double shift QR algorithm.  NMIN must be */
/*                        at least 11. */

/*              ISPEC=13: (INWIN)  Size of the deflation window. */
/*                        This is best set greater than or equal to */
/*                        the number of simultaneous shifts NS. */
/*                        Larger matrices benefit from larger deflation */
/*                        windows. */

/*              ISPEC=14: (INIBL) Determines when to stop nibbling and */
/*                        invest in an (expensive) multi-shift QR sweep. */
/*                        If the aggressive early deflation subroutine */
/*                        finds LD converged eigenvalues from an order */
/*                        NW deflation window and LD.GT.(NW*NIBBLE)/100, */
/*                        then the next QR sweep is skipped and early */
/*                        deflation is applied immediately to the */
/*                        remaining active diagonal block.  Setting */
/*                        IPARMQ(ISPEC=14) = 0 causes TTQRE to skip a */
/*                        multi-shift QR sweep whenever early deflation */
/*                        finds a converged eigenvalue.  Setting */
/*                        IPARMQ(ISPEC=14) greater than or equal to 100 */
/*                        prevents TTQRE from skipping a multi-shift */
/*                        QR sweep. */

/*              ISPEC=15: (NSHFTS) The number of simultaneous shifts in */
/*                        a multi-shift QR iteration. */

/*              ISPEC=16: (IACC22) IPARMQ is set to 0, 1 or 2 with the */
/*                        following meanings. */
/*                        0:  During the multi-shift QR sweep, */
/*                            xLAQR5 does not accumulate reflections and */
/*                            does not use matrix-matrix multiply to */
/*                            update the far-from-diagonal matrix */
/*                            entries. */
/*                        1:  During the multi-shift QR sweep, */
/*                            xLAQR5 and/or xLAQRaccumulates reflections and uses */
/*                            matrix-matrix multiply to update the */
/*                            far-from-diagonal matrix entries. */
/*                        2:  During the multi-shift QR sweep. */
/*                            xLAQR5 accumulates reflections and takes */
/*                            advantage of 2-by-2 block structure during */
/*                            matrix-matrix multiplies. */
/*                        (If xTRMM is slower than xGEMM, then */
/*                        IPARMQ(ISPEC=16)=1 may be more efficient than */
/*                        IPARMQ(ISPEC=16)=2 despite the greater level of */
/*                        arithmetic work implied by the latter choice.) */

/*       NAME    (input) character string */
/*               Name of the calling subroutine */

/*       OPTS    (input) character string */
/*               This is a concatenation of the string arguments to */
/*               TTQRE. */

/*       N       (input) integer scalar */
/*               N is the order of the Hessenberg matrix H. */

/*       ILO     (input) INTEGER */
/*       IHI     (input) INTEGER */
/*               It is assumed that H is already upper triangular */
/*               in rows and columns 1:ILO-1 and IHI+1:N. */

/*       LWORK   (input) integer scalar */
/*               The amount of workspace available. */

/*  Further Details */
/*  =============== */

/*       Little is known about how best to choose these parameters. */
/*       It is possible to use different values of the parameters */
/*       for each of CHSEQR, DHSEQR, SHSEQR and ZHSEQR. */

/*       It is probably best to choose different parameters for */
/*       different matrices and different parameters at different */
/*       times during the iteration, but this has not been */
/*       implemented --- yet. */


/*       The best choices of most of the parameters depend */
/*       in an ill-understood way on the relative execution */
/*       rate of xLAQR3 and xLAQR5 and on the nature of each */
/*       particular eigenvalue problem.  Experiment may be the */
/*       only practical way to determine which choices are most */
/*       effective. */

/*       Following is a list of default values supplied by IPARMQ. */
/*       These defaults may be adjusted in order to attain better */
/*       performance in any particular computational environment. */

/*       IPARMQ(ISPEC=12) The xLAHQR vs xLAQR0 crossover point. */
/*                        Default: 75. (Must be at least 11.) */

/*       IPARMQ(ISPEC=13) Recommended deflation window size. */
/*                        This depends on ILO, IHI and NS, the */
/*                        number of simultaneous shifts returned */
/*                        by IPARMQ(ISPEC=15).  The default for */
/*                        (IHI-ILO+1).LE.500 is NS.  The default */
/*                        for (IHI-ILO+1).GT.500 is 3*NS/2. */

/*       IPARMQ(ISPEC=14) Nibble crossover point.  Default: 14. */

/*       IPARMQ(ISPEC=15) Number of simultaneous shifts, NS. */
/*                        a multi-shift QR iteration. */

/*                        If IHI-ILO+1 is ... */

/*                        greater than      ...but less    ... the */
/*                        or equal to ...      than        default is */

/*                                0               30       NS =   2+ */
/*                               30               60       NS =   4+ */
/*                               60              150       NS =  10 */
/*                              150              590       NS =  ** */
/*                              590             3000       NS =  64 */
/*                             3000             6000       NS = 128 */
/*                             6000             infinity   NS = 256 */

/*                    (+)  By default matrices of this order are */
/*                         passed to the implicit double shift routine */
/*                         xLAHQR.  See IPARMQ(ISPEC=12) above.   These */
/*                         values of NS are used only in case of a rare */
/*                         xLAHQR failure. */

/*                    (**) The asterisks (**) indicate an ad-hoc */
/*                         function increasing from 10 to 64. */

/*       IPARMQ(ISPEC=16) Select structured matrix multiply. */
/*                        (See ISPEC=16 above for details.) */
/*                        Default: 3. */

/*     ================================================================ */
/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */
    if (*ispec == 15 || *ispec == 13 || *ispec == 16) {

/*        ==== Set the number simultaneous shifts ==== */

	nh = *ihi - *ilo + 1;
	ns = 2;
	if (nh >= 30) {
	    ns = 4;
	}
	if (nh >= 60) {
	    ns = 10;
	}
	if (nh >= 150) {
/* Computing MAX */
	    r__1 = (real)(log((real) nh) / log(2.f));
	    i__1 = 10, i__2 = nh / i_nint(&r__1);
	    ns = Dymola_max(i__1,i__2);
	}
	if (nh >= 590) {
	    ns = 64;
	}
	if (nh >= 3000) {
	    ns = 128;
	}
	if (nh >= 6000) {
	    ns = 256;
	}
/* Computing MAX */
	i__1 = 2, i__2 = ns - ns % 2;
	ns = Dymola_max(i__1,i__2);
    }

    if (*ispec == 12) {


/*        ===== Matrices of order smaller than NMIN get sent */
/*        .     to xLAHQR, the classic double shift algorithm. */
/*        .     This must be at least 11. ==== */

	ret_val = 75;

    } else if (*ispec == 14) {

/*        ==== INIBL: skip a multi-shift qr iteration and */
/*        .    whenever aggressive early deflation finds */
/*        .    at least (NIBBLE*(window size)/100) deflations. ==== */

	ret_val = 14;

    } else if (*ispec == 15) {

/*        ==== NSHFTS: The number of simultaneous shifts ===== */

	ret_val = ns;

    } else if (*ispec == 13) {

/*        ==== NW: deflation window size.  ==== */

	if (nh <= 500) {
	    ret_val = ns;
	} else {
	    ret_val = ns * 3 / 2;
	}

    } else if (*ispec == 16) {

/*        ==== IACC22: Whether to accumulate reflections */
/*        .     before updating the far-from-diagonal elements */
/*        .     and whether to use 2-by-2 block structure while */
/*        .     doing it.  A small amount of work could be saved */
/*        .     by making this choice dependent also upon the */
/*        .     NH=IHI-ILO+1. */

	ret_val = 0;
	if (ns >= 14) {
	    ret_val = 1;
	}
	if (ns >= 14) {
	    ret_val = 2;
	}

    } else {
/*        ===== invalid value of ispec ===== */
	ret_val = -1;

    }

/*     ==== End of IPARMQ ==== */

    return ret_val;
} /* iparmq_ */


/* Subroutine */ DYMOLA_STATIC int dgemm_(const char*transa,const char*transb,const integer*m,const integer*n,const integer * k,const doublereal*alpha,doublereal * a,const integer*lda,doublereal * b,const integer*ldb, const doublereal*beta,doublereal * c__, const integer*ldc)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2, 
	    i__3;

    /* Local variables */
    integer i__, j, l, info;
    logical nota, notb;
    doublereal temp;
    integer ncola;
    integer nrowa, nrowb;


/*  -- Reference BLAS level3 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Parameters .. */
/*     .. */

/*     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not */
/*     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows */
/*     and  columns of  A  and the  number of  rows  of  B  respectively. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;

    /* Function Body */
    nota = lsame_(transa, "N", (ftnlen)1, (ftnlen)1);
    notb = lsame_(transb, "N", (ftnlen)1, (ftnlen)1);
    if (nota) {
	nrowa = *m;
	ncola = *k;
    } else {
	nrowa = *k;
	ncola = *m;
    }
    if (notb) {
	nrowb = *k;
    } else {
	nrowb = *n;
    }

/*     Test the input parameters. */

    info = 0;
    if (! nota && ! lsame_(transa, "C", (ftnlen)1, (ftnlen)1) && ! lsame_(
	    transa, "T", (ftnlen)1, (ftnlen)1)) {
	info = 1;
    } else if (! notb && ! lsame_(transb, "C", (ftnlen)1, (ftnlen)1) && ! 
	    lsame_(transb, "T", (ftnlen)1, (ftnlen)1)) {
	info = 2;
    } else if (*m < 0) {
	info = 3;
    } else if (*n < 0) {
	info = 4;
    } else if (*k < 0) {
	info = 5;
    } else if (*lda < Dymola_max(1,nrowa)) {
	info = 8;
    } else if (*ldb < Dymola_max(1,nrowb)) {
	info = 10;
    } else if (*ldc < Dymola_max(1,*m)) {
	info = 13;
    }
    if (info != 0) {
	xerbla_("DGEMM ", &info);
	return 0;
    }

/*     Quick return if possible. */

    if (*m == 0 || *n == 0 || (*alpha == 0. || *k == 0) && *beta == 1.) {
	return 0;
    }

/*     And if  alpha.eq.zero. */

    if (*alpha == 0.) {
	if (*beta == 0.) {
	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    c__[i__ + j * c_dim1] = 0.;
/* L10: */
		}
/* L20: */
	    }
	} else {
	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    c__[i__ + j * c_dim1] = *beta * c__[i__ + j * c_dim1];
/* L30: */
		}
/* L40: */
	    }
	}
	return 0;
    }

/*     Start the operations. */

    if (notb) {
	if (nota) {

/*           Form  C := alpha*A*B + beta*C. */

	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		if (*beta == 0.) {
		    i__2 = *m;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] = 0.;
/* L50: */
		    }
		} else if (*beta != 1.) {
		    i__2 = *m;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] = *beta * c__[i__ + j * c_dim1];
/* L60: */
		    }
		}
		i__2 = *k;
		for (l = 1; l <= i__2; ++l) {
		    if (b[l + j * b_dim1] != 0.) {
			temp = *alpha * b[l + j * b_dim1];
			i__3 = *m;
			for (i__ = 1; i__ <= i__3; ++i__) {
			    c__[i__ + j * c_dim1] += temp * a[i__ + l * 
				    a_dim1];
/* L70: */
			}
		    }
/* L80: */
		}
/* L90: */
	    }
	} else {

/*           Form  C := alpha*A**T*B + beta*C */

	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    temp = 0.;
		    i__3 = *k;
		    for (l = 1; l <= i__3; ++l) {
			temp += a[l + i__ * a_dim1] * b[l + j * b_dim1];
/* L100: */
		    }
		    if (*beta == 0.) {
			c__[i__ + j * c_dim1] = *alpha * temp;
		    } else {
			c__[i__ + j * c_dim1] = *alpha * temp + *beta * c__[
				i__ + j * c_dim1];
		    }
/* L110: */
		}
/* L120: */
	    }
	}
    } else {
	if (nota) {

/*           Form  C := alpha*A*B**T + beta*C */

	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		if (*beta == 0.) {
		    i__2 = *m;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] = 0.;
/* L130: */
		    }
		} else if (*beta != 1.) {
		    i__2 = *m;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			c__[i__ + j * c_dim1] = *beta * c__[i__ + j * c_dim1];
/* L140: */
		    }
		}
		i__2 = *k;
		for (l = 1; l <= i__2; ++l) {
		    if (b[j + l * b_dim1] != 0.) {
			temp = *alpha * b[j + l * b_dim1];
			i__3 = *m;
			for (i__ = 1; i__ <= i__3; ++i__) {
			    c__[i__ + j * c_dim1] += temp * a[i__ + l * 
				    a_dim1];
/* L150: */
			}
		    }
/* L160: */
		}
/* L170: */
	    }
	} else {

/*           Form  C := alpha*A**T*B**T + beta*C */

	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    temp = 0.;
		    i__3 = *k;
		    for (l = 1; l <= i__3; ++l) {
			temp += a[l + i__ * a_dim1] * b[j + l * b_dim1];
/* L180: */
		    }
		    if (*beta == 0.) {
			c__[i__ + j * c_dim1] = *alpha * temp;
		    } else {
			c__[i__ + j * c_dim1] = *alpha * temp + *beta * c__[
				i__ + j * c_dim1];
		    }
/* L190: */
		}
/* L200: */
	    }
	}
    }

    return 0;

/*     End of DGEMM . */

} /* dgemm_ */

/* Subroutine */ 
LIBDS_API int dgemv_(char *trans, integer *m, integer *n, doublereal *alpha, doublereal *a, integer *lda, doublereal *x, integer *incx, doublereal *beta, doublereal *y, integer *incy)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    integer i__, j, ix, iy, jx, jy, kx, ky, info;
    doublereal temp;
    integer lenx, leny;

/*  -- Reference BLAS level2 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --x;
    --y;

    /* Function Body */
    info = 0;
    if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "T", (
	    ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (ftnlen)1)
	    ) {
	info = 1;
    } else if (*m < 0) {
	info = 2;
    } else if (*n < 0) {
	info = 3;
    } else if (*lda < Dymola_max(1,*m)) {
	info = 6;
    } else if (*incx == 0) {
	info = 8;
    } else if (*incy == 0) {
	info = 11;
    }
    if (info != 0) {
	xerbla_("DGEMV ", &info);
	return 0;
    }

/*     Quick return if possible. */

    if (*m == 0 || *n == 0 || *alpha == 0. && *beta == 1.) {
	return 0;
    }

/*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set */
/*     up the start points in  X  and  Y. */

    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {
	lenx = *n;
	leny = *m;
    } else {
	lenx = *m;
	leny = *n;
    }
    if (*incx > 0) {
	kx = 1;
    } else {
	kx = 1 - (lenx - 1) * *incx;
    }
    if (*incy > 0) {
	ky = 1;
    } else {
	ky = 1 - (leny - 1) * *incy;
    }

/*     Start the operations. In this version the elements of A are */
/*     accessed sequentially with one pass through A. */

/*     First form  y := beta*y. */

    if (*beta != 1.) {
	if (*incy == 1) {
	    if (*beta == 0.) {
		i__1 = leny;
		for (i__ = 1; i__ <= i__1; ++i__) {
		    y[i__] = 0.;
/* L10: */
		}
	    } else {
		i__1 = leny;
		for (i__ = 1; i__ <= i__1; ++i__) {
		    y[i__] = *beta * y[i__];
/* L20: */
		}
	    }
	} else {
	    iy = ky;
	    if (*beta == 0.) {
		i__1 = leny;
		for (i__ = 1; i__ <= i__1; ++i__) {
		    y[iy] = 0.;
		    iy += *incy;
/* L30: */
		}
	    } else {
		i__1 = leny;
		for (i__ = 1; i__ <= i__1; ++i__) {
		    y[iy] = *beta * y[iy];
		    iy += *incy;
/* L40: */
		}
	    }
	}
    }
    if (*alpha == 0.) {
	return 0;
    }
    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {

/*        Form  y := alpha*A*x + y. */

	jx = kx;
	if (*incy == 1) {
	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		if (x[jx] != 0.) {
		    temp = *alpha * x[jx];
		    i__2 = *m;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			y[i__] += temp * a[i__ + j * a_dim1];
/* L50: */
		    }
		}
		jx += *incx;
/* L60: */
	    }
	} else {
	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		if (x[jx] != 0.) {
		    temp = *alpha * x[jx];
		    iy = ky;
		    i__2 = *m;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			y[iy] += temp * a[i__ + j * a_dim1];
			iy += *incy;
/* L70: */
		    }
		}
		jx += *incx;
/* L80: */
	    }
	}
    } else {

/*        Form  y := alpha*A**T*x + y. */

	jy = ky;
	if (*incx == 1) {
	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		temp = 0.;
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    temp += a[i__ + j * a_dim1] * x[i__];
/* L90: */
		}
		y[jy] += *alpha * temp;
		jy += *incy;
/* L100: */
	    }
	} else {
	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		temp = 0.;
		ix = kx;
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    temp += a[i__ + j * a_dim1] * x[ix];
		    ix += *incx;
/* L110: */
		}
		y[jy] += *alpha * temp;
		jy += *incy;
/* L120: */
	    }
	}
    }

    return 0;

/*     End of DGEMV . */

} /* dgemv_ */

/* Subroutine */ DYMOLA_STATIC int dger_(const integer*m,const integer*n,const doublereal*alpha,doublereal*x,const integer*incx,doublereal*y,const integer*incy, doublereal*a,const integer*lda)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    integer i__, j, ix, jy, kx, info;
    doublereal temp;

/*  -- Reference BLAS level2 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    --x;
    --y;
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    info = 0;
    if (*m < 0) {
	info = 1;
    } else if (*n < 0) {
	info = 2;
    } else if (*incx == 0) {
	info = 5;
    } else if (*incy == 0) {
	info = 7;
    } else if (*lda < Dymola_max(1,*m)) {
	info = 9;
    }
    if (info != 0) {
      xerbla_("DGER  ", &info);
	return 0;
    }

/*     Quick return if possible. */

    if (*m == 0 || *n == 0 || *alpha == 0.) {
	return 0;
    }

/*     Start the operations. In this version the elements of A are */
/*     accessed sequentially with one pass through A. */

    if (*incy > 0) {
	jy = 1;
    } else {
	jy = 1 - (*n - 1) * *incy;
    }
    if (*incx == 1) {
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    if (y[jy] != 0.) {
		temp = *alpha * y[jy];
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    a[i__ + j * a_dim1] += x[i__] * temp;
/* L10: */
		}
	    }
	    jy += *incy;
/* L20: */
	}
    } else {
	if (*incx > 0) {
	    kx = 1;
	} else {
	    kx = 1 - (*m - 1) * *incx;
	}
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    if (y[jy] != 0.) {
		temp = *alpha * y[jy];
		ix = kx;
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    a[i__ + j * a_dim1] += x[ix] * temp;
		    ix += *incx;
/* L30: */
		}
	    }
	    jy += *incy;
/* L40: */
	}
    }

    return 0;

/*     End of DGER  . */

} /* dger_ */

#endif /* GODESS */


/* From blas (accompanying lapack)*/
/* Used instead from 2000-08-07 since it can handle +/-inf */
/* and generate sensible results in contrast to the other version of dnrm2 */
DYMOLA_STATIC doublereal dnrm2_(const integer *n, doublereal *x, const integer *incx)
{
    /* System generated locals */
    integer i__1, i__2;
    doublereal ret_val, d__1;

    /* Local variables */
    integer ix;
    doublereal ssq, norm, scale, absxi;


/*  -- Reference BLAS level1 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
    /* Parameter adjustments */
    --x;

    /* Function Body */
    if (*n < 1 || *incx < 1) {
	norm = 0.;
    } else if (*n == 1) {
	norm = Dymola_abs(x[1]);
    } else {
	scale = 0.;
	ssq = 1.;
/*        The following loop is equivalent to this call to the LAPACK */
/*        auxiliary routine: */
/*        CALL DLASSQ( N, X, INCX, SCALE, SSQ ) */

	i__1 = (*n - 1) * *incx + 1;
	i__2 = *incx;
	for (ix = 1; i__2 < 0 ? ix >= i__1 : ix <= i__1; ix += i__2) {
	    if (x[ix] != 0.) {
		absxi = (d__1 = x[ix], Dymola_abs(d__1));
		if (scale < absxi) {
/* Computing 2nd power */
		    d__1 = scale / absxi;
		    ssq = ssq * (d__1 * d__1) + 1.;
		    scale = absxi;
		} else {
/* Computing 2nd power */
		    d__1 = absxi / scale;
		    ssq += d__1 * d__1;
		}
	    }
/* L10: */
	}
	norm = scale * sqrt(ssq);
    }

    ret_val = norm;
    return ret_val;

/*     End of DNRM2. */

} /* dnrm2_ */

/* From blas (accompanying lapack)*/
/* Used instead from 2000-08-07 since it can handle +/-inf */
/* and generate sensible results in contrast to the other version of dnrm2 */
DYMOLA_STATIC doublereal dnrm2_Fast1(const integer np, const doublereal *x)
{

	doublereal d__1;

    /* Local variables */
     doublereal norm, scale, absxi;
     integer ix;
     doublereal ssq,Xix;

     /*  DNRM2 returns the euclidean norm of a vector via the function  name, so that  */

     /*       DNRM2 := sqrt( x'*x )   */



     /*    -- This version written on 25-October-1982.   */
     /*       Modified on 14-October-1993 to inline the call to DLASSQ.   */
     /*       Sven Hammarling, Nag Ltd.   */


    
     /*   Parameter adjustments   */
     /*       Function Body */
#define X(I) x[(I)-1]

	 if (np<1) {
		 norm=0;
	 } else if (np==1) {
		 norm=fabs(X(1));
	 } else {
		 scale = 0.0;
		 ssq = 1.0;
/*        The following loop is equivalent to this call to the LAPACK 
		 
		   auxiliary routine:   
		 CALL DLASSQ( N, X, INCX, SCALE, SSQ ) */
		 
		 for (ix=1; ix <= np; ix += 1) {
			 Xix=X(ix);
#if defined(_MSC_VER)
			 if (!_finite(Xix)) return DBL_MAX;
#else
			 if (!(Xix==Xix)) return DBL_MAX;
#endif /* defined(_MSC_VER) */
			 if (Xix != 0.) {
				 absxi = fabs(Xix);
				 if (scale < absxi) {
					 /* Computing 2nd power */
					 d__1 = scale / absxi;
					 ssq = ssq * (d__1 * d__1) + 1.;
					 scale = absxi;
				 } else {
					 /* Computing 2nd power */
					 d__1 = absxi / scale;
					 ssq += d__1 * d__1;
				 }
			 }
			 /* L10: */
		 }
		 norm = scale * sqrt(ssq);
	 }

    return norm;

/*     End of DNRM2. */
}
#undef X

#ifndef GODESS
/* Subroutine */ DYMOLA_STATIC int dscal_(const integer *n, const doublereal *da, doublereal *dx, const integer *incx)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    integer i__, m, mp1, nincx;


/*  -- Reference BLAS level1 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
    /* Parameter adjustments */
    --dx;

    /* Function Body */
    if (*n <= 0 || *incx <= 0) {
	return 0;
    }
    if (*incx == 1) {

/*        code for increment equal to 1 */


/*        clean-up loop */

	m = *n % 5;
	if (m != 0) {
	    i__1 = m;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		dx[i__] = *da * dx[i__];
	    }
	    if (*n < 5) {
		return 0;
	    }
	}
	mp1 = m + 1;
	i__1 = *n;
	for (i__ = mp1; i__ <= i__1; i__ += 5) {
	    dx[i__] = *da * dx[i__];
	    dx[i__ + 1] = *da * dx[i__ + 1];
	    dx[i__ + 2] = *da * dx[i__ + 2];
	    dx[i__ + 3] = *da * dx[i__ + 3];
	    dx[i__ + 4] = *da * dx[i__ + 4];
	}
    } else {

/*        code for increment not equal to 1 */

	nincx = *n * *incx;
	i__1 = nincx;
	i__2 = *incx;
	for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	    dx[i__] = *da * dx[i__];
	}
    }
    return 0;
} /* dscal_ */

/* Subroutine */ DYMOLA_STATIC int dswap_(const integer *n, doublereal *dx, const integer *incx, doublereal *dy, const integer *incy)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    integer i__, m, ix, iy, mp1;
    doublereal dtemp;


/*  -- Reference BLAS level1 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
    /* Parameter adjustments */
    --dy;
    --dx;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    if (*incx == 1 && *incy == 1) {

/*       code for both increments equal to 1 */


/*       clean-up loop */

	m = *n % 3;
	if (m != 0) {
	    i__1 = m;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		dtemp = dx[i__];
		dx[i__] = dy[i__];
		dy[i__] = dtemp;
	    }
	    if (*n < 3) {
		return 0;
	    }
	}
	mp1 = m + 1;
	i__1 = *n;
	for (i__ = mp1; i__ <= i__1; i__ += 3) {
	    dtemp = dx[i__];
	    dx[i__] = dy[i__];
	    dy[i__] = dtemp;
	    dtemp = dx[i__ + 1];
	    dx[i__ + 1] = dy[i__ + 1];
	    dy[i__ + 1] = dtemp;
	    dtemp = dx[i__ + 2];
	    dx[i__ + 2] = dy[i__ + 2];
	    dy[i__ + 2] = dtemp;
	}
    } else {

/*       code for unequal increments or equal increments not equal */
/*         to 1 */

	ix = 1;
	iy = 1;
	if (*incx < 0) {
	    ix = (-(*n) + 1) * *incx + 1;
	}
	if (*incy < 0) {
	    iy = (-(*n) + 1) * *incy + 1;
	}
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    dtemp = dx[ix];
	    dx[ix] = dy[iy];
	    dy[iy] = dtemp;
	    ix += *incx;
	    iy += *incy;
	}
    }
    return 0;
} /* dswap_ */

/* Subroutine */ DYMOLA_STATIC int  dtrsm_(const char *side, const char *uplo, const char *transa, const char *diag, integer *m, integer *n, const doublereal *alpha, const doublereal *a, integer *lda, doublereal *b, integer *ldb)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2, i__3;

    /* Local variables */
    integer i__, j, k, info;
    doublereal temp;
    logical lside;
    integer nrowa;
    logical upper;
    logical nounit;


/*  -- Reference BLAS level3 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Parameters .. */
/*     .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    lside = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
    if (lside) {
	nrowa = *m;
    } else {
	nrowa = *n;
    }
    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);
    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);

    info = 0;
    if (! lside && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
	info = 1;
    } else if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
	info = 2;
    } else if (! lsame_(transa, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(transa,
	     "T", (ftnlen)1, (ftnlen)1) && ! lsame_(transa, "C", (ftnlen)1, (
	    ftnlen)1)) {
	info = 3;
    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
	    "N", (ftnlen)1, (ftnlen)1)) {
	info = 4;
    } else if (*m < 0) {
	info = 5;
    } else if (*n < 0) {
	info = 6;
    } else if (*lda < Dymola_max(1,nrowa)) {
	info = 9;
    } else if (*ldb < Dymola_max(1,*m)) {
	info = 11;
    }
    if (info != 0) {
	xerbla_("DTRSM ", &info);
	return 0;
    }

/*     Quick return if possible. */

    if (*m == 0 || *n == 0) {
	return 0;
    }

/*     And when  alpha.eq.zero. */

    if (*alpha == 0.) {
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *m;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		b[i__ + j * b_dim1] = 0.;
/* L10: */
	    }
/* L20: */
	}
	return 0;
    }

/*     Start the operations. */

    if (lside) {
	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {

/*           Form  B := alpha*inv( A )*B. */

	    if (upper) {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    if (*alpha != 1.) {
			i__2 = *m;
			for (i__ = 1; i__ <= i__2; ++i__) {
			    b[i__ + j * b_dim1] = *alpha * b[i__ + j * b_dim1]
				    ;
/* L30: */
			}
		    }
		    for (k = *m; k >= 1; --k) {
			if (b[k + j * b_dim1] != 0.) {
			    if (nounit) {
				b[k + j * b_dim1] /= a[k + k * a_dim1];
			    }
			    i__2 = k - 1;
			    for (i__ = 1; i__ <= i__2; ++i__) {
				b[i__ + j * b_dim1] -= b[k + j * b_dim1] * a[
					i__ + k * a_dim1];
/* L40: */
			    }
			}
/* L50: */
		    }
/* L60: */
		}
	    } else {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    if (*alpha != 1.) {
			i__2 = *m;
			for (i__ = 1; i__ <= i__2; ++i__) {
			    b[i__ + j * b_dim1] = *alpha * b[i__ + j * b_dim1]
				    ;
/* L70: */
			}
		    }
		    i__2 = *m;
		    for (k = 1; k <= i__2; ++k) {
			if (b[k + j * b_dim1] != 0.) {
			    if (nounit) {
				b[k + j * b_dim1] /= a[k + k * a_dim1];
			    }
			    i__3 = *m;
			    for (i__ = k + 1; i__ <= i__3; ++i__) {
				b[i__ + j * b_dim1] -= b[k + j * b_dim1] * a[
					i__ + k * a_dim1];
/* L80: */
			    }
			}
/* L90: */
		    }
/* L100: */
		}
	    }
	} else {

/*           Form  B := alpha*inv( A**T )*B. */

	    if (upper) {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    i__2 = *m;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			temp = *alpha * b[i__ + j * b_dim1];
			i__3 = i__ - 1;
			for (k = 1; k <= i__3; ++k) {
			    temp -= a[k + i__ * a_dim1] * b[k + j * b_dim1];
/* L110: */
			}
			if (nounit) {
			    temp /= a[i__ + i__ * a_dim1];
			}
			b[i__ + j * b_dim1] = temp;
/* L120: */
		    }
/* L130: */
		}
	    } else {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    for (i__ = *m; i__ >= 1; --i__) {
			temp = *alpha * b[i__ + j * b_dim1];
			i__2 = *m;
			for (k = i__ + 1; k <= i__2; ++k) {
			    temp -= a[k + i__ * a_dim1] * b[k + j * b_dim1];
/* L140: */
			}
			if (nounit) {
			    temp /= a[i__ + i__ * a_dim1];
			}
			b[i__ + j * b_dim1] = temp;
/* L150: */
		    }
/* L160: */
		}
	    }
	}
    } else {
	if (lsame_(transa, "N", (ftnlen)1, (ftnlen)1)) {

/*           Form  B := alpha*B*inv( A ). */

	    if (upper) {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    if (*alpha != 1.) {
			i__2 = *m;
			for (i__ = 1; i__ <= i__2; ++i__) {
			    b[i__ + j * b_dim1] = *alpha * b[i__ + j * b_dim1]
				    ;
/* L170: */
			}
		    }
		    i__2 = j - 1;
		    for (k = 1; k <= i__2; ++k) {
			if (a[k + j * a_dim1] != 0.) {
			    i__3 = *m;
			    for (i__ = 1; i__ <= i__3; ++i__) {
				b[i__ + j * b_dim1] -= a[k + j * a_dim1] * b[
					i__ + k * b_dim1];
/* L180: */
			    }
			}
/* L190: */
		    }
		    if (nounit) {
			temp = 1. / a[j + j * a_dim1];
			i__2 = *m;
			for (i__ = 1; i__ <= i__2; ++i__) {
			    b[i__ + j * b_dim1] = temp * b[i__ + j * b_dim1];
/* L200: */
			}
		    }
/* L210: */
		}
	    } else {
		for (j = *n; j >= 1; --j) {
		    if (*alpha != 1.) {
			i__1 = *m;
			for (i__ = 1; i__ <= i__1; ++i__) {
			    b[i__ + j * b_dim1] = *alpha * b[i__ + j * b_dim1]
				    ;
/* L220: */
			}
		    }
		    i__1 = *n;
		    for (k = j + 1; k <= i__1; ++k) {
			if (a[k + j * a_dim1] != 0.) {
			    i__2 = *m;
			    for (i__ = 1; i__ <= i__2; ++i__) {
				b[i__ + j * b_dim1] -= a[k + j * a_dim1] * b[
					i__ + k * b_dim1];
/* L230: */
			    }
			}
/* L240: */
		    }
		    if (nounit) {
			temp = 1. / a[j + j * a_dim1];
			i__1 = *m;
			for (i__ = 1; i__ <= i__1; ++i__) {
			    b[i__ + j * b_dim1] = temp * b[i__ + j * b_dim1];
/* L250: */
			}
		    }
/* L260: */
		}
	    }
	} else {

/*           Form  B := alpha*B*inv( A**T ). */

	    if (upper) {
		for (k = *n; k >= 1; --k) {
		    if (nounit) {
			temp = 1. / a[k + k * a_dim1];
			i__1 = *m;
			for (i__ = 1; i__ <= i__1; ++i__) {
			    b[i__ + k * b_dim1] = temp * b[i__ + k * b_dim1];
/* L270: */
			}
		    }
		    i__1 = k - 1;
		    for (j = 1; j <= i__1; ++j) {
			if (a[j + k * a_dim1] != 0.) {
			    temp = a[j + k * a_dim1];
			    i__2 = *m;
			    for (i__ = 1; i__ <= i__2; ++i__) {
				b[i__ + j * b_dim1] -= temp * b[i__ + k * 
					b_dim1];
/* L280: */
			    }
			}
/* L290: */
		    }
		    if (*alpha != 1.) {
			i__1 = *m;
			for (i__ = 1; i__ <= i__1; ++i__) {
			    b[i__ + k * b_dim1] = *alpha * b[i__ + k * b_dim1]
				    ;
/* L300: */
			}
		    }
/* L310: */
		}
	    } else {
		i__1 = *n;
		for (k = 1; k <= i__1; ++k) {
		    if (nounit) {
			temp = 1. / a[k + k * a_dim1];
			i__2 = *m;
			for (i__ = 1; i__ <= i__2; ++i__) {
			    b[i__ + k * b_dim1] = temp * b[i__ + k * b_dim1];
/* L320: */
			}
		    }
		    i__2 = *n;
		    for (j = k + 1; j <= i__2; ++j) {
			if (a[j + k * a_dim1] != 0.) {
			    temp = a[j + k * a_dim1];
			    i__3 = *m;
			    for (i__ = 1; i__ <= i__3; ++i__) {
				b[i__ + j * b_dim1] -= temp * b[i__ + k * 
					b_dim1];
/* L330: */
			    }
			}
/* L340: */
		    }
		    if (*alpha != 1.) {
			i__2 = *m;
			for (i__ = 1; i__ <= i__2; ++i__) {
			    b[i__ + k * b_dim1] = *alpha * b[i__ + k * b_dim1]
				    ;
/* L350: */
			}
		    }
/* L360: */
		}
	    }
	}
    }

    return 0;

/*     End of DTRSM . */

} /* dtrsm_ */

/* Subroutine */ DYMOLA_STATIC int dtrsv_(char *uplo, char *trans, char *diag, integer *n, doublereal *a, integer *lda, doublereal *x, integer *incx)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    integer i__, j, ix, jx, kx, info;
    doublereal temp;
    logical nounit;


/*  -- Reference BLAS level1 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --x;

    /* Function Body */
    info = 0;
    if (! lsame_(uplo, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(uplo, "L", (
	    ftnlen)1, (ftnlen)1)) {
	info = 1;
    } else if (! lsame_(trans, "N", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, 
	    "T", (ftnlen)1, (ftnlen)1) && ! lsame_(trans, "C", (ftnlen)1, (
	    ftnlen)1)) {
	info = 2;
    } else if (! lsame_(diag, "U", (ftnlen)1, (ftnlen)1) && ! lsame_(diag, 
	    "N", (ftnlen)1, (ftnlen)1)) {
	info = 3;
    } else if (*n < 0) {
	info = 4;
    } else if (*lda < Dymola_max(1,*n)) {
	info = 6;
    } else if (*incx == 0) {
	info = 8;
    }
    if (info != 0) {
	xerbla_("DTRSV ", &info);
	return 0;
    }

/*     Quick return if possible. */

    if (*n == 0) {
	return 0;
    }

    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);

/*     Set up the start point in X if the increment is not unity. This */
/*     will be  ( N - 1 )*INCX  too small for descending loops. */

    if (*incx <= 0) {
	kx = 1 - (*n - 1) * *incx;
    } else if (*incx != 1) {
	kx = 1;
    }

/*     Start the operations. In this version the elements of A are */
/*     accessed sequentially with one pass through A. */

    if (lsame_(trans, "N", (ftnlen)1, (ftnlen)1)) {

/*        Form  x := inv( A )*x. */

	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
	    if (*incx == 1) {
		for (j = *n; j >= 1; --j) {
		    if (x[j] != 0.) {
			if (nounit) {
			    x[j] /= a[j + j * a_dim1];
			}
			temp = x[j];
			for (i__ = j - 1; i__ >= 1; --i__) {
			    x[i__] -= temp * a[i__ + j * a_dim1];
/* L10: */
			}
		    }
/* L20: */
		}
	    } else {
		jx = kx + (*n - 1) * *incx;
		for (j = *n; j >= 1; --j) {
		    if (x[jx] != 0.) {
			if (nounit) {
			    x[jx] /= a[j + j * a_dim1];
			}
			temp = x[jx];
			ix = jx;
			for (i__ = j - 1; i__ >= 1; --i__) {
			    ix -= *incx;
			    x[ix] -= temp * a[i__ + j * a_dim1];
/* L30: */
			}
		    }
		    jx -= *incx;
/* L40: */
		}
	    }
	} else {
	    if (*incx == 1) {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    if (x[j] != 0.) {
			if (nounit) {
			    x[j] /= a[j + j * a_dim1];
			}
			temp = x[j];
			i__2 = *n;
			for (i__ = j + 1; i__ <= i__2; ++i__) {
			    x[i__] -= temp * a[i__ + j * a_dim1];
/* L50: */
			}
		    }
/* L60: */
		}
	    } else {
		jx = kx;
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    if (x[jx] != 0.) {
			if (nounit) {
			    x[jx] /= a[j + j * a_dim1];
			}
			temp = x[jx];
			ix = jx;
			i__2 = *n;
			for (i__ = j + 1; i__ <= i__2; ++i__) {
			    ix += *incx;
			    x[ix] -= temp * a[i__ + j * a_dim1];
/* L70: */
			}
		    }
		    jx += *incx;
/* L80: */
		}
	    }
	}
    } else {

/*        Form  x := inv( A**T )*x. */

	if (lsame_(uplo, "U", (ftnlen)1, (ftnlen)1)) {
	    if (*incx == 1) {
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    temp = x[j];
		    i__2 = j - 1;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			temp -= a[i__ + j * a_dim1] * x[i__];
/* L90: */
		    }
		    if (nounit) {
			temp /= a[j + j * a_dim1];
		    }
		    x[j] = temp;
/* L100: */
		}
	    } else {
		jx = kx;
		i__1 = *n;
		for (j = 1; j <= i__1; ++j) {
		    temp = x[jx];
		    ix = kx;
		    i__2 = j - 1;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			temp -= a[i__ + j * a_dim1] * x[ix];
			ix += *incx;
/* L110: */
		    }
		    if (nounit) {
			temp /= a[j + j * a_dim1];
		    }
		    x[jx] = temp;
		    jx += *incx;
/* L120: */
		}
	    }
	} else {
	    if (*incx == 1) {
		for (j = *n; j >= 1; --j) {
		    temp = x[j];
		    i__1 = j + 1;
		    for (i__ = *n; i__ >= i__1; --i__) {
			temp -= a[i__ + j * a_dim1] * x[i__];
/* L130: */
		    }
		    if (nounit) {
			temp /= a[j + j * a_dim1];
		    }
		    x[j] = temp;
/* L140: */
		}
	    } else {
		kx += (*n - 1) * *incx;
		jx = kx;
		for (j = *n; j >= 1; --j) {
		    temp = x[jx];
		    ix = kx;
		    i__1 = j + 1;
		    for (i__ = *n; i__ >= i__1; --i__) {
			temp -= a[i__ + j * a_dim1] * x[ix];
			ix -= *incx;
/* L150: */
		    }
		    if (nounit) {
			temp /= a[j + j * a_dim1];
		    }
		    x[jx] = temp;
		    jx -= *incx;
/* L160: */
		}
	    }
	}
    }

    return 0;

/*     End of DTRSV . */

} /* dtrsv_ */

DYMOLA_STATIC integer idamax_(integer *n, doublereal *dx, integer *incx)
{
    /* System generated locals */
    integer ret_val, i__1;
    doublereal d__1;

    /* Local variables */
    integer i__, ix;
    doublereal dmax__;


/*  -- Reference BLAS level1 routine (version 3.4.0) -- */
/*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
    /* Parameter adjustments */
    --dx;

    /* Function Body */
    ret_val = 0;
    if (*n < 1 || *incx <= 0) {
	return ret_val;
    }
    ret_val = 1;
    if (*n == 1) {
	return ret_val;
    }
    if (*incx == 1) {

/*        code for increment equal to 1 */

	dmax__ = Dymola_abs(dx[1]);
	i__1 = *n;
	for (i__ = 2; i__ <= i__1; ++i__) {
	    if ((d__1 = dx[i__], Dymola_abs(d__1)) > dmax__) {
		ret_val = i__;
		dmax__ = (d__1 = dx[i__], Dymola_abs(d__1));
	    }
	}
    } else {

/*        code for increment not equal to 1 */

	ix = 1;
	dmax__ = Dymola_abs(dx[1]);
	ix += *incx;
	i__1 = *n;
	for (i__ = 2; i__ <= i__1; ++i__) {
	    if ((d__1 = dx[ix], Dymola_abs(d__1)) > dmax__) {
		ret_val = i__;
		dmax__ = (d__1 = dx[ix], Dymola_abs(d__1));
	    }
	    ix += *incx;
	}
    }
    return ret_val;
} /* idamax_ */

/* Subroutine */ DYMOLA_STATIC int dgecon_(const char *norm, integer *n, const doublereal *a, integer *lda, const doublereal *anorm, doublereal *rcond, doublereal *work, integer *iwork, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1;
    doublereal d__1;

    /* Local variables */
    doublereal sl;
    integer ix;
    doublereal su;
    integer kase, kase1;
    doublereal scale;
    integer isave[3];
    doublereal ainvnm;
    logical onenrm;
    char normin[1];
    doublereal smlnum;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Local Arrays .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --work;
    --iwork;

    /* Function Body */
    *info = 0;
    onenrm = *(unsigned char *)norm == '1' || lsame_(norm, "O", (ftnlen)1, (
	    ftnlen)1);
    if (! onenrm && ! lsame_(norm, "I", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -4;
    } else if (*anorm < 0.) {
	*info = -5;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGECON", &i__1);
	return 0;
    }

/*     Quick return if possible */

    *rcond = 0.;
    if (*n == 0) {
	*rcond = 1.;
	return 0;
    } else if (*anorm == 0.) {
	return 0;
    }

    smlnum = dlamch_("Safe minimum");

/*     Estimate the norm of inv(A). */

    ainvnm = 0.;
    *(unsigned char *)normin = 'N';
    if (onenrm) {
	kase1 = 1;
    } else {
	kase1 = 2;
    }
    kase = 0;
L10:
    dlacn2_(n, &work[*n + 1], &work[1], &iwork[1], &ainvnm, &kase, isave);
    if (kase != 0) {
	if (kase == kase1) {

/*           Multiply by inv(L). */

	    dlatrs_("Lower", "No transpose", "Unit", normin, n, (doublereal*)&a[a_offset], 
		    lda, &work[1], &sl, &work[(*n << 1) + 1], info);

/*           Multiply by inv(U). */

	    dlatrs_("Upper", "No transpose", "Non-unit", normin, n, (doublereal*)&a[
		    a_offset], lda, &work[1], &su, &work[*n * 3 + 1], info);
	} else {

/*           Multiply by inv(U**T). */

	    dlatrs_("Upper", "Transpose", "Non-unit", normin, n, (doublereal*)&a[a_offset],
		     lda, &work[1], &su, &work[*n * 3 + 1], info);

/*           Multiply by inv(L**T). */

	    dlatrs_("Lower", "Transpose", "Unit", normin, n, (doublereal*)&a[a_offset], 
		    lda, &work[1], &sl, &work[(*n << 1) + 1], info);
	}

/*        Divide X by 1/(SL*SU) if doing so will not cause overflow. */

	scale = sl * su;
	*(unsigned char *)normin = 'Y';
	if (scale != 1.) {
	    ix = idamax_(n, &work[1], &c__1);
	    if (scale < (d__1 = work[ix], Dymola_abs(d__1)) * smlnum || scale == 0.) 
		    {
		goto L20;
	    }
	    drscl_(n, &scale, &work[1], &c__1);
	}
	goto L10;
    }

/*     Compute the estimate of the reciprocal condition number. */

    if (ainvnm != 0.) {
	*rcond = 1. / ainvnm / *anorm;
    }

L20:
    return 0;

/*     End of DGECON */

} /* dgecon_ */

/* Subroutine */ DYMOLA_STATIC int dgeqpf_(const integer *m, integer *n, doublereal *a, integer *lda, integer *jpvt, doublereal *tau, doublereal *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublereal d__1, d__2;

	/* Local variables */
    integer i__, j, ma, mn;
    doublereal aii;
    integer pvt;
    doublereal temp;
    doublereal temp2, tol3z;
    integer itemp;

/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --jpvt;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -4;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGEQPF", &i__1);
	return 0;
    }

    mn = Dymola_min(*m,*n);
    tol3z = sqrt(dlamch_("Epsilon"));

/*     Move initial columns up front */

    itemp = 1;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (jpvt[i__] != 0) {
	    if (i__ != itemp) {
        dswap_((integer*)m, &a[i__ * a_dim1 + 1], &c__1, &a[itemp * a_dim1 + 1],
			 &c__1);
		jpvt[i__] = jpvt[itemp];
		jpvt[itemp] = i__;
	    } else {
		jpvt[i__] = i__;
	    }
	    ++itemp;
	} else {
	    jpvt[i__] = i__;
	}
/* L10: */
    }
    --itemp;

/*     Compute the QR factorization and update remaining columns */

    if (itemp > 0) {
	ma = Dymola_min(itemp,*m);
	dgeqr2_((integer*)m, &ma, &a[a_offset], lda, &tau[1], &work[1], info);
	if (ma < *n) {
	    i__1 = *n - ma;
	    dorm2r_("Left", "Transpose", (integer*)m, &i__1, &ma, &a[a_offset], lda, &
		    tau[1], &a[(ma + 1) * a_dim1 + 1], lda, &work[1], info);
	}
    }

    if (itemp < mn) {

/*        Initialize partial column norms. The first n elements of */
/*        work store the exact column norms. */

	i__1 = *n;
	for (i__ = itemp + 1; i__ <= i__1; ++i__) {
	    i__2 = *m - itemp;
	    work[i__] = dnrm2_(&i__2, &a[itemp + 1 + i__ * a_dim1], &c__1);
	    work[*n + i__] = work[i__];
/* L20: */
	}

/*        Compute factorization */

	i__1 = mn;
	for (i__ = itemp + 1; i__ <= i__1; ++i__) {

/*           Determine ith pivot column and swap if necessary */

	    i__2 = *n - i__ + 1;
	    pvt = i__ - 1 + idamax_(&i__2, &work[i__], &c__1);

	    if (pvt != i__) {
		dswap_((integer*)m, &a[pvt * a_dim1 + 1], &c__1, &a[i__ * a_dim1 + 1], &
			c__1);
		itemp = jpvt[pvt];
		jpvt[pvt] = jpvt[i__];
		jpvt[i__] = itemp;
		work[pvt] = work[i__];
		work[*n + pvt] = work[*n + i__];
	    }

/*           Generate elementary reflector H(i) */

	    if (i__ < *m) {
		i__2 = *m - i__ + 1;
		dlarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[i__ + 1 + i__ * 
			a_dim1], &c__1, &tau[i__]);
	    } else {
		dlarfg_(&c__1, &a[*m + *m * a_dim1], &a[*m + *m * a_dim1], &
			c__1, &tau[*m]);
	    }

	    if (i__ < *n) {

/*              Apply H(i) to A(i:m,i+1:n) from the left */

		aii = a[i__ + i__ * a_dim1];
		a[i__ + i__ * a_dim1] = 1.;
		i__2 = *m - i__ + 1;
		i__3 = *n - i__;
		dlarf_("LEFT", &i__2, &i__3, &a[i__ + i__ * a_dim1], &c__1, &
			tau[i__], &a[i__ + (i__ + 1) * a_dim1], lda, &work[(*
			n << 1) + 1]);
		a[i__ + i__ * a_dim1] = aii;
	    }

/*           Update partial column norms */

	    i__2 = *n;
	    for (j = i__ + 1; j <= i__2; ++j) {
		if (work[j] != 0.) {

/*                 NOTE: The following 4 lines follow from the analysis in */
/*                 Lapack Working Note 176. */

		    temp = (d__1 = a[i__ + j * a_dim1], Dymola_abs(d__1)) / work[j];
/* Computing MAX */
		    d__1 = 0., d__2 = (temp + 1.) * (1. - temp);
		    temp = Dymola_max(d__1,d__2);
/* Computing 2nd power */
		    d__1 = work[j] / work[*n + j];
		    temp2 = temp * (d__1 * d__1);
		    if (temp2 <= tol3z) {
			if (*m - i__ > 0) {
			    i__3 = *m - i__;
			    work[j] = dnrm2_(&i__3, &a[i__ + 1 + j * a_dim1], 
				    &c__1);
			    work[*n + j] = work[j];
			} else {
			    work[j] = 0.;
			    work[*n + j] = 0.;
			}
		    } else {
			work[j] *= sqrt(temp);
		    }
		}
/* L30: */
	    }

/* L40: */
	}
    }
    return 0;

/*     End of DGEQPF */

} /* dgeqpf_ */

/* Subroutine */ DYMOLA_STATIC int dgeqr2_(integer *m, integer *n, doublereal *a, integer *lda, doublereal *tau, doublereal *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    integer i__, k;
    doublereal aii;

/*  -- LAPACK computational routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    --work;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -4;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGEQR2", &i__1);
	return 0;
    }

    k = Dymola_min(*m,*n);

    i__1 = k;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*        Generate elementary reflector H(i) to annihilate A(i+1:m,i) */

	i__2 = *m - i__ + 1;
/* Computing MIN */
	i__3 = i__ + 1;
	dlarfg_(&i__2, &a[i__ + i__ * a_dim1], &a[Dymola_min(i__3,*m) + i__ * a_dim1]
		, &c__1, &tau[i__]);
	if (i__ < *n) {

/*           Apply H(i) to A(i:m,i+1:n) from the left */

	    aii = a[i__ + i__ * a_dim1];
	    a[i__ + i__ * a_dim1] = 1.;
	    i__2 = *m - i__ + 1;
	    i__3 = *n - i__;
	    dlarf_("Left", &i__2, &i__3, &a[i__ + i__ * a_dim1], &c__1, &tau[
		    i__], &a[i__ + (i__ + 1) * a_dim1], lda, &work[1]);
	    a[i__ + i__ * a_dim1] = aii;
	}
/* L10: */
    }
    return 0;

/*     End of DGEQR2 */

} /* dgeqr2_ */

/* Subroutine */ DYMOLA_STATIC int dgetf2_(integer *m, integer *n, doublereal *a, integer *lda, integer *ipiv, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublereal d__1;

    /* Local variables */
    integer i__, j, jp;
    doublereal sfmin;
    extern integer idamax_(integer *, doublereal *, integer *);

/*  -- LAPACK computational routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -4;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGETF2", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {
	return 0;
    }

/*     Compute machine safe minimum */

    sfmin = dlamch_("S");

    i__1 = Dymola_min(*m,*n);
    for (j = 1; j <= i__1; ++j) {

/*        Find pivot and test for singularity. */

	i__2 = *m - j + 1;
	jp = j - 1 + idamax_(&i__2, &a[j + j * a_dim1], &c__1);
	ipiv[j] = jp;
	if (a[jp + j * a_dim1] != 0.) {

/*           Apply the interchange to columns 1:N. */

	    if (jp != j) {
		dswap_(n, &a[j + a_dim1], lda, &a[jp + a_dim1], lda);
	    }

/*           Compute elements J+1:M of J-th column. */

	    if (j < *m) {
		if ((d__1 = a[j + j * a_dim1], Dymola_abs(d__1)) >= sfmin) {
		    i__2 = *m - j;
		    d__1 = 1. / a[j + j * a_dim1];
		    dscal_(&i__2, &d__1, &a[j + 1 + j * a_dim1], &c__1);
		} else {
		    i__2 = *m - j;
		    for (i__ = 1; i__ <= i__2; ++i__) {
			a[j + i__ + j * a_dim1] /= a[j + j * a_dim1];
/* L20: */
		    }
		}
	    }

	} else if (*info == 0) {

	    *info = j;
	}

	if (j < Dymola_min(*m,*n)) {

/*           Update trailing submatrix. */

	    i__2 = *m - j;
	    i__3 = *n - j;
	    dger_(&i__2, &i__3, &c_b8_dgetf2, &a[j + 1 + j * a_dim1], &c__1, &a[j + (
		    j + 1) * a_dim1], lda, &a[j + 1 + (j + 1) * a_dim1], lda);
	}
/* L10: */
    }
    return 0;

/*     End of DGETF2 */

} /* dgetf2_ */

/* Subroutine */ DYMOLA_STATIC int dgetrf_(const integer *m, const integer *n, doublereal *a, integer *lda, integer *ipiv, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4, i__5;

    /* Local variables */
    integer i__, j, jb, nb;
    integer iinfo;

/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -4;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGETRF", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {
	return 0;
    }

/*     Determine the block size for this environment. */

    nb = ilaenv_(&c__1, "DGETRF", " ", m, n, &c_n1, &c_n1);
    if (nb <= 1 || nb >= Dymola_min(*m,*n)) {

/*        Use unblocked code. */

	dgetf2_((integer*)m, (integer*)n, &a[a_offset], lda, &ipiv[1], info);
    } else {

/*        Use blocked code. */

	i__1 = Dymola_min(*m,*n);
	i__2 = nb;
	for (j = 1; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {
/* Computing MIN */
	    i__3 = Dymola_min(*m,*n) - j + 1;
	    jb = Dymola_min(i__3,nb);

/*           Factor diagonal and subdiagonal blocks and test for exact */
/*           singularity. */

	    i__3 = *m - j + 1;
	    dgetf2_(&i__3, &jb, &a[j + j * a_dim1], lda, &ipiv[j], &iinfo);

/*           Adjust INFO and the pivot indices. */

	    if (*info == 0 && iinfo > 0) {
		*info = iinfo + j - 1;
	    }
/* Computing MIN */
	    i__4 = *m, i__5 = j + jb - 1;
	    i__3 = Dymola_min(i__4,i__5);
	    for (i__ = j; i__ <= i__3; ++i__) {
		ipiv[i__] = j - 1 + ipiv[i__];
/* L10: */
	    }

/*           Apply interchanges to columns 1:J-1. */

	    i__3 = j - 1;
	    i__4 = j + jb - 1;
	    dlaswp_(&i__3, &a[a_offset], lda, &j, &i__4, &ipiv[1], &c__1);

	    if (j + jb <= *n) {

/*              Apply interchanges to columns J+JB:N. */

		i__3 = *n - j - jb + 1;
		i__4 = j + jb - 1;
		dlaswp_(&i__3, &a[(j + jb) * a_dim1 + 1], lda, &j, &i__4, &
			ipiv[1], &c__1);

/*              Compute block row of U. */

		i__3 = *n - j - jb + 1;
		dtrsm_("Left", "Lower", "No transpose", "Unit", &jb, &i__3, &
			c_b16, &a[j + j * a_dim1], lda, &a[j + (j + jb) * 
			a_dim1], lda);
		if (j + jb <= *m) {

/*                 Update trailing submatrix. */

		    i__3 = *m - j - jb + 1;
		    i__4 = *n - j - jb + 1;
		    dgemm_("No transpose", "No transpose", &i__3, &i__4, &jb, 
			    &c_b19, &a[j + jb + j * a_dim1], lda, &a[j + (j + 
			    jb) * a_dim1], lda, &c_b16, &a[j + jb + (j + jb) *
			     a_dim1], lda);
		}
	    }
/* L20: */
	}
    }
    return 0;

/*     End of DGETRF */

} /* dgetrf_ */

/* Subroutine */ DYMOLA_STATIC int dgetrs_(const char *trans, const integer *n, const integer *nrhs, doublereal *a, integer *lda, const integer *ipiv, doublereal *b, integer *ldb, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    logical notran;


/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    *info = 0;
    notran = lsame_(trans, "N", (ftnlen)1, (ftnlen)1);
    if (! notran && ! lsame_(trans, "T", (ftnlen)1, (ftnlen)1) && ! lsame_(
	    trans, "C", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*nrhs < 0) {
	*info = -3;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -5;
    } else if (*ldb < Dymola_max(1,*n)) {
	*info = -8;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGETRS", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0 || *nrhs == 0) {
	return 0;
    }

    if (notran) {

/*        Solve A * X = B. */

/*        Apply row interchanges to the right hand sides. */

	dlaswp_(nrhs, &b[b_offset], ldb, &c__1, n, &ipiv[1], &c__1);

/*        Solve L*X = B, overwriting B with X. */

	dtrsm_("Left", "Lower", "No transpose", "Unit", (integer*)n, (integer*)nrhs, &c_b12, &a[
		a_offset], lda, &b[b_offset], ldb);

/*        Solve U*X = B, overwriting B with X. */

	dtrsm_("Left", "Upper", "No transpose", "Non-unit", (integer*)n, (integer*)nrhs, &c_b12, &
		a[a_offset], lda, &b[b_offset], ldb);
    } else {

/*        Solve A**T * X = B. */

/*        Solve U**T *X = B, overwriting B with X. */

	dtrsm_("Left", "Upper", "Transpose", "Non-unit", (integer*)n, (integer*)nrhs, &c_b12, &a[
		a_offset], lda, &b[b_offset], ldb);

/*        Solve L**T *X = B, overwriting B with X. */

	dtrsm_("Left", "Lower", "Transpose", "Unit", (integer*)n, (integer*)nrhs, &c_b12, &a[
		a_offset], lda, &b[b_offset], ldb);

/*        Apply row interchanges to the solution vectors. */

	dlaswp_(nrhs, &b[b_offset], ldb, &c__1, n, &ipiv[1], &c_n1);
    }

    return 0;

/*     End of DGETRS */

} /* dgetrs_ */

#endif /* GODESS */

#ifndef GODESS
/* Subroutine */ DYMOLA_STATIC int dlabad_(doublereal *small, doublereal *large)
{
    /* Builtin functions */
    /* double d_lg10(doublereal *), sqrt(doublereal); */


/*  -- LAPACK auxiliary routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     If it looks like we're on a Cray, take the square root of */
/*     SMALL and LARGE to avoid overflow and underflow problems. */

    if (d_lg10(large) > 2e3) {
	*small = sqrt(*small);
	*large = sqrt(*large);
    }

    return 0;

/*     End of DLABAD */

} /* dlabad_ */

/* Subroutine */ DYMOLA_STATIC int dlacon_(integer *n, doublereal *v, doublereal *x,integer *isgn, doublereal *est, integer *kase)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, iter;
    static doublereal temp;
    static integer jump;
    extern doublereal dasum_(integer *, doublereal *, integer *);
    static integer jlast;
    extern integer idamax_(integer *, doublereal *, integer *);
    static doublereal altsgn, estold;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Save statement .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    --isgn;
    --x;
    --v;

    /* Function Body */
    if (*kase == 0) {
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    x[i__] = 1. / (doublereal) (*n);
/* L10: */
	}
	*kase = 1;
	jump = 1;
	return 0;
    }

    switch (jump) {
	case 1:  goto L20;
	case 2:  goto L40;
	case 3:  goto L70;
	case 4:  goto L110;
	case 5:  goto L140;
    }

/*     ................ ENTRY   (JUMP = 1) */
/*     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X. */

L20:
    if (*n == 1) {
	v[1] = x[1];
	*est = Dymola_abs(v[1]);
/*        ... QUIT */
	goto L150;
    }
    *est = dasum_(n, &x[1], &c__1);

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	x[i__] = d_sign(&c_b11, &x[i__]);
	isgn[i__] = i_dnnt(&x[i__]);
/* L30: */
    }
    *kase = 2;
    jump = 2;
    return 0;

/*     ................ ENTRY   (JUMP = 2) */
/*     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY TRANSPOSE(A)*X. */

L40:
    j = idamax_(n, &x[1], &c__1);
    iter = 2;

/*     MAIN LOOP - ITERATIONS 2,3,...,ITMAX. */

L50:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	x[i__] = 0.;
/* L60: */
    }
    x[j] = 1.;
    *kase = 1;
    jump = 3;
    return 0;

/*     ................ ENTRY   (JUMP = 3) */
/*     X HAS BEEN OVERWRITTEN BY A*X. */

L70:
    dcopy_(n, &x[1], &c__1, &v[1], &c__1);
    estold = *est;
    *est = dasum_(n, &v[1], &c__1);
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	d__1 = d_sign(&c_b11, &x[i__]);
	if (i_dnnt(&d__1) != isgn[i__]) {
	    goto L90;
	}
/* L80: */
    }
/*     REPEATED SIGN VECTOR DETECTED, HENCE ALGORITHM HAS CONVERGED. */
    goto L120;

L90:
/*     TEST FOR CYCLING. */
    if (*est <= estold) {
	goto L120;
    }

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	x[i__] = d_sign(&c_b11, &x[i__]);
	isgn[i__] = i_dnnt(&x[i__]);
/* L100: */
    }
    *kase = 2;
    jump = 4;
    return 0;

/*     ................ ENTRY   (JUMP = 4) */
/*     X HAS BEEN OVERWRITTEN BY TRANSPOSE(A)*X. */

L110:
    jlast = j;
    j = idamax_(n, &x[1], &c__1);
    if (x[jlast] != (d__1 = x[j], Dymola_abs(d__1)) && iter < 5) {
	++iter;
	goto L50;
    }

/*     ITERATION COMPLETE.  FINAL STAGE. */

L120:
    altsgn = 1.;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	x[i__] = altsgn * ((doublereal) (i__ - 1) / (doublereal) (*n - 1) + 
		1.);
	altsgn = -altsgn;
/* L130: */
    }
    *kase = 1;
    jump = 5;
    return 0;

/*     ................ ENTRY   (JUMP = 5) */
/*     X HAS BEEN OVERWRITTEN BY A*X. */

L140:
    temp = dasum_(n, &x[1], &c__1) / (doublereal) (*n * 3) * 2.;
    if (temp > *est) {
	dcopy_(n, &x[1], &c__1, &v[1], &c__1);
	*est = temp;
    }

L150:
    *kase = 0;
    return 0;

/*     End of DLACON */

} /* dlacon_ */


#endif /* GODESS */

/* Subroutine */ DYMOLA_STATIC int dlacon_clean(n, v, x, isgn, est, kase, staticarea)
integer*n;
doublereal *v, *x;
integer *isgn;
doublereal *est;
integer *kase;
struct dlacon_clean_struct *staticarea;
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Builtin functions */

    /* Local variables */
#define i__ (staticarea->i__)
#define j (staticarea->j)
#define iter (staticarea->iter)
#define temp (staticarea->temp)
#define jump (staticarea->jump)
#define jlast (staticarea->jlast)
#define altsgn (staticarea->altsgn)
#define estold (staticarea->estold)


/*  -- LAPACK auxiliary routine (version 1.1) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd., */
/*     Courant Institute, Argonne National Lab, and Rice University */
/*     February 29, 1992 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  Purpose */
/*  ======= */

/*  DLACON estimates the 1-norm of a square, real matrix A. */
/*  Reverse communication is used for evaluating matrix-vector products. */

	/* Cleaned up to avoid internal memory. Requires extra input argument */
/*  Arguments */
/*  ========= */

/*  N      (input) INTEGER */
/*         The order of the matrix.  N >= 1. */

/*  V      (workspace) DOUBLE PRECISION array, dimension (N) */
/*         On the final return, V = A*W,  where  EST = norm(V)/norm(W) */
/*         (W is not returned). */

/*  X      (input/output) DOUBLE PRECISION array, dimension (N) */
/*         On an intermediate return, X should be overwritten by */
/*               A * X,   if KASE=1, */
/*               A' * X,  if KASE=2, */
/*         and DLACON must be re-called with all the other parameters */
/*         unchanged. */

/*  ISGN   (workspace) INTEGER array, dimension (N) */

/*  EST    (output) DOUBLE PRECISION */
/*         An estimate (a lower bound) for norm(A). */

/*  KASE   (input/output) INTEGER */
/*         On the initial call to DLACON, KASE should be 0. */
/*         On an intermediate return, KASE will be 1 or 2, indicating */
/*         whether X should be overwritten by A * X  or A' * X. */
/*         On the final return from DLACON, KASE will again be 0. */

/*  Further Details */
/*  ======= ======= */

/*  Contributed by Nick Higham, University of Manchester. */
/*  Originally named SONEST, dated March 16, 1988. */

/*  Reference: N.J. Higham, "FORTRAN codes for estimating the one-norm of */
/*  a real or complex matrix, with applications to condition estimation", */
/*  ACM Trans. Math. Soft., vol. 14, no. 4, pp. 381-396, December 1988. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Save statement .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    --isgn;
    --x;
    --v;

    /* Function Body */
    if (*kase == 0) {
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    x[i__] = 1. / (doublereal) (*n);
/* L10: */
	}
	*kase = 1;
	jump = 1;
	return 0;
    }

    switch ((int)jump) {
	case 1:  goto L20;
	case 2:  goto L40;
	case 3:  goto L70;
	case 4:  goto L110;
	case 5:  goto L140;
    }

/*     ................ ENTRY   (JUMP = 1) */
/*     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY A*X. */

L20:
    if (*n == 1) {
	v[1] = x[1];
	*est = Dymola_abs(v[1]);
/*        ... QUIT */
	goto L150;
    }
    *est = dasum_(n, &x[1], &c__1);

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
		if (x[i__]>=0.0) {
			x[i__]=1;
			isgn[i__]=1;
		} else {
			x[i__]=-1;
			isgn[i__]=-1;
		}
/* L30: */
    }
    *kase = 2;
    jump = 2;
    return 0;

/*     ................ ENTRY   (JUMP = 2) */
/*     FIRST ITERATION.  X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X. */

L40:
    j = idamax_(n, &x[1], &c__1);
    iter = 2;

/*     MAIN LOOP - ITERATIONS 2,3,...,ITMAX. */

L50:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	x[i__] = 0.;
/* L60: */
    }
    x[j] = 1.;
    *kase = 1;
    jump = 3;
    return 0;

/*     ................ ENTRY   (JUMP = 3) */
/*     X HAS BEEN OVERWRITTEN BY A*X. */

L70:
    dcopy_(n, &x[1], &c__1, &v[1], &c__1);
    estold = *est;
    *est = dasum_(n, &v[1], &c__1);
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
		if (((x[i__]>=0.0) ? 1 : -1)!=isgn[i__]) {
	/*d__1 = d_sign(&c_b263, &x[i__]);
	if (i_dnnt(&d__1) != isgn[i__]){ */
	    goto L90;
	}
/* L80: */
    }
/*     REPEATED SIGN VECTOR DETECTED, HENCE ALGORITHM HAS CONVERGED. */
    goto L120;

L90:
/*     TEST FOR CYCLING. */
    if (*est <= estold) {
	goto L120;
    }

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
		if (x[i__]>=0.0) {
			x[i__]=1;
			isgn[i__]=1;
		} else {
			x[i__]=-1;
			isgn[i__]=-1;
		}
				/*
	x[i__] = d_sign(&c_b263, &x[i__]);
	isgn[i__] = i_dnnt(&x[i__]);*/
/* L100: */
    }
    *kase = 2;
    jump = 4;
    return 0;

/*     ................ ENTRY   (JUMP = 4) */
/*     X HAS BEEN OVERWRITTEN BY TRANDPOSE(A)*X. */

L110:
    jlast = j;
    j = idamax_(n, &x[1], &c__1);
    if (x[jlast] != (d__1 = x[j], Dymola_abs(d__1)) && iter < 5) {
	++iter;
	goto L50;
    }

/*     ITERATION COMPLETE.  FINAL STAGE. */

L120:
    altsgn = 1.;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	x[i__] = altsgn * ((doublereal) (i__ - 1) / (doublereal) (*n - 1) + 
		1.);
	altsgn = -altsgn;
/* L130: */
    }
    *kase = 1;
    jump = 5;
    return 0;

/*     ................ ENTRY   (JUMP = 5) */
/*     X HAS BEEN OVERWRITTEN BY A*X. */

L140:
    temp = dasum_(n, &x[1], &c__1) / (doublereal) (*n * 3) * 2.;
    if (temp > *est) {
	dcopy_(n, &x[1], &c__1, &v[1], &c__1);
	*est = temp;
    }

L150:
    *kase = 0;
    return 0;

/*     End of DLACON_CLEAN */

} /* dlacon_clean */

#undef i__
#undef j
#undef iter
#undef temp
#undef jump
#undef jlast
#undef altsgn
#undef estold

/* Subroutine */ DYMOLA_STATIC int dlaic1_(job, j, x, sest, w, gamma, sestpr, s, c__)
integer *job;
integer *j;
doublereal *x, *sest, *w, *gamma, *sestpr, *s, *c__;
{
    /* System generated locals */
    doublereal d__1, d__2, d__3, d__4;

    /* Local variables */
    doublereal b, t, s1, s2, eps, tmp;
    doublereal sine, test, zeta1, zeta2, alpha, norma;
    doublereal absgam, absalp, cosine, absest;
	doublereal sp,cp;


/*  -- LAPACK auxiliary routine (version 1.1) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd., */
/*     Courant Institute, Argonne National Lab, and Rice University */
/*     October 31, 1992 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  Purpose */
/*  ======= */

/*  DLAIC1 applies one step of incremental condition estimation in */
/*  its simplest version: */

/*  Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j */
/*  lower triangular matrix L, such that */
/*           twonorm(L*x) = sest */
/*  Then DLAIC1 computes sestpr, s, c such that */
/*  the vector */
/*                  [ s*x ] */
/*           xhat = [  c  ] */
/*  is an approximate singular vector of */
/*                  [ L     0  ] */
/*           Lhat = [ w' gamma ] */
/*  in the sense that */
/*           twonorm(Lhat*xhat) = sestpr. */

/*  Depending on JOB, an estimate for the largest or smallest singular */
/*  value is computed. */

/*  Note that [s c]' and sestpr**2 is an eigenpair of the system */

/*      diag(sest*sest, 0) + [alpha  gamma] * [ alpha ] */
/*                                            [ gamma ] */

/*  where  alpha =  x'*w. */

/*  Arguments */
/*  ========= */

/*  JOB     (input) INTEGER */
/*          = 1: an estimate for the largest singular value is computed. */
/*          = 2: an estimate for the smallest singular value is computed. */

/*  J       (input) INTEGER */
/*          Length of X and W */

/*  X       (input) DOUBLE PRECISION array, dimension (J) */
/*          The j-vector x. */

/*  SEST    (input) DOUBLE PRECISION */
/*          Estimated singular value of j by j matrix L */

/*  W       (input) DOUBLE PRECISION array, dimension (J) */
/*          The j-vector w. */

/*  GAMMA   (input) DOUBLE PRECISION */
/*          The diagonal element gamma. */

/*  SEDTPR  (output) DOUBLE PRECISION */
/*          Estimated singular value of (j+1) by (j+1) matrix Lhat. */

/*  S       (output) DOUBLE PRECISION */
/*          Sine needed in forming xhat. */

/*  C       (output) DOUBLE PRECISION */
/*          Cosine needed in forming xhat. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    --w;
    --x;

    /* Function Body */
    eps = DBL_EPSILON;
    /* alpha = ddot_(j, &x[1], &c__1, &w[1], &c__1); */
    alpha = ddot1_(j, &x[1], &w[1]);

    absalp = Dymola_abs(alpha);
    absgam = Dymola_abs(*gamma);
    absest = Dymola_abs(*sest);

    if (*job == 1) {

/*        Estimating largest singular value */

/*        special cases */

	if (absest == 0.) {
	    s1 = Dymola_max(absgam,absalp);
	    if (s1 == 0.) {
		sp = 0.;
		cp = 1.;
		*sestpr = 0.;
	    } else {
		sp = alpha / s1;
		cp = *gamma / s1;
		tmp = sqrt(sp * sp + cp * cp);
		sp /= tmp;
		cp /= tmp;
		*sestpr = s1 * tmp;
	    }
	} else if (absgam <= eps * absest) {
	    sp = 1.;
	    cp = 0.;
	    tmp = Dymola_max(absest,absalp);
	    s1 = absest / tmp;
	    s2 = absalp / tmp;
	    *sestpr = tmp * sqrt(s1 * s1 + s2 * s2);
	} else if (absalp <= eps * absest) {
	    s1 = absgam;
	    s2 = absest;
	    if (s1 <= s2) {
		sp = 1.;
		cp = 0.;
		*sestpr = s2;
	    } else {
		sp = 0.;
		cp = 1.;
		*sestpr = s1;
	    }
	} else if (absest <= eps * absalp || absest <= eps * absgam) {
	    s1 = absgam;
	    s2 = absalp;
	    if (s1 <= s2) {
		tmp = s1 / s2;
		sp = sqrt(tmp * tmp + 1.);
		*sestpr = s2 * sp;
		cp = *gamma / s2 / sp;
		sp=(alpha>=0.0? 1.0 : -1.0)/ sp;
		/* *s = d_sign(&c_b263, &alpha) / *s; */
	    } else {
		tmp = s2 / s1;
		cp = sqrt(tmp * tmp + 1.);
		*sestpr = s1 * cp;
		sp = alpha / s1 / cp;
		cp = (*gamma>=0.0 ? 1.0 : -1.0) / cp;
		/*	*c__ = d_sign(&c_b263, gamma) / *c__; */
	    }
	} else {

/*           normal case */

	    zeta1 = alpha / absest;
	    zeta2 = *gamma / absest;

	    b = (1. - zeta1 * zeta1 - zeta2 * zeta2) * .5;
	    cp = zeta1 * zeta1;
	    if (b > 0.) {
		t = cp / (b + sqrt(b * b + cp));
	    } else {
		t = sqrt(b * b + cp) - b;
	    }

	    sine = -zeta1 / t;
	    cosine = -zeta2 / (t + 1.);
	    tmp = sqrt(sine * sine + cosine * cosine);
	    sp = sine / tmp;
	    cp = cosine / tmp;
	    *sestpr = sqrt(t + 1.) * absest;
	}

    } else if (*job == 2) {

/*        Estimating smallest singular value */

/*        special cases */

	if (absest == 0.) {
	    *sestpr = 0.;
	    if (Dymola_max(absgam,absalp) == 0.) {
		sine = 1.;
		cosine = 0.;
	    } else {
		sine = -(*gamma);
		cosine = alpha;
	    }
/* Computing MAX */
	    d__1 = Dymola_abs(sine), d__2 = Dymola_abs(cosine);
	    s1 = Dymola_max(d__1,d__2);
	    sp = sine / s1;
	    cp = cosine / s1;
	    tmp = sqrt(sp * sp + cp * cp);
	    sp /= tmp;
	    cp /= tmp;
	} else if (absgam <= eps * absest) {
	    sp = 0.;
	    cp = 1.;
	    *sestpr = absgam;
	} else if (absalp <= eps * absest) {
	    s1 = absgam;
	    s2 = absest;
	    if (s1 <= s2) {
		sp = 0.;
		cp = 1.;
		*sestpr = s1;
	    } else {
		sp = 1.;
		cp = 0.;
		*sestpr = s2;
	    }
	} else if (absest <= eps * absalp || absest <= eps * absgam) {
	    s1 = absgam;
	    s2 = absalp;
	    if (s1 <= s2) {
		tmp = s1 / s2;
		cp = sqrt(tmp * tmp + 1.);
		*sestpr = absest * (tmp / cp);
		sp = -(*gamma / s2) / cp;
		cp = (alpha>=0.0 ? 1.0 : -1.0) / cp;
		/* *c__ = d_sign(&c_b263, &alpha) / *c__; */
	    } else {
		tmp = s2 / s1;
		sp = sqrt(tmp * tmp + 1.);
		*sestpr = absest / sp;
		cp = alpha / s1 / sp;
		sp = -(*gamma >= 0.0 ? 1.0 : -1.0) / sp;
		/* *s = -d_sign(&c_b263, gamma) / *s; */
	    }
	} else {

/*           normal case */

	    zeta1 = alpha / absest;
	    zeta2 = *gamma / absest;

/* Computing MAX */
		d__3 = zeta1 * zeta1 + 1. + Dymola_abs(zeta1 * zeta2);
		d__4 = Dymola_abs(zeta1 * zeta2) + zeta2 * zeta2;
	    norma = Dymola_max(d__3,d__4);

/*           See if root is closer to zero or to ONE */

	    test = (zeta1 - zeta2) * 2. * (zeta1 + zeta2) + 1.;
	    if (test >= 0.) {

/*              root is close to zero, compute directly */

		b = (zeta1 * zeta1 + zeta2 * zeta2 + 1.) * .5;
		cp = zeta2 * zeta2;
		t = cp / (b + sqrt(Dymola_abs(b * b - cp)));
		sine = zeta1 / (1. - t);
		cosine = -zeta2 / t;
		*sestpr = sqrt(t + eps * 4. * eps * norma) * absest;
	    } else {

/*              root is closer to ONE, shift by that amount */

		b = (zeta2 * zeta2 + zeta1 * zeta1 - 1.) * .5;
		cp = zeta1 * zeta1;
		if (b >= 0.) {
		    t = -(cp) / (b + sqrt(b * b + cp));
		} else {
		    t = b - sqrt(b * b + cp);
		}
		sine = -zeta1 / t;
		cosine = -zeta2 / (t + 1.);
		*sestpr = sqrt(t + 1. + eps * 4. * eps * norma) * absest;
	    }
	    tmp = sqrt(sine * sine + cosine * cosine);
	    sp = sine / tmp;
	    cp = cosine / tmp;

	}
    } else return 0;
	*s = sp;
	*c__ = cp;
    return 0;

/*     End of DLAIC1 */

} /* dlaic1_ */

#ifndef GODESS
static doublereal dlamch_(char *cmach)
{
#if 1
	/* Fast variant, no extra calls */
    switch (*cmach) {
    case 'e':
    case 'E':
		return DBL_EPSILON;
    case 's':
    case 'S':
		return DBL_MIN;
    case 'b':
    case 'B':
		return FLT_RADIX;
    case 'p':
    case 'P':
		return DBL_EPSILON * FLT_RADIX;
    case 'n':
    case 'N':
		return DBL_MANT_DIG;
    case 'r':
    case 'R':
		return FLT_ROUNDS == 1;
    case 'm':
    case 'M':
		return DBL_MIN_10_EXP;
    case 'u':
    case 'U':
		return DBL_MIN;
    case 'l':
    case 'L':
		return DBL_MAX_10_EXP;
    case 'o':
    case 'O':
		return DBL_MAX;
    default:
		return 0;	/* error */
    }
#else /* 1 */
    /* Initialized data */

    static logical first = TRUE_;

    /* System generated locals */
    integer i__1;
    doublereal ret_val;

    /* Local variables */
    static doublereal t;
    integer it;
    static doublereal rnd, eps, base;
    integer beta;
    static doublereal emin, prec, emax;
    integer imin, imax;
    logical lrnd;
    static doublereal rmin, rmax;
    doublereal rmach;
    doublereal small;
    static doublereal sfmin;

/*  -- LAPACK auxiliary routine (version 3.4.1) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     April 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Save statement .. */
/*     .. */
/*     .. Data statements .. */
/*     .. */
/*     .. Executable Statements .. */

    if (first) {
	dlamc2_(&beta, &it, &lrnd, &eps, &imin, &rmin, &imax, &rmax);
	base = (doublereal) beta;
	t = (doublereal) it;
	if (lrnd) {
	    rnd = 1.;
	    i__1 = 1 - it;
	    eps = pow_di(&base, &i__1) / 2;
	} else {
	    rnd = 0.;
	    i__1 = 1 - it;
	    eps = pow_di(&base, &i__1);
	}
	prec = eps * base;
	emin = (doublereal) imin;
	emax = (doublereal) imax;
	sfmin = rmin;
	small = 1. / rmax;
	if (small >= sfmin) {

/*           Use SMALL plus a bit, to avoid the possibility of rounding */
/*           causing overflow when computing  1/sfmin. */

	    sfmin = small * (eps + 1.);
	}
    }

    if (lsame_(cmach, "E", (ftnlen)1, (ftnlen)1)) {
	rmach = eps;
    } else if (lsame_(cmach, "S", (ftnlen)1, (ftnlen)1)) {
	rmach = sfmin;
    } else if (lsame_(cmach, "B", (ftnlen)1, (ftnlen)1)) {
	rmach = base;
    } else if (lsame_(cmach, "P", (ftnlen)1, (ftnlen)1)) {
	rmach = prec;
    } else if (lsame_(cmach, "N", (ftnlen)1, (ftnlen)1)) {
	rmach = t;
    } else if (lsame_(cmach, "R", (ftnlen)1, (ftnlen)1)) {
	rmach = rnd;
    } else if (lsame_(cmach, "M", (ftnlen)1, (ftnlen)1)) {
	rmach = emin;
    } else if (lsame_(cmach, "U", (ftnlen)1, (ftnlen)1)) {
	rmach = rmin;
    } else if (lsame_(cmach, "L", (ftnlen)1, (ftnlen)1)) {
	rmach = emax;
    } else if (lsame_(cmach, "O", (ftnlen)1, (ftnlen)1)) {
	rmach = rmax;
    }
    ret_val = rmach;
    first = FALSE_;
    return ret_val;

#endif /* 1 */
/*     End of DLAMCH */

} /* dlamch_ */


/* *********************************************************************** */

/* > \brief \b DLAMC1 */
/* > \details */
/* > \b Purpose: */
/* > \verbatim */
/* > DLAMC1 determines the machine parameters given by BETA, T, RND, and */
/* > IEEE1. */
/* > \endverbatim */
/* > */
/* > \param[out] BETA */
/* > \verbatim */
/* >          The base of the machine. */
/* > \endverbatim */
/* > */
/* > \param[out] T */
/* > \verbatim */
/* >          The number of ( BETA ) digits in the mantissa. */
/* > \endverbatim */
/* > */
/* > \param[out] RND */
/* > \verbatim */
/* >          Specifies whether proper rounding  ( RND = .TRUE. )  or */
/* >          chopping  ( RND = .FALSE. )  occurs in addition. This may not */
/* >          be a reliable guide to the way in which the machine performs */
/* >          its arithmetic. */
/* > \endverbatim */
/* > */
/* > \param[out] IEEE1 */
/* > \verbatim */
/* >          Specifies whether rounding appears to be done in the IEEE */
/* >          'round to nearest' style. */
/* > \endverbatim */
/* > \author LAPACK is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. 
of Colorado Denver and NAG Ltd.. */
/* > \date April 2012 */
/* > \ingroup auxOTHERauxiliary */
/* > */
/* > \details \b Further \b Details */
/* > \verbatim */
/* > */
/* >  The routine is based on the routine  ENVRON  by Malcolm and */
/* >  incorporates suggestions by Gentleman and Marovich. See */
/* > */
/* >     Malcolm M. A. (1972) Algorithms to reveal properties of */
/* >        floating-point arithmetic. Comms. of the ACM, 15, 949-951. */
/* > */
/* >     Gentleman W. M. and Marovich S. B. (1974) More on algorithms */
/* >        that reveal properties of floating point arithmetic units. */
/* >        Comms. of the ACM, 17, 276-277. */
/* > \endverbatim */
/* > */
/* Subroutine */ static int dlamc1_(integer *beta, integer *t, logical *rnd, logical 
	*ieee1)
{
    /* Initialized data */

    static logical first = TRUE_;

    /* System generated locals */
    doublereal d__1, d__2;

    /* Local variables */
    doublereal a, b, c__, f, t1, t2;
    static integer lt;
    doublereal one, qtr;
    static logical lrnd;
    static integer lbeta;
    doublereal savec;
    static logical lieee1;


/*  -- LAPACK auxiliary routine (version 3.4.1) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. */
/*     November 2010 */

/*     .. Scalar Arguments .. */
/*     .. */
/* ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Save statement .. */
/*     .. */
/*     .. Data statements .. */
/*     .. */
/*     .. Executable Statements .. */

    if (first) {
	one = 1.;

/*        LBETA,  LIEEE1,  LT and  LRND  are the  local values  of  BETA, */
/*        IEEE1, T and RND. */

/*        Throughout this routine  we use the function  DLAMC3  to ensure */
/*        that relevant values are  stored and not held in registers,  or */
/*        are not affected by optimizers. */

/*        Compute  a = 2.0**m  with the  smallest positive integer m such */
/*        that */

/*           fl( a + 1.0 ) = a. */

	a = 1.;
	c__ = 1.;

/* +       WHILE( C.EQ.ONE )LOOP */
L10:
	if (c__ == one) {
	    a *= 2;
	    c__ = dlamc3_(&a, &one);
	    d__1 = -a;
	    c__ = dlamc3_(&c__, &d__1);
	    goto L10;
	}
/* +       END WHILE */

/*        Now compute  b = 2.0**m  with the smallest positive integer m */
/*        such that */

/*           fl( a + b ) .gt. a. */

	b = 1.;
	c__ = dlamc3_(&a, &b);

/* +       WHILE( C.EQ.A )LOOP */
L20:
	if (c__ == a) {
	    b *= 2;
	    c__ = dlamc3_(&a, &b);
	    goto L20;
	}
/* +       END WHILE */

/*        Now compute the base.  a and c  are neighbouring floating point */
/*        numbers  in the  interval  ( beta**t, beta**( t + 1 ) )  and so */
/*        their difference is beta. Adding 0.25 to c is to ensure that it */
/*        is truncated to beta and not ( beta - 1 ). */

	qtr = one / 4;
	savec = c__;
	d__1 = -a;
	c__ = dlamc3_(&c__, &d__1);
	lbeta = (integer) (c__ + qtr);

/*        Now determine whether rounding or chopping occurs,  by adding a */
/*        bit  less  than  beta/2  and a  bit  more  than  beta/2  to  a. */

	b = (doublereal) lbeta;
	d__1 = b / 2;
	d__2 = -b / 100;
	f = dlamc3_(&d__1, &d__2);
	c__ = dlamc3_(&f, &a);
	if (c__ == a) {
	    lrnd = TRUE_;
	} else {
	    lrnd = FALSE_;
	}
	d__1 = b / 2;
	d__2 = b / 100;
	f = dlamc3_(&d__1, &d__2);
	c__ = dlamc3_(&f, &a);
	if (lrnd && c__ == a) {
	    lrnd = FALSE_;
	}

/*        Try and decide whether rounding is done in the  IEEE  'round to */
/*        nearest' style. B/2 is half a unit in the last place of the two */
/*        numbers A and SAVEC. Furthermore, A is even, i.e. has last  bit */
/*        zero, and SAVEC is odd. Thus adding B/2 to A should not  change */
/*        A, but adding B/2 to SAVEC should change SAVEC. */

	d__1 = b / 2;
	t1 = dlamc3_(&d__1, &a);
	d__1 = b / 2;
	t2 = dlamc3_(&d__1, &savec);
	lieee1 = t1 == a && t2 > savec && lrnd;

/*        Now find  the  mantissa, t.  It should  be the  integer part of */
/*        log to the base beta of a,  however it is safer to determine  t */
/*        by powering.  So we find t as the smallest positive integer for */
/*        which */

/*           fl( beta**t + 1.0 ) = 1.0. */

	lt = 0;
	a = 1.;
	c__ = 1.;

/* +       WHILE( C.EQ.ONE )LOOP */
L30:
	if (c__ == one) {
	    ++lt;
	    a *= lbeta;
	    c__ = dlamc3_(&a, &one);
	    d__1 = -a;
	    c__ = dlamc3_(&c__, &d__1);
	    goto L30;
	}
/* +       END WHILE */

    }

    *beta = lbeta;
    *t = lt;
    *rnd = lrnd;
    *ieee1 = lieee1;
    first = FALSE_;
    return 0;

/*     End of DLAMC1 */

} /* dlamc1_ */


/* *********************************************************************** */

/* > \brief \b DLAMC2 */
/* > \details */
/* > \b Purpose: */
/* > \verbatim */
/* > DLAMC2 determines the machine parameters specified in its argument */
/* > list. */
/* > \endverbatim */
/* > \author LAPACK is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. 
of Colorado Denver and NAG Ltd.. */
/* > \date April 2012 */
/* > \ingroup auxOTHERauxiliary */
/* > */
/* > \param[out] BETA */
/* > \verbatim */
/* >          The base of the machine. */
/* > \endverbatim */
/* > */
/* > \param[out] T */
/* > \verbatim */
/* >          The number of ( BETA ) digits in the mantissa. */
/* > \endverbatim */
/* > */
/* > \param[out] RND */
/* > \verbatim */
/* >          Specifies whether proper rounding  ( RND = .TRUE. )  or */
/* >          chopping  ( RND = .FALSE. )  occurs in addition. This may not */
/* >          be a reliable guide to the way in which the machine performs */
/* >          its arithmetic. */
/* > \endverbatim */
/* > */
/* > \param[out] EPS */
/* > \verbatim */
/* >          The smallest positive number such that */
/* >             fl( 1.0 - EPS ) .LT. 1.0, */
/* >          where fl denotes the computed value. */
/* > \endverbatim */
/* > */
/* > \param[out] EMIN */
/* > \verbatim */
/* >          The minimum exponent before (gradual) underflow occurs. */
/* > \endverbatim */
/* > */
/* > \param[out] RMIN */
/* > \verbatim */
/* >          The smallest normalized number for the machine, given by */
/* >          BASE**( EMIN - 1 ), where  BASE  is the floating point value */
/* >          of BETA. */
/* > \endverbatim */
/* > */
/* > \param[out] EMAX */
/* > \verbatim */
/* >          The maximum exponent before overflow occurs. */
/* > \endverbatim */
/* > */
/* > \param[out] RMAX */
/* > \verbatim */
/* >          The largest positive number for the machine, given by */
/* >          BASE**EMAX * ( 1 - EPS ), where  BASE  is the floating point */
/* >          value of BETA. */
/* > \endverbatim */
/* > */
/* > \details \b Further \b Details */
/* > \verbatim */
/* > */
/* >  The computation of  EPS  is based on a routine PARANOIA by */
/* >  W. Kahan of the University of California at Berkeley. */
/* > \endverbatim */
/* Subroutine */ static int dlamc2_(integer *beta, integer *t, logical *rnd, 
	doublereal *eps, integer *emin, doublereal *rmin, integer *emax, 
	doublereal *rmax)
{
    /* Initialized data */

    static logical first = TRUE_;
    static logical iwarn = FALSE_;

    /* Format strings */
    static char fmt_9999[] = "(//\002 WARNING. The value EMIN may be incorre"
	    "ct:-\002,\002  EMIN = \002,i8,/\002 If, after inspection, the va"
	    "lue EMIN looks\002,\002 acceptable please comment out \002,/\002"
	    " the IF block as marked within the code of routine\002,\002 DLAM"
	    "C2,\002,/\002 otherwise supply EMIN explicitly.\002,/)";

    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2, d__3, d__4, d__5;

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    doublereal a, b, c__;
    integer i__;
    static integer lt;
    doublereal one, two;
    logical ieee;
    doublereal half;
    logical lrnd;
    static doublereal leps;
    doublereal zero;
    static integer lbeta;
    doublereal rbase;
    static integer lemin, lemax;
    integer gnmin;
    doublereal small;
    integer gpmin;
    doublereal third;
    static doublereal lrmin, lrmax;
    doublereal sixth;
    logical lieee1;
    integer ngnmin, ngpmin;

    /* Fortran I/O blocks */
    static cilist io___58 = { 0, 6, 0, fmt_9999, 0 };



/*  -- LAPACK auxiliary routine (version 3.4.1) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. */
/*     November 2010 */

/*     .. Scalar Arguments .. */
/*     .. */
/* ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Save statement .. */
/*     .. */
/*     .. Data statements .. */
/*     .. */
/*     .. Executable Statements .. */

    if (first) {
	zero = 0.;
	one = 1.;
	two = 2.;

/*        LBETA, LT, LRND, LEPS, LEMIN and LRMIN  are the local values of */
/*        BETA, T, RND, EPS, EMIN and RMIN. */

/*        Throughout this routine  we use the function  DLAMC3  to ensure */
/*        that relevant values are stored  and not held in registers,  or */
/*        are not affected by optimizers. */

/*        DLAMC1 returns the parameters  LBETA, LT, LRND and LIEEE1. */

	dlamc1_(&lbeta, &lt, &lrnd, &lieee1);

/*        Start to find EPS. */

	b = (doublereal) lbeta;
	i__1 = -lt;
	a = pow_di(&b, &i__1);
	leps = a;

/*        Try some tricks to see whether or not this is the correct  EPS. */

	b = two / 3;
	half = one / 2;
	d__1 = -half;
	sixth = dlamc3_(&b, &d__1);
	third = dlamc3_(&sixth, &sixth);
	d__1 = -half;
	b = dlamc3_(&third, &d__1);
	b = dlamc3_(&b, &sixth);
	b = Dymola_abs(b);
	if (b < leps) {
	    b = leps;
	}

	leps = 1.;

/* +       WHILE( ( LEPS.GT.B ).AND.( B.GT.ZERO ) )LOOP */
L10:
	if (leps > b && b > zero) {
	    leps = b;
	    d__1 = half * leps;
/* Computing 5th power */
	    d__3 = two, d__4 = d__3, d__3 *= d__3;
/* Computing 2nd power */
	    d__5 = leps;
	    d__2 = d__4 * (d__3 * d__3) * (d__5 * d__5);
	    c__ = dlamc3_(&d__1, &d__2);
	    d__1 = -c__;
	    c__ = dlamc3_(&half, &d__1);
	    b = dlamc3_(&half, &c__);
	    d__1 = -b;
	    c__ = dlamc3_(&half, &d__1);
	    b = dlamc3_(&half, &c__);
	    goto L10;
	}
/* +       END WHILE */

	if (a < leps) {
	    leps = a;
	}

/*        Computation of EPS complete. */

/*        Now find  EMIN.  Let A = + or - 1, and + or - (1 + BASE**(-3)). */
/*        Keep dividing  A by BETA until (gradual) underflow occurs. This */
/*        is detected when we cannot recover the previous A. */

	rbase = one / lbeta;
	small = one;
	for (i__ = 1; i__ <= 3; ++i__) {
	    d__1 = small * rbase;
	    small = dlamc3_(&d__1, &zero);
/* L20: */
	}
	a = dlamc3_(&one, &small);
	dlamc4_(&ngpmin, &one, &lbeta);
	d__1 = -one;
	dlamc4_(&ngnmin, &d__1, &lbeta);
	dlamc4_(&gpmin, &a, &lbeta);
	d__1 = -a;
	dlamc4_(&gnmin, &d__1, &lbeta);
	ieee = FALSE_;

	if (ngpmin == ngnmin && gpmin == gnmin) {
	    if (ngpmin == gpmin) {
		lemin = ngpmin;
/*            ( Non twos-complement machines, no gradual underflow; */
/*              e.g.,  VAX ) */
	    } else if (gpmin - ngpmin == 3) {
		lemin = ngpmin - 1 + lt;
		ieee = TRUE_;
/*            ( Non twos-complement machines, with gradual underflow; */
/*              e.g., IEEE standard followers ) */
	    } else {
		lemin = Dymola_min(ngpmin,gpmin);
/*            ( A guess; no known machine ) */
		iwarn = TRUE_;
	    }

	} else if (ngpmin == gpmin && ngnmin == gnmin) {
	    if ((i__1 = ngpmin - ngnmin, Dymola_abs(i__1)) == 1) {
		lemin = Dymola_max(ngpmin,ngnmin);
/*            ( Twos-complement machines, no gradual underflow; */
/*              e.g., CYBER 205 ) */
	    } else {
		lemin = Dymola_min(ngpmin,ngnmin);
/*            ( A guess; no known machine ) */
		iwarn = TRUE_;
	    }

	} else if ((i__1 = ngpmin - ngnmin, Dymola_abs(i__1)) == 1 && gpmin == gnmin)
		 {
	    if (gpmin - Dymola_min(ngpmin,ngnmin) == 3) {
		lemin = Dymola_max(ngpmin,ngnmin) - 1 + lt;
/*            ( Twos-complement machines with gradual underflow; */
/*              no known machine ) */
	    } else {
		lemin = Dymola_min(ngpmin,ngnmin);
/*            ( A guess; no known machine ) */
		iwarn = TRUE_;
	    }

	} else {
/* Computing MIN */
	    i__1 = Dymola_min(ngpmin,ngnmin), i__1 = Dymola_min(i__1,gpmin);
	    lemin = Dymola_min(i__1,gnmin);
/*         ( A guess; no known machine ) */
	    iwarn = TRUE_;
	}
	first = FALSE_;
/* ** */
/* Comment out this if block if EMIN is ok */
	if (iwarn) {
	    first = TRUE_;
      /*
	    s_wsfe(&io___58);
	    do_fio(&c__1, (char *)&lemin, (ftnlen)sizeof(integer));
	    e_wsfe();
      */
	}
/* ** */

/*        Assume IEEE arithmetic if we found denormalised  numbers above, */
/*        or if arithmetic seems to round in the  IEEE style,  determined */
/*        in routine DLAMC1. A true IEEE machine should have both  things */
/*        true; however, faulty machines may have one or the other. */

	ieee = ieee || lieee1;

/*        Compute  RMIN by successive division by  BETA. We could compute */
/*        RMIN as BASE**( EMIN - 1 ),  but some machines underflow during */
/*        this computation. */

	lrmin = 1.;
	i__1 = 1 - lemin;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    d__1 = lrmin * rbase;
	    lrmin = dlamc3_(&d__1, &zero);
/* L30: */
	}

/*        Finally, call DLAMC5 to compute EMAX and RMAX. */

	dlamc5_(&lbeta, &lt, &lemin, &ieee, &lemax, &lrmax);
    }

    *beta = lbeta;
    *t = lt;
    *rnd = lrnd;
    *eps = leps;
    *emin = lemin;
    *rmin = lrmin;
    *emax = lemax;
    *rmax = lrmax;

    return 0;


/*     End of DLAMC2 */

} /* dlamc2_ */


/* *********************************************************************** */

/* > \brief \b DLAMC3 */
/* > \details */
/* > \b Purpose: */
/* > \verbatim */
/* > DLAMC3  is intended to force  A  and  B  to be stored prior to doing */
/* > the addition of  A  and  B ,  for use in situations where optimizers */
/* > might hold one of these in a register. */
/* > \endverbatim */
/* > */
/* > \param[in] A */
/* > */
/* > \param[in] B */
/* > \verbatim */
/* >          The values A and B. */
/* > \endverbatim */
static doublereal dlamc3_(doublereal *a, doublereal *b)
{
    /* System generated locals */
    doublereal ret_val;


/*  -- LAPACK auxiliary routine (version 3.4.1) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. */
/*     November 2010 */

/*     .. Scalar Arguments .. */
/*     .. */
/* ===================================================================== */

/*     .. Executable Statements .. */

    ret_val = *a + *b;

    return ret_val;

/*     End of DLAMC3 */

} /* dlamc3_ */


/* *********************************************************************** */

/* > \brief \b DLAMC4 */
/* > \details */
/* > \b Purpose: */
/* > \verbatim */
/* > DLAMC4 is a service routine for DLAMC2. */
/* > \endverbatim */
/* > */
/* > \param[out] EMIN */
/* > \verbatim */
/* >          The minimum exponent before (gradual) underflow, computed by */
/* >          setting A = START and dividing by BASE until the previous A */
/* >          can not be recovered. */
/* > \endverbatim */
/* > */
/* > \param[in] START */
/* > \verbatim */
/* >          The starting point for determining EMIN. */
/* > \endverbatim */
/* > */
/* > \param[in] BASE */
/* > \verbatim */
/* >          The base of the machine. */
/* > \endverbatim */
/* > */
/* Subroutine */ static int dlamc4_(integer *emin, doublereal *start, integer *base)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Local variables */
    doublereal a;
    integer i__;
    doublereal b1, b2, c1, c2, d1, d2, one, zero, rbase;

/*  -- LAPACK auxiliary routine (version 3.4.1) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. */
/*     November 2010 */

/*     .. Scalar Arguments .. */
/*     .. */
/* ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    a = *start;
    one = 1.;
    rbase = one / *base;
    zero = 0.;
    *emin = 1;
    d__1 = a * rbase;
    b1 = dlamc3_(&d__1, &zero);
    c1 = a;
    c2 = a;
    d1 = a;
    d2 = a;
/* +    WHILE( ( C1.EQ.A ).AND.( C2.EQ.A ).AND. */
/*    $       ( D1.EQ.A ).AND.( D2.EQ.A )      )LOOP */
L10:
    if (c1 == a && c2 == a && d1 == a && d2 == a) {
	--(*emin);
	a = b1;
	d__1 = a / *base;
	b1 = dlamc3_(&d__1, &zero);
	d__1 = b1 * *base;
	c1 = dlamc3_(&d__1, &zero);
	d1 = zero;
	i__1 = *base;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    d1 += b1;
/* L20: */
	}
	d__1 = a * rbase;
	b2 = dlamc3_(&d__1, &zero);
	d__1 = b2 / rbase;
	c2 = dlamc3_(&d__1, &zero);
	d2 = zero;
	i__1 = *base;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    d2 += b2;
/* L30: */
	}
	goto L10;
    }
/* +    END WHILE */

    return 0;

/*     End of DLAMC4 */

} /* dlamc4_ */


/* *********************************************************************** */

/* > \brief \b DLAMC5 */
/* > \details */
/* > \b Purpose: */
/* > \verbatim */
/* > DLAMC5 attempts to compute RMAX, the largest machine floating-point */
/* > number, without overflow.  It assumes that EMAX + Dymola_abs(EMIN) sum */
/* > approximately to a power of 2.  It will fail on machines where this */
/* > assumption does not hold, for example, the Cyber 205 (EMIN = -28625, */
/* > EMAX = 28718).  It will also fail if the value supplied for EMIN is */
/* > too large (i.e. too close to zero), probably with overflow. */
/* > \endverbatim */
/* > */
/* > \param[in] BETA */
/* > \verbatim */
/* >          The base of floating-point arithmetic. */
/* > \endverbatim */
/* > */
/* > \param[in] P */
/* > \verbatim */
/* >          The number of base BETA digits in the mantissa of a */
/* >          floating-point value. */
/* > \endverbatim */
/* > */
/* > \param[in] EMIN */
/* > \verbatim */
/* >          The minimum exponent before (gradual) underflow. */
/* > \endverbatim */
/* > */
/* > \param[in] IEEE */
/* > \verbatim */
/* >          A logical flag specifying whether or not the arithmetic */
/* >          system is thought to comply with the IEEE standard. */
/* > \endverbatim */
/* > */
/* > \param[out] EMAX */
/* > \verbatim */
/* >          The largest exponent before overflow */
/* > \endverbatim */
/* > */
/* > \param[out] RMAX */
/* > \verbatim */
/* >          The largest machine floating-point number. */
/* > \endverbatim */
/* > */
/* Subroutine */ static int dlamc5_(integer *beta, integer *p, integer *emin, 
	logical *ieee, integer *emax, doublereal *rmax)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Local variables */
    integer i__;
    doublereal y, z__;
    integer try__, lexp;
    doublereal oldy;
    integer uexp, nbits;
    doublereal recbas;
    integer exbits, expsum;


/*  -- LAPACK auxiliary routine (version 3.4.1) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. */
/*     November 2010 */

/*     .. Scalar Arguments .. */
/*     .. */
/* ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     First compute LEXP and UEXP, two powers of 2 that bound */
/*     Dymola_abs(EMIN). We then assume that EMAX + Dymola_abs(EMIN) will sum */
/*     approximately to the bound that is closest to Dymola_abs(EMIN). */
/*     (EMAX is the exponent of the required number RMAX). */

    lexp = 1;
    exbits = 1;
L10:
    try__ = lexp << 1;
    if (try__ <= -(*emin)) {
	lexp = try__;
	++exbits;
	goto L10;
    }
    if (lexp == -(*emin)) {
	uexp = lexp;
    } else {
	uexp = try__;
	++exbits;
    }

/*     Now -LEXP is less than or equal to EMIN, and -UEXP is greater */
/*     than or equal to EMIN. EXBITS is the number of bits needed to */
/*     store the exponent. */

    if (uexp + *emin > -lexp - *emin) {
	expsum = lexp << 1;
    } else {
	expsum = uexp << 1;
    }

/*     EXPSUM is the exponent range, approximately equal to */
/*     EMAX - EMIN + 1 . */

    *emax = expsum + *emin - 1;
    nbits = exbits + 1 + *p;

/*     NBITS is the total number of bits needed to store a */
/*     floating-point number. */

    if (nbits % 2 == 1 && *beta == 2) {

/*        Either there are an odd number of bits used to store a */
/*        floating-point number, which is unlikely, or some bits are */
/*        not used in the representation of numbers, which is possible, */
/*        (e.g. Cray machines) or the mantissa has an implicit bit, */
/*        (e.g. IEEE machines, Dec Vax machines), which is perhaps the */
/*        most likely. We have to assume the last alternative. */
/*        If this is true, then we need to reduce EMAX by one because */
/*        there must be some way of representing zero in an implicit-bit */
/*        system. On machines like Cray, we are reducing EMAX by one */
/*        unnecessarily. */

	--(*emax);
    }

    if (*ieee) {

/*        Assume we are on an IEEE machine which reserves one exponent */
/*        for infinity and NaN. */

	--(*emax);
    }

/*     Now create RMAX, the largest machine number, which should */
/*     be equal to (1.0 - BETA**(-P)) * BETA**EMAX . */

/*     First compute 1.0 - BETA**(-P), being careful that the */
/*     result is less than 1.0 . */

    recbas = 1. / *beta;
    z__ = *beta - 1.;
    y = 0.;
    i__1 = *p;
    for (i__ = 1; i__ <= i__1; ++i__) {
	z__ *= recbas;
	if (y < 1.) {
	    oldy = y;
	}
	y = dlamc3_(&y, &z__);
/* L20: */
    }
    if (y >= 1.) {
	y = oldy;
    }

/*     Now multiply by BETA**EMAX to get RMAX. */

    i__1 = *emax;
    for (i__ = 1; i__ <= i__1; ++i__) {
	d__1 = y * *beta;
	y = dlamc3_(&d__1, &c_b32);
/* L30: */
    }

    *rmax = y;
    return 0;

/*     End of DLAMC5 */

} /* dlamc5_ */

DYMOLA_STATIC doublereal dlange_(const char *norm, integer *m, integer *n, const doublereal *a, integer *lda, doublereal *work)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal ret_val, d__1;

    /* Local variables */
    integer i__, j;
    doublereal sum, temp, scale;
    doublereal value;
    extern logical disnan_(doublereal *);

/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/* ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --work;

    /* Function Body */
    if (Dymola_min(*m,*n) == 0) {
	value = 0.;
    } else if (lsame_(norm, "M", (ftnlen)1, (ftnlen)1)) {

/*        Find max(Dymola_abs(A(i,j))). */

	value = 0.;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *m;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		temp = (d__1 = a[i__ + j * a_dim1], Dymola_abs(d__1));
		if (value < temp || disnan_(&temp)) {
		    value = temp;
		}
/* L10: */
	    }
/* L20: */
	}
    } else if (lsame_(norm, "O", (ftnlen)1, (ftnlen)1) || *(unsigned char *)
	    norm == '1') {

/*        Find norm1(A). */

	value = 0.;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    sum = 0.;
	    i__2 = *m;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		sum += (d__1 = a[i__ + j * a_dim1], Dymola_abs(d__1));
/* L30: */
	    }
	    if (value < sum || disnan_(&sum)) {
		value = sum;
	    }
/* L40: */
	}
    } else if (lsame_(norm, "I", (ftnlen)1, (ftnlen)1)) {

/*        Find normI(A). */

	i__1 = *m;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    work[i__] = 0.;
/* L50: */
	}
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *m;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		work[i__] += (d__1 = a[i__ + j * a_dim1], Dymola_abs(d__1));
/* L60: */
	    }
/* L70: */
	}
	value = 0.;
	i__1 = *m;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    temp = work[i__];
	    if (value < temp || disnan_(&temp)) {
		value = temp;
	    }
/* L80: */
	}
    } else if (lsame_(norm, "F", (ftnlen)1, (ftnlen)1) || lsame_(norm, "E", (
	    ftnlen)1, (ftnlen)1)) {

/*        Find normF(A). */

	scale = 0.;
	sum = 1.;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
    dlassq_(m, (doublereal*) &a[j * a_dim1 + 1], &c__1, &scale, &sum);
/* L90: */
	}
	value = scale * sqrt(sum);
    }

    ret_val = value;
    return ret_val;

/*     End of DLANGE */

} /* dlange_ */


DYMOLA_STATIC doublereal dlapy2_(x, y)
doublereal *x, *y;
{
    /* System generated locals */
    doublereal ret_val, d__1;


    /* Local variables */
    doublereal w, z__, xabs, yabs;


/*  -- LAPACK auxiliary routine (version 1.1) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd., */
/*     Courant Institute, Argonne National Lab, and Rice University */
/*     October 31, 1992 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  Purpose */
/*  ======= */

/*  DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary 
*/
/*  overflow. */

/*  Arguments */
/*  ========= */

/*  X       (input) DOUBLE PRECISION */
/*  Y       (input) DOUBLE PRECISION */
/*          X and Y specify the values x and y. */

/*  ===================================================================== 
*/

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    xabs = Dymola_abs(*x);
    yabs = Dymola_abs(*y);
    w = Dymola_max(xabs,yabs);
    z__ = Dymola_min(xabs,yabs);
    if (z__ == 0.) {
	ret_val = w;
    } else {
/* Computing 2nd power */
	d__1 = z__ / w;
	ret_val = w * sqrt(d__1 * d__1 + 1.);
    }
    return ret_val;

/*     End of DLAPY2 */

} /* dlapy2_ */



/* Subroutine */ DYMOLA_STATIC int dlarf_(char *side, integer *m, integer *n, doublereal *v, integer *incv, doublereal *tau, doublereal *c__, integer *ldc, doublereal *work)
{
    /* System generated locals */
    integer c_dim1, c_offset;
    doublereal d__1;

    /* Local variables */
    integer i__;
    logical applyleft;
    integer lastc, lastv;
    extern integer iladlc_(integer *, integer *, doublereal *, integer *), 
	    iladlr_(integer *, integer *, doublereal *, integer *);

/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    --v;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    applyleft = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
    lastv = 0;
    lastc = 0;
    if (*tau != 0.) {
/*     Set up variables for scanning V.  LASTV begins pointing to the end */
/*     of V. */
	if (applyleft) {
	    lastv = *m;
	} else {
	    lastv = *n;
	}
	if (*incv > 0) {
	    i__ = (lastv - 1) * *incv + 1;
	} else {
	    i__ = 1;
	}
/*     Look for the last non-zero row in V. */
	while(lastv > 0 && v[i__] == 0.) {
	    --lastv;
	    i__ -= *incv;
	}
	if (applyleft) {
/*     Scan for the last non-zero column in C(1:lastv,:). */
	    lastc = iladlc_(&lastv, n, &c__[c_offset], ldc);
	} else {
/*     Scan for the last non-zero row in C(:,1:lastv). */
	    lastc = iladlr_(m, &lastv, &c__[c_offset], ldc);
	}
    }
/*     Note that lastc.eq.0 renders the BLAS operations null; no special */
/*     case is needed at this level. */
    if (applyleft) {

/*        Form  H * C */

	if (lastv > 0) {

/*           w(1:lastc,1) := C(1:lastv,1:lastc)**T * v(1:lastv,1) */

	    dgemv_("Transpose", &lastv, &lastc, &c_b4, &c__[c_offset], ldc, &
		    v[1], incv, &c_b5_dlarf, &work[1], &c__1);

/*           C(1:lastv,1:lastc) := C(...) - v(1:lastv,1) * w(1:lastc,1)**T */

	    d__1 = -(*tau);
	    dger_(&lastv, &lastc, &d__1, &v[1], incv, &work[1], &c__1, &c__[
		    c_offset], ldc);
	}
    } else {

/*        Form  C * H */

	if (lastv > 0) {

/*           w(1:lastc,1) := C(1:lastc,1:lastv) * v(1:lastv,1) */

	    dgemv_("No transpose", &lastc, &lastv, &c_b4, &c__[c_offset], ldc,
		     &v[1], incv, &c_b5_dlarf, &work[1], &c__1);

/*           C(1:lastc,1:lastv) := C(...) - w(1:lastc,1) * v(1:lastv,1)**T */

	    d__1 = -(*tau);
	    dger_(&lastc, &lastv, &d__1, &work[1], &c__1, &v[1], incv, &c__[
		    c_offset], ldc);
	}
    }
    return 0;

/*     End of DLARF */

} /* dlarf_ */


DYMOLA_STATIC int dlarfg_(integer *n, doublereal *alpha, doublereal *x, 
	integer *incx, doublereal *tau)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Local variables */
    integer j, knt;
    doublereal beta;
    doublereal xnorm;
    doublereal safmin, rsafmn;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    --x;

    /* Function Body */
    if (*n <= 1) {
	*tau = 0.;
	return 0;
    }

    i__1 = *n - 1;
    xnorm = dnrm2_(&i__1, &x[1], incx);

    if (xnorm == 0.) {

/*        H  =  I */

	*tau = 0.;
    } else {

/*        general case */

	d__1 = dlapy2_(alpha, &xnorm);
	beta = -d_sign(&d__1, alpha);
	safmin = dlamch_("S") / dlamch_("E");
	knt = 0;
	if (Dymola_abs(beta) < safmin) {

/*           XNORM, BETA may be inaccurate; scale X and recompute them */

	    rsafmn = 1. / safmin;
L10:
	    ++knt;
	    i__1 = *n - 1;
	    dscal_(&i__1, &rsafmn, &x[1], incx);
	    beta *= rsafmn;
	    *alpha *= rsafmn;
	    if (Dymola_abs(beta) < safmin) {
		goto L10;
	    }

/*           New BETA is at most 1, at least SAFMIN */

	    i__1 = *n - 1;
	    xnorm = dnrm2_(&i__1, &x[1], incx);
	    d__1 = dlapy2_(alpha, &xnorm);
	    beta = -d_sign(&d__1, alpha);
	}
	*tau = (beta - *alpha) / beta;
	i__1 = *n - 1;
	d__1 = 1. / (*alpha - beta);
	dscal_(&i__1, &d__1, &x[1], incx);

/*        If ALPHA is subnormal, it may lose relative accuracy */

	i__1 = knt;
	for (j = 1; j <= i__1; ++j) {
	    beta *= safmin;
/* L20: */
	}
	*alpha = beta;
    }

    return 0;

/*     End of DLARFG */

} /* dlarfg_ */

/* Subroutine */ DYMOLA_STATIC int dlassq_(integer *n, doublereal *x, integer *incx, doublereal *scale, doublereal *sumsq)
{
    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Local variables */
    integer ix;
    doublereal absxi;
    extern logical disnan_(doublereal *);


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/* ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    --x;

    /* Function Body */
    if (*n > 0) {
	i__1 = (*n - 1) * *incx + 1;
	i__2 = *incx;
	for (ix = 1; i__2 < 0 ? ix >= i__1 : ix <= i__1; ix += i__2) {
	    absxi = (d__1 = x[ix], Dymola_abs(d__1));
	    if (absxi > 0. || disnan_(&absxi)) {
		if (*scale < absxi) {
/* Computing 2nd power */
		    d__1 = *scale / absxi;
		    *sumsq = *sumsq * (d__1 * d__1) + 1;
		    *scale = absxi;
		} else {
/* Computing 2nd power */
		    d__1 = absxi / *scale;
		    *sumsq += d__1 * d__1;
		}
	    }
/* L10: */
	}
    }
    return 0;

/*     End of DLASSQ */

} /* dlassq_ */

/* Subroutine */ DYMOLA_STATIC int dlaswp_(const integer*n,doublereal*a,const integer*lda,const integer *k1,const integer * k2,const integer * ipiv,const integer*incx)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    integer i__, j, k, i1, i2, n32, ip, ix, ix0, inc;
    doublereal temp;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/* ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Interchange row I with row IPIV(I) for each of rows K1 through K2. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --ipiv;

    /* Function Body */
    if (*incx > 0) {
	ix0 = *k1;
	i1 = *k1;
	i2 = *k2;
	inc = 1;
    } else if (*incx < 0) {
	ix0 = (1 - *k2) * *incx + 1;
	i1 = *k2;
	i2 = *k1;
	inc = -1;
    } else {
	return 0;
    }

    n32 = *n / 32 << 5;
    if (n32 != 0) {
	i__1 = n32;
	for (j = 1; j <= i__1; j += 32) {
	    ix = ix0;
	    i__2 = i2;
	    i__3 = inc;
	    for (i__ = i1; i__3 < 0 ? i__ >= i__2 : i__ <= i__2; i__ += i__3) 
		    {
		ip = ipiv[ix];
		if (ip != i__) {
		    i__4 = j + 31;
		    for (k = j; k <= i__4; ++k) {
			temp = a[i__ + k * a_dim1];
			a[i__ + k * a_dim1] = a[ip + k * a_dim1];
			a[ip + k * a_dim1] = temp;
/* L10: */
		    }
		}
		ix += *incx;
/* L20: */
	    }
/* L30: */
	}
    }
    if (n32 != *n) {
	++n32;
	ix = ix0;
	i__1 = i2;
	i__3 = inc;
	for (i__ = i1; i__3 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__3) {
	    ip = ipiv[ix];
	    if (ip != i__) {
		i__2 = *n;
		for (k = n32; k <= i__2; ++k) {
		    temp = a[i__ + k * a_dim1];
		    a[i__ + k * a_dim1] = a[ip + k * a_dim1];
		    a[ip + k * a_dim1] = temp;
/* L40: */
		}
	    }
	    ix += *incx;
/* L50: */
	}
    }

    return 0;

/*     End of DLASWP */

} /* dlaswp_ */


/* Subroutine */ DYMOLA_STATIC int dlatrs_(char *uplo, char *trans, char *diag, char *normin, integer *n, doublereal *a, integer *lda, doublereal *x, 
	doublereal *scale, doublereal *cnorm, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublereal d__1, d__2, d__3;

    /* Local variables */
    integer i__, j;
    doublereal xj, rec, tjj;
    integer jinc;
    doublereal xbnd;
    integer imax;
    doublereal tmax, tjjs, xmax, grow, sumj;
    doublereal tscal, uscal;
    extern doublereal dasum_(integer *, doublereal *, integer *);
    integer jlast;
    logical upper;
    extern /* Subroutine */ int dtrsv_(char *, char *, char *, integer *, 
	    doublereal *, integer *, doublereal *, integer *);
    extern integer idamax_(integer *, doublereal *, integer *);
    doublereal bignum;
    logical notran;
    integer jfirst;
    doublereal smlnum;
    logical nounit;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --x;
    --cnorm;

    /* Function Body */
    *info = 0;
    upper = lsame_(uplo, "U", (ftnlen)1, (ftnlen)1);
    notran = lsame_(trans, "N", (ftnlen)1, (ftnlen)1);
    nounit = lsame_(diag, "N", (ftnlen)1, (ftnlen)1);

/*     Test the input parameters. */

    if (! upper && ! lsame_(uplo, "L", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! notran && ! lsame_(trans, "T", (ftnlen)1, (ftnlen)1) && ! 
	    lsame_(trans, "C", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (! nounit && ! lsame_(diag, "U", (ftnlen)1, (ftnlen)1)) {
	*info = -3;
    } else if (! lsame_(normin, "Y", (ftnlen)1, (ftnlen)1) && ! lsame_(normin,
	     "N", (ftnlen)1, (ftnlen)1)) {
	*info = -4;
    } else if (*n < 0) {
	*info = -5;
    } else if (*lda < Dymola_max(1,*n)) {
	*info = -7;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DLATRS", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*n == 0) {
	return 0;
    }

/*     Determine machine dependent parameters to control overflow. */

    smlnum = dlamch_("Safe minimum") / dlamch_("Precision");
    bignum = 1. / smlnum;
    *scale = 1.;

    if (lsame_(normin, "N", (ftnlen)1, (ftnlen)1)) {

/*        Compute the 1-norm of each column, not including the diagonal. */

	if (upper) {

/*           A is upper triangular. */

	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		i__2 = j - 1;
		cnorm[j] = dasum_(&i__2, &a[j * a_dim1 + 1], &c__1);
/* L10: */
	    }
	} else {

/*           A is lower triangular. */

	    i__1 = *n - 1;
	    for (j = 1; j <= i__1; ++j) {
		i__2 = *n - j;
		cnorm[j] = dasum_(&i__2, &a[j + 1 + j * a_dim1], &c__1);
/* L20: */
	    }
	    cnorm[*n] = 0.;
	}
    }

/*     Scale the column norms by TSCAL if the maximum element in CNORM is */
/*     greater than BIGNUM. */

    imax = idamax_(n, &cnorm[1], &c__1);
    tmax = cnorm[imax];
    if (tmax <= bignum) {
	tscal = 1.;
    } else {
	tscal = 1. / (smlnum * tmax);
	dscal_(n, &tscal, &cnorm[1], &c__1);
    }

/*     Compute a bound on the computed solution vector to see if the */
/*     Level 2 BLAS routine DTRSV can be used. */

    j = idamax_(n, &x[1], &c__1);
    xmax = (d__1 = x[j], Dymola_abs(d__1));
    xbnd = xmax;
    if (notran) {

/*        Compute the growth in A * x = b. */

	if (upper) {
	    jfirst = *n;
	    jlast = 1;
	    jinc = -1;
	} else {
	    jfirst = 1;
	    jlast = *n;
	    jinc = 1;
	}

	if (tscal != 1.) {
	    grow = 0.;
	    goto L50;
	}

	if (nounit) {

/*           A is non-unit triangular. */

/*           Compute GROW = 1/G(j) and XBND = 1/M(j). */
/*           Initially, G(0) = max{x(i), i=1,...,n}. */

	    grow = 1. / Dymola_max(xbnd,smlnum);
	    xbnd = grow;
	    i__1 = jlast;
	    i__2 = jinc;
	    for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*              Exit the loop if the growth factor is too small. */

		if (grow <= smlnum) {
		    goto L50;
		}

/*              M(j) = G(j-1) / Dymola_abs(A(j,j)) */

		tjj = (d__1 = a[j + j * a_dim1], Dymola_abs(d__1));
/* Computing MIN */
		d__1 = xbnd, d__2 = Dymola_min(1.,tjj) * grow;
		xbnd = Dymola_min(d__1,d__2);
		if (tjj + cnorm[j] >= smlnum) {

/*                 G(j) = G(j-1)*( 1 + CNORM(j) / Dymola_abs(A(j,j)) ) */

		    grow *= tjj / (tjj + cnorm[j]);
		} else {

/*                 G(j) could overflow, set GROW to 0. */

		    grow = 0.;
		}
/* L30: */
	    }
	    grow = xbnd;
	} else {

/*           A is unit triangular. */

/*           Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}. */

/* Computing MIN */
	    d__1 = 1., d__2 = 1. / Dymola_max(xbnd,smlnum);
	    grow = Dymola_min(d__1,d__2);
	    i__2 = jlast;
	    i__1 = jinc;
	    for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*              Exit the loop if the growth factor is too small. */

		if (grow <= smlnum) {
		    goto L50;
		}

/*              G(j) = G(j-1)*( 1 + CNORM(j) ) */

		grow *= 1. / (cnorm[j] + 1.);
/* L40: */
	    }
	}
L50:

	;
    } else {

/*        Compute the growth in A**T * x = b. */

	if (upper) {
	    jfirst = 1;
	    jlast = *n;
	    jinc = 1;
	} else {
	    jfirst = *n;
	    jlast = 1;
	    jinc = -1;
	}

	if (tscal != 1.) {
	    grow = 0.;
	    goto L80;
	}

	if (nounit) {

/*           A is non-unit triangular. */

/*           Compute GROW = 1/G(j) and XBND = 1/M(j). */
/*           Initially, M(0) = max{x(i), i=1,...,n}. */

	    grow = 1. / Dymola_max(xbnd,smlnum);
	    xbnd = grow;
	    i__1 = jlast;
	    i__2 = jinc;
	    for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*              Exit the loop if the growth factor is too small. */

		if (grow <= smlnum) {
		    goto L80;
		}

/*              G(j) = max( G(j-1), M(j-1)*( 1 + CNORM(j) ) ) */

		xj = cnorm[j] + 1.;
/* Computing MIN */
		d__1 = grow, d__2 = xbnd / xj;
		grow = Dymola_min(d__1,d__2);

/*              M(j) = M(j-1)*( 1 + CNORM(j) ) / Dymola_abs(A(j,j)) */

		tjj = (d__1 = a[j + j * a_dim1], Dymola_abs(d__1));
		if (xj > tjj) {
		    xbnd *= tjj / xj;
		}
/* L60: */
	    }
	    grow = Dymola_min(grow,xbnd);
	} else {

/*           A is unit triangular. */

/*           Compute GROW = 1/G(j), where G(0) = max{x(i), i=1,...,n}. */

/* Computing MIN */
	    d__1 = 1., d__2 = 1. / Dymola_max(xbnd,smlnum);
	    grow = Dymola_min(d__1,d__2);
	    i__2 = jlast;
	    i__1 = jinc;
	    for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*              Exit the loop if the growth factor is too small. */

		if (grow <= smlnum) {
		    goto L80;
		}

/*              G(j) = ( 1 + CNORM(j) )*G(j-1) */

		xj = cnorm[j] + 1.;
		grow /= xj;
/* L70: */
	    }
	}
L80:
	;
    }

    if (grow * tscal > smlnum) {

/*        Use the Level 2 BLAS solve if the reciprocal of the bound on */
/*        elements of X is not too small. */

	dtrsv_(uplo, trans, diag, n, &a[a_offset], lda, &x[1], &c__1);
    } else {

/*        Use a Level 1 BLAS solve, scaling intermediate results. */

	if (xmax > bignum) {

/*           Scale X so that its components are less than or equal to */
/*           BIGNUM in absolute value. */

	    *scale = bignum / xmax;
	    dscal_(n, scale, &x[1], &c__1);
	    xmax = bignum;
	}

	if (notran) {

/*           Solve A * x = b */

	    i__1 = jlast;
	    i__2 = jinc;
	    for (j = jfirst; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {

/*              Compute x(j) = b(j) / A(j,j), scaling x if necessary. */

		xj = (d__1 = x[j], Dymola_abs(d__1));
		if (nounit) {
		    tjjs = a[j + j * a_dim1] * tscal;
		} else {
		    tjjs = tscal;
		    if (tscal == 1.) {
			goto L100;
		    }
		}
		tjj = Dymola_abs(tjjs);
		if (tjj > smlnum) {

/*                    Dymola_abs(A(j,j)) > SMLNUM: */

		    if (tjj < 1.) {
			if (xj > tjj * bignum) {

/*                          Scale x by 1/b(j). */

			    rec = 1. / xj;
			    dscal_(n, &rec, &x[1], &c__1);
			    *scale *= rec;
			    xmax *= rec;
			}
		    }
		    x[j] /= tjjs;
		    xj = (d__1 = x[j], Dymola_abs(d__1));
		} else if (tjj > 0.) {

/*                    0 < Dymola_abs(A(j,j)) <= SMLNUM: */

		    if (xj > tjj * bignum) {

/*                       Scale x by (1/Dymola_abs(x(j)))*Dymola_abs(A(j,j))*BIGNUM */
/*                       to avoid overflow when dividing by A(j,j). */

			rec = tjj * bignum / xj;
			if (cnorm[j] > 1.) {

/*                          Scale by 1/CNORM(j) to avoid overflow when */
/*                          multiplying x(j) times column j. */

			    rec /= cnorm[j];
			}
			dscal_(n, &rec, &x[1], &c__1);
			*scale *= rec;
			xmax *= rec;
		    }
		    x[j] /= tjjs;
		    xj = (d__1 = x[j], Dymola_abs(d__1));
		} else {

/*                    A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and */
/*                    scale = 0, and compute a solution to A*x = 0. */

		    i__3 = *n;
		    for (i__ = 1; i__ <= i__3; ++i__) {
			x[i__] = 0.;
/* L90: */
		    }
		    x[j] = 1.;
		    xj = 1.;
		    *scale = 0.;
		    xmax = 0.;
		}
L100:

/*              Scale x if necessary to avoid overflow when adding a */
/*              multiple of column j of A. */

		if (xj > 1.) {
		    rec = 1. / xj;
		    if (cnorm[j] > (bignum - xmax) * rec) {

/*                    Scale x by 1/(2*Dymola_abs(x(j))). */

			rec *= .5;
			dscal_(n, &rec, &x[1], &c__1);
			*scale *= rec;
		    }
		} else if (xj * cnorm[j] > bignum - xmax) {

/*                 Scale x by 1/2. */

		    dscal_(n, &c_b36, &x[1], &c__1);
		    *scale *= .5;
		}

		if (upper) {
		    if (j > 1) {

/*                    Compute the update */
/*                       x(1:j-1) := x(1:j-1) - x(j) * A(1:j-1,j) */

			i__3 = j - 1;
			d__1 = -x[j] * tscal;
			daxpy_(&i__3, &d__1, &a[j * a_dim1 + 1], &c__1, &x[1],
				 &c__1);
			i__3 = j - 1;
			i__ = idamax_(&i__3, &x[1], &c__1);
			xmax = (d__1 = x[i__], Dymola_abs(d__1));
		    }
		} else {
		    if (j < *n) {

/*                    Compute the update */
/*                       x(j+1:n) := x(j+1:n) - x(j) * A(j+1:n,j) */

			i__3 = *n - j;
			d__1 = -x[j] * tscal;
			daxpy_(&i__3, &d__1, &a[j + 1 + j * a_dim1], &c__1, &
				x[j + 1], &c__1);
			i__3 = *n - j;
			i__ = j + idamax_(&i__3, &x[j + 1], &c__1);
			xmax = (d__1 = x[i__], Dymola_abs(d__1));
		    }
		}
/* L110: */
	    }

	} else {

/*           Solve A**T * x = b */

	    i__2 = jlast;
	    i__1 = jinc;
	    for (j = jfirst; i__1 < 0 ? j >= i__2 : j <= i__2; j += i__1) {

/*              Compute x(j) = b(j) - sum A(k,j)*x(k). */
/*                                    k<>j */

		xj = (d__1 = x[j], Dymola_abs(d__1));
		uscal = tscal;
		rec = 1. / Dymola_max(xmax,1.);
		if (cnorm[j] > (bignum - xj) * rec) {

/*                 If x(j) could overflow, scale x by 1/(2*XMAX). */

		    rec *= .5;
		    if (nounit) {
			tjjs = a[j + j * a_dim1] * tscal;
		    } else {
			tjjs = tscal;
		    }
		    tjj = Dymola_abs(tjjs);
		    if (tjj > 1.) {

/*                       Divide by A(j,j) when scaling x if A(j,j) > 1. */

/* Computing MIN */
			d__1 = 1., d__2 = rec * tjj;
			rec = Dymola_min(d__1,d__2);
			uscal /= tjjs;
		    }
		    if (rec < 1.) {
			dscal_(n, &rec, &x[1], &c__1);
			*scale *= rec;
			xmax *= rec;
		    }
		}

		sumj = 0.;
		if (uscal == 1.) {

/*                 If the scaling needed for A in the dot product is 1, */
/*                 call DDOT to perform the dot product. */

		    if (upper) {
			i__3 = j - 1;
			sumj = ddot_(&i__3, &a[j * a_dim1 + 1], &c__1, &x[1], 
				&c__1);
		    } else if (j < *n) {
			i__3 = *n - j;
			sumj = ddot_(&i__3, &a[j + 1 + j * a_dim1], &c__1, &x[
				j + 1], &c__1);
		    }
		} else {

/*                 Otherwise, use in-line code for the dot product. */

		    if (upper) {
			i__3 = j - 1;
			for (i__ = 1; i__ <= i__3; ++i__) {
			    sumj += a[i__ + j * a_dim1] * uscal * x[i__];
/* L120: */
			}
		    } else if (j < *n) {
			i__3 = *n;
			for (i__ = j + 1; i__ <= i__3; ++i__) {
			    sumj += a[i__ + j * a_dim1] * uscal * x[i__];
/* L130: */
			}
		    }
		}

		if (uscal == tscal) {

/*                 Compute x(j) := ( x(j) - sumj ) / A(j,j) if 1/A(j,j) */
/*                 was not used to scale the dotproduct. */

		    x[j] -= sumj;
		    xj = (d__1 = x[j], Dymola_abs(d__1));
		    if (nounit) {
			tjjs = a[j + j * a_dim1] * tscal;
		    } else {
			tjjs = tscal;
			if (tscal == 1.) {
			    goto L150;
			}
		    }

/*                    Compute x(j) = x(j) / A(j,j), scaling if necessary. */

		    tjj = Dymola_abs(tjjs);
		    if (tjj > smlnum) {

/*                       Dymola_abs(A(j,j)) > SMLNUM: */

			if (tjj < 1.) {
			    if (xj > tjj * bignum) {

/*                             Scale X by 1/Dymola_abs(x(j)). */

				rec = 1. / xj;
				dscal_(n, &rec, &x[1], &c__1);
				*scale *= rec;
				xmax *= rec;
			    }
			}
			x[j] /= tjjs;
		    } else if (tjj > 0.) {

/*                       0 < Dymola_abs(A(j,j)) <= SMLNUM: */

			if (xj > tjj * bignum) {

/*                          Scale x by (1/Dymola_abs(x(j)))*Dymola_abs(A(j,j))*BIGNUM. */

			    rec = tjj * bignum / xj;
			    dscal_(n, &rec, &x[1], &c__1);
			    *scale *= rec;
			    xmax *= rec;
			}
			x[j] /= tjjs;
		    } else {

/*                       A(j,j) = 0:  Set x(1:n) = 0, x(j) = 1, and */
/*                       scale = 0, and compute a solution to A**T*x = 0. */

			i__3 = *n;
			for (i__ = 1; i__ <= i__3; ++i__) {
			    x[i__] = 0.;
/* L140: */
			}
			x[j] = 1.;
			*scale = 0.;
			xmax = 0.;
		    }
L150:
		    ;
		} else {

/*                 Compute x(j) := x(j) / A(j,j)  - sumj if the dot */
/*                 product has already been divided by 1/A(j,j). */

		    x[j] = x[j] / tjjs - sumj;
		}
/* Computing MAX */
		d__2 = xmax, d__3 = (d__1 = x[j], Dymola_abs(d__1));
		xmax = Dymola_max(d__2,d__3);
/* L160: */
	    }
	}
	*scale /= tscal;
    }

/*     Scale the column norms by 1/TSCAL for return. */

    if (tscal != 1.) {
	d__1 = 1. / tscal;
	dscal_(n, &d__1, &cnorm[1], &c__1);
    }

    return 0;

/*     End of DLATRS */

} /* dlatrs_ */

/* Subroutine */ DYMOLA_STATIC int dlatzm_(char *side, integer *m, integer *n, doublereal *v, integer *incv, doublereal *tau, doublereal *c1, doublereal *c2, integer *ldc, doublereal *work)
{
    /* System generated locals */
    integer c1_dim1, c1_offset, c2_dim1, c2_offset, i__1;
    doublereal d__1;

/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    --v;
    c2_dim1 = *ldc;
    c2_offset = 1 + c2_dim1;
    c2 -= c2_offset;
    c1_dim1 = *ldc;
    c1_offset = 1 + c1_dim1;
    c1 -= c1_offset;
    --work;

    /* Function Body */
    if (Dymola_min(*m,*n) == 0 || *tau == 0.) {
	return 0;
    }

    if (lsame_(side, "L", (ftnlen)1, (ftnlen)1)) {

/*        w :=  (C1 + v**T * C2)**T */

	dcopy_(n, &c1[c1_offset], ldc, &work[1], &c__1);
	i__1 = *m - 1;
	dgemv_("Transpose", &i__1, n, &c_b5, &c2[c2_offset], ldc, &v[1], incv,
		 &c_b5, &work[1], &c__1);

/*        [ C1 ] := [ C1 ] - tau* [ 1 ] * w**T */
/*        [ C2 ]    [ C2 ]        [ v ] */

	d__1 = -(*tau);
	daxpy_(n, &d__1, &work[1], &c__1, &c1[c1_offset], ldc);
	i__1 = *m - 1;
	d__1 = -(*tau);
	dger_(&i__1, n, &d__1, &v[1], incv, &work[1], &c__1, &c2[c2_offset], 
		ldc);

    } else if (lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {

/*        w := C1 + C2 * v */

	dcopy_(m, &c1[c1_offset], &c__1, &work[1], &c__1);
	i__1 = *n - 1;
	dgemv_("No transpose", m, &i__1, &c_b5, &c2[c2_offset], ldc, &v[1], 
		incv, &c_b5, &work[1], &c__1);

/*        [ C1, C2 ] := [ C1, C2 ] - tau* w * [ 1 , v**T] */

	d__1 = -(*tau);
	daxpy_(m, &d__1, &work[1], &c__1, &c1[c1_offset], &c__1);
	i__1 = *n - 1;
	d__1 = -(*tau);
	dger_(m, &i__1, &d__1, &work[1], &c__1, &v[1], incv, &c2[c2_offset], 
		ldc);
    }

    return 0;

/*     End of DLATZM */

} /* dlatzm_ */

/* Subroutine */ DYMOLA_STATIC int dorm2r_(char *side, char *trans, integer *m, integer *n, integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *c__, integer *ldc, doublereal *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2;

    /* Local variables */
    integer i__, i1, i2, i3, ic, jc, mi, ni, nq;
    doublereal aii;
    logical left;
    logical notran;


/*  -- LAPACK computational routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input arguments */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = lsame_(side, "L", (ftnlen)1, (ftnlen)1);
    notran = lsame_(trans, "N", (ftnlen)1, (ftnlen)1);

/*     NQ is the order of Q */

    if (left) {
	nq = *m;
    } else {
	nq = *n;
    }
    if (! left && ! lsame_(side, "R", (ftnlen)1, (ftnlen)1)) {
	*info = -1;
    } else if (! notran && ! lsame_(trans, "T", (ftnlen)1, (ftnlen)1)) {
	*info = -2;
    } else if (*m < 0) {
	*info = -3;
    } else if (*n < 0) {
	*info = -4;
    } else if (*k < 0 || *k > nq) {
	*info = -5;
    } else if (*lda < Dymola_max(1,nq)) {
	*info = -7;
    } else if (*ldc < Dymola_max(1,*m)) {
	*info = -10;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DORM2R", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0 || *k == 0) {
	return 0;
    }

    if (left && ! notran || ! left && notran) {
	i1 = 1;
	i2 = *k;
	i3 = 1;
    } else {
	i1 = *k;
	i2 = 1;
	i3 = -1;
    }

    if (left) {
	ni = *n;
	jc = 1;
    } else {
	mi = *m;
	ic = 1;
    }

    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	if (left) {

/*           H(i) is applied to C(i:m,1:n) */

	    mi = *m - i__ + 1;
	    ic = i__;
	} else {

/*           H(i) is applied to C(1:m,i:n) */

	    ni = *n - i__ + 1;
	    jc = i__;
	}

/*        Apply H(i) */

	aii = a[i__ + i__ * a_dim1];
	a[i__ + i__ * a_dim1] = 1.;
	dlarf_(side, &mi, &ni, &a[i__ + i__ * a_dim1], &c__1, &tau[i__], &c__[
		ic + jc * c_dim1], ldc, &work[1]);
	a[i__ + i__ * a_dim1] = aii;
/* L10: */
    }
    return 0;

/*     End of DORM2R */

} /* dorm2r_ */

/* Subroutine */ DYMOLA_STATIC int drscl_(integer *n, doublereal *sa, doublereal *sx, integer *incx)
{
    doublereal mul, cden;
    logical done;
    doublereal cnum, cden1, cnum1;
    doublereal bignum, smlnum;


/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/* ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Quick return if possible */

    /* Parameter adjustments */
    --sx;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }

/*     Get machine parameters */

    smlnum = dlamch_("S");
    bignum = 1. / smlnum;
    dlabad_(&smlnum, &bignum);

/*     Initialize the denominator to SA and the numerator to 1. */

    cden = *sa;
    cnum = 1.;

L10:
    cden1 = cden * smlnum;
    cnum1 = cnum / bignum;
    if (Dymola_abs(cden1) > Dymola_abs(cnum) && cnum != 0.) {

/*        Pre-multiply X by SMLNUM if CDEN is large compared to CNUM. */

	mul = smlnum;
	done = FALSE_;
	cden = cden1;
    } else if (Dymola_abs(cnum1) > Dymola_abs(cden)) {

/*        Pre-multiply X by BIGNUM if CDEN is small compared to CNUM. */

	mul = bignum;
	done = FALSE_;
	cnum = cnum1;
    } else {

/*        Multiply X by CNUM / CDEN and return. */

	mul = cnum / cden;
	done = TRUE_;
    }

/*     Scale the vector X by MUL */

    dscal_(n, &mul, &sx[1], incx);

    if (! done) {
	goto L10;
    }

    return 0;

/*     End of DRSCL */

} /* drscl_ */

/* Subroutine */ DYMOLA_STATIC int dtzrqf_(integer *m, integer *n, doublereal *a, integer *
	lda, doublereal *tau, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    integer i__, k, m1;

/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
	*info = -1;
    } else if (*n < *m) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -4;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DTZRQF", &i__1);
	return 0;
    }

/*     Perform the factorization. */

    if (*m == 0) {
	return 0;
    }
    if (*m == *n) {
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    tau[i__] = 0.;
/* L10: */
	}
    } else {
/* Computing MIN */
	i__1 = *m + 1;
	m1 = Dymola_min(i__1,*n);
	for (k = *m; k >= 1; --k) {

/*           Use a Householder reflection to zero the kth row of A. */
/*           First set up the reflection. */

	    i__1 = *n - *m + 1;
	    dlarfg_(&i__1, &a[k + k * a_dim1], &a[k + m1 * a_dim1], lda, &tau[
		    k]);

	    if (tau[k] != 0. && k > 1) {

/*              We now perform the operation  A := A*P( k ). */

/*              Use the first ( k - 1 ) elements of TAU to store  a( k ), */
/*              where  a( k ) consists of the first ( k - 1 ) elements of */
/*              the  kth column  of  A.  Also  let  B  denote  the  first */
/*              ( k - 1 ) rows of the last ( n - m ) columns of A. */

		i__1 = k - 1;
		dcopy_(&i__1, &a[k * a_dim1 + 1], &c__1, &tau[1], &c__1);

/*              Form   w = a( k ) + B*z( k )  in TAU. */

		i__1 = k - 1;
		i__2 = *n - *m;
		dgemv_("No transpose", &i__1, &i__2, &c_b8, &a[m1 * a_dim1 + 
			1], lda, &a[k + m1 * a_dim1], lda, &c_b8, &tau[1], &
			c__1);

/*              Now form  a( k ) := a( k ) - tau*w */
/*              and       B      := B      - tau*w*z( k )**T. */

		i__1 = k - 1;
		d__1 = -tau[k];
		daxpy_(&i__1, &d__1, &tau[1], &c__1, &a[k * a_dim1 + 1], &
			c__1);
		i__1 = k - 1;
		i__2 = *n - *m;
		d__1 = -tau[k];
		dger_(&i__1, &i__2, &d__1, &tau[1], &c__1, &a[k + m1 * a_dim1]
			, lda, &a[m1 * a_dim1 + 1], lda);
	    }
/* L20: */
	}
    }

    return 0;

/*     End of DTZRQF */

} /* dtzrqf_ */

DYMOLA_STATIC integer ilaenv_(const integer *ispec,const char *name__,const char *opts,const integer*n1,const integer*n2,const integer*n3,const integer*n4)
{
    /* System generated locals */
    integer ret_val;

    /* Local variables */
    integer i__;
    char c1[1], c2[2], c3[3], c4[2];
    integer ic, nb, iz, nx;
    logical cname;
    integer nbmin;
    logical sname;
    extern integer ieeeck_(integer *, real *, real *);
    char subnam[6];
    extern integer iparmq_(integer *, char *, char *, integer *, integer *, 
	    integer *, integer *);

    ftnlen name_len, opts_len;

    name_len = strlen (name__);
    opts_len = strlen (opts);

/*  -- LAPACK auxiliary routine (version 3.2) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd.. */
/*     January 2007 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  Purpose */
/*  ======= */

/*  ILAENV is called from the LAPACK routines to choose problem-dependent */
/*  parameters for the local environment.  See ISPEC for a description of */
/*  the parameters. */

/*  ILAENV returns an INTEGER */
/*  if ILAENV >= 0: ILAENV returns the value of the parameter specified by ISPEC */
/*  if ILAENV < 0:  if ILAENV = -k, the k-th argument had an illegal value. */

/*  This version provides a set of parameters which should give good, */
/*  but not optimal, performance on many of the currently available */
/*  computers.  Users are encouraged to modify this subroutine to set */
/*  the tuning parameters for their particular machine using the option */
/*  and problem size information in the arguments. */

/*  This routine will not function correctly if it is converted to all */
/*  lower case.  Converting it to all upper case is allowed. */

/*  Arguments */
/*  ========= */

/*  ISPEC   (input) INTEGER */
/*          Specifies the parameter to be returned as the value of */
/*          ILAENV. */
/*          = 1: the optimal blocksize; if this value is 1, an unblocked */
/*               algorithm will give the best performance. */
/*          = 2: the minimum block size for which the block routine */
/*               should be used; if the usable block size is less than */
/*               this value, an unblocked routine should be used. */
/*          = 3: the crossover point (in a block routine, for N less */
/*               than this value, an unblocked routine should be used) */
/*          = 4: the number of shifts, used in the nonsymmetric */
/*               eigenvalue routines (DEPRECATED) */
/*          = 5: the minimum column dimension for blocking to be used; */
/*               rectangular blocks must have dimension at least k by m, */
/*               where k is given by ILAENV(2,...) and m by ILAENV(5,...) */
/*          = 6: the crossover point for the SVD (when reducing an m by n */
/*               matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds */
/*               this value, a QR factorization is used first to reduce */
/*               the matrix to a triangular form.) */
/*          = 7: the number of processors */
/*          = 8: the crossover point for the multishift QR method */
/*               for nonsymmetric eigenvalue problems (DEPRECATED) */
/*          = 9: maximum size of the subproblems at the bottom of the */
/*               computation tree in the divide-and-conquer algorithm */
/*               (used by xGELSD and xGESDD) */
/*          =10: ieee NaN arithmetic can be trusted not to trap */
/*          =11: infinity arithmetic can be trusted not to trap */
/*          12 <= ISPEC <= 16: */
/*               xHSEQR or one of its subroutines, */
/*               see IPARMQ for detailed explanation */

/*  NAME    (input) CHARACTER*(*) */
/*          The name of the calling subroutine, in either upper case or */
/*          lower case. */

/*  OPTS    (input) CHARACTER*(*) */
/*          The character options to the subroutine NAME, concatenated */
/*          into a single character string.  For example, UPLO = 'U', */
/*          TRANS = 'T', and DIAG = 'N' for a triangular routine would */
/*          be specified as OPTS = 'UTN'. */

/*  N1      (input) INTEGER */
/*  N2      (input) INTEGER */
/*  N3      (input) INTEGER */
/*  N4      (input) INTEGER */
/*          Problem dimensions for the subroutine NAME; these may not all */
/*          be required. */

/*  Further Details */
/*  =============== */

/*  The following conventions have been used when calling ILAENV from the */
/*  LAPACK routines: */
/*  1)  OPTS is a concatenation of all of the character options to */
/*      subroutine NAME, in the same order that they appear in the */
/*      argument list for NAME, even if they are not used in determining */
/*      the value of the parameter specified by ISPEC. */
/*  2)  The problem dimensions N1, N2, N3, N4 are specified in the order */
/*      that they appear in the argument list for NAME.  N1 is used */
/*      first, N2 second, and so on, and unused problem dimensions are */
/*      passed a value of -1. */
/*  3)  The parameter value returned by ILAENV is checked for validity in */
/*      the calling subroutine.  For example, ILAENV is used to retrieve */
/*      the optimal blocksize for STRTRI as follows: */

/*      NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 ) */
/*      IF( NB.LE.1 ) NB = MAX( 1, N ) */

/*  ===================================================================== */

/*     .. Local Scalars .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

    switch (*ispec) {
	case 1:  goto L10;
	case 2:  goto L10;
	case 3:  goto L10;
	case 4:  goto L80;
	case 5:  goto L90;
	case 6:  goto L100;
	case 7:  goto L110;
	case 8:  goto L120;
	case 9:  goto L130;
	case 10:  goto L140;
	case 11:  goto L150;
	case 12:  goto L160;
	case 13:  goto L160;
	case 14:  goto L160;
	case 15:  goto L160;
	case 16:  goto L160;
    }

/*     Invalid value for ISPEC */

    ret_val = -1;
    return ret_val;

L10:

/*     Convert NAME to upper case if the first character is lower case. */

    ret_val = 1;
    s_copy(subnam, name__, (ftnlen)6, name_len);
    ic = *(unsigned char *)subnam;
    iz = 'Z';
    if (iz == 90 || iz == 122) {

/*        ASCII character set */

	if (ic >= 97 && ic <= 122) {
	    *(unsigned char *)subnam = (char) (ic - 32);
	    for (i__ = 2; i__ <= 6; ++i__) {
		ic = *(unsigned char *)&subnam[i__ - 1];
		if (ic >= 97 && ic <= 122) {
		    *(unsigned char *)&subnam[i__ - 1] = (char) (ic - 32);
		}
/* L20: */
	    }
	}

    } else if (iz == 233 || iz == 169) {

/*        EBCDIC character set */

	if (ic >= 129 && ic <= 137 || ic >= 145 && ic <= 153 || ic >= 162 && 
		ic <= 169) {
	    *(unsigned char *)subnam = (char) (ic + 64);
	    for (i__ = 2; i__ <= 6; ++i__) {
		ic = *(unsigned char *)&subnam[i__ - 1];
		if (ic >= 129 && ic <= 137 || ic >= 145 && ic <= 153 || ic >= 
			162 && ic <= 169) {
		    *(unsigned char *)&subnam[i__ - 1] = (char) (ic + 64);
		}
/* L30: */
	    }
	}

    } else if (iz == 218 || iz == 250) {

/*        Prime machines:  ASCII+128 */

	if (ic >= 225 && ic <= 250) {
	    *(unsigned char *)subnam = (char) (ic - 32);
	    for (i__ = 2; i__ <= 6; ++i__) {
		ic = *(unsigned char *)&subnam[i__ - 1];
		if (ic >= 225 && ic <= 250) {
		    *(unsigned char *)&subnam[i__ - 1] = (char) (ic - 32);
		}
/* L40: */
	    }
	}
    }

    *(unsigned char *)c1 = *(unsigned char *)subnam;
    sname = *(unsigned char *)c1 == 'S' || *(unsigned char *)c1 == 'D';
    cname = *(unsigned char *)c1 == 'C' || *(unsigned char *)c1 == 'Z';
    if (! (cname || sname)) {
	return ret_val;
    }
    s_copy(c2, subnam + 1, (ftnlen)2, (ftnlen)2);
    s_copy(c3, subnam + 3, (ftnlen)3, (ftnlen)3);
    s_copy(c4, c3 + 1, (ftnlen)2, (ftnlen)2);

    switch (*ispec) {
	case 1:  goto L50;
	case 2:  goto L60;
	case 3:  goto L70;
    }

L50:

/*     ISPEC = 1:  block size */

/*     In these examples, separate code is provided for setting NB for */
/*     real and complex.  We assume that NB will take the same value in */
/*     single or double precision. */

    nb = 1;

    if (s_cmp(c2, "GE", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nb = 64;
	    } else {
		nb = 64;
	    }
	} else if (s_cmp(c3, "QRF", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, 
		"RQF", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, "LQF", (ftnlen)
		3, (ftnlen)3) == 0 || s_cmp(c3, "QLF", (ftnlen)3, (ftnlen)3) 
		== 0) {
	    if (sname) {
		nb = 32;
	    } else {
		nb = 32;
	    }
	} else if (s_cmp(c3, "HRD", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nb = 32;
	    } else {
		nb = 32;
	    }
	} else if (s_cmp(c3, "BRD", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nb = 32;
	    } else {
		nb = 32;
	    }
	} else if (s_cmp(c3, "TRI", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nb = 64;
	    } else {
		nb = 64;
	    }
	}
    } else if (s_cmp(c2, "PO", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nb = 64;
	    } else {
		nb = 64;
	    }
	}
    } else if (s_cmp(c2, "SY", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nb = 64;
	    } else {
		nb = 64;
	    }
	} else if (sname && s_cmp(c3, "TRD", (ftnlen)3, (ftnlen)3) == 0) {
	    nb = 32;
	} else if (sname && s_cmp(c3, "GST", (ftnlen)3, (ftnlen)3) == 0) {
	    nb = 64;
	}
    } else if (cname && s_cmp(c2, "HE", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
	    nb = 64;
	} else if (s_cmp(c3, "TRD", (ftnlen)3, (ftnlen)3) == 0) {
	    nb = 32;
	} else if (s_cmp(c3, "GST", (ftnlen)3, (ftnlen)3) == 0) {
	    nb = 64;
	}
    } else if (sname && s_cmp(c2, "OR", (ftnlen)2, (ftnlen)2) == 0) {
	if (*(unsigned char *)c3 == 'G') {
	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
		    ftnlen)2, (ftnlen)2) == 0) {
		nb = 32;
	    }
	} else if (*(unsigned char *)c3 == 'M') {
	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
		    ftnlen)2, (ftnlen)2) == 0) {
		nb = 32;
	    }
	}
    } else if (cname && s_cmp(c2, "UN", (ftnlen)2, (ftnlen)2) == 0) {
	if (*(unsigned char *)c3 == 'G') {
	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
		    ftnlen)2, (ftnlen)2) == 0) {
		nb = 32;
	    }
	} else if (*(unsigned char *)c3 == 'M') {
	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
		    ftnlen)2, (ftnlen)2) == 0) {
		nb = 32;
	    }
	}
    } else if (s_cmp(c2, "GB", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		if (*n4 <= 64) {
		    nb = 1;
		} else {
		    nb = 32;
		}
	    } else {
		if (*n4 <= 64) {
		    nb = 1;
		} else {
		    nb = 32;
		}
	    }
	}
    } else if (s_cmp(c2, "PB", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		if (*n2 <= 64) {
		    nb = 1;
		} else {
		    nb = 32;
		}
	    } else {
		if (*n2 <= 64) {
		    nb = 1;
		} else {
		    nb = 32;
		}
	    }
	}
    } else if (s_cmp(c2, "TR", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "TRI", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nb = 64;
	    } else {
		nb = 64;
	    }
	}
    } else if (s_cmp(c2, "LA", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "UUM", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nb = 64;
	    } else {
		nb = 64;
	    }
	}
    } else if (sname && s_cmp(c2, "ST", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "EBZ", (ftnlen)3, (ftnlen)3) == 0) {
	    nb = 1;
	}
    }
    ret_val = nb;
    return ret_val;

L60:

/*     ISPEC = 2:  minimum block size */

    nbmin = 2;
    if (s_cmp(c2, "GE", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "QRF", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, "RQF", (
		ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, "LQF", (ftnlen)3, (
		ftnlen)3) == 0 || s_cmp(c3, "QLF", (ftnlen)3, (ftnlen)3) == 0)
		 {
	    if (sname) {
		nbmin = 2;
	    } else {
		nbmin = 2;
	    }
	} else if (s_cmp(c3, "HRD", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nbmin = 2;
	    } else {
		nbmin = 2;
	    }
	} else if (s_cmp(c3, "BRD", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nbmin = 2;
	    } else {
		nbmin = 2;
	    }
	} else if (s_cmp(c3, "TRI", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nbmin = 2;
	    } else {
		nbmin = 2;
	    }
	}
    } else if (s_cmp(c2, "SY", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "TRF", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nbmin = 8;
	    } else {
		nbmin = 8;
	    }
	} else if (sname && s_cmp(c3, "TRD", (ftnlen)3, (ftnlen)3) == 0) {
	    nbmin = 2;
	}
    } else if (cname && s_cmp(c2, "HE", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "TRD", (ftnlen)3, (ftnlen)3) == 0) {
	    nbmin = 2;
	}
    } else if (sname && s_cmp(c2, "OR", (ftnlen)2, (ftnlen)2) == 0) {
	if (*(unsigned char *)c3 == 'G') {
	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
		    ftnlen)2, (ftnlen)2) == 0) {
		nbmin = 2;
	    }
	} else if (*(unsigned char *)c3 == 'M') {
	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
		    ftnlen)2, (ftnlen)2) == 0) {
		nbmin = 2;
	    }
	}
    } else if (cname && s_cmp(c2, "UN", (ftnlen)2, (ftnlen)2) == 0) {
	if (*(unsigned char *)c3 == 'G') {
	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
		    ftnlen)2, (ftnlen)2) == 0) {
		nbmin = 2;
	    }
	} else if (*(unsigned char *)c3 == 'M') {
	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
		    ftnlen)2, (ftnlen)2) == 0) {
		nbmin = 2;
	    }
	}
    }
    ret_val = nbmin;
    return ret_val;

L70:

/*     ISPEC = 3:  crossover point */

    nx = 0;
    if (s_cmp(c2, "GE", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "QRF", (ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, "RQF", (
		ftnlen)3, (ftnlen)3) == 0 || s_cmp(c3, "LQF", (ftnlen)3, (
		ftnlen)3) == 0 || s_cmp(c3, "QLF", (ftnlen)3, (ftnlen)3) == 0)
		 {
	    if (sname) {
		nx = 128;
	    } else {
		nx = 128;
	    }
	} else if (s_cmp(c3, "HRD", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nx = 128;
	    } else {
		nx = 128;
	    }
	} else if (s_cmp(c3, "BRD", (ftnlen)3, (ftnlen)3) == 0) {
	    if (sname) {
		nx = 128;
	    } else {
		nx = 128;
	    }
	}
    } else if (s_cmp(c2, "SY", (ftnlen)2, (ftnlen)2) == 0) {
	if (sname && s_cmp(c3, "TRD", (ftnlen)3, (ftnlen)3) == 0) {
	    nx = 32;
	}
    } else if (cname && s_cmp(c2, "HE", (ftnlen)2, (ftnlen)2) == 0) {
	if (s_cmp(c3, "TRD", (ftnlen)3, (ftnlen)3) == 0) {
	    nx = 32;
	}
    } else if (sname && s_cmp(c2, "OR", (ftnlen)2, (ftnlen)2) == 0) {
	if (*(unsigned char *)c3 == 'G') {
	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
		    ftnlen)2, (ftnlen)2) == 0) {
		nx = 128;
	    }
	}
    } else if (cname && s_cmp(c2, "UN", (ftnlen)2, (ftnlen)2) == 0) {
	if (*(unsigned char *)c3 == 'G') {
	    if (s_cmp(c4, "QR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "RQ", 
		    (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "LQ", (ftnlen)2, (
		    ftnlen)2) == 0 || s_cmp(c4, "QL", (ftnlen)2, (ftnlen)2) ==
		     0 || s_cmp(c4, "HR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
		    c4, "TR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(c4, "BR", (
		    ftnlen)2, (ftnlen)2) == 0) {
		nx = 128;
	    }
	}
    }
    ret_val = nx;
    return ret_val;

L80:

/*     ISPEC = 4:  number of shifts (used by xHSEQR) */

    ret_val = 6;
    return ret_val;

L90:

/*     ISPEC = 5:  minimum column dimension (not used) */

    ret_val = 2;
    return ret_val;

L100:

/*     ISPEC = 6:  crossover point for SVD (used by xGELSS and xGESVD) */

    ret_val = (integer) ((real) Dymola_min(*n1,*n2) * 1.6f);
    return ret_val;

L110:

/*     ISPEC = 7:  number of processors (not used) */

    ret_val = 1;
    return ret_val;

L120:

/*     ISPEC = 8:  crossover point for multishift (used by xHSEQR) */

    ret_val = 50;
    return ret_val;

L130:

/*     ISPEC = 9:  maximum size of the subproblems at the bottom of the */
/*                 computation tree in the divide-and-conquer algorithm */
/*                 (used by xGELSD and xGESDD) */

    ret_val = 25;
    return ret_val;

L140:

/*     ISPEC = 10: ieee NaN arithmetic can be trusted not to trap */

/*     ILAENV = 0 */
    ret_val = 1;
    if (ret_val == 1) {
	ret_val = ieeeck_(&c__1, &c_b163, &c_b164);
    }
    return ret_val;

L150:

/*     ISPEC = 11: infinity arithmetic can be trusted not to trap */

/*     ILAENV = 0 */
    ret_val = 1;
    if (ret_val == 1) {
	ret_val = ieeeck_(&c__0, &c_b163, &c_b164);
    }
    return ret_val;

L160:

/*     12 <= ISPEC <= 16: xHSEQR or one of its subroutines. */

    ret_val = iparmq_((integer*)ispec, (char*)name__, (char*)opts, (integer*)n1, (integer*)n2, (integer*)n3, (integer*)n4)
	    ;
    return ret_val;

/*     End of ILAENV */

} /* ilaenv_ */

#undef lsame_
DYMOLA_STATIC logical lsame_(ca, cb, ca_len, cb_len)
const char *ca, *cb;
ftnlen ca_len;
ftnlen cb_len;
{
    /* System generated locals */
    logical ret_val;

    /* Local variables */
    integer inta, intb, zcode;


/*  -- LAPACK auxiliary routine (version 1.1) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd., */
/*     Courant Institute, Argonne National Lab, and Rice University */
/*     February 29, 1992 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  Purpose */
/*  ======= */

/*  LSAME returns .TRUE. if CA is the same letter as CB regardless of */
/*  case. */

/*  Arguments */
/*  ========= */

/*  CA      (input) CHARACTER*1 */
/*  CB      (input) CHARACTER*1 */
/*          CA and CB specify the single characters to be compared. */

/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test if the characters are equal */
    ret_val = *(unsigned char *)ca == *(unsigned char *)cb;
    if (ret_val) {
	return ret_val;
    }

/*     Now test for equivalence if both characters are alphabetic. */

    zcode = 'Z';

/*     Use 'Z' rather than 'A' so that ASCII can be detected on Prime */
/*     machines, on which ICHAR returns a value with bit 8 set. */
/*     ICHAR('A') on Prime machines returns 193 which is the same as */
/*     ICHAR('A') on an EBCDIC machine. */

    inta = *(unsigned char *)ca;
    intb = *(unsigned char *)cb;

    if (zcode == 90 || zcode == 122) {

/*        ASCII is assumed - ZCODE is the ASCII code of either lower o
r */
/*        upper case 'Z'. */

	if (inta >= 97 && inta <= 122) {
	    inta += -32;
	}
	if (intb >= 97 && intb <= 122) {
	    intb += -32;
	}

    } else if (zcode == 233 || zcode == 169) {

/*        EBCDIC is assumed - ZCODE is the EBCDIC code of either lower
 or */
/*        upper case 'Z'. */

	if ((inta >= 129 && inta <= 137) || (inta >= 145 && inta <= 153) || (inta >= 162 && inta <= 169)) {
	    inta += 64;
	}
	if ((intb >= 129 && intb <= 137) || (intb >= 145 && intb <= 153) || (intb >= 162 && intb <= 169)) {
	    intb += 64;
	}

    } else if (zcode == 218 || zcode == 250) {

/*        ASCII is assumed, on Prime machines - ZCODE is the ASCII cod
e */
/*        plus 128 of either lower or upper case 'Z'. */

	if (inta >= 225 && inta <= 250) {
	    inta += -32;
	}
	if (intb >= 225 && intb <= 250) {
	    intb += -32;
	}
    }
    ret_val = inta == intb;

/*     RETURN */

/*     End of LSAME */

    return ret_val;
} /* lsame_ */

/* Subroutine */ DYMOLA_STATIC int xerbla_(srname, info)
char *srname;
integer *info;
{

/*  -- LAPACK auxiliary routine (version 1.1) -- */
/*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd., */
/*     Courant Institute, Argonne National Lab, and Rice University */
/*     February 29, 1992 */

/*     .. Scalar Arguments .. */
/*     .. */

/*  Purpose */
/*  ======= */

/*  XERBLA  is an error handler for the LAPACK routines. */
/*  It is called by an LAPACK routine if an input parameter has an */
/*  invalid value.  A message is printed and execution stops. */

/*  Installers may consider modifying the STOP statement in order to */
/*  call system-specific exception-handling facilities. */

/*  Arguments */
/*  ========= */

/*  SRNAME  (input) CHARACTER*6 */
/*          The name of the routine which called XERBLA. */

/*  INFO    (input) INTEGER */
/*          The position of the invalid parameter in the parameter list */
/*          of the calling routine. */

/*     .. Executable Statements .. */

/* CC      WRITE( *, FMT = 9999 )SRNAME, INFO */

/* CC      STOP */
    return 0;

/*CC 9999 FORMAT( ' ** On entry to ', A6, ' parameter number ', I2, ' had 
',*/
/* CC     $      'an illegal value' ) */

/*     End of XERBLA */

} /* xerbla_ */
#endif /* GODESS */

/* Subroutine */ DYMOLA_STATIC int dgbfa_(abd, lda, n, ml, mu, ipvt, info)
doublereal *abd;
const integer*lda, *n, *ml, *mu;
integer *ipvt, *info;
{
    /* System generated locals */
    integer abd_dim1, abd_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    integer i__, j, k, l, m;
    doublereal t;
    integer i0, j0, j1, lm, mm, ju, jz, kp1, nm1;


/*     DGBFA FACTORS A DOUBLE PRECISION BAND MATRIX BY ELIMINATION. */

/*     DGBFA IS USUALLY CALLED BY DGBCO, BUT IT CAN BE CALLED */
/*     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED. */

/*     ON ENTRY */

/*        ABD     DOUBLE PRECISION(LDA, N) */
/*                CONTAINS THE MATRIX IN BAND STORAGE.  THE COLUMNS */
/*                OF THE MATRIX ARE STORED IN THE COLUMNS OF  ABD  AND */
/*                THE DIAGONALS OF THE MATRIX ARE STORED IN ROWS */
/*                ML+1 THROUGH 2*ML+MU+1 OF  ABD . */
/*                SEE THE COMMENTS BELOW FOR DETAILS. */

/*        LDA     INTEGER */
/*                THE LEADING DIMENSION OF THE ARRAY  ABD . */
/*                LDA MUST BE .GE. 2*ML + MU + 1 . */

/*        N       INTEGER */
/*                THE ORDER OF THE ORIGINAL MATRIX. */

/*        ML      INTEGER */
/*                NUMBER OF DIAGONALS BELOW THE MAIN DIAGONAL. */
/*                0 .LE. ML .LT. N . */

/*        MU      INTEGER */
/*                NUMBER OF DIAGONALS ABOVE THE MAIN DIAGONAL. */
/*                0 .LE. MU .LT. N . */
/*                MORE EFFICIENT IF  ML .LE. MU . */
/*     ON RETURN */

/*        ABD     AN UPPER TRIANGULAR MATRIX IN BAND STORAGE AND */
/*                THE MULTIPLIERS WHICH WERE USED TO OBTAIN IT. */
/*                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE */
/*                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER */
/*                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR. */

/*        IPVT    INTEGER(N) */
/*                AN INTEGER VECTOR OF PIVOT INDICES. */

/*        INFO    INTEGER */
/*                = 0  NORMAL VALUE. */
/*                = K  IF  U(K,K) .EQ. 0.0 .  THIS IS NOT AN ERROR */
/*                     CONDITION FOR THIS SUBROUTINE, BUT IT DOES */
/*                     INDICATE THAT DGBSL WILL DIVIDE BY ZERO IF */
/*                     CALLED.  USE  RCOND  IN DGBCO FOR A RELIABLE */
/*                     INDICATION OF SINGULARITY. */

/*     BAND STORAGE */

/*           IF  A  IS A BAND MATRIX, THE FOLLOWING PROGRAM SEGMENT */
/*           WILL SET UP THE INPUT. */

/*                   ML = (BAND WIDTH BELOW THE DIAGONAL) */
/*                   MU = (BAND WIDTH ABOVE THE DIAGONAL) */
/*                   M = ML + MU + 1 */
/*                   DO 20 J = 1, N */
/*                      I1 = MAX0(1, J-MU) */
/*                      I2 = MIN0(N, J+ML) */
/*                      DO 10 I = I1, I2 */
/*                         K = I - J + M */
/*                         ABD(K,J) = A(I,J) */
/*                10    CONTINUE */
/*                20 CONTINUE */

/*           THIS USES ROWS  ML+1  THROUGH  2*ML+MU+1  OF  ABD . */
/*           IN ADDITION, THE FIRST  ML  ROWS IN  ABD  ARE USED FOR */
/*           ELEMENTS GENERATED DURING THE TRIANGULARIZATION. */
/*           THE TOTAL NUMBER OF ROWS NEEDED IN  ABD  IS  2*ML+MU+1 . */
/*           THE  ML+MU BY ML+MU  UPPER LEFT TRIANGLE AND THE */
/*           ML BY ML  LOWER RIGHT TRIANGLE ARE NOT REFERENCED. */

/*     LINPACK. THIS VERSION DATED 08/14/78 . */
/*     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB. */

/*     SUBROUTINES AND FUNCTIONS */

/*     BLAS DAXPY,DSCAL,IDAMAX */
/*     FORTRAN MAX0,MIN0 */

/*     INTERNAL VARIABLES */



    /* Parameter adjustments */
    abd_dim1 = *lda;
    abd_offset = abd_dim1 + 1;
    abd -= abd_offset;
    --ipvt;

    /* Function Body */
    m = *ml + *mu + 1;
    *info = 0;

/*     ZERO INITIAL FILL-IN COLUMNS */

    j0 = *mu + 2;
    j1 = Dymola_min(*n,m) - 1;
    if (j1 < j0) {
	goto L30;
    }
    i__1 = j1;
    for (jz = j0; jz <= i__1; ++jz) {
	i0 = m + 1 - jz;
	i__2 = *ml;
	for (i__ = i0; i__ <= i__2; ++i__) {
	    abd[i__ + jz * abd_dim1] = 0.;
/* L10: */
	}
/* L20: */
    }
L30:
    jz = j1;
    ju = 0;

/*     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING */

    nm1 = *n - 1;
    if (nm1 < 1) {
	goto L130;
    }
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	kp1 = k + 1;

/*        ZERO NEXT FILL-IN COLUMN */

	++jz;
	if (jz > *n) {
	    goto L50;
	}
	if (*ml < 1) {
	    goto L50;
	}
	i__2 = *ml;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    abd[i__ + jz * abd_dim1] = 0.;
/* L40: */
	}
L50:

/*        FIND L = PIVOT INDEX */

/* Computing MIN */
	i__2 = *ml, i__3 = *n - k;
	lm = Dymola_min(i__2,i__3);
	i__2 = lm + 1;
	l = idamax_(&i__2, &abd[m + k * abd_dim1], &c__1) + m - 1;
	ipvt[k] = l + k - m;

/*        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED */

	if (abd[l + k * abd_dim1] == 0.) {
	    goto L100;
	}

/*           INTERCHANGE IF NECESSARY */

	if (l == m) {
	    goto L60;
	}
	t = abd[l + k * abd_dim1];
	abd[l + k * abd_dim1] = abd[m + k * abd_dim1];
	abd[m + k * abd_dim1] = t;
L60:

/*           COMPUTE MULTIPLIERS */

	t = -1. / abd[m + k * abd_dim1];
	dscal_(&lm, &t, &abd[m + 1 + k * abd_dim1], &c__1);

/*           ROW ELIMINATION WITH COLUMN INDEXING */

/* Computing MIN */
/* Computing MAX */
	i__3 = ju, i__4 = *mu + ipvt[k];
	i__2 = Dymola_max(i__3,i__4);
	ju = Dymola_min(i__2,*n);
	mm = m;
	if (ju < kp1) {
	    goto L90;
	}
	i__2 = ju;
	for (j = kp1; j <= i__2; ++j) {
	    --l;
	    --mm;
	    t = abd[l + j * abd_dim1];
	    if (l == mm) {
		goto L70;
	    }
	    abd[l + j * abd_dim1] = abd[mm + j * abd_dim1];
	    abd[mm + j * abd_dim1] = t;
L70:
	    daxpy_(&lm, &t, &abd[m + 1 + k * abd_dim1], &c__1, &abd[mm + 1 + 
		    j * abd_dim1], &c__1);
/* L80: */
	}
L90:
	goto L110;
L100:
	*info = k;
L110:
/* L120: */
	;
    }
L130:
    ipvt[*n] = *n;
    if (abd[m + *n * abd_dim1] == 0.) {
	*info = *n;
    }
    return 0;
} /* dgbfa_ */

/* Subroutine */ DYMOLA_STATIC int dgbsl_(abd, lda, n, ml, mu, ipvt, b, job)
doublereal *abd;
const integer*lda, *n, *ml, *mu;
integer *ipvt;
doublereal *b;
const integer *job;
{
    /* System generated locals */
    integer abd_dim1, abd_offset, i__1, i__2, i__3;

    /* Local variables */
    integer k, l, m;
    doublereal t;
    integer kb, la, lb, lm, nm1;


/*     DGBSL SOLVES THE DOUBLE PRECISION BAND SYSTEM */
/*     A * X = B  OR  TRANS(A) * X = B */
/*     USING THE FACTORS COMPUTED BY DGBCO OR DGBFA. */

/*     ON ENTRY */

/*        ABD     DOUBLE PRECISION(LDA, N) */
/*                THE OUTPUT FROM DGBCO OR DGBFA. */

/*        LDA     INTEGER */
/*                THE LEADING DIMENSION OF THE ARRAY  ABD . */

/*        N       INTEGER */
/*                THE ORDER OF THE ORIGINAL MATRIX. */

/*        ML      INTEGER */
/*                NUMBER OF DIAGONALS BELOW THE MAIN DIAGONAL. */

/*        MU      INTEGER */
/*                NUMBER OF DIAGONALS ABOVE THE MAIN DIAGONAL. */

/*        IPVT    INTEGER(N) */
/*                THE PIVOT VECTOR FROM DGBCO OR DGBFA. */

/*        B       DOUBLE PRECISION(N) */
/*                THE RIGHT HAND SIDE VECTOR. */

/*        JOB     INTEGER */
/*                = 0         TO SOLVE  A*X = B , */
/*                = NONZERO   TO SOLVE  TRANS(A)*X = B , WHERE */
/*                            TRANS(A)  IS THE TRANSPOSE. */

/*     ON RETURN */

/*        B       THE SOLUTION VECTOR  X . */

/*     ERROR CONDITION */

/*        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A */
/*        ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES SINGULARITY */
/*        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER */
/*        SETTING OF LDA .  IT WILL NOT OCCUR IF THE SUBROUTINES ARE */
/*        CALLED CORRECTLY AND IF DGBCO HAS SET RCOND .GT. 0.0 */
/*        OR DGBFA HAS SET INFO .EQ. 0 . */

/*     TO COMPUTE  INVERSE(A) * C  WHERE  C  IS A MATRIX */
/*     WITH  P  COLUMNS */
/*           CALL DGBCO(ABD,LDA,N,ML,MU,IPVT,RCOND,Z) */
/*           IF (RCOND IS TOO SMALL) GO TO ... */
/*           DO 10 J = 1, P */
/*              CALL DGBSL(ABD,LDA,N,ML,MU,IPVT,C(1,J),0) */
/*        10 CONTINUE */

/*     LINPACK. THIS VERSION DATED 08/14/78 . */
/*     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB. */

/*     SUBROUTINES AND FUNCTIONS */

/*     BLAS DAXPY,DDOT */
/*     FORTRAN MIN0 */

/*     INTERNAL VARIABLES */


    /* Parameter adjustments */
    abd_dim1 = *lda;
    abd_offset = abd_dim1 + 1;
    abd -= abd_offset;
    --ipvt;
    --b;

    /* Function Body */
    m = *mu + *ml + 1;
    nm1 = *n - 1;
    if (*job != 0) {
	goto L50;
    }

/*        JOB = 0 , SOLVE  A * X = B */
/*        FIRST SOLVE L*Y = B */

    if (*ml == 0) {
	goto L30;
    }
    if (nm1 < 1) {
	goto L30;
    }
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
/* Computing MIN */
	i__2 = *ml, i__3 = *n - k;
	lm = Dymola_min(i__2,i__3);
	l = ipvt[k];
	t = b[l];
	if (l == k) {
	    goto L10;
	}
	b[l] = b[k];
	b[k] = t;
L10:
	daxpy_(&lm, &t, &abd[m + 1 + k * abd_dim1], &c__1, &b[k + 1], &c__1);
/* L20: */
    }
L30:

/*        NOW SOLVE  U*X = Y */

    i__1 = *n;
    for (kb = 1; kb <= i__1; ++kb) {
	k = *n + 1 - kb;
	b[k] /= abd[m + k * abd_dim1];
	lm = Dymola_min(k,m) - 1;
	la = m - lm;
	lb = k - lm;
	t = -b[k];
	daxpy_(&lm, &t, &abd[la + k * abd_dim1], &c__1, &b[lb], &c__1);
/* L40: */
    }
    goto L100;
L50:

/*        JOB = NONZERO, SOLVE  TRANS(A) * X = B */
/*        FIRST SOLVE  TRANS(U)*Y = B */

    i__1 = *n;
    for (k = 1; k <= i__1; ++k) {
	lm = Dymola_min(k,m) - 1;
	la = m - lm;
	lb = k - lm;
	/* t = ddot_(&lm, &abd[la + k * abd_dim1], &c__1, &b[lb], &c__1); */
	t = ddot1_(&lm, &abd[la + k * abd_dim1], &b[lb]);
	b[k] = (b[k] - t) / abd[m + k * abd_dim1];
/* L60: */
    }

/*        NOW SOLVE TRANS(L)*X = Y */

    if (*ml == 0) {
	goto L90;
    }
    if (nm1 < 1) {
	goto L90;
    }
    i__1 = nm1;
    for (kb = 1; kb <= i__1; ++kb) {
	k = *n - kb;
/* Computing MIN */
	i__2 = *ml, i__3 = *n - k;
	lm = Dymola_min(i__2,i__3);
	/* b[k] += ddot_(&lm, &abd[m + 1 + k * abd_dim1], &c__1, &b[k + 1], &c__1); */
	b[k] += ddot1_(&lm, &abd[m + 1 + k * abd_dim1], &b[k + 1]);
	l = ipvt[k];
	if (l == k) {
	    goto L70;
	}
	t = b[l];
	b[l] = b[k];
	b[k] = t;
L70:
/* L80: */
	;
    }
L90:
L100:
    return 0;
} /* dgbsl_ */

/* Subroutine */ DYMOLA_STATIC int dgeco_(a, lda, n, ipvt, rcond, z__)
doublereal *a;
integer*lda, *n;
integer *ipvt;
doublereal *rcond, *z__;
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal d__1, d__2;

    /* Builtin functions */

    /* Local variables */
    integer j, k, l;
    doublereal s, t;
    integer kb;
    doublereal ek, sm, wk;
    integer kp1;
    doublereal wkm;
    integer info;
    doublereal anorm;
    doublereal ynorm;


/*     DGECO FACTORS A DOUBLE PRECISION MATRIX BY GAUSSIAN ELIMINATION */
/*     AND ESTIMATES THE CONDITION OF THE MATRIX. */

/*     IF  RCOND  IS NOT NEEDED, DGEFA IS SLIGHTLY FASTER. */
/*     TO SOLVE  A*X = B , FOLLOW DGECO BY DGESL. */
/*     TO COMPUTE  INVERSE(A)*C , FOLLOW DGECO BY DGESL. */
/*     TO COMPUTE  DETERMINANT(A) , FOLLOW DGECO BY DGEDI. */
/*     TO COMPUTE  INVERSE(A) , FOLLOW DGECO BY DGEDI. */

/*     ON ENTRY */

/*        A       DOUBLE PRECISION(LDA, N) */
/*                THE MATRIX TO BE FACTORED. */

/*        LDA     INTEGER */
/*                THE LEADING DIMENSION OF THE ARRAY  A . */

/*        N       INTEGER */
/*                THE ORDER OF THE MATRIX  A . */

/*     ON RETURN */

/*        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS */
/*                WHICH WERE USED TO OBTAIN IT. */
/*                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE */
/*                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER */
/*                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR. */

/*        IPVT    INTEGER(N) */
/*                AN INTEGER VECTOR OF PIVOT INDICES. */

/*        RCOND   DOUBLE PRECISION */
/*                AN ESTIMATE OF THE RECIPROCAL CONDITION OF  A . */
/*                FOR THE SYSTEM  A*X = B , RELATIVE PERTURBATIONS */
/*                IN  A  AND  B  OF SIZE  EPSILON  MAY CAUSE */
/*                RELATIVE PERTURBATIONS IN  X  OF SIZE  EPSILON/RCOND . 
*/
/*                IF  RCOND  IS SO SMALL THAT THE LOGICAL EXPRESSION */
/*                           1.0 + RCOND .EQ. 1.0 */
/*                IS TRUE, THEN  A  MAY BE SINGULAR TO WORKING */
/*                PRECISION.  IN PARTICULAR,  RCOND  IS ZERO  IF */
/*                EXACT SINGULARITY IS DETECTED OR THE ESTIMATE */
/*                UNDERFLOWS. */

/*        Z       DOUBLE PRECISION(N) */
/*                A WORK VECTOR WHOSE CONTENTS ARE USUALLY UNIMPORTANT. */
/*                IF  A  IS CLOSE TO A SINGULAR MATRIX, THEN  Z  IS */
/*                AN APPROXIMATE NULL VECTOR IN THE SENSE THAT */
/*                NORM(A*Z) = RCOND*NORM(A)*NORM(Z) . */

/*     LINPACK. THIS VERSION DATED 08/14/78 . */
/*     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB. */

/*     SUBROUTINES AND FUNCTIONS */

/*     LINPACK DGEFA */
/*     BLAS DAXPY,DDOT,DSCAL,DASUM */
/*     FORTRAN DABS,DMAX1,DSIGN */

/*     INTERNAL VARIABLES */



/*     COMPUTE 1-NORM OF A */

    /* Parameter adjustments */
    --z__;
    --ipvt;
    a_dim1 = *lda;
    a_offset = a_dim1 + 1;
    a -= a_offset;

    /* Function Body */
    anorm = 0.;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
	d__1 = anorm, d__2 = dasum_(n, &a[j * a_dim1 + 1], &c__1);
	anorm = Dymola_max(d__1,d__2);
/* L10: */
    }

/*     FACTOR */

    dgefa_(&a[a_offset], lda, n, &ipvt[1], &info);

/*     RCOND = 1/(NORM(A)*(ESTIMATE OF NORM(INVERSE(A)))) . */
/*     ESTIMATE = NORM(Z)/NORM(Y) WHERE  A*Z = Y  AND  TRANS(A)*Y = E . */
/*     TRANS(A)  IS THE TRANSPOSE OF A .  THE COMPONENTS OF  E  ARE */
/*     CHOSEN TO CAUSE MAXIMUM LOCAL GROWTH IN THE ELEMENTS OF W  WHERE */
/*     TRANS(U)*W = E .  THE VECTORS ARE FREQUENTLY RESCALED TO AVOID */
/*     OVERFLOW. */

/*     SOLVE TRANS(U)*W = E */

    ek = 1.;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
	z__[j] = 0.;
/* L20: */
    }
    i__1 = *n;
    for (k = 1; k <= i__1; ++k) {
	if (z__[k] != 0.) {
	    d__1 = -z__[k];
	    ek = d_sign(&ek, &d__1);
	}
	if ((d__1 = ek - z__[k], Dymola_abs(d__1)) <= (d__2 = a[k + k * a_dim1], Dymola_abs(
		d__2))) {
	    goto L30;
	}
	s = (d__1 = a[k + k * a_dim1], Dymola_abs(d__1)) / (d__2 = ek - z__[k], Dymola_abs(
		d__2));
	dscal_(n, &s, &z__[1], &c__1);
	ek = s * ek;
L30:
	wk = ek - z__[k];
	wkm = -ek - z__[k];
	s = Dymola_abs(wk);
	sm = Dymola_abs(wkm);
	if (a[k + k * a_dim1] == 0.) {
	    goto L40;
	}
	wk /= a[k + k * a_dim1];
	wkm /= a[k + k * a_dim1];
	goto L50;
L40:
	wk = 1.;
	wkm = 1.;
L50:
	kp1 = k + 1;
	if (kp1 > *n) {
	    goto L90;
	}
	i__2 = *n;
	for (j = kp1; j <= i__2; ++j) {
	    sm += (d__1 = z__[j] + wkm * a[k + j * a_dim1], Dymola_abs(d__1));
	    z__[j] += wk * a[k + j * a_dim1];
	    s += (d__1 = z__[j], Dymola_abs(d__1));
/* L60: */
	}
	if (s >= sm) {
	    goto L80;
	}
	t = wkm - wk;
	wk = wkm;
	i__2 = *n;
	for (j = kp1; j <= i__2; ++j) {
	    z__[j] += t * a[k + j * a_dim1];
/* L70: */
	}
L80:
L90:
	z__[k] = wk;
/* L100: */
    }
    s = 1. / dasum_(n, &z__[1], &c__1);
    dscal_(n, &s, &z__[1], &c__1);

/*     SOLVE TRANS(L)*Y = W */

    i__1 = *n;
    for (kb = 1; kb <= i__1; ++kb) {
	k = *n + 1 - kb;
	if (k < *n) {
	    i__2 = *n - k;
	    /* z__[k] += ddot_(&i__2, &a[k + 1 + k * a_dim1], &c__1, &z__[k + 1], &c__1); */
	    z__[k] += ddot1_(&i__2, &a[k + 1 + k * a_dim1], &z__[k + 1]);
	}
	if ((d__1 = z__[k], Dymola_abs(d__1)) <= 1.) {
	    goto L110;
	}
	s = 1. / (d__1 = z__[k], Dymola_abs(d__1));
	dscal_(n, &s, &z__[1], &c__1);
L110:
	l = ipvt[k];
	t = z__[l];
	z__[l] = z__[k];
	z__[k] = t;
/* L120: */
    }
    s = 1. / dasum_(n, &z__[1], &c__1);
    dscal_(n, &s, &z__[1], &c__1);

    ynorm = 1.;

/*     SOLVE L*V = Y */

    i__1 = *n;
    for (k = 1; k <= i__1; ++k) {
	l = ipvt[k];
	t = z__[l];
	z__[l] = z__[k];
	z__[k] = t;
	if (k < *n) {
	    i__2 = *n - k;
	    daxpy_(&i__2, &t, &a[k + 1 + k * a_dim1], &c__1, &z__[k + 1], &
		    c__1);
	}
	if ((d__1 = z__[k], Dymola_abs(d__1)) <= 1.) {
	    goto L130;
	}
	s = 1. / (d__1 = z__[k], Dymola_abs(d__1));
	dscal_(n, &s, &z__[1], &c__1);
	ynorm = s * ynorm;
L130:
/* L140: */
	;
    }
    s = 1. / dasum_(n, &z__[1], &c__1);
    dscal_(n, &s, &z__[1], &c__1);
    ynorm = s * ynorm;

/*     SOLVE  U*Z = V */

    i__1 = *n;
    for (kb = 1; kb <= i__1; ++kb) {
	k = *n + 1 - kb;
	if ((d__1 = z__[k], Dymola_abs(d__1)) <= (d__2 = a[k + k * a_dim1], Dymola_abs(d__2)
		)) {
	    goto L150;
	}
	s = (d__1 = a[k + k * a_dim1], Dymola_abs(d__1)) / (d__2 = z__[k], Dymola_abs(d__2))
		;
	dscal_(n, &s, &z__[1], &c__1);
	ynorm = s * ynorm;
L150:
	if (a[k + k * a_dim1] != 0.) {
	    z__[k] /= a[k + k * a_dim1];
	}
	if (a[k + k * a_dim1] == 0.) {
	    z__[k] = 1.;
	}
	t = -z__[k];
	i__2 = k - 1;
	daxpy_(&i__2, &t, &a[k * a_dim1 + 1], &c__1, &z__[1], &c__1);
/* L160: */
    }
/*     MAKE ZNORM = 1.0 */
    s = 1. / dasum_(n, &z__[1], &c__1);
    dscal_(n, &s, &z__[1], &c__1);
    ynorm = s * ynorm;

    if (anorm != 0.) {
	*rcond = ynorm / anorm;
    }
    if (anorm == 0.) {
	*rcond = 0.;
    }
    return 0;
} /* dgeco_ */

/* Subroutine */ DYMOLA_STATIC int dgefa_(a, lda, n, ipvt, info)
doublereal *a;
const integer*lda, *n;
integer *ipvt, *info;
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    integer j, k, l;
    doublereal t;
    integer kp1, nm1;


/*     DGEFA FACTORS A DOUBLE PRECISION MATRIX BY GAUSSIAN ELIMINATION. */

/*     DGEFA IS USUALLY CALLED BY DGECO, BUT IT CAN BE CALLED */
/*     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED. */
/*     (TIME FOR DGECO) = (1 + 9/N)*(TIME FOR DGEFA) . */

/*     ON ENTRY */

/*        A       DOUBLE PRECISION(LDA, N) */
/*                THE MATRIX TO BE FACTORED. */

/*        LDA     INTEGER */
/*                THE LEADING DIMENSION OF THE ARRAY  A . */

/*        N       INTEGER */
/*                THE ORDER OF THE MATRIX  A . */

/*     ON RETURN */

/*        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS */
/*                WHICH WERE USED TO OBTAIN IT. */
/*                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE */
/*                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER */
/*                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR. */

/*        IPVT    INTEGER(N) */
/*                AN INTEGER VECTOR OF PIVOT INDICES. */

/*        INFO    INTEGER */
/*                = 0  NORMAL VALUE. */
/*                = K  IF  U(K,K) .EQ. 0.0 .  THIS IS NOT AN ERROR */
/*                     CONDITION FOR THIS SUBROUTINE, BUT IT DOES */
/*                     INDICATE THAT DGESL OR DGEDI WILL DIVIDE BY ZERO */
/*                     IF CALLED.  USE  RCOND  IN DGECO FOR A RELIABLE */
/*                     INDICATION OF SINGULARITY. */

/*     LINPACK. THIS VERSION DATED 08/14/78 . */
/*     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB. */

/*     SUBROUTINES AND FUNCTIONS */

/*     BLAS DAXPY,DSCAL,IDAMAX */

/*     INTERNAL VARIABLES */



/*     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING */

    /* Parameter adjustments */
    --ipvt;
    a_dim1 = *lda;
    a_offset = a_dim1 + 1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    nm1 = *n - 1;
    if (nm1 < 1) {
	goto L70;
    }
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	kp1 = k + 1;

/*        FIND L = PIVOT INDEX */

	i__2 = *n - k + 1;
	l = idamax_(&i__2, &a[k + k * a_dim1], &c__1) + k - 1;
	ipvt[k] = l;

/*        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED */

	if (a[l + k * a_dim1] == 0.) {
	    goto L40;
	}

/*           INTERCHANGE IF NECESSARY */

	if (l == k) {
	    goto L10;
	}
	t = a[l + k * a_dim1];
	a[l + k * a_dim1] = a[k + k * a_dim1];
	a[k + k * a_dim1] = t;
L10:

/*           COMPUTE MULTIPLIERS */

	t = -1. / a[k + k * a_dim1];
	i__2 = *n - k;
	dscal_(&i__2, &t, &a[k + 1 + k * a_dim1], &c__1);

/*           ROW ELIMINATION WITH COLUMN INDEXING */

	i__2 = *n;
	for (j = kp1; j <= i__2; ++j) {
	    t = a[l + j * a_dim1];
	    if (l == k) {
		goto L20;
	    }
	    a[l + j * a_dim1] = a[k + j * a_dim1];
	    a[k + j * a_dim1] = t;
L20:
	    i__3 = *n - k;
	    /* daxpy_(&i__3, &t, &a[k + 1 + k * a_dim1], &c__1, &a[k + 1 + j * a_dim1], &c__1); */
	    daxpy1_(&i__3, &t, &a[k + 1 + k * a_dim1], &a[k + 1 + j * a_dim1]);
/* L30: */
	}
	goto L50;
L40:
	*info = k;
L50:
/* L60: */
	;
    }
L70:
    ipvt[*n] = *n;
    if (a[*n + *n * a_dim1] == 0.) {
	*info = *n;
    }
    return 0;
} /* dgefa_ */

/* Subroutine */ DYMOLA_STATIC int dgesl_(a, lda, n, ipvt, b, job)
doublereal *a;
const integer*lda, *n, *ipvt;
doublereal *b;
const integer *job;
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    integer k, l;
    doublereal t;
    integer kb, nm1;


/*     DGESL SOLVES THE DOUBLE PRECISION SYSTEM */
/*     A * X = B  OR  TRANS(A) * X = B */
/*     USING THE FACTORS COMPUTED BY DGECO OR DGEFA. */

/*     ON ENTRY */

/*        A       DOUBLE PRECISION(LDA, N) */
/*                THE OUTPUT FROM DGECO OR DGEFA. */

/*        LDA     INTEGER */
/*                THE LEADING DIMENSION OF THE ARRAY  A . */

/*        N       INTEGER */
/*                THE ORDER OF THE MATRIX  A . */

/*        IPVT    INTEGER(N) */
/*                THE PIVOT VECTOR FROM DGECO OR DGEFA. */

/*        B       DOUBLE PRECISION(N) */
/*                THE RIGHT HAND SIDE VECTOR. */

/*        JOB     INTEGER */
/*                = 0         TO SOLVE  A*X = B , */
/*                = NONZERO   TO SOLVE  TRANS(A)*X = B  WHERE */
/*                            TRANS(A)  IS THE TRANSPOSE. */

/*     ON RETURN */

/*        B       THE SOLUTION VECTOR  X . */

/*     ERROR CONDITION */

/*        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A */
/*        ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES SINGULARITY */
/*        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER */
/*        SETTING OF LDA .  IT WILL NOT OCCUR IF THE SUBROUTINES ARE */
/*        CALLED CORRECTLY AND IF DGECO HAS SET RCOND .GT. 0.0 */
/*        OR DGEFA HAS SET INFO .EQ. 0 . */

/*     TO COMPUTE  INVERSE(A) * C  WHERE  C  IS A MATRIX */
/*     WITH  P  COLUMNS */
/*           CALL DGECO(A,LDA,N,IPVT,RCOND,Z) */
/*           IF (RCOND IS TOO SMALL) GO TO ... */
/*           DO 10 J = 1, P */
/*              CALL DGESL(A,LDA,N,IPVT,C(1,J),0) */
/*        10 CONTINUE */

/*     LINPACK. THIS VERSION DATED 08/14/78 . */
/*     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB. */

/*     SUBROUTINES AND FUNCTIONS */

/*     BLAS DAXPY,DDOT */

/*     INTERNAL VARIABLES */


    /* Parameter adjustments */
    --b;
    a_dim1 = *lda;
    a_offset = a_dim1 + 1;
    a -= a_offset;
    --ipvt;

    /* Function Body */
    nm1 = *n - 1;
    if (*job != 0) {
	goto L50;
    }

/*        JOB = 0 , SOLVE  A * X = B */
/*        FIRST SOLVE  L*Y = B */

    if (nm1 < 1) {
	goto L30;
    }
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	l = ipvt[k];
	t = b[l];
	if (l == k) {
	    goto L10;
	}
	b[l] = b[k];
	b[k] = t;
L10:
	i__2 = *n - k;
	/* daxpy_(&i__2, &t, &a[k + 1 + k * a_dim1], &c__1, &b[k + 1], &c__1); */
	daxpy1_(&i__2, &t, &a[k + 1 + k * a_dim1], &b[k + 1]);
/* L20: */
    }
L30:

/*        NOW SOLVE  U*X = Y */

    i__1 = *n;
    for (kb = 1; kb <= i__1; ++kb) {
	k = *n + 1 - kb;
	b[k] /= a[k + k * a_dim1];
	t = -b[k];
	i__2 = k - 1;
	/* daxpy_(&i__2, &t, &a[k * a_dim1 + 1], &c__1, &b[1], &c__1); */
	daxpy1_(&i__2, &t, &a[k * a_dim1 + 1], &b[1]);
/* L40: */
    }
    goto L100;
L50:

/*        JOB = NONZERO, SOLVE  TRANS(A) * X = B */
/*        FIRST SOLVE  TRANS(U)*Y = B */

    i__1 = *n;
    for (k = 1; k <= i__1; ++k) {
	i__2 = k - 1;
	/* t = ddot_(&i__2, &a[k * a_dim1 + 1], &c__1, &b[1], &c__1); */
	t = ddot1_(&i__2, &a[k * a_dim1 + 1], &b[1]);
	b[k] = (b[k] - t) / a[k + k * a_dim1];
/* L60: */
    }

/*        NOW SOLVE TRANS(L)*X = Y */

    if (nm1 < 1) {
	goto L90;
    }
    i__1 = nm1;
    for (kb = 1; kb <= i__1; ++kb) {
	k = *n - kb;
	i__2 = *n - k;
	/* b[k] += ddot_(&i__2, &a[k + 1 + k * a_dim1], &c__1, &b[k + 1], &c__1); */
	b[k] += ddot1_(&i__2, &a[k + 1 + k * a_dim1], &b[k + 1]);
	l = ipvt[k];
	if (l == k) {
	    goto L70;
	}
	t = b[l];
	b[l] = b[k];
	b[k] = t;
L70:
/* L80: */
	;
    }
L90:
L100:
    return 0;
} /* dgesl_ */

/* Subroutine */ DYMOLA_STATIC int dymres_(a, lda, n, b, ierr)
doublereal *a;
const integer*lda, *n;
doublereal *b;
integer *ierr;
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    integer i__, j;


/*     Reset matrix A and vector b (columnwise) */


    /* Parameter adjustments */
    --b;
    a_dim1 = *lda;
    a_offset = a_dim1 + 1;
    a -= a_offset;

    /* Function Body */
    if (*n > *lda) {
	dymosimmessageSev_(1, "--- Too large matrix. MaxMat in dsmodel.c needs to be increased.", 64);
	*ierr = 1;
    } else {
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *n;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		a[i__ + j * a_dim1] = 0.;
/* L10: */
	    }
	    b[j] = 0.;
/* L20: */
	}
	*ierr = 0;
    }
    return 0;
} /* dymres_ */



/* Subroutine */ DYMOLA_STATIC int dymsol_(a, lda, n, b, dwork, iwork, ierr)
doublereal *a;
integer*lda, *n;
doublereal *b, *dwork;
integer *iwork, *ierr;
{
    /* System generated locals */
    integer a_dim1, a_offset;

    /* Local variables */
    doublereal rcond;



/*     Solves the equation */
/*       A*x = b */

    /* Parameter adjustments */
    --iwork;
    --dwork;
    --b;
    a_dim1 = *lda;
    a_offset = a_dim1 + 1;
    a -= a_offset;

    /* Function Body */
    *ierr = 0;
    dgeco_(&a[a_offset], lda, n, &iwork[1], &rcond, &dwork[1]);
    if (rcond * .01 + 1. <= 1.) {
	dymosimmessageSev_(1, "--- Error in Dymola model:", 26);
	dymosimmessageSev_(1, "---    System of equations is singular.", 39);
	dymosimmessagedoubleSev_(1, "---   Condition number = ", &rcond, 25);
	*ierr = 1;
    } else {
	dgesl_(&a[a_offset], lda, n, &iwork[1], &b[1], &c__0);
    }
    return 0;
} /* dymsol_ */


/* Subroutine */ DYMOLA_STATIC int dymlin_(infrev, n, sol, res, jac, ljac, dwork, iwork, 
	time, event, printpriority, sysnr, ierr)
integer *infrev;
integer*n;
doublereal *sol, *res, *jac;
integer *ljac;
doublereal *dwork;
integer *iwork;
doublereal *time;
integer *event, *printpriority, *sysnr, *ierr;
{
    /* System generated locals */
    integer jac_dim1, jac_offset, i__1;

    /* Local variables */
    integer i__, icol;


/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */

/* Solve linear system "A*x = b", where code to compute */
/* "Res = A*x - b" is provided (x=Sol) */

/* InfRev: IN, OUT, INTEGER, reverse communication parameter */
/*         InfRev is an integer variable that must be set by the user to 
*/
/*         a non-positive value initially, in order to indicate */
/*         the start of the calculation. The value of InfRev on each */
/*         return indicates the reason for the return. If it is 1,3 or 4, 
*/
/*         then the user's program has to provide new values of Res, */
/*         and then recall the subroutine with InfRev still set to this */
/*         number. */
/*         InfRev on return */
/*            = 0  : Solver terminated */
/*            = 1,3: Calculate Res */

/* N     : IN, INTEGER, N.gt.0 */
/*         Number of residues and solution variables. */

/* Sol   : OUT, DOUBLE(N) */
/*         On output QSol contains the values for which Res has to be */
/*         computed in the next iteration step (InfRev=1,3) or the */
/*         final solution (InfRev=0). */

/* Res   : IN, DOUBLE(N) */
/*         Res has to contain the residues evaluated at Sol. */
/*         (INFREV=1,3) */

/* Jac   : OUT, DOUBLE(N,N) */
/*         Jac contains the A-matrix after successful termination. */

/* dwork : OUT, DOUBLE(ldwork) */
/*         work array of length ldwork. */
/*         ldwork must not be less than N*N+5*N */

/* iwork : IN, INTEGER (liwork) */
/*         work array of length liwork. */
/*         liwork must not be less than 2*N. */

/*  Time    (input) double */
/*          Actualt time instant (used in error message) */

/* Event : IN, INTEGER */
/*         = 0: DYMSOL called during continuous integration. */
/*         = 1: DYMSOL called at an event instant. */

/* Printpriority: IN, INTEGER */
/*         If PrintPriority >= 80 and Event=1, a message is printed */
/*         if A is singular but with consistent equations. */

/* SysNr : IN, INTEGER */
/*         The number of the linear equation system (used to identify the 
*/
/*         system of equations in the Dymola model */

/* ierr  : OUT, INTEGER */
/*         = 0: successful exit */
/*        = 1: an error occured; an error message has been already printed
.*/

/* Author: M. Otter, DLR Oberpfaffenhofen, March 1998. */

/* ====================================================================== 
*/


    /* Parameter adjustments */
    --iwork;
    --dwork;
    --res;
    --sol;
    jac_dim1 = *ljac;
    jac_offset = jac_dim1 + 1;
    jac -= jac_offset;

    /* Function Body */
    *ierr = 0;
    if (*infrev < 0) {
/*        -- First call. Compute right hand side vector b */
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    sol[i__] = 0.;
/* L10: */
	}
	*infrev = 1;
	return 0;

    } else if (*infrev == 1) {
/*        -- Right hand side vector computed in last step. */
/*        -- Store it in double work array. */
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    dwork[i__] = -res[i__];
/* L20: */
	}

/*        -- Initialize computation of all the columns of the A-Matrix
 */
	iwork[1] = 1;
	sol[1] = 1.;
	i__1 = *n;
	for (i__ = 2; i__ <= i__1; ++i__) {
	    sol[i__] = 0.;
/* L30: */
	}
	*infrev = 3;
	return 0;

    } else if (*infrev == 3) {
/*        -- Store computed column in A-Matrix */
	icol = iwork[1];
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    jac[i__ + icol * jac_dim1] = res[i__] + dwork[i__];
/* L40: */
	}

/*        -- Compute next column */
	++icol;
	iwork[1] = icol;
	if (icol <= *n) {
	    i__1 = *n;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		sol[i__] = 0.;
/* L50: */
	    }
	    sol[icol] = 1.;
	    *infrev = 3;
	    return 0;
	}

/*        -- Solve linear system of equations */
	dymli1_(sysnr, &c__0, &jac[jac_offset], ljac, n, &dwork[1], time, 
		event, printpriority, &dwork[*n + 1], &iwork[1], ierr);
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    sol[i__] = dwork[i__];
/* L60: */
	}
	*infrev = 0;
	return 0;
    } else {
/*        -- Wrong input argument */
	DymosimMessageIntSev_(1, "... Wrong input argument of DYMLIN, InvRev = ", 
		infrev, 45);
	*infrev = 0;
	*ierr = 1;
	return 0;
    }
    return 0;
} /* dymlin_ */




/* Subroutine */ LIBDS_API int dymli1_(sysnr, fact, a, lda, n, b, time, event, 
	printpriority, dwork, iwork, ierr)
integer *sysnr;
const integer *fact;
doublereal *a;
integer*lda;
integer *n;
doublereal *b, *time;
integer *event, *printpriority;
doublereal *dwork;
integer *iwork, *ierr;
{
    /* Initialized data */

    /* System generated locals */
    integer a_dim1, a_offset, i__1;

    /* Local variables */
    integer i__;
    doublereal eps;
    integer info;

/*     .. */

/*  Purpose */
/*  ======= */

/*  DYMSOL computes the solution to a real system of linear equations */
/*     A * X = B, */
/*  where A is an N-by-N matrix and X and B are N-by-1 matrices. */

/*  If FACT = 0, the LU decomposition with partial pivoting and row */
/*  interchanges is used to factor A as */
/*     A = P * L * U, */
/*  where P is a permutation matrix, L is unit lower triangular, and U is 
*/
/*  upper triangular.  If A is nonsingular, then the factored form of A */
/*  is used to solve the system of equations A * X = B. */
/*  If FACT = 1 or if A is singular, the QR decomposition with */
/*  column pivoting is used to factor A as */
/*     A*P = Q * R */
/*  where P is a permutation matrix, Q is an orthogonal matrix, and R is 
*/
/*  upper triangular. The rank of A is determined and the compatibility */
/*  of the linear system is checked. If the system is compatible a */
/*  minimum norm solution is computed using the QR decomposition of A. */

/*  If A is singular but with consistent equations, a message is */
/*  printed at event instants and if the print priority is >= 80. */


/*  Arguments */
/*  ========= */

/*  SysNr   (input) INTEGER */
/*          The number of the linear equation system (used to identify the
 */
/*          system of equations in the Dymola model) */

/*  FACT    (input) INTEGER */
/*          Option to specify the solution method. */
/*          FACT = 0, use the LU-decomposition to solve AX = B or */
/*                    the QR-decomposition if A is singular. */
/*          FACT = 1, use the QR-decomposition to solve AX = B. */

/*  A       (input/output) DOUBLE PRECISION array, dimension (N,N) */
/*          On entry, the N-by-N coefficient matrix A. */
/*          On exit, information on LU or QR decomposition of A. */

/*  LDA     (input) INTEGER */
/*          The declared leading dimension of A. LDA >= 1. */

/*  N       (input) INTEGER */
/*          The number of linear equations, i.e., the order of the */
/*          matrix A.  1 <= N <= LDA. */

/*  B       (input/output) DOUBLE PRECISION array, dimension (N) */
/*          On entry, the N-by-1 matrix of right hand side matrix B. */
/*          On exit, if INFO = 0, the N-by-1 solution matrix X. */

/*  Time    (input) double */
/*          Actual time instant (used in error message) */

/*  Event   (input) INTEGER */
/*          = 0: DYMSOL called during continuous integration. */
/*          = 1: DYMSOL called at an event instant. */

/*  PrintPriority (input) INTEGER */
/*          If PrintPriority >= 80 and Event=1, a message is printed */
/*          if A is singular but with consistent equations. */

/*  WORK    (output) REAL work array, dimension (LWORK), where */
/*           LWORK = N*N+4*N if FACT = 0 */
/*           LWORK = 4*N     if FACT = 1 */

/*  IWORK   (output) INTEGER work array, dimension (2*N) */

/*  IERR    (output) INTEGER */
/*          = 0:  successful exit */
/*                (A regular or singular with consistent equations) */
/*          = 1:  error exit (A singular, AX=B not compatible). */
/*                a message has already been computed. */

/* Author: M. Otter, DLR Oberpfaffenhofen, Feb. 1998. */

/* ====================================================================== 
*/

		eps=DBL_EPSILON*1e7;




    /* Parameter adjustments */
    --iwork;
    --dwork;
    --b;
    a_dim1 = *lda;
    a_offset = a_dim1 + 1;
    a -= a_offset;

    /* Function Body */

    *ierr = 0;
/* Inquire machine epsilon */

    dymlqr_(fact, &a[a_offset], lda, n, &b[1], &eps, &iwork[1], &dwork[1], &
	    iwork[*n + 1], &info);
    if (info == 1 && *event == 1 && (*printpriority & (1<<12))) {
	dymosimmessagedoubleSev_(1, "... System of equations is singular at Time = "
		, time, 46);
	DymosimMessageIntSev_(1, "...    Linear system of equations number = ", 
		sysnr, 43);
	dymosimmessageSev_(1, "...    Variables X(i) which cannot be uniquely computed:", 56);
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (iwork[i__] == 1) {
		DymosimMessageIntSev_(1, "...     ", &i__, 8);
	    }
/* L10: */
	}
	dymosimmessageSev_(1, "... Simulation continues with minimum norm solution."
		, 52);
    } else if (info == 2) {
	dymosimmessageSev_(1, " ", 1);
	dymosimmessagedoubleSev_(1, "LINEAR SYSTEM OF EQUATIONS IS SINGULAR AT TIME = ", time, 49);
	DymosimMessageIntSev_(1, "   linear system of equations number = ", sysnr, 
		39);
	dymosimmessageSev_(1, " ", 1);
	*ierr = 1;
    }

    return 0;
} /* dymli1_ */
LIBDS_API int dymlqr5_(integer *fact, doublereal*a, integer*lda, integer*n, doublereal*b, const doublereal*x0, doublereal*tol, integer*pivots, doublereal*work, integer*iwork, integer*factor,integer*info,integer*sysnr, const char*const*varnames,integer*fEvent,doublereal*intTol);

/* Subroutine */ LIBDS_API int dymli5_(sysnr, fact, a, lda, n, b, x0, time, event, 
	PrintEvent, dwork, iwork, factor,varnames,ierr,fEvent,intTol)
integer *sysnr, *fact;
doublereal *a;
integer*lda, *n;
doublereal *b, *time;
const doublereal*x0;
integer *event, *PrintEvent;
doublereal *dwork;
integer *iwork, *factor;
const char*const*varnames;
integer *ierr;
int *fEvent;
doublereal *intTol;
{
    /* Initialized data */

    /* System generated locals */
    /* integer a_dim1, a_offset;*/
	integer i__1;

    /* Local variables */
    integer i__;
    doublereal eps;
    integer info;

/*     .. */

/*  Purpose */
/*  ======= */

/*  DYMSOL computes the solution to a real system of linear equations */
/*     A * X = B, */
/*  where A is an N-by-N matrix and X and B are N-by-1 matrices. */

/*  If FACT = 0, the LU decomposition with partial pivoting and row */
/*  interchanges is used to factor A as */
/*     A = P * L * U, */
/*  where P is a permutation matrix, L is unit lower triangular, and U is 
*/
/*  upper triangular.  If A is nonsingular, then the factored form of A */
/*  is used to solve the system of equations A * X = B. */
/*  If FACT = 1 or if A is singular, the QR decomposition with */
/*  column pivoting is used to factor A as */
/*     A*P = Q * R */
/*  where P is a permutation matrix, Q is an orthogonal matrix, and R is 
*/
/*  upper triangular. The rank of A is determined and the compatibility */
/*  of the linear system is checked. If the system is compatible a */
/*  minimum norm solution is computed using the QR decomposition of A. */

/*  If A is singular but with consistent equations, a message is */
/*  printed at event instants and if the print priority is >= 80. */


/*  Arguments */
/*  ========= */

/*  SysNr   (input) INTEGER */
/*          The number of the linear equation system (used to identify the
 */
/*          system of equations in the Dymola model) */

/*  FACT    (input) INTEGER */
/*          Option to specify the solution method. */
/*          FACT&1 = 0, use the LU-decomposition to solve AX = B or */
/*                    the QR-decomposition if A is singular. */
/*          FACT&1 = 1, use the QR-decomposition to solve AX = B. */
/*          FACT&2 = 0, do not perform row and column scaling */
/*          FACT&2 = 2, perform row and column before LU/QR-decomposition */

/*  A       (input) DOUBLE PRECISION array, dimension (N,N) */
/*          On entry, the N-by-N coefficient matrix A. */

/*  LDA     (input) INTEGER */
/*          The declared leading dimension of A. LDA >= 1. */

/*  N       (input) INTEGER */
/*          The number of linear equations, i.e., the order of the */
/*          matrix A.  1 <= N <= LDA. */

/*  B       (input/output) DOUBLE PRECISION array, dimension (N) */
/*          On entry, the N-by-1 matrix of right hand side matrix B. */
/*          On exit, if INFO = 0, the N-by-1 solution matrix X. */

/* X0       (input) The old value for minimimum norm solution */

/*  Time    (input) double */
/*          Actual time instant (used in error message) */

/*  Event   (input) INTEGER */
/*          = 0: DYMSOL called during continuous integration. */
/*          = 1: DYMSOL called at an event instant. */

/*  PrintPriority (input) INTEGER */
/*          If PrintPriority >= 80 and Event=1, a message is printed */
/*          if A is singular but with consistent equations. */

/*  WORK    (output) REAL work array, dimension (LWORK), where */
/*           LWORK = N*N+6*N */

/*  IWORK   (output) INTEGER work array, dimension (2*N+1) */

  /* Factor (input/output)
     Factor&3     = 0: Factorize matrix
                  = 1: Use existing LU-decomposition
                  = 2: Use existing QR-decomposition
     Factor&256   =256: Use row-equlibrization
           &512   =512: Use column-equilibrization
             Updated after each call.
             The LU-factorization is stored in the first N*N elements 
             of WORK and the first N elements of IWORK.
             The QR-factorization is stored in the first N*N+N elements
             of WORK and the first N+1 elements of IWORK.
	     The equilib information is stored in the 2*N last elements
	     of WORK */

/*  IERR    (output) INTEGER */
/*          = 0:  successful exit */
/*                (A regular or singular with consistent equations) */
/*          = 1:  error exit (A singular, AX=B not compatible). */
/*                a message has already been computed. */

/* Author: M. Otter, DLR Oberpfaffenhofen, Feb. 1998. */
/* Modified to reuse factorization: H. Olsson, Dynasim, Feb 1999. */
/* Modified to include variable names: H. Olsson, Dynasim, Sep 2000 */

/* ====================================================================== 
*/





    /* Shortened parameter adjustments */
    --iwork;
 
    /* Function Body */

    *ierr = 0;
/* Inquire machine epsilon */
    if (1) {
	/* eps = dlamch_("E") * 1e3; */
        eps = DBL_EPSILON * 1e7;
		if (fEvent && *fEvent) eps = eps*1e4;
#ifdef DYMOSIM
		{
			extern int Check5(char*key);
			if (!Check5("")) {
				DymosimMessage("");
				*ierr = 1;
				return 0;
			}
		}
#endif /* DYMOSIM */
    }
    dymlqr5_(fact, a, lda, n, b, x0, &eps, &iwork[1], dwork, &
	    iwork[*n + 2], factor,&info,sysnr,varnames,fEvent,intTol);
    if ((info == 1 && *event == 1 && PrintEvent && *PrintEvent & (1<<12)) || info==2) {
		if (info==2)
		dymosimmessagedoubleSev_(1, "LINEAR SYSTEM OF EQUATIONS IS SINGULAR AT TIME = ", time, 49);
		else
	dymosimmessagedoubleSev_(1, "... System of equations is singular at Time = "
		, time, 46);
	DymosimMessageIntSev_(1, "...    Linear system of equations number = ", 
		sysnr, 43);
		if (varnames==0) {
			dymosimmessageSev_(1, "...    Variables X(i) which cannot be uniquely computed:", 56);
			i__1 = *n;
			for (i__ = 1; i__ <= i__1; ++i__) {
				if (iwork[(*n)+1+i__] == 1) {
					DymosimMessageInt_("...     ", &i__, 8);
				}
/* L10: */
			}
		} else {
			dymosimmessageSev_(1, "... Variables which cannot be uniquely computed:", 48);
			i__1 = *n;
			for (i__ = 1; i__ <= i__1; ++i__) {
				if (iwork[(*n)+1+i__] == 1) {
					char str[200];
					int i;
					for(i=0;varnames[i__-1][i]!='\0';i++) {
						str[i]=varnames[i__-1][i];
						if (i>=140) {
							strcpy(str+i,"...");i+=3;
							break;
						}
					}
					strcpy(str+i," = ");i+=3;
					dymosimmessagedoubleSev_(1, str,b+(i__-1),i);
				}
			}
		}
		if (info==1) 
	dymosimmessageSev_(1, "... Simulation continues with minimum norm solution."
		, 52);
		else {
			dymosimmessageSev_(1, "... NOT ACCEPTING SINCE TOO LARGE RESDIUAL", 42);
			*ierr = 1;
		}
	}

    return 0;
} /* dymli4_ */

LIBDS_API int dymli3_(sysnr, fact, a, lda, n, b, time, event, 
	printpriority, dwork, iwork, factor,varnames,ierr)
integer *sysnr, *fact;
doublereal *a;
integer*lda, *n;
doublereal *b, *time;
integer *event, *printpriority;
doublereal *dwork;
integer *iwork, *factor;
const char*const*varnames;
integer *ierr;
{
	return dymli5_(sysnr,fact,a,lda,n,b,0,time,event,printpriority,dwork,iwork,factor,varnames,ierr,0,0);
}
LIBDS_API int dymli4_(sysnr, fact, a, lda, n, b, time, event, 
	printpriority, dwork, iwork, factor,varnames,ierr,fEvent)
integer *sysnr, *fact;
doublereal *a;
integer*lda, *n;
doublereal *b, *time;
integer *event, *printpriority;
doublereal *dwork;
integer *iwork, *factor;
const char*const*varnames;
integer *ierr;
int*fEvent;
{
	return dymli5_(sysnr,fact,a,lda,n,b,0,time,event,printpriority,dwork,iwork,factor,varnames,ierr,fEvent,0);
}
LIBDS_API int dymli2_(sysnr, fact, a, lda, n, b, time, event, 
	printpriority, dwork, iwork, factor,ierr)
integer *sysnr, *fact;
doublereal *a;
integer*lda, *n;
doublereal *b, *time;
integer *event, *printpriority;
doublereal *dwork;
integer *iwork, *factor, *ierr;
{
	return dymli3_(sysnr,fact,a,lda,n,b,time,event,printpriority,dwork,iwork,factor,0,ierr);
}

/* Subroutine */ LIBDS_API int dymlqr_(fact, a, lda, n, b, tol, itype, work, iwork, 
	info)
const integer *fact;
doublereal *a;
integer *lda;
integer *n;
doublereal *b;
const doublereal *tol;
integer *itype;
doublereal *work;
integer *iwork, *info;
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    integer i__, j, k;
    doublereal c1, c2;
    integer n1, n2;
    doublereal s1, s2, t1, t2;
    integer iw, it1, it2, job, rank, ierr;
    doublereal smin, smax;
    integer info2;
    doublereal rcond, anorm;
    integer ismin, ismax;
    doublereal sminpr, smaxpr;


/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/* C      INTEGER            ITYPE( * ), IWORK( * ) */
/* C      DOUBLE PRECISION   A( LDA, * ), B( * ), WORK( * ) */
/*     .. */

/*  Purpose */
/*  ======= */

/*  DYMLQR computes the solution to a real system of linear equations */
/*     A * X = B, */
/*  where A is an N-by-N matrix and X and B are N-by-1 matrices. */

/*  If FACT = 0, the LU decomposition with partial pivoting and row */
/*  interchanges is used to factor A as */
/*     A = P * L * U, */
/*  where P is a permutation matrix, L is unit lower triangular, and U is 
*/
/*  upper triangular.  If A is nonsingular, then the factored form of A */
/*  is used to solve the system of equations A * X = B. */
/*  If FACT = 1 or if A is singular, the QR decomposition with */
/*  column pivoting is used to factor A as */
/*     A*P = Q * R */
/*  where P is a permutation matrix, Q is an orthogonal matrix, and R is 
*/
/*  upper triangular. The rank of A is determined and the compatibility */
/*  of the linear system is checked. If the system is compatible a */
/*  minimum norm solution is computed using the QR decomposition of A. */


/*  Arguments */
/*  ========= */

/*  FACT    (input) INTEGER */
/*          Option to specify the solution method. */
/*          FACT = 0, use the LU-decomposition to solve AX = B or */
/*                    the QR-decomposition if A is singular. */
/*          FACT = 1, use the QR-decomposition to solve AX = B. */

/*  A       (input/output) DOUBLE PRECISION array, dimension (N,N) */
/*          On entry, the N-by-N coefficient matrix A. */
/*          On exit, information on LU or QR decomposition of A. */

/*  LDA     (input) INTEGER */
/*          The declared leading dimension of A. LDA >= 1. */

/*  N       (input) INTEGER */
/*          The number of linear equations, i.e., the order of the */
/*          matrix A.  1 <= N <= LDA. */

/*  B       (input/output) DOUBLE PRECISION array, dimension (N) */
/*          On entry, the N-by-1 matrix of right hand side matrix B. */
/*          On exit, if INFO = 0, the N-by-1 solution matrix X. */

/*  TOL     (input) DOUBLE PRECISION */
/*           Tolerance for system compatibility test. */

/*  ITYPE   (output) INTEGER array, dimension (N) */
/*          Specifies the redundant/nonredundant components of X: */
/*          ITYPE(k) = 0, if the k-th component is nonredundant */
/*          ITYPE(k) = 1, if the k-th component is redundant */

/*  WORK    (output) REAL work array, dimension (LWORK), where */
/*           LWORK = N*N+4*N if FACT = 0 */
/*           LWORK = 4*N     if FACT = 1 */

/*  IWORK   (output) INTEGER work array, dimension (2*N) */

/*  INFO    (output) INTEGER */
/*          = 0:  successful exit (A regular) */
/*          = 1:  successful exit (A singular, AX=B compatible) */
/*          = 2:  error exit (A singular, AX=B not compatible). */


/* Author: A. Varga, M. Otter, DLR Oberpfaffenhofen, Feb. 1998. */

/* ====================================================================== 
*/

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    --iwork;
    --work;
    --itype;
    --b;
    a_dim1 = *lda;
    a_offset = a_dim1 + 1;
    a -= a_offset;

    /* Function Body */
    *info = 0;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	itype[i__] = 0;
/* L10: */
    }
    n1 = *n + 1;
    n2 = (*n << 1) + 1;
    iw = *n * *n + 1;

/*     Compute the LU factorization of A. */

    job = *fact;
    if (job == 0) {

/*         Save A. */

/* CC       CALL DCOPY( N*N, A, 1, WORK, 1 ) */
	k = 0;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *n;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		++k;
		work[k] = a[i__ + j * a_dim1];
/* L11: */
	    }
/* L12: */
	}

/*         Compute the LU factorization of A. */

	dgetrf_(n, n, &work[1], n, &iwork[1], &ierr);

/*         Estimate reciprocal condition number and check for singular
ity. */

	if (ierr == 0) {
	    anorm = dlange_("1", n, n, &work[1], n, &work[iw]);
	    dgecon_("1", n, &work[1], n, &anorm, &rcond, &work[iw], &iwork[n1]
		    , &info2);

/*            real workspace 4*N; integer workspace N */

	    if (rcond <= *tol) {
		ierr = 1;
	    }
	}
	if (ierr == 0) {

/*            Solve the system A*X = B, overwriting B with X. */

	    dgetrs_("No transpose", n, &c__1, &work[1], n, &iwork[1], &b[1], 
		    n, &info2);
	} else {

/*            Singular A, use QR decomposition. */

	    job = 1;
	}
    }

    if (job == 1) {
	*info = 1;

/*        Compute the QR factorization with column pivoting of A: */
/*          A * P = Q * R */

	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    iwork[i__] = 0;
/* L15: */
	}
	dgeqpf_(n, n, &a[a_offset], lda, &iwork[1], &work[1], &work[n1], &
		ierr);

/*        workspace 3*N. Details of Householder rotations stored */
/*        in WORK(1:N). */


/*        B := Q' * B */

	dorm2r_("Left", "Transpose", n, &c__1, n, &a[a_offset], lda, &work[1],
		 &b[1], n, &c1, &info2);

/*        Determine RANK using incremental condition estimation */

	ismin = n1;
	ismax = n2;
	work[ismin] = 1.;
	work[ismax] = 1.;
	smax = (d__1 = a[a_dim1 + 1], Dymola_abs(d__1));
	smin = smax;
	if ((d__1 = a[a_dim1 + 1], Dymola_abs(d__1)) == 0.) {
	    rank = 0;
	} else {
	    rank = 1;
	}

L20:
	if (rank < *n) {
	    i__ = rank + 1;
	    dlaic1_(&c__2, &rank, &work[ismin], &smin, &a[i__ * a_dim1 + 1], &
		    a[i__ + i__ * a_dim1], &sminpr, &s1, &c1);
	    dlaic1_(&c__1, &rank, &work[ismax], &smax, &a[i__ * a_dim1 + 1], &
		    a[i__ + i__ * a_dim1], &smaxpr, &s2, &c2);

	    if (smaxpr * *tol <= sminpr) {
		i__1 = rank;
		for (i__ = 1; i__ <= i__1; ++i__) {
		    work[ismin + i__ - 1] = s1 * work[ismin + i__ - 1];
		    work[ismax + i__ - 1] = s2 * work[ismax + i__ - 1];
/* L30: */
		}
		work[ismin + rank] = c1;
		work[ismax + rank] = c2;
		smin = sminpr;
		smax = smaxpr;
		++rank;
		goto L20;
	    }
	}

/*        Check compatibility of the system */

	if (rank >= *n) {
	    *info = 0;
	}
	i__1 = *n;
	for (i__ = rank + 1; i__ <= i__1; ++i__) {
	    if ((d__1 = b[i__], Dymola_abs(d__1)) > *tol) {
		*info = 2;
		return 0;
	    }
	    itype[i__] = 1;
	    b[i__] = 0.;
/* L40: */
	}
	if (rank == 0) {
	    return 0;
	}

/*        Logically partition R = [ R11 R12 ] */
/*                                [  0  R22 ] */
/*        where R11 = R(1:RANK,1:RANK) */

/*        [R11,R12] = [ T11, 0 ] * Y */
	if (rank < *n) {
	    dtzrqf_(&rank, n, &a[a_offset], lda, &work[n1], &ierr);
	}

/*        Details of Householder rotations stored in WORK(N1:2*N) */

/*        B(1:RANK) := inv(T11) * B(1:RANK) */

	dtrsm_("Left", "Upper", "No transpose", "Non-unit", &rank, &c__1, &
		c_b263, &a[a_offset], lda, &b[1], n);

/*        B := Y' * B */

	if (rank < *n) {
	    i__1 = rank;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		i__2 = *n - rank + 1;
		dlatzm_("Left", &i__2, &c__1, &a[i__ + (rank + 1) * a_dim1], 
			n, &work[*n + i__], &b[i__], &b[rank + 1], n, &c1)
			;
/* L50: */
	    }
	}

/*        B := P * B */

	--n2;
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    work[(*n << 1) + i__] = 1.;
/* L60: */
	}
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (work[n2 + i__] == 1.) {
		if (iwork[i__] != i__) {
		    k = i__;
		    t1 = b[k];
		    t2 = b[iwork[k]];
		    it1 = itype[k];
		    it2 = itype[iwork[k]];
L70:
		    b[iwork[k]] = t1;
		    itype[iwork[k]] = it1;
		    work[n2 + k] = 0.;
		    t1 = t2;
		    it1 = it2;
		    k = iwork[k];
		    t2 = b[iwork[k]];
		    it2 = itype[iwork[k]];
		    if (iwork[k] != i__) {
			goto L70;
		    }
		    b[i__] = t1;
		    itype[i__] = it1;
		    work[n2 + k] = 0.;
		}
	    }
/* L80: */
	}
    }
    return 0;

/*     End of DYMLQR */

} /* dymlqr_ */

/* Subroutine */ LIBDS_API int dymlqr5_(fact, a, lda, n, b, x0, tol, ipivot, work, iwork, factor,
	info,sysnr,varnames,fEvent,intTol)
integer *fact;
doublereal *a;
integer*lda, *n;
doublereal *b, *tol;
const doublereal * x0;
integer *ipivot;
doublereal *work;
integer *iwork, *factor, *info;
integer *sysnr;
const char*const*varnames;
integer *fEvent;
doublereal *intTol;
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    integer i__, j, k;
    doublereal c1, c2;
    integer n1, n2;
	integer workTau,workTau2,workWork,workB;
    doublereal s1, s2, t1, t2;
    integer iw, it1, it2, factjob, eqjob, rank, ierr;
    doublereal smin, smax;
    integer info2;
    doublereal rcond, anorm;
    integer ismin, ismax;
    integer iscale,iequilib;
    doublereal eqrow,eqcol,eqmax;
	integer rank_def;
	integer rank_max;
    char equed;
    doublereal sminpr, smaxpr;


/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/* C      INTEGER            ITYPE( * ), IWORK( * ) */
/* C      DOUBLE PRECISION   A( LDA, * ), B( * ), WORK( * ) */
/*     .. */

/*  Purpose */
/*  ======= */

/*  DYMLQR computes the solution to a real system of linear equations */
/*     A * X = B, */
/*  where A is an N-by-N matrix and X and B are N-by-1 matrices. */

/*  If FACT = 0, the LU decomposition with partial pivoting and row */
/*  interchanges is used to factor A as */
/*     A = P * L * U, */
/*  where P is a permutation matrix, L is unit lower triangular, and U is 
*/
/*  upper triangular.  If A is nonsingular, then the factored form of A */
/*  is used to solve the system of equations A * X = B. */
/*  If FACT = 1 or if A is singular, the QR decomposition with */
/*  column pivoting is used to factor A as */
/*     A*P = Q * R */
/*  where P is a permutation matrix, Q is an orthogonal matrix, and R is 
*/
/*  upper triangular. The rank of A is determined and the compatibility */
/*  of the linear system is checked. If the system is compatible a */
/*  minimum norm solution is computed using the QR decomposition of A. */


/*  Arguments */
/*  ========= */

/*  FACT    (input) INTEGER */
/*          Option to specify the solution method. (See also Factor). */
/*          FACT&1 = 0, use the LU-decomposition to solve AX = B or */
/*                    the QR-decomposition if A is singular. */
/*          FACT&1 = 1, use the QR-decomposition to solve AX = B. */
/*          FACT&2 = 2, automatic row and column scaling */

/*  A       (input) DOUBLE PRECISION array, dimension (N,N) */
/*          On entry, the N-by-N coefficient matrix A. */

/*  LDA     (input) INTEGER */
/*          The declared leading dimension of A. LDA >= 1. */

/*  N       (input) INTEGER */
/*          The number of linear equations, i.e., the order of the */
/*          matrix A.  1 <= N <= LDA. */

/*  B       (input/output) DOUBLE PRECISION array, dimension (N) */
/*          On entry, the N-by-1 matrix of right hand side matrix B. */
/*          On exit, if INFO = 0, the N-by-1 solution matrix X. */

/*  TOL     (input) DOUBLE PRECISION */
/*           Tolerance for system compatibility test. */

/*  IPIVOT  (input/output) INTEGER array, dimension (N+1) */
/*          Pivot information for LU and QR. The last elements */
/*          is the rank for the QR-factorization */

/*  WORK    (input/output) REAL work array, dimension (LWORK), where */
/*           LWORK = N*N+6*N */

/*  IWORK   (output) INTEGER work array, dimension (N) */
/*          Specifies the redundant/nonredundant components of X: */
/*          ITYPE(k) = 0, if the k-th component is nonredundant */
/*          ITYPE(k) = 1, if the k-th component is redundant */

/*  FACTOR  (input) INTEGER */
/*    Factor&3     = 0: Factorize matrix
                  = 1: Use existing LU-decomposition
                  = 2: Use existing QR-decomposition
     Factor&256   =256: Use row-equlibrization
           &512   =512: Use column-equilibrization
             Updated after each call.
             The LU-factorization is stored in the first N*N elements 
             of WORK and the first N elements of IPIVOT
             The QR-factorization is stored in the first N*N+2*N elements
             of WORK and and IPIVOT.
	     The equilib information is stored in the 2*N last elements
	     of LWORK */


/*  INFO    (output) INTEGER */
/*          = 0:  successful exit (A regular) */
/*          = 1:  successful exit (A singular, AX=B compatible) */
/*          = 2:  error exit (A singular, AX=B not compatible). */


/* Author: A. Varga, M. Otter, DLR Oberpfaffenhofen, Feb. 1998. */
/* Modified to reuse factorization: H. Olsson, Dynasim, Feb. 1999. */
/* Modified to use row/column equilibrization: H. Olsson, Dynasim, July 1999 */
/* Modified to not modify A: H. Olsson, Dynasim, Jan. 2000*/

/* ====================================================================== 
*/

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Executable Statements .. */

    /* Parameter adjustments */
    --iwork;
    --work;
    --ipivot;
    --b;
    a_dim1 = *lda;
    a_offset = a_dim1 + 1;
    a -= a_offset;


    /* Function Body */
	rank_max = 0;
 L15:
	*info = 0;
    n1 = *n + 1;
    n2 = (*n << 1) + 1;
	workTau = *n * *n +1;
	workTau2 = workTau + *n;
	workWork = workTau2 + *n;
	workB= workWork+*n;
    iw = *n * *n + 1;

    iscale = iw + 4* *n;
/*     Compute the LU factorization of A. */

    factjob = *fact &1;
    eqjob = *fact &2;

	for(i__=1;i__<=*n;++i__) {
		volatile double v=b[i__];
		if (v!=v || v>=DBL_MAX || v<=-DBL_MAX) {
			char str[100];
			sprintfC(str,"Rhs component %d of system %d is %e",i__,*sysnr,v);
			DymosimMessage(str);
		}
	}
				
	if ((*factor & 3) == 0) {

/*         Save A and then use copy */

/* CC       CALL DCOPY( N*N, A, 1, WORK, 1 ) */
        k = 0;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
          i__2 = *n;
          for (i__ = 1; i__ <= i__2; ++i__) {
            ++k;
            work[k] = a[i__ + j * a_dim1];
/* L11: */
	    
          }
/* L12: */
        }
      
	/* Determine row and column scaling for equilibrization */
      iequilib=0;
      ierr=0;
      if (eqjob) {dgeequ_(n, n, &a[a_offset], lda, &work[iscale], &work[iscale+*n], 
	      &eqrow, &eqcol, &eqmax, &ierr);}
      if (eqjob && ierr==0) {
	      /* equilib the matrix */
		dlaqge_(n, n, &work[1], n, &work[iscale], &work[iscale+*n], 
			&eqrow, &eqcol, &eqmax, &equed);

		iequilib=(equed=='B')? 512|256 : (equed=='C')? 512 : (equed=='R') ? 256 :0;
      }
      if (factjob == 0 && ierr==0) { /* No need to try LU-factorization if equilibrization failed */
		  ierr=0;


/*         Compute the LU factorization of A. */
	
	   dgetrf_(n, n, &work[1], n, &ipivot[1], &ierr);

/*         Estimate reciprocal condition number and check for singular
ity. */


        if (ierr == 0) {
          anorm = dlange_("1", n, n, &work[1], n, &work[iw]);
          dgecon_("1", n, &work[1], n, &anorm, &rcond, &work[iw], &iwork[1]
                  , &info2);

/*            real workspace 4*N; integer workspace N */
/* tau-vectors are not yet used and can thus be used as work-space*/

          if (rcond <= *tol) {
            ierr = 1;
	  }
        }
        if (ierr == 0) {
          *factor=1 | iequilib;
        } else {

		/*DymosimMessageInt_("Size of equation system: ",n,24);*/
/*            Singular A, use QR decomposition. */
          factjob =1;
        }
      }
      if (factjob == 1) {
		  /* Restore work to equilibrated A */
		  if (ierr != 0) {
			  /* LU-factorization failed: have to restore*/
			  k = 0;
			  i__1 = *n;
			  for (j = 1; j <= i__1; ++j) {
				  i__2 = *n;
				  for (i__ = 1; i__ <= i__2; ++i__) {
					  ++k;
					  work[k]=a[i__ + j * a_dim1];
					  /* L11: */
					  
				  }
				  /* L12: */
			  }
			  if (iequilib) /* Equilibrate once more: should give same results */
				  dlaqge_(n, n, &work[1], n, &work[iscale], &work[iscale+*n], 
				  &eqrow, &eqcol, &eqmax, &equed);
		  }
		  ierr = 0;

/*        Compute the QR factorization with column pivoting of A: */
/*          A * P = Q * R */
        
        i__1 = *n;
        for (i__ = 1; i__ <= i__1; ++i__) {
          ipivot[i__] = 0;
/* L15: */
	}
	dgeqpf_(n, n, &work[1], n, &ipivot[1], &work[workTau], &work[workTau2], &
		ierr);

/*        workspace 3*N (second tau is not yet used).
	         Details of Householder rotations stored */
/*        in WORK(1:N). */

 

/*        Determine RANK using incremental condition estimation */
/* Uses work(2*n+1:3*n) and work(3*n+1:4*n) as work area */
/* And R-part of QR-factorization */

	ismin = workWork;
	ismax = workWork+*n;
	work[ismin] = 1.;
	work[ismax] = 1.;
	smax = (d__1 = work[1], Dymola_abs(d__1));
	smin = smax;
	if (rank_max>0) {rank=rank_max;goto L25;}
	if ((d__1 = work[1], Dymola_abs(d__1)) == 0.) {
	    rank = 0;
	} else {
	    rank = 1;
	}
	rank_max = rank;

L20:
	if (rank_max < *n) {
	    i__ = rank_max + 1;
	    dlaic1_(&c__2, &rank_max, &work[ismin], &smin, &work[(i__-1) * *n + 1], 
		    &work[(i__-1) * *n + i__], &sminpr, &s1, &c1);
	    dlaic1_(&c__1, &rank_max, &work[ismax], &smax, &work[(i__-1) * *n + 1], 
		    &work[(i__-1) * *n + i__], &smaxpr, &s2, &c2);

		/* Hard lower limit for the residual */
		/* This could be decreased even further */
	    if (smaxpr * DBL_EPSILON <= sminpr) {
			if (smaxpr * *tol <=sminpr && rank_max==rank) {
				++rank;
			}
		i__1 = rank_max;
		for (i__ = 1; i__ <= i__1; ++i__) {
		    work[ismin + i__ - 1] = s1 * work[ismin + i__ - 1];
		    work[ismax + i__ - 1] = s2 * work[ismax + i__ - 1];
/* L30: */
		}
		work[ismin + rank_max] = c1;
		work[ismax + rank_max] = c2;
		smin = sminpr;
		smax = smaxpr;
		++rank_max;
		goto L20;
	    }
	}


/*        Logically partition R = [ R11 R12 ] */
/*                                [  0  R22 ] */
/*        where R11 = R(1:RANK,1:RANK) */

/*        [R11,R12] = [ T11, 0 ] * Y */
	/* After estimating rank*/
L25:
	if (rank < *n) {
	    dtzrqf_(&rank, n, &work[1], n, &work[workTau2], &ierr);
	}
        *factor=2 | iequilib;

        ipivot[(*n)+1]=rank;
/* L80: */
      }
    }
    iequilib = *factor;
	/* Remember b */
    rank=ipivot[(*n)+1];
	rank_def=((*factor&3)==2 && rank<*n);
	if (rank_def) {
		for( i__1 = 1; i__1 <= *n; ++i__1) work[workB+i__1-1]=b[i__1];
		if (x0) {
			c1=-1;
			c2=1;
			i__=1;
			dgemv_("N",n,n,&c1,&a[a_offset],lda,(doublereal*)(x0),&i__,&c2,&b[1],&i__);
		}
	}
    if (iequilib&256) {
	    /* Apply row scaling */
	    for( i__1 = 1; i__1 <= *n; ++i__1) b[i__1] *= work[i__1-1+iscale];
    }
    if ((*factor & 3)==1) {
/*            Solve the system A*X = B, overwriting B with X. */

	    dgetrs_("No transpose", n, &c__1, &work[1], n, &ipivot[1], &b[1], 
		    n, &info2);

    } else if ((*factor & 3)==2) {        
      *info = 1;
      i__1 = *n;


        for (i__ = 1; i__ <= i__1; ++i__) {
          iwork[i__] = 0;
      }

     /*        B := Q' * B */

	dorm2r_("Left", "Transpose", n, &c__1, n, &work[1], n, &work[workTau],
		 &b[1], n, &c1, &info2);
        rank=ipivot[(*n)+1];

 
/*        Check compatibility of the system */

	if (rank >= *n) {
	    *info = 0;
	}
        i__1 = *n;
	for (i__ = rank + 1; i__ <= i__1; ++i__) {
	    if ((d__1 = b[i__], Dymola_abs(d__1)) > *tol) {
		/**info = 2; Removed by Hans Olsson, Dynasim 2000-03-24.*/
	    /* Instead we test the residual for sufficiently small numbers*/
		/* return 0; */
	    }
	    iwork[i__] = 1;
	    b[i__] = 0.;
/* L40: */
	}
	if (rank == 0) {
	    return 0; /* No need to scale if everything is zero */
	}
 

/*        Details of Householder rotations stored in WORK(work) */

/*        B(1:RANK) := inv(T11) * B(1:RANK) */

	dtrsm_("Left", "Upper", "No transpose", "Non-unit", &rank, &c__1, &
		c_b263, &work[1], n, &b[1], n);

/*        B := Y' * B */

	if (rank < *n) {
	    i__1 = rank;
	    for (i__ = 1; i__ <= i__1; ++i__) {
		i__2 = *n - rank + 1;
		dlatzm_("Left", &i__2, &c__1, &work[i__ + (rank + 1-1) * *n], 
			n, &work[workTau2+ i__-1], &b[i__], &b[rank + 1], n, &c1)
			;
/* L50: */
	    }
	}

/*        B := P * B */

	--n2;
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    work[workWork + i__-1] = 1.;
/* L60: */
	}
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (work[workWork + i__-1] == 1.) {
		if (ipivot[i__] != i__) {
		    k = i__;
		    t1 = b[k];
		    t2 = b[ipivot[k]];
		    it1 = iwork[k];
		    it2 = iwork[ipivot[k]];
L70:
		    b[ipivot[k]] = t1;
		    iwork[ipivot[k]] = it1;
		    work[workWork + k-1] = 0.;
		    t1 = t2;
		    it1 = it2;
		    k = ipivot[k];
		    t2 = b[ipivot[k]];
		    it2 = iwork[ipivot[k]];
		    if (ipivot[k] != i__) {
			goto L70;
		    }
		    b[i__] = t1;
		    iwork[i__] = it1;
		    work[workWork + k-1] = 0.;
		}
	    }
        }
    }
    if (iequilib&512) {
	    /* Apply column scaling */
	    for( i__1 = 1; i__1 <= *n; ++i__1) b[i__1] *= work[i__1-1+iscale+*n];
    }
	if (rank_def) {
		double res_tol = *tol;
		if (intTol && *intTol >= 0.0) {
			/* Only during continuous simulation, at events sharp tolerance needed. */
			const double safety_coeff = 0.001; /* Very conservative, could probably be larger. */
			double x0_norm = 0.0, b_norm = 0.0;
			for (i__ = 1; i__ <= *n; ++i__) {
				x0_norm += Dymola_abs(x0[i__-1]);
				b_norm += Dymola_abs(work[workB+i__-1]);
			}
			/* Need small tolerance if residual scale smaller than error scale. */
			res_tol = Dymola_min(1.0, b_norm / (*tol + x0_norm)) * (*intTol) * safety_coeff;
			res_tol = Dymola_max(res_tol, *tol);
		}
		c1 = -1;
		c2 = 1;
		i__ = 1;
		dcopy_(n, &work[workB], &i__, &work[workWork], &i__);
		if (x0) dgemv_("N",n,n,&c1,&a[a_offset],lda,(doublereal*)(x0),&i__,&c2,&work[workWork],&i__);
		dgemv_("N",n,n,&c1,&a[a_offset],lda,&b[1],&i__,&c2,&work[workWork],&i__);
		for(i__=1;i__<=*n;++i__) if (c1=work[workWork+i__-1],Dymola_abs(c1)>res_tol) {
			if (rank<rank_max) {
				/* Try to increase rank, restore, and re-test */
				/* This should be done in a more optimal way, but assume it does not happen so often */
				for( i__1 = 1; i__1 <= *n; ++i__1) b[i__1]=work[workB+i__1-1];
				*factor =0; /* Will refactor */
				goto L15;
			} else {
			char str[100];
			sprintfC(str,"Residual component %d of system %d is %e",i__,*sysnr,c1);
			DymosimMessage(str);
			if (!(fEvent && fEvent[2])) *info=2;
			}
		}
		if (x0) for(i__=1;i__<=*n;++i__) b[i__]+=x0[i__-1];
	} else if (1) {
		for(i__=1;i__<=*n;++i__) {
		    volatile double v=b[i__];
			if (v!=v || v>=DBL_MAX || v<=-DBL_MAX) {
				char str[200];
				if (varnames) {
					const char*extra="";
					if (strlen(varnames[i__-1])>140) extra="...";
					sprintfC(str,"In system %d %.140s%s = %e",*sysnr,varnames[i__-1],extra,v);
				} else
					sprintfC(str,"Solution component %d of system %d is %e",i__,*sysnr,v);
				DymosimMessage(str);
				if (!(fEvent && fEvent[2])) *info=2;
			}
		}
	}
    return 0;

/*     End of DYMLQR2 */

} /* dymlqr2_ */
/* Subroutine */ LIBDS_API int dymmdp_(void)
{


/* Set machine dependent constants in common /DYMCB/: */
/*     EPSMCH    machine precision */
/*               (may be determined by function EPSLON from EISPACK) */
/*     GIANT     largest magnitude */

/* Libraries used: */
/*  EISPACK:  epslon */




    
    return 0;

} /* dymmdp_ */


/* inJacobian_ = 0 during normal simulation, 
   inJacobian_ = 1 (or any non-zero value) during computation of Jacobian for ODE-solver*/


/* dymnl_WithNominal */
/* The function call before computing the Jacobian must be at f(x) and Jacobians at f(x+dx) */

/* -----------------------------------------------------------------------
 */
/*            INFO =  0  Improper input parameters (wrong initialization) 
*/
/*            INFO =  1  Algorithm estimates that the relative error */
/*                       between X and the solution is at most TOL */
/*                       (regular end). */
/*            INFO =  2  Number of calls to FCN has reached or exceeded */
/*                       100*(N+1) for IOPT=1 or 200*(N+1) for IOPT=2. */
/*            INFO =  3  TOL is too small.  No further improvement in the 
*/
/*                       approximate solution X is possible. */
/*            INFO =  4  Iteration is not making good progress. */
/*         ENDIF */
/* DUM   : OUT, DOUBLE( (N**2+13*N)/2 ) */
/*         work array of length LDUM = 20 + (N**2+13*N)/2+ldfjac2 */

/* LDUM  : IN, INTEGER */
/*         Provided length of the work array DUM. */
/*         LDUM must not be less than 20 + (N**2+13*N)/2+ldfjac2. */

/* IDUM  : IN, INTEGER */
/*         work array of length 20. */

/* Nominal: IN, DOUBLE */
/*         Used for determining suitable scaling of x.*/

/* Method: */
/* DYMNL is a modification of the Powell Hybrid method.  Two of */
/* its main characteristics involve the choice of the correction as */
/* a convex combination of the Newton and scaled gradient directions, */
/* and the updating of the Jacobian by the rank-1 method of Broyden. */
/* The choice of the correction guarantees (under reasonable conditions) 
*/
/* global convergence for starting points far from the solution and a */
/* fast rate of convergence. The Jacobian is calculated at the starting */
/* point by either the user-supplied code or a forward-difference */
/* approximation, but it is not recalculated until the rank-1 method */
/* fails to produce satisfactory progress. */

/* The time required by DYMNL to solve a given problem depends on N, */
/* the behavior of the functions, the accuracy requested, and the */
/* starting point. The number of arithmetic operations needed by DYMNL */
/* is about 11.5*(N**2) to process each evaluation of the functions and */
/* 1.3*(N**3) to process each evaluation of the Jacobian (if IOPT = 1). */

/* This code is the combination of the MINPACK codes (Argonne) HYBRD1 and 
*/
/* HYBRJ1. */

/* References: */
/*   Gramlich, G., Ein nichtlinearer Gleichungssytemloeser mit "reverse- 
*/
/*      communication". DLR TR ER59-91, 1991 */
/*   Powell, M., A Hybrid Method for Nonlinear Equations. */
/*      Numerical Methods for Nonlinear Algebraic Equations, */
/*      P. Rabinowitz, Editor, Gordon and Breach, 1970 */

/* Life cycle: */
/* 1980 MAR  Burton S. Garbow, Kenneth E. Hillstrom, Jorge J. More, */
/*           Argonne National Laboratory. Minpack Project. */
/* 1991 OKT  G. Gramlich, DLR FF-DF: reverse communication interface */
/* 1993 SEP  D. Joos, DLR FF-DR    : iopt=3 introduced */
/* 1997 AUG  M. Otter, DLR FF-DR   : termination criteria improved, */
/*                                   multiple usage at the same time */
/*                                   (internal state is stored in */
/*                                   work arrays). */
/* 2002 FEB H. Olsson, Dynasim. Revised to have nominal value */

DYMOLA_STATIC void dymnl_WithNominal2(integer*infrev, integer iopt, integer n,doublereal*x,
					   doublereal*fvec,doublereal*fjac, doublereal*fjac2, doublereal*qres2,integer ldfjac2, doublereal tol,doublereal toldesired,
					   integer*info,doublereal*dum,integer ldum,integer*idum,
					   doublereal const*nominalx,const char*const*varnames,
					   integer*ipivots,int printEvent,int inJacobian, int preciseTol) {
    /* Initialized data */

    static const doublereal factor = 100.;
    static const doublereal one = 1.;
    static const doublereal zero = 0.;

    /* Local variables */
    integer j, ml, lr, mu, ibeg, nfev, njev;
    doublereal xtol, xtoldesired;
    integer jopt1, jopt2;
    integer ldfjac, maxfev;
	integer extra;

/* -----------------------------------------------------------------------
 */
/*            INFO =  0  Improper input parameters (wrong initialization) 
*/
/*            INFO =  1  Algorithm estimates that the relative error */
/*                       between X and the solution is at most TOL */
/*                       (regular end). */
/*            INFO =  2  Number of calls to FCN has reached or exceeded */
/*                       100*(N+1) for IOPT=1 or 200*(N+1) for IOPT=2. */
/*            INFO =  3  TOL is too small.  No further improvement in the 
*/
/*                       approximate solution X is possible. */
/*            INFO =  4  Iteration is not making good progress. */
/*         ENDIF */
/* DUM   : OUT, DOUBLE( (N**2+15*N)/2 ) */
/*         work array of length LDUM = 20 + (N**2+15*N)/2 */

/* LDUM  : IN, INTEGER */
/*         Provided length of the work array DUM. */
/*         LDUM must not be less than 20 + (N**2+15*N)/2+ldfjac2. */

/* IDUM  : IN, INTEGER */
/*         work array of length 20. */

/* Method: */
/* DYMNL is a modification of the Powell Hybrid method.  Two of */
/* its main characteristics involve the choice of the correction as */
/* a convex combination of the Newton and scaled gradient directions, */
/* and the updating of the Jacobian by the rank-1 method of Broyden. */
/* The choice of the correction guarantees (under reasonable conditions) 
*/
/* global convergence for starting points far from the solution and a */
/* fast rate of convergence. The Jacobian is calculated at the starting */
/* point by either the user-supplied code or a forward-difference */
/* approximation, but it is not recalculated until the rank-1 method */
/* fails to produce satisfactory progress. */

/* The time required by DYMNL to solve a given problem depends on N, */
/* the behavior of the functions, the accuracy requested, and the */
/* starting point. The number of arithmetic operations needed by DYMNL */
/* is about 11.5*(N**2) to process each evaluation of the functions and */
/* 1.3*(N**3) to process each evaluation of the Jacobian (if IOPT = 1). */

/* This code is the combination of the MINPACK codes (Argonne) HYBRD1 and 
*/
/* HYBRJ1. */

/* References: */
/*   Gramlich, G., Ein nichtlinearer Gleichungssytemloeser mit "reverse- 
*/
/*      communication". DLR TR ER59-91, 1991 */
/*   Powell, M., A Hybrid Method for Nonlinear Equations. */
/*      Numerical Methods for Nonlinear Algebraic Equations, */
/*      P. Rabinowitz, Editor, Gordon and Breach, 1970 */

/* Life cycle: */
/* 1980 MAR  Burton S. Garbow, Kenneth E. Hillstrom, Jorge J. More, */
/*           Argonne National Laboratory. Minpack Project. */
/* 1991 OKT  G. Gramlich, DLR FF-DF: reverse communication interface */
/* 1993 SEP  D. Joos, DLR FF-DR    : iopt=3 introduced */
/* 1997 AUG  M. Otter, DLR FF-DR   : termination criteria improved, */
/*                                   multiple usage at the same time */
/*                                   (internal state is stored in */
/*                                   work arrays). */

/* Libraries required: */
/* BLAS1:    DNRM2 */

/* Common Blocks: */
/* The subroutines DYMNL* need common /DYMCB/ for the values of */
/*  the machine precision EPSMCH and largest magnitude GIANT. */

/* Example: */

/* The problem is to determine the values of X(1) and X(2), */
/* which solve the nonlinear system of equations */

/*             X(1)*X(2) - X(2)**3 - 1 = 0 */
/*             X(1)**2*X(2) + X(2) - 5 = 0 */

/* ********** */

/*       PROGRAM TEST */
/* C */
/* C     DRIVER FOR DYMNL EXAMPLE. */
/* C */
/*       INTEGER J,N,INFREV,IOPT,INFO,LDUM,IDUM(20) */
/*       PARAMETER (N=2,LDUM=35) */
/*       DOUBLE PRECISION TOL */
/*       DOUBLE PRECISION X(N),FVEC(N),DUM(LDUM),FJAC(N,N) */
/* C */
/*       DOUBLE PRECISION DNRM2, FNORM */
/* C */
/* C     Initialize machine dependent constants */
/*       CALL DYMMDP */
/* C */
/*       IOPT = 1 */
/*       INFREV=-1 */
/*       X(1)=1.D0 */
/*       X(2)=1.D0 */
/* C */
/* C     SET TOL TO ZERO, HENCE THE SQUARE ROOT OF THE MACHINE PRECISION 
*/
/* C     IS ASSUMED INTERNALY. */
/* C */
/*       TOL = 0.D0 */
/* C */
/* 10    CONTINUE */
/*       IF(INFREV .GE. 1 ) THEN */
/*          FVEC(1)=X(1)*X(2)-X(2)**3-1.D0 */
/*          FVEC(2)=X(1)**2*X(2)+X(2)-5.D0 */
/*       END IF */
/*       IF(INFREV .EQ. 2 ) THEN */
/*          FJAC(1,1)=X(2) */
/*          FJAC(1,2)=X(1)-3.*X(2)**2 */
/*          FJAC(2,1)=2.*X(1)*X(2) */
/*          FJAC(2,2)=X(1)**2+1.D0 */
/*       END IF */
/*      CALL DYMNL(INFREV,IOPT,N,X,FVEC,FJAC,TOL,INFO,DUM,LDUM,IDUM,0.0D0)
*/
/*       IF (INFREV .GE. 1) GO TO 10 */
/*       FNORM = DNRM2(N,FVEC,1) */
/*       WRITE (6,1000) FNORM,INFO,(X(J),J=1,N) */
/*  1000 FORMAT (5X,' FINAL L2 NORM OF THE RESIDUALS',E15.7 // */
/*      *        5X,' INFO PARAMETER',16X,I10 // */
/*      *        5X,' FINAL APPROXIMATE SOLUTION' // (5X,3E15.7)) */
/*       STOP */
/*       END */

/* ************ */

/*      FINAL L2 NORM OF THE RESIDUALS  0.1434642E-10 */

/*      INFO PARAMETER                         1 */

/*      FINAL APPROXIMATE SOLUTION */

/*      0.2000000E+01  0.1000000E+01 */

/* ************ */

/* Results obtained with different compilers or machines may be slightly 
*/
/* different. */
/* -----------------------------------------------------------------------
 */




/*     .. executable statements .. */
    /* Parameter adjustments */
    --fvec;
    --x;
    --fjac;
    --dum;
    --idum;

	if (!infrev || !info) return; /* Null-pointer check */
	if (ldum<20 + (n*n+15*n)/2) {*info=-1; return;}
    /* Function Body */

/* ***first executable statement  dymnl */
    ibeg = 20;
    if (*infrev < 1 && !(*infrev<=-20 && *infrev>=-40)) {
		/*        ... initial call */
		if (nominalx==0) {
			for (j = 1; j <= n; ++j) {
				dum[ibeg + j] = one;
			}
		} else {
			for(j = 1; j  <= n; ++j) {
				dum[ibeg + j] = nominalx[j-1];
			}
		}
    }


	if (iopt == 1) {
		jopt1 = 1;
		jopt2 = 0;
	} else if (iopt == 2) {
		jopt1 = 2;
		jopt2 = 0;
	} else if (iopt == 3) {
		jopt1 = 2;
		jopt2 = 1;
	} else {
		*info = 0;
		goto L30;
	}

    maxfev = (n + 1) * 100;
    if (iopt == 2) {
		maxfev *= 2;
    }
	{
		double sqrtn=sqrt(n);
		xtol = tol*sqrtn;
		if (xtol <= zero) {
			xtol = sqrt(DBL_EPSILON);
		}
		xtoldesired = toldesired*sqrtn;
		if (xtoldesired > xtol)
			xtoldesired=xtol;
		if (preciseTol)
			xtol = xtoldesired;
	}
    ml = n - 1;
    mu = n - 1;
    lr = n * (n + 1) / 2;
    ldfjac = n;
	extra = ldfjac2;
    dymnl1_Fast(infrev, jopt1, n, &x[1], &fvec[1], &fjac[1], ldfjac, fjac2, qres2, ldfjac2, xtol, xtoldesired,
		maxfev, ml, mu, nominalx, &dum[ibeg + 1], &dum[ibeg+n*6+1 + extra],factor, info, &
	    nfev, &njev, &dum[ibeg + n * 7 + 1 + extra], lr, &dum[ibeg + n + 1], &
	    dum[ibeg + n * 2+ 1], &dum[ibeg + n * 3 + 1+extra], &dum[ibeg + 
	    n * 4 + 1 + extra], &dum[ibeg + n * 5 + 1 + extra], jopt2, &dum[1], &idum[1],varnames,ipivots,printEvent,inJacobian);
    if (*info == 5) {
		*info = 4;
    }
L30:
    return ;
}
DYMOLA_STATIC void dymnl_WithNominal(integer*infrev, integer iopt, integer n,doublereal*x,
					   doublereal*fvec,doublereal*fjac,doublereal tol,doublereal toldesired,
					   integer*info,doublereal*dum,integer ldum,integer*idum,
					   doublereal const*nominalx) {
	dymnl_WithNominal2(infrev, iopt, n,x,
					   fvec,fjac,0,0,0,tol,toldesired,
					   info,dum,ldum,idum,
					   nominalx,0,0,0,0,0);
}

/* Subroutine */ DYMOLA_STATIC int dymnl_(infrev, iopt, n, x, fvec, fjac, tol, toldesired, info, dum, 
	ldum, idum, epsfcn)
integer *infrev, *iopt;
const integer *n;
doublereal *x, *fvec, *fjac;
const doublereal *tol, *toldesired;
integer *info;
doublereal *dum;
integer*ldum, *idum;
const doublereal *epsfcn;
{
	dymnl_WithNominal2(infrev,*iopt,*n,x,fvec,fjac,0,0,0,*tol,*toldesired,info,dum,*ldum,idum,
		(const doublereal*)(0),(const char*const*)(0),(integer*)(0),0,0,0);
	return 0;

/* -----------------------------------------------------------------------
 */
/*            INFO =  0  Improper input parameters (wrong initialization) 
*/
/*            INFO =  1  Algorithm estimates that the relative error */
/*                       between X and the solution is at most TOL */
/*                       (regular end). */
/*            INFO =  2  Number of calls to FCN has reached or exceeded */
/*                       100*(N+1) for IOPT=1 or 200*(N+1) for IOPT=2. */
/*            INFO =  3  TOL is too small.  No further improvement in the 
*/
/*                       approximate solution X is possible. */
/*            INFO =  4  Iteration is not making good progress. */
/*         ENDIF */
/* DUM   : OUT, DOUBLE( (N**2+13*N)/2 ) */
/*         work array of length LDUM = 20 + (N**2+13*N)/2 */

/* LDUM  : IN, INTEGER */
/*         Provided length of the work array DUM. */
/*         LDUM must not be less than 20 + (N**2+13*N)/2. */

/* IDUM  : IN, INTEGER */
/*         work array of length 20. */

/* EPSFCN: IN, DOUBLE */
/*         Used in determining a suitable step for the forward-difference 
*/
/*         approximation. This approximation assumes that the relative */
/*         errors in the functions are of the order of epsfcn. If epsfcn 
*/
/*         is less than the machine precision, it is assumed that the */
/*         relative errors in the functions are of the order of the */
/*         machine precision. If iopt=1, then epsfcn can be ignored */
/*         (treat it as a dummy argument). */

/* Method: */
/* DYMNL is a modification of the Powell Hybrid method.  Two of */
/* its main characteristics involve the choice of the correction as */
/* a convex combination of the Newton and scaled gradient directions, */
/* and the updating of the Jacobian by the rank-1 method of Broyden. */
/* The choice of the correction guarantees (under reasonable conditions) 
*/
/* global convergence for starting points far from the solution and a */
/* fast rate of convergence. The Jacobian is calculated at the starting */
/* point by either the user-supplied code or a forward-difference */
/* approximation, but it is not recalculated until the rank-1 method */
/* fails to produce satisfactory progress. */

/* The time required by DYMNL to solve a given problem depends on N, */
/* the behavior of the functions, the accuracy requested, and the */
/* starting point. The number of arithmetic operations needed by DYMNL */
/* is about 11.5*(N**2) to process each evaluation of the functions and */
/* 1.3*(N**3) to process each evaluation of the Jacobian (if IOPT = 1). */

/* This code is the combination of the MINPACK codes (Argonne) HYBRD1 and 
*/
/* HYBRJ1. */

/* References: */
/*   Gramlich, G., Ein nichtlinearer Gleichungssytemloeser mit "reverse- 
*/
/*      communication". DLR TR ER59-91, 1991 */
/*   Powell, M., A Hybrid Method for Nonlinear Equations. */
/*      Numerical Methods for Nonlinear Algebraic Equations, */
/*      P. Rabinowitz, Editor, Gordon and Breach, 1970 */

/* Life cycle: */
/* 1980 MAR  Burton S. Garbow, Kenneth E. Hillstrom, Jorge J. More, */
/*           Argonne National Laboratory. Minpack Project. */
/* 1991 OKT  G. Gramlich, DLR FF-DF: reverse communication interface */
/* 1993 SEP  D. Joos, DLR FF-DR    : iopt=3 introduced */
/* 1997 AUG  M. Otter, DLR FF-DR   : termination criteria improved, */
/*                                   multiple usage at the same time */
/*                                   (internal state is stored in */
/*                                   work arrays). */

/* Libraries required: */
/* BLAS1:    DNRM2 */

/* Common Blocks: */
/* The subroutines DYMNL* need common /DYMCB/ for the values of */
/*  the machine precision EPSMCH and largest magnitude GIANT. */

/* Example: */

/* The problem is to determine the values of X(1) and X(2), */
/* which solve the nonlinear system of equations */

/*             X(1)*X(2) - X(2)**3 - 1 = 0 */
/*             X(1)**2*X(2) + X(2) - 5 = 0 */

/* ********** */

/*       PROGRAM TEST */
/* C */
/* C     DRIVER FOR DYMNL EXAMPLE. */
/* C */
/*       INTEGER J,N,INFREV,IOPT,INFO,LDUM,IDUM(20) */
/*       PARAMETER (N=2,LDUM=35) */
/*       DOUBLE PRECISION TOL */
/*       DOUBLE PRECISION X(N),FVEC(N),DUM(LDUM),FJAC(N,N) */
/* C */
/*       DOUBLE PRECISION DNRM2, FNORM */
/* C */
/* C     Initialize machine dependent constants */
/*       CALL DYMMDP */
/* C */
/*       IOPT = 1 */
/*       INFREV=-1 */
/*       X(1)=1.D0 */
/*       X(2)=1.D0 */
/* C */
/* C     SET TOL TO ZERO, HENCE THE SQUARE ROOT OF THE MACHINE PRECISION 
*/
/* C     IS ASSUMED INTERNALY. */
/* C */
/*       TOL = 0.D0 */
/* C */
/* 10    CONTINUE */
/*       IF(INFREV .GE. 1 ) THEN */
/*          FVEC(1)=X(1)*X(2)-X(2)**3-1.D0 */
/*          FVEC(2)=X(1)**2*X(2)+X(2)-5.D0 */
/*       END IF */
/*       IF(INFREV .EQ. 2 ) THEN */
/*          FJAC(1,1)=X(2) */
/*          FJAC(1,2)=X(1)-3.*X(2)**2 */
/*          FJAC(2,1)=2.*X(1)*X(2) */
/*          FJAC(2,2)=X(1)**2+1.D0 */
/*       END IF */
/*      CALL DYMNL(INFREV,IOPT,N,X,FVEC,FJAC,TOL,INFO,DUM,LDUM,IDUM,0.0D0)
*/
/*       IF (INFREV .GE. 1) GO TO 10 */
/*       FNORM = DNRM2(N,FVEC,1) */
/*       WRITE (6,1000) FNORM,INFO,(X(J),J=1,N) */
/*  1000 FORMAT (5X,' FINAL L2 NORM OF THE RESIDUALS',E15.7 // */
/*      *        5X,' INFO PARAMETER',16X,I10 // */
/*      *        5X,' FINAL APPROXIMATE SOLUTION' // (5X,3E15.7)) */
/*       STOP */
/*       END */

/* ************ */

/*      FINAL L2 NORM OF THE RESIDUALS  0.1434642E-10 */

/*      INFO PARAMETER                         1 */

/*      FINAL APPROXIMATE SOLUTION */

/*      0.2000000E+01  0.1000000E+01 */

/* ************ */

/* Results obtained with different compilers or machines may be slightly 
*/
/* different. */
/* -----------------------------------------------------------------------
 */
} /* dymnl_ */

DYMOLA_STATIC void dymnl1_Fast(integer*infrev, const integer iopt, const integer n, doublereal*x, 
			 doublereal*fvec, doublereal*fjac, const integer ldfjac, doublereal*fjac2, doublereal*qres2, const integer ldfjac2, const doublereal xtol,
			 const doublereal xtoldesired, const integer maxfev, const integer ml, 
			 const integer mu, const doublereal*nominalx, doublereal*diag, 
			 doublereal *diag2,
			 const doublereal factor, integer*info, integer*nfev, integer*njev, 
			 doublereal *r__, const integer lr,doublereal* qtf, 
			 doublereal * wa1, doublereal*wa2, doublereal*wa3, doublereal*wa4, 
			 const integer jopt, doublereal*dsave, integer*isave,const char*const*varnames,
			 integer*ipivots,int printEvent,int inJacobian)
{
    /* Initialized data */

    static const doublereal one
			 = 1.;
    static const doublereal p1
			 = .1;
    static const doublereal p5
			 = .5;
    static const doublereal p001
			 = .001;
    static const doublereal p0001
			 = 1e-4;
    static const doublereal zero
			 = 0.;

    /* System generated locals */
    integer fjac_dim1, fjac_offset;
    doublereal d__1, d__2;

    /* Local variables */
    integer i__, j, l, jm1, iwa[1];
    doublereal sum;
    logical sing;
    integer iter, irev;
    doublereal temp;
    doublereal delta;
    logical jeval;
    integer ncsuc;
    doublereal ratio, fnorm, pnorm, fnorm1, fnorm_old;
    integer nslow1, nslow2, ncfail;
    doublereal actred, prered;
    integer ifirst;
    doublereal ftolabs, xtolabs;
	logical debugNonLinear;
	logical debugNonLinearDetails;

/*    factor is a positive input variable used in determining the */
/*      initial step bound.  this bound is set to the product of */
/*      factor and the euclidean norm of diag*x if nonzero, or else to */
/*      factor itself.  in most cases factor should lie in the */
/*      interval (.1,100.).  100. is a generally recommended value. */

/*    info is an integer output variable. info is set as follows. */

/*      info = 0  improper input parameters. */

/*      info = 1  relative error between two consecutive iterates is */
/*                at most xtol. */

/*      info = 2  number of calls to fcn has reached or exceeded */
/*                maxfev. */

/*      info = 3  xtol is too small.  no further improvement in the */
/*                approximate solution x is possible. */

/*      info = 4  iteration is not making good progress, as measured */
/*                by the improvement from the last five jacobian */
/*                evaluations. */

/*      info = 5  iteration is not making good progress, as measured */
/*                by the improvement from the last ten iterations. */

/*      sections 4 and 5 contain more details about info. */

/*    nfev is an integer output variable set to the number of */
/*      function evaluations. */

/*    njev is an integer output variable set to the number of */
/*      jacobian evaluations. (if iopt=2, then njev is set zero.) */

/*    r is an output array of length lr which contains the upper */
/*      triangular matrix produced by the qr factorization of the */
/*      final approximate jacobian, stored rowwise. */

/*    lr is a positive integer input variable not less than */
/*      (n*(n+1))/2. */

/*    qtf is an output array of length n which contains the vector */
/*      (q transpose)*fvec. */

/*    wa1, wa2, wa3, and wa4 are work arrays of length n. */

/*    dsave is a double precision work array of length 20. */
/*    isave is an integer work array of length 20. */

/* subprograms called */
/* ------------------ */
/* dymnl-supplied    dymnl2,dymnl3,dymnl4,dymnl5,dymnl6,dymnl7 */
/* blas1-supplied    dnrm2 */
/* fortran-supplied  min0,dmax1,dmin1,dabs */

/* author            guenter m. gramlich, d. joos */
/* date              23.05.91, oberpfaffenhofen */
/* version           1.0       23.09.93 */
/* -----------------------------------------------------------------------
 */
/* Changed substantially 2002-02-11 by Hans Olsson Dynasim */

/* diag2 is used for storing residual*/
/* The code automatically rescales residuals */
/* This is necessary in combination with tearing, where */
/* very badly conditioned systems of equations can occur */

/* If nominalx is non-nil it represents nominal values of*/
/* the variables. If nil we assume that nominal=1 for all variables */
/**/ 



/* C */
/*     .. executable statements .. */
	{
		debugNonLinear=printEvent && !!(printEvent&(1<<8));
		debugNonLinearDetails = debugNonLinear && (printEvent&(1<<7));
	}
    /* Parameter adjustments */
    --wa4;
    --wa3;
    --wa2;
    --wa1;
    --qtf;
    --diag;
    --fvec;
    --x;
    fjac_dim1 = ldfjac;
    fjac_offset = fjac_dim1 + 1;
    fjac -= fjac_offset;
    --r__;
    --dsave;
    --isave;

    /* Function Body */

/* ***first executable statement  dymnl1 */

    xtolabs = xtol;
    ftolabs = xtol;

#ifdef fastnl
#define	actred (dsave[1])
#define delta (dsave[2])
#define fnorm (dsave[3])
#define fnorm1 (dsave[4])
#define pnorm (dsave[5])
#define prered (dsave[6])
#define ratio (dsave[7])
#define sum (dsave[8])
#define temp (dsave[9])
#define xnorm (dsave[10])
	/* dsave 11..13 used by dymnl5 */
	/* dsave 14 used for norm of Jacobian */

	/* Handling of scalar systems: */
	/* 1. Localize an interval enclosing a sign-change (can sort of be generalized to non-scalar) */
	/* 2. Update f(dsave[18])<=0, f(fdsave[19])>=0 */
	/*    Active if isave[20]&1   isave[20]&2   */
	/* 3. If new x will leave dsave[18].. dsave[19] or new x < 0.1*|dsave[18]-save[19]| => bisect. */
#define	i__ (isave[3])
#define iter (isave[4])
#define j (isave[6])
#define jm1 (isave[7])
#define l (isave[8])
#define ncfail (isave[9])
#define ncsuc (isave[10])
#define nslow1 (isave[11])
#define nslow2 (isave[12])
#define irev (isave[13])
#define ifirst (isave[14])
#define jeval (isave[15])
#define sing (isave[16])
#endif /* fastnl */
    if (*infrev < 1) {
		/*        ... initial call; initialize local variables */
		actred = 0.;
		delta = 0.;
		fnorm = 0.;
		fnorm1 = 0.;
		fnorm_old = 0.;
		pnorm = 0.;
		prered = 0.;
		ratio = 0.;
		sum = 0.;
		temp = 0.;
		*nfev = 0;
		*njev = 0;
		i__ = 0;
		iter = 0;
		l = 0;
		j = 0;
		jm1 = 0;
		ncfail = 0;
		ncsuc = 0;
		nslow1 = 0;
		nslow2 = 0;
		irev = 0;
		ifirst = 0;
		jeval = FALSE_;
		sing = FALSE_;
		isave[19]=0;
		isave[20]=0;
#ifdef DYMOSIM
		{
			extern int Check5(char*key);
			if (!Check5("")) {
				DymosimMessage("");
				*info=5;
				goto L370real;
			}
		}
#endif /* DYMOSIM */
		if (!(*infrev <= -20 && *infrev>=-40)) {
			j = 0;
			{int i;for(i=1;i<=n;++i)
				diag2[i-1]=1;}
			dsave[14]=0;
			iwa[0] = 0;
			jm1 = 0;
		} else {
			j = isave[6];
			jm1 = isave[7];
			iwa[0] = isave[5];
			if (*infrev<-30) {*infrev+=10;if (n!=1) isave[20]=1;}
		}
    } else {
		/*        ... get values of local variables from last call */
#ifndef fastnl
		actred = dsave[1];
		delta = dsave[2];
		fnorm = dsave[3];
		fnorm_old = 0.0;
		fnorm1 = dsave[4];
		pnorm = dsave[5];
		prered = dsave[6];
		ratio = dsave[7];
		sum = dsave[8];
		temp = dsave[9];
		/* dsave 11..13 used by dymnl5 */
		/* dsave 14 used for norm of Jacobian */
		/* dsave 15-17 used for singular systems */
#endif /* fastln */
		*nfev = isave[1];
		*njev = isave[2];
#ifndef fastnl
		i__ = isave[3];
		iter = isave[4];
#endif /* fastln */
		iwa[0] = isave[5];
#ifndef fastnl
		j = isave[6];
		jm1 = isave[7];
		l = isave[8];
		ncfail = isave[9];
		ncsuc = isave[10];
		nslow1 = isave[11];
		nslow2 = isave[12];
		irev = isave[13];
		ifirst = isave[14];
		if (isave[15] == 0) {
			jeval = FALSE_;
		} else {
			jeval = TRUE_;
		}
		if (isave[16] == 0) {
			sing = FALSE_;
		} else {
			sing = TRUE_;
		}
#endif /* fastnl */
		/* isave 17..18 used by dymnl5 */
		/* isave 19 used for singular systems and zero start values */
    }
#if defined(DYMOSIM) || defined(GODESS)
	{
		extern int ds_res_int_poll_fast(int,integer n,const doublereal*sol,const char*const*varnames);
		if (ds_res_int_poll_fast(*nfev,n,&x[1],varnames)) {
			*info=5;
			*nfev=-1;
			goto L370a;
		}
	}
#endif /* defined(DYMOSIM) || defined(GODESS) */
	{
		debugNonLinear=!!(printEvent&(1<<8));
		debugNonLinearDetails = debugNonLinear && (printEvent&(1<<7));
	}
#if DEBUG_NL
	DymosimMessageInt("Infrev",*infrev);
#endif /* DEBUG_NL */
    switch ((int)*infrev) {
	case 1:  goto L30; /* got initial value, also used if initial had singular Jac */
	case 32: goto L70c;
	case 2:  goto L50; /* got Jacobian */
	case 3:  goto L70; /* got column for Jacobian */
	case 4:  goto L260;/* got new value in inner loop */
	case 5:  goto L5; /* got value for line-search */
	case 6:  goto L6;
	case 11:case 12:case 13:case 14:case 15:case 16: case 17:case 18:case 19:goto L260;
	case 88: goto L88; /* for treating singular Jacobian */

	case 101: *infrev=1; 
		/* Failed to evaluate rhs, set err to max*/
		/* Failed to evaluate original */
		++*nfev;fnorm=DBL_MAX; 
		if (isave[19]==0) {
			if (debugNonLinearDetails) {
				 DymosimMessage("Trying to modify values.");
			}
			for(j=1;j<=n;++j) {
				double dx;
				dx=fabs(x[j]);
				if (nominalx!=0) dx+=nominalx[j-1];
				else dx+=1;
				x[j]+=dx*1e-8;
			}
			isave[19]=-1;
			goto L999;
		} else if (isave[19]==-1) {
			/* Failed to get any residual at all*/
			for(j=1;j<=n;++j)
				fvec[j]=DBL_MAX;
			*info = 5;
			goto L370; 
		}
		goto L40;
	case 102: *infrev=2; 
		goto L70; /* Failed to evalaute analytical Jacobian, try numeric one */
	case 103: 
		/* Failed during evaluation of numeric Jacobian */ 
			  *infrev=3; 
			  irev=2;
			  if (debugNonLinearDetails) {
				  DymosimMessage("Error for numeric Jacobian");
			  }
			  goto L70;
	case 104: *infrev=4;     
		/* Failed to evaluate rhs, set err to max*/
			  {
				  for (j = 1; j <= n; ++j) {
					  wa2[j] = wa4[j];
					  wa4[j] = fvec[j]*diag2[j-1];
					  fvec[j] = wa2[j];
					  wa2[j] = x[j];
					  x[j] = wa3[j];
					  /* L270: */
				  }
			  }
			  if (debugNonLinearDetails) {
				  DymosimMessage("Handled error by setting error to max");
			  }
		++(*nfev);fnorm1=DBL_MAX; goto L260a;
	case 105:
		/* Failed for debug line search. Give up */
		*infrev=5;
		goto L370real;
	case 106:
		goto L6b;
	case 188: 
		/* Failed to evaluate rhs, set err to max*/
		*infrev=88; ++*nfev;fnorm=DBL_MAX; goto L88a;
	default:
		/* First call continue on */
		break;
    }

    *nfev = 0;
    *njev = 0;

/* check the input parameters for errors. */

/* ...exit */
    *info = 0;
    if (iopt < 1 || iopt > 2 || n <= 0 || xtol < zero || maxfev <= 0 || 
	    ml < 0 || mu < 0 || factor <= zero || ldfjac < n || lr < n *
	     (n + 1) / 2) {
	goto L370;
    }

    if (nominalx !=0) {
		for (j = 1; j <= n; ++j) {
			/*   ** .........exit */
			if (nominalx[j-1] <= zero) {
				goto L370;
			}
		/* L10: */
		}
    }

    /* Note: Added special code 2001-10-17 by Hans:   */
	/* Modified 2003-04-14 */
    /* If we start with infrev between -10 and -40 we */
    /* assume that the residue is already given.      */
    /* If infrev is furthermore between -11 and -40   */
    /* we also assume that the Jacobian is available. */
	/* If infrev is -11-i or -20-i we use i iterations */
/* evaluate the function at the starting point */
/* and calculate its norm. */
	/* If it is -30-i we use i iterations, and forbid new Jacobians, that is handled by setting isave[20] */

/* ...return */

/* initialize iteration counter and monitors. */
	*nfev = 0;
    iter = 1;
    *info = 10;
    ncsuc = 0;
    ncfail = 0;
    nslow1 = 0;
    nslow2 = 0;
    ifirst = 1;

	if (*infrev >=-40 && *infrev<= -10) goto L30;
    *infrev = 1;
    goto L999;

L30:
    ++*nfev;
 
/* beginning of the outer loop. */

/* note that we proceed even with zero residual, we will otherwise get failures */
/* already have residual */
L40:
/* begin block permitting ...exits to 90 */
	if (n==1) {
		if (fvec[1]<0) {
			dsave[18]=x[1];
			isave[20]|=1;
		} else if (fvec[1]>0) {
			dsave[19]=x[1];
			isave[20]|=2;
		}
	}
    jeval = TRUE_;

	if (*infrev <= -20 && *infrev>=-30) {
		/* Scale residual and compute new norm */
		for (i__ = 1; i__ <= n; ++i__) 
			fvec[i__]*=diag2[i__-1];
		fnorm = dnrm2_Fast1(n,&fvec[1]);
		for (i__ = 1; i__ <= n; ++i__) {
			double sumtemp;
			sumtemp=0;
			for(j = 1;j <= n;++j) {
				sumtemp+=fjac[i__*ldfjac+j]*fvec[j];
			}
			qtf[i__]=sumtemp;
		}
		for (j = 1; j <= n; ++j) {
			wa3[j] = diag[j] * x[j];
			/* L110: */
		}
		delta = factor; 
		/* Goto inner loop */
		if (*infrev==-20) {
			*infrev=2;
		} else {
			*infrev=-10-*infrev;
		}
		goto L230;
	}
/* calculate the jacobian matrix. */
    if (iopt == 2 || isave[19]==-1) {
	goto L60;
    }

/* user supplies jacobian */

/* ...return */
    if (*infrev >=-20 && *infrev< -10) {
		if (*infrev==-10 || *infrev==-11 || *infrev==-20)
			*infrev=2;
		else 
			*infrev=-*infrev-1;
		goto L50;
	}
	*infrev = 2;
    goto L999;

L50:
    ++(*njev);
#ifdef CHECK_JACOBIAN_APPROXIMATION
	{
		goto L65b;
	}
#endif /* CHECK_JACOBIAN_APPROXIMATION */
    goto L80;

L60:
#ifdef CHECK_JACOBIAN_APPROXIMATION
	goto L65b;
#endif /* CHECK_JACOBIAN_APPROXIMATION */
/* code approximates the jacobian */

    if (jopt == 1 && ifirst == 1) {
/* for the first time an approx. of the jacobian is already provided 
*/
	ifirst = 0;
	goto L80;
    }
#ifdef CHECK_JACOBIAN_APPROXIMATION
L65b:
#endif /* CHECK_JACOBIAN_APPROXIMATION */
    irev = 0;
	if (debugNonLinearDetails) {
		DymosimMessage("Compute numeric Jacobian");
	}
L70:
	if (fjac2 && qres2) dymnl5_Fast(&irev, n, ldfjac2, &x[1], qres2, &fvec[1], fjac2, ldfjac2, ml, mu,
		nominalx, &wa1[1], &wa2[1], &dsave[11], &isave[17], nslow2 >= 6, debugNonLinear, varnames,
		iopt == 1);
	else
		dymnl5_Fast(&irev, n, n, &x[1], &fvec[1], 0, &fjac[fjac_offset], ldfjac, ml, mu, 
	    nominalx, &wa1[1], &wa2[1], &dsave[11], &isave[17], nslow2>=6,debugNonLinear,varnames,
		iopt==1);
	if (irev ==2) {
		if (debugNonLinear) {
			DymosimMessage("Cannot evaluate numeric Jacobian");
		}
		*info = 4;
		goto L370;
	} else if (irev == 1) {
/*   ** ...return */
	*infrev = 3;
	goto L999;

	} else if (fjac2 && qres2) {
		*infrev = 32;
		goto L999;
	}
L70c:
/* Computing MIN */
    *nfev += Dymola_min(ml+mu+1,n);
L80:
	if (n==1) {
		if (!(isave[20]&8)) {
			if (fjac[1+1]>0) 
				isave[20]|=(8|16); /* Positive Jacobian */
			else if (fjac[1+1]<0) 
				isave[20]|=8; /* Negative Jacobian */
		} else if ((isave[20]&3)!=3) {
			/* Known sign of Jacobian, but no interval with sign-change */
			/* The Jacobian has switched sign, but not the residual. That indicates a singularity */
			if (fjac[1+1]!=0 && (fjac[1+1]>0 != !!(isave[20]&16))) {
				goto L359b;
			}
		}

	}
	/* Scale rows of new Jacobian to compensate for ill-conditioned Jacobians*/
	{
		int nrResLess=0;
	{
		int i,j;
#if DEBUG_NL
		if (LocalTime>0.550215) 
		DymosimMessageDoubleMatrix("J",&(fjac[1+1*fjac_dim1]),n,n,fjac_dim1);
#endif /* DEBUG_NL */
		for(i=1;i<=n;++i) {
			double Jsum=0;
			if (nominalx!=0) {
				for (j=1; j<= n; ++j) {
					Jsum+=Dymola_abs(fjac[i+j*fjac_dim1])*(Dymola_abs(x[j])+nominalx[j-1]);
				}
			} else {
				for (j=1; j<= n; ++j) {
					Jsum+=Dymola_abs(fjac[i+j*fjac_dim1])*(Dymola_abs(x[j])+1);
				}
			}
			if (debugNonLinearDetails) {
				char str[100];
				sprintfC(str,"Residual scale row %d, J_sum=%g",i,Jsum);
				DymosimMessage(str);
			} else if (debugNonLinear&&(Jsum==0)) {
				char str[100];
				sprintfC(str,"Row %d of Jacobian is zero",i);
				DymosimMessage(str);
			}
			if (Jsum==0) {
				/* Count number of Jacobian zero-rows with exactly zero residual */
				/* If these correspond to the loss of singularity the system is consistently overdetermined */
				if (fvec[i]!=0) nrResLess=n+1;
				else nrResLess++;
			}
			Jsum += 1 ; /* Guard against singularity */
			{
				double invScale=1.0 / Jsum;
				diag2[i-1]=invScale;
				for(j=1;j<=n;++j) {
					fjac[i+j*fjac_dim1]*=invScale;
				}
			}
		}
	}
	/* Also scale residual */
	{
		int i;
		for(i=1;i<=n;++i) fvec[i]*=diag2[i-1];
	}
	fnorm = dnrm2_Fast1(n, &fvec[1]);
	if (fnorm!=fnorm || !(fnorm>=0)) fnorm=DBL_MAX;


/* compute the qr factorization of the scaled jacobian. */

	if (ipivots!=0)
		dymnl7_Fast(n, n, &fjac[fjac_offset], ldfjac, ipivots!=0, ipivots, n, &wa1[1], &
	    wa2[1], &wa3[1],varnames, &x[1], printEvent);
	else
    dymnl7_Fast(n, n, &fjac[fjac_offset], ldfjac, c_false, iwa, c__1, &wa1[1], &
	    wa2[1], &wa3[1],varnames, &x[1], printEvent);

	if (*infrev>=0) {
		/* HO 2000-06-27 */
		/* Handle singular matrix. */
		int is_singular;
		int i;
		is_singular=0;
		for(i=1;i<=n;i++) if (wa1[i]==0) is_singular++;
		if (debugNonLinearDetails||(debugNonLinear&&is_singular)) {
			if (is_singular)
				DymosimMessage("Singular Jacobian matrix");
			else {
				double dmi = 1.0;
				double dma = 1.0;
				for(i=1;i<=n;i++) {
					double wabs;
					wabs=fabs(wa1[i]);
					if (i==1 || wabs>dma) dma=wabs;
					if (i==1 || wabs<dmi) dmi=wabs;
				}
				DymosimMessageDouble("Condition estimate of Jacobian matrix",dma/dmi);
			}
		}

		if (is_singular && (fnorm!=0 && nrResLess!=is_singular) && isave[19]!=-1 && !(n==1 && (isave[20]&3)==3)) {
			/* Ignore the case where a scalar system has singular jacobian and we have both upper and lower*/
			/* HO 2000-08-07 only care about singular systems with non-zero residual */
			if (is_singular) {
				/* Singular Jacobian. How to proceed? */
				/* Ignoring would not be meaningful */
				/* Attempt to recompute Jacobian at different point */
				if (isave[19]<=0) {
					/* First time*/
					dsave[17]=fnorm;
					dsave[15]=1e-5;
					isave[19]=0;
					if (printEvent&(1 << 6)) {
						char str[200];
						sprintf(str, "Jacobian is singular. Trying up to %d different points for Jacobian computation.", n);
						DymosimMessage(str);
					}
				} else {
					x[isave[19]]-=dsave[16];
				}
				isave[19]++;
				if (isave[19]>n) {
					isave[19]=1;
					if (dsave[15]>0)
						dsave[15]=-dsave[15];
					else 
						dsave[15]=-dsave[15]*(fabs(dsave[15])<1.5e-4 ? 10 : 2);
					/* Sequence:   1e-5, 1e-4, 1e-3, 2e-3, 4e-3 8e-3, 16e-3, 32e-3, 64e-3, 128e-3 */
					/* Previously: 1e-5, 1e-4, 1e-3, 1e-2, 1e-1 */
					if (printEvent&(1 << 6)) {
						char str[200];
						sprintf(str, "Jacobian is still singular. Trying another %d points for Jacobian computation.", n);
						DymosimMessage(str);
					}
					if (fabs(dsave[15])>.2) {
						isave[19]=-1; /* Go back to original once more */
						if (iopt != 2 && debugNonLinear)
							DymosimMessage("Using Numeric Jacobian");
					}
				}
				if (isave[19]>=0) {
					dsave[16]=Dymola_max(1.0,fabs(x[isave[19]]))*dsave[15];
					x[isave[19]]+=dsave[16];
				}
				*infrev=1;
				goto L999;
			}
		}
	}
	}
	if (isave[19]!=0 && isave[19]!=-1 && fnorm>dsave[17]) {
		/* Got non-singular matrix, but unfortunately the error is larger */
		/* We must now fix this because we will otherwise take another step that leads us back into trouble*/
		dsave[16]*=0.5;
		x[isave[19]]-=dsave[16]; /* Start midway */
		*infrev=88;
		if (debugNonLinear) {
			DymosimMessage("Have found non-singular matrix, but larger error");
		}
		goto L999;
	}
	goto L89;
L88:
	++*nfev;
	{
		int i;
		for(i=1;i<=n;++i) fvec[i]*=diag2[i-1];
	}
    fnorm = dnrm2_Fast1(n, &fvec[1]);
	if (fnorm!=fnorm || !(fnorm>=0)) fnorm=DBL_MAX;
L88a:
	if (fnorm>=dsave[17]) {
		if (fabs(dsave[16])>=1e-14*Dymola_max(1.0,x[isave[19]])) {
			dsave[16]*=0.5;
			if (fnorm>dsave[17])
				x[isave[19]]-=dsave[16];
			else
				x[isave[19]]+=dsave[16];
			*infrev=88;
			goto L999;
		}
		/* Done, now we need a new Jacobian*/
		isave[19]=-1; /* Hope that it is not singular again*/
		{
			int i;
			for(i=1;i<=n;++i) 
				fvec[i]/=diag2[i-1];
		}
		goto L40;
	}
L89:
	isave[19]=0;

/* on the first iteration and if mode is 1, scale according */
/* to the norms of the columns of the initial jacobian. */

/* ...exit */
    if (iter != 1) {
	goto L120;
    }
    for (j = 1; j <= n; ++j) {
		if (nominalx) {
			diag[j] = 1.0/(Dymola_abs(x[j])+nominalx[j-1]);
		} else {
			diag[j] = 1.0/(Dymola_abs(x[j])+1);
		}
		/* L90: */
    }
/* on the first iteration, initialize the step bound delta. */

    delta = factor; 
	if (isave[19]!=0)
		delta=Dymola_min(delta,fabs(dsave[15]/10));

L120:

/* form (q transpose)*fvec and store in qtf. */

    for (i__ = 1; i__ <= n; ++i__) {
		qtf[i__] = fvec[i__];
		/* L130: */
    }
    for (j = 1; j <= n; ++j) {
		if (fjac[j + j * fjac_dim1] == zero) {
			goto L160;
		}
		sum = zero;
		for (i__ = j; i__ <= n; ++i__) {
			sum += fjac[i__ + j * fjac_dim1] * qtf[i__];
			/* L140: */
		}
		temp = -sum / fjac[j + j * fjac_dim1];
		for (i__ = j; i__ <=n; ++i__) {
			qtf[i__] += fjac[i__ + j * fjac_dim1] * temp;
			/* L150: */
		}
L160:
		/* L170: */
		;
    }

/* copy the triangular factor of the qr factorization into r. */

    sing = FALSE_;
    for (j = 1; j <= n; ++j) {
		l = j;
		for (i__ = 1; i__ <= j-1; ++i__) {
			r__[l] = fjac[i__ + j * fjac_dim1];
			l = l + n - i__;
			/* L180: */
		}
		r__[l] = wa1[j];
		if (wa1[j] == zero) {
			sing = TRUE_;
		}
		/* L200: */
    }

/* accumulate the orthogonal factor in fjac. */

    dymnl6_Fast(n, n, &fjac[fjac_offset], ldfjac, &wa1[1]);

/* rescale if necessary. */

    for (j = 1; j <= n; ++j) {
/* Computing MAX */
		double newDiag=0;
		if (nominalx!=0) {
			newDiag=1.0/(Dymola_abs(x[j])+nominalx[j-1]);
		} else {
			newDiag=1.0/(Dymola_abs(x[j])+1);
		}
		if ((nslow2<6)||newDiag<diag[j] )
			diag[j]=newDiag;
		/* remove the 1|| to only rescale if increasing, makes more sense close to singularities */
		/* Modified to nslow2<6 Hans 2004-08-20. To handle Dynasim #1245 and not influence most cases */
/* L210: */
    }

/* beginning of the inner loop. */

L230:

/* determine the direction p. in wa1. */

    dymnl4_Fast(n, &r__[1], lr, &diag[1], &qtf[1], delta, &wa1[1], &wa2[1], &wa3[
	    1],ipivots,inJacobian && (nslow1<5));
	if (n==1 && (isave[20]&3)==3) {
		double lower;
		double upper;
		lower=dsave[18];
		upper=dsave[19];
		if (lower>upper) {
			double xxx;
			xxx=lower;
			lower=upper;
			upper=xxx;
		}
		if (x[1]-wa1[1]<lower || x[1]-wa1[1]>upper) {
			/* Technically speaking we should integrate this much more fully, etc */
			/* However, it worked for several examples */
			if (debugNonLinearDetails) {
				DymosimMessage("Using bisection");
			}
			if (upper-lower<1e-13 && (isave[20]&64)==0) {
				/* Too small interval - must be a discontinuity at the edge, Dynasim #7044*/
				if (x[1]-wa1[1]<lower) 
					wa2[1] = lower;
				else 
					wa2[1] = upper;
				isave[20]|=64; /* Only do it once*/
			} else {
				wa2[1] = (upper+lower)/2;
				isave[20]&=~64; /* Allow other code to be activated */
			}
			/* Ensure that we exactly hit limit. Important since test for out-of-bounds use exact limits*/
			wa1[1] = wa2[1] -x[1];
			wa3[1] = diag[1] * wa1[1];
			isave[20]|=4;
			goto LhaveNewP;
		}
	}

/* store the direction p and x + p. calculate the norm of p. */
#if DEBUG_NL
	if (LocalTime>0.550215) 
		DymosimMessageDoubleMatrix("x",&x[1],1,n,1);
	if (LocalTime>0.550215) 
		DymosimMessageDoubleMatrix("-dx",&wa1[1],1,n,1);
#endif /* DEBUG_NL */
    for (j = 1; j <= n; ++j) {
		wa1[j] = -wa1[j];
		wa2[j] = x[j] + wa1[j];
		wa3[j] = diag[j] * wa1[j];
		/* L240: */
    }
LhaveNewP:
    pnorm = dnrm2_Fast1(n, &wa3[1]);

/* on the first iteration, adjust the initial step bound. */

    if (iter == 1) {
	delta = Dymola_min(delta,pnorm);
    }

/* evaluate the function at x + p and calculate its norm. */

/* ...return */
    for (j = 1; j <= n; ++j) {
		wa3[j] = x[j];
		x[j] = wa2[j];
		wa4[j] = fvec[j];
		/* L250: */
    }
	if (*infrev<10 || *infrev>19)
		*infrev = 4;
	else {
		--*infrev;
		if (*infrev==10) {
			*infrev = 0;
			*info=1;
		}
	}
    goto L999;

L260:
	if (n==1) {
		if (fvec[1]<0) {
			dsave[18]=x[1];
			isave[20]|=1;
		} else if (fvec[1]>0) {
			dsave[19]=x[1];
			isave[20]|=2;
		}
	}
#if DEBUG_NL
	if (LocalTime>0.550215) 
		DymosimMessageDoubleMatrix("f",&fvec[1],1,n,1);
#endif /* DEBUG_NL */

    for (j = 1; j <= n; ++j) {
	wa2[j] = wa4[j];
	wa4[j] = fvec[j]*diag2[j-1];
	fvec[j] = wa2[j];
	wa2[j] = x[j];
	x[j] = wa3[j];
/* L270: */
    }
    ++(*nfev);
    fnorm1 = dnrm2_Fast1(n, &wa4[1]);

	if (debugNonLinearDetails)
			DymosimMessageDouble("Scaled residual",fnorm1);
	if (fnorm1!=fnorm1 || !(fnorm1>=0)) fnorm1=DBL_MAX;
L260a:
	/* test for successful iteration. */
    if (n==1 && (isave[20]&7)==7) {

		/* Bisected. Always accept if fnorm1<DBL_MAX*/
		isave[20]&=~4;
		/* Always accept if old value is not inside new limits */
		if (fnorm1<DBL_MAX && fnorm1>=fnorm) {
			double lower=dsave[18];
			double upper=dsave[19];
			if (lower>upper) {
				double xxx=upper;
				upper=lower;
				lower=xxx;
			}
			if (pnorm>diag[1]*(upper-lower))
				pnorm = diag[1]*(upper-lower); /* Always. */
			if (wa2[1]<lower || wa2[1]>upper) {
				goto L320; /* Always accept it - even if no progress */
			}
		}
		/* Note: It is important to have fnorm1==fnorm handled by this in order to deal with singular Jacobian */
	}
/* compute the scaled actual reduction. */

    actred = -one;
    if (fnorm1 < fnorm) {
/* Computing 2nd power */
	d__1 = fnorm1 / fnorm;
	actred = one - d__1 * d__1;
    }

/* compute the scaled predicted reduction. */
/* Compute: Q'(f+A*wa1)=Q'(f+QRP'*wa1)=Q'f+RP'*wa1, special formula for P'*wa1 */


    l = 1;
    for (i__ = 1; i__ <= n; ++i__) {
	sum = zero;
	for (j = i__; j <= n; ++j) {
		sum += r__[l] * (ipivots? wa1[ipivots[j-1]]: wa1[j]);
	    ++l;
/* L280: */
	}
	wa3[i__] = qtf[i__] + sum;
/* L290: */
    }
    temp = dnrm2_Fast1(n, &wa3[1]);
    prered = zero;
    if (temp < fnorm) {
/* Computing 2nd power */
	d__1 = temp / fnorm;
	prered = one - d__1 * d__1;
    }

/* compute the ratio of the actual to the predicted */
/* reduction. */

    ratio = zero;
    if (prered > zero) {
	ratio = actred / prered;
    }
	if (debugNonLinearDetails) {
		if (prered>=0) {
			DymosimMessageDouble("Old Residual",fnorm);
			DymosimMessageDouble("Predicted relative decrease",(1-sqrt(1-prered)));
			if (fnorm1>=DBL_MAX)
				DymosimMessage("Failed to evaluate");
			else
				DymosimMessageDouble("Actual relative decrease",1-fnorm1/fnorm);
		}
	}
/* update the step bound. */

    if (ratio >= p1) {
	goto L300;
    }
    ncsuc = 0;
    ++ncfail;
	if (iter==1 && fnorm1>1e30) delta=0.01*delta; /* Could not evaluate -> reduce trust region heavility */
	else delta = p5 * delta; 
    goto L310;

L300:
    ncfail = 0;
    ++ncsuc;
    if (ratio >= p5 || ncsuc > 1) {
/* Computing MAX */
	d__1 = delta, d__2 = pnorm / p5;
	delta = Dymola_max(d__1,d__2);
    }
    if ((d__1 = ratio - one, Dymola_abs(d__1)) <= p1) {
	delta = pnorm / p5;
    }
L310:


    if (ratio < p0001) {
	goto L330;
    }
L320:
/* successful iteration. update x, fvec, and their norms. */

    for (j = 1; j <= n; ++j) {
		x[j] = wa2[j];
		wa2[j] = diag[j] * x[j];
		fvec[j] = wa4[j];
		/* L320: */
    }
	fnorm_old = fnorm;
    fnorm = fnorm1;
    ++iter;
    *info = 10;
L330:

/* determine the progress of the iteration. */

    ++nslow1;
    if (actred >= p001) {
	nslow1 = 0;
    }
    if (jeval) {
	++nslow2;
    }
    if (actred >= p1) {
	nslow2 = 0;
    }

/* test for convergence. */

/* Otter, July 1997: original convergence test: */
/*  if (delta .le. xtol*xnorm .or. fnorm .eq. zero) info = 1 */

/*  where xnorm: norm(x) */
/*        fnorm: norm(residue) */
/*        xtol : termination occurs when the relative error between two */
/*               consecutive (scaled) iterates is at most xtol */
/*       delta: bound on the maximum allowed step, i.e., on norm(x_new - x_old).*/

/*  The original convergence test fails, if x=0 is the solution, */
/*  because in such a case delta must be zero. */
/*  Furthermore, the solver may terminate even if the residue */
/*  is large, i.e., when a local minimum is reached. */
/*  In such a case, an error message should be given. */

/*  The assumption has to be made that the equations are well */
/*  scaled (a small residue is desired). Otherwise, a local minimum */
/*  cannot be distinguished from the solution. */

/*  The new convergence criteria requires, that the residue is */
/*  small enough AND that the relative error between two */
/*  consecutive iterates is also small enough (otherwise, the */
/*  solution vector may not reach the required accuracy). */
/*  If "delta" is used in the test, problems occur for linear */
/*  systems because for linear systems the solution is reached */
/*  in one Newton step. However, "delta" is only modestly reduced */
/*  (delta=0.1*delta). As a result, the solver reports */
/*  "not making good progress". Therefore, norm(x_new - x_old) = pnorm */
/*  has to be used in the convergence test. */

/* fnorm == 0.0 added. If the residual is zero we have converged. Additionally,
   if we don't stop here there will be problems later since we skip the qtf
   update for small values on fnorm. 
   -- Erik Henningsson, 2018-04-24 */

	if ((pnorm<=xtoldesired && fnorm<=xtoldesired) || fnorm == 0.0) { 
		
		/* Duplicated below with xtol instead of xtoldesired */
		/* (inJacobian_ && *iopt!=2) || Immediate return if in Jacobian and user-supplied Jacobian (i.e. non-approximate) */
		/* Still not good enough */
		/* dsave[14] computed by dymnl5 is the norm of the Jacobian (actually sum of absolute values). */
		/* If the system of equations is consistent we should have f(x)=J*delta x
		   and thus |f|<=|J|*|delta x| in the solution*/
		/* Only use pnorm because of discussion above */
		/* The scaling of residuals ensure that |J|=1 */
		*info = 1;
	}

/* .........exit */
    if (*info == 1) {
	goto L370;
    }

/* tests for termination and stringent tolerances. */

    if (*nfev >= maxfev) {
	*info = 2;
    }
/* Computing MAX */
    d__1 = p1 * delta;
    if (p1 * Dymola_max(d__1,pnorm) <= DBL_EPSILON) {
		if (debugNonLinear) {
			DymosimMessageDouble("Cannot reach precision since step bound is",p1 * Dymola_max(d__1,pnorm));
		}
		*info = 3;
    }
    if (nslow2 == 10) {
		if (debugNonLinear) {
			DymosimMessage("Too many Jacobian evaluations due to slow iterations");
		}
	*info = 4;
    }
    if (nslow1 == 45) { /* Increased 1999-12-03 and 2001-09-13 by Hans to avoid premature stops*/
		if (debugNonLinear) {
			DymosimMessage("Too many slow iterations with no progress");
		}
	*info = 5;
    }
    if (*info>=2 && *info<=5 && (pnorm<=xtol && fnorm<=xtol)) {
		/* Not as good as desired but good enough, better using it than failing*/
		/* Introduced by H. Olsson 2000-06-29 */
		*info=1;
	}
/* .........exit */
    if (*info >= 1 && *info <= 5) {
	goto L370;
    }

/* criterion for recalculating jacobian */

/* ...exit */
    if (ncfail ==3) {
		if (n!=1 && isave[20]) {
			*info = 4; /* Cannot compute Jacobian */
			goto L370;
		}
	goto L360;
    }

	/* calculate the rank one modification to the jacobian */
	/* and update qtf if necessary. */
	if ((actred>-1 || fnorm1<10*fnorm) && fnorm>5e-12) {
		/* Only update Jacobian if sensible value. */
		/* Note that fnorm might already have been assigned the value of */
		/* fnorm1 if actred>=0 */

		/* Note that fjac is q as a dense matrix */

		/* Not influenced by permutations: */
		/* In: wa4=f_new */
		/* In: wa3=Q'*f_old+RP'*delta_x [already computed] */
		/* Out: wa2 = (Q'*f_new-(Q'*f_old+RP'*delta_x))/pnorm */
		/* Out: wa1 diagonal scaling of wa1 (=delta_x) */
		for (j = 1; j <= n; ++j) {
			sum = zero;
			for (i__ = 1; i__ <=n; ++i__) {
				sum += fjac[i__ + j * fjac_dim1] * wa4[i__];
			}
			wa2[j] = (sum - wa3[j]) / pnorm;
			wa1[j] = diag[j] * (diag[j] * wa1[j] / pnorm);
			if (ratio >= p0001) {
				qtf[j] = sum;
			}
		}
		
		/* compute the qr factorization of the updated jacobian. */

		/* Note that dymnl3_Fast talks about lower-trapezoidal matrices.*/
		/* */
		/* Thus it treats r as r^T, and solves the transposed problem.*/

		/*Therefore dymnl3_Fast computes a transformation such that:*/
		/*(r^T+wa1*wa2^T)*q is lower triangular, i.e.*/
		/* q^T*(r+wa2*wa1^T) is upper triangular. */

		/*This implies that diagonal scaling of x is a column scaling of r,*/
		/*and the scaling is equivalent to multiplying elements of r by the same scaling.*/
		/**/
		/* A permutation matrix can be seen as replacing r by rp^T in the formula, i.e. */
		/* seeing that without permutation r=q^T*A and thus we operate on */
		/* q^T*(q^T*A+wa2*wa1^T) */ 
		/* With QR with permutations A*P=q*r i.e. q^T*A=r*P^T => */
		/* q^T*(r*P^T+wa2*wa1^T) */
		/* Multiplying from right with P gives: */
		/* q^T*(r+wa2*wa1^T*P)=q^T*(r+wa2*(P^T*wa1)^T */
		dymnl3_Fast(n, n, &r__[1], lr, &wa1[1], &wa2[1], &wa3[1], &sing, ipivots);
		if (n==1 && (isave[20]&3)!=3 && (nslow1>4)) {
			goto L359; /* We have not gotten anywhere. Try a simple line search */
		}
		if (sing) {
			goto L360; /* New Jacobian since it became singular */
		}
		dymnl2_Fast(n, n, &fjac[fjac_offset], ldfjac, &wa2[1], &wa3[1]);
		dymnl2_Fast(c__1, n, &qtf[1], c__1, &wa2[1], &wa3[1]);
		
	}
/* end of the inner loop. */

    jeval = FALSE_;
    goto L230;

	/* Special case for scalar */
L359:
	
	/* restore scaling of residuals */
	{
		int i;
		for(i=1;i<=n;++i) {
			fvec[i]/=diag2[i-1];
		}
	}
L359b:
	if (debugNonLinearDetails) {
			DymosimMessage("Line search to find interval with sign change");
	}
	if (n==1 && fabs(wa1[1])<1e-10*(nominalx ? nominalx[1-1] : 1)) wa1[1]=1e-10*(nominalx ? nominalx[1-1] : 1);
	/* This should be examined in more detail */
	/* But is only used for scalar non-linear equations that have problem with convergence. */
	/* Line search to find better value */
	for (j = 1; j <= n; ++j) {
		wa3[j] = x[j];
		x[j] = x[j]+wa1[j];
		wa4[j] = fvec[j];
		/* L250: */
    }
	/* Perform line search to find problem */
	*infrev = 6;
	goto L999;
	
L6:
	++(*nfev);
	/* Found new value */
	if (n==1) {
		if (fvec[1]==0) {
			*info=1;
			goto L370;
		} else if (fvec[1]<0) {
			dsave[18]=x[1];
			isave[20]|=1;
		} else if (fvec[1]>0) {
			dsave[19]=x[1];
			isave[20]|=2;
		}
	}
	/* We can then use bisection when necessary */
	if ((isave[20]&3)==3) {
		goto L40;
	}

L6b: 
	/* This evaluation was not good enough. Continue with line-search */
	for(j=1;j<=n;++j) {
		wa1[j]=-1.2*wa1[j];
		if (fabs(wa1[j])>1e30*(nominalx ? nominalx[j-1] : 1)) {
			goto L6c;
		}
		x[j]=wa3[j]+wa1[j];
	}
    *infrev = 6;
	goto L999;
L6c:
	/* No progress and too far from start. Restore to original. */
	for(j=1;j<=n;++j) {
		x[j]=wa3[j];
		fvec[j]=wa4[j]*diag2[j-1];
	}
	*info=5;
	if (n==1)
		wa1[1]=1e-3*(fabs(x[1])+(nominalx?nominalx[0]:0));
	goto L370;
L360:

/* end of the outer loop. */

	/* restore scaling of residuals */
	{
		int i;
		for(i=1;i<=n;++i) {
			fvec[i]/=diag2[i-1];
		}
	}
    goto L40;

L370:
	if (!debugNonLinear || *info==1) {
		goto L370real;
	}
L370a:
	/* Decrease scale */
	for(j=1;j<=n;++j) wa1[j]*=0.001;
	if (n==1 && (isave[20]&3)==3) {
		char str[200];
		double lower;
		double upper;
		DymosimMessage("Had interval with sign-change and still failed");
		lower=dsave[18];
		upper=dsave[19];
		sprintfC(str,"Interval: [%g %g]", lower, upper);
		DymosimMessage(str);
	}
	dymosimmessagedoubles_("Search direction ",&wa1[1],&n,strlen("Search direction"));
	DymosimMessage("To investigate the properties of the function, you can plot the ");
	DymosimMessage("function in the search direction by pasting the following ");
	DymosimMessage("commands in the Dymola command window:");
	DymosimMessage("  Amat={<...>};");
	DymosimMessage("  plotArray(Amat[:,1],Amat[:,2],-1);");
	DymosimMessage("The columns in Amat below are: {Line-search-alpha,scaled-residua-norm, residual[1] (unscaled), residual[2] (unscaled), ...}");
    DymosimMessage("The search is done from the starting point in both direction along the search-direction, the line-search-alpha is 0 at the starting point.");
	DymosimMessage("If the graph has discontinuities, local minima above zero,");
	DymosimMessage(" and/or knees that indicates the cause of the problem.");
	DymosimMessage("");
	DymosimMessage("Amat={");
	if (*nfev!=-1) {
	{
		/* Write initial ones */
		int more=1;
		char str[200];
		char*buf;
		buf=str+sprintfC(str,"{ %.16g, %.16g",0.0, fnorm);
		for(j=1;j<=n;++j) {
			buf=buf+sprintfC(buf,", %.16g",fvec[j]);
			if (j%5==3) {
				DymosimMessage(str);
				buf=str;
			}
		}
		buf=buf+sprintfC(buf,"%s",more?"},":"}};");
		DymosimMessage(str);
	}
	*nfev=0;
	}
L370b:
	for (j = 1; j <= n; ++j) {
		wa3[j] = x[j];
		x[j] = x[j]+wa1[j];
		wa4[j] = fvec[j];
		/* L250: */
    }
	/* Perform line search to find problem */
	*infrev = 5;

	goto L999;
L5:
   for (j = 1; j <= n; ++j) {
	   double d;
	   d=wa4[j];
	wa4[j] = fvec[j]*diag2[j-1];
	wa2[j] = x[j];
	x[j] = wa3[j];
	fvec[j]=d;
/* L270: */
    }
    ++(*nfev);
    fnorm1 = dnrm2_Fast1(n, &wa4[1]);
	if (*nfev==0) fnorm=fnorm1;
	{
		double wnorm;
		int more;
		char str[200];
		char*buf;
		wnorm=dnrm2_Fast1(n, &wa1[1]);
		more=(fnorm1<fnorm*1.1 || *nfev<20 || (n==1 && fnorm1<fnorm*1000)) && wnorm<1e100;
		if (more) {
			for(j=1;j<=n;++j) 
				wa1[j]*=-1.1;
		}
		if (*nfev%2) wnorm=-wnorm;
		buf=str+sprintfC(str,"{ %.16g, %.16g",wnorm, fnorm1);
		for(j=1;j<=n;++j) {
			buf=buf+sprintfC(buf,", %.16g",wa4[j]);
			if (j%5==3) {
				DymosimMessage(str);
				buf=str;
			}
		}
		buf=buf+sprintfC(buf,"%s",more?"},":"}};");
		DymosimMessage(str);
		if (more)
			goto L370b;
	}
	DymosimMessage("plotArray(Amat[:,1],Amat[:,2],-1);");
	DymosimMessage("");
L370real:
	/* end: restore scaling of residuals for error messages */
	{
		int i;
		for(i=1;i<=n;++i) {
			fvec[i]/=diag2[i-1];
		}
	}
/* termination. */

    *infrev = 0;
    goto L999;



/* ... save local variables in work array before return */
L999:
#ifndef fastnl
    dsave[1] = actred;
    dsave[2] = delta;
    dsave[3] = fnorm;
    dsave[4] = fnorm1;
    dsave[5] = pnorm;
    dsave[6] = prered;
    dsave[7] = ratio;
    dsave[8] = sum;
    dsave[9] = temp;
#endif /* fastnl */
    isave[1] = *nfev;
    isave[2] = *njev;
#ifndef fastnl
    isave[3] = i__;
    isave[4] = iter;
#endif /* fastnl */
    isave[5] = iwa[0];
#ifndef fastnl
    isave[6] = j;
    isave[7] = jm1;
    isave[8] = l;
    isave[9] = ncfail;
    isave[10] = ncsuc;
    isave[11] = nslow1;
    isave[12] = nslow2;
    isave[13] = irev;
    isave[14] = ifirst;
    if (jeval) {
	isave[15] = 1;
    } else {
	isave[15] = 0;
    }
    if (sing) {
	isave[16] = 1;
    } else {
	isave[16] = 0;
    }
#endif /* fastnl */
#ifdef fastnl
#undef	actred
#undef delta 
#undef fnorm 
#undef fnorm1
#undef pnorm 
#undef prered
#undef ratio 
#undef sum 
#undef temp
#undef xnorm
	/* dsave 11..13 used by dymnl5 */
	/* dsave 14 used for norm of Jacobian */

#undef	i__ 
#undef iter
#undef j 
#undef jm1
#undef l 
#undef ncfail 
#undef ncsuc 
#undef nslow1 
#undef nslow2 
#undef irev 
#undef ifirst 
#undef jeval 
#undef sing 
#endif /* fastnl */
    return;

/* last card of subroutine dymnl1. */

} /* dymnl1_ */


DYMOLA_STATIC void dymnl2_Fast(const integer m, const integer n, doublereal* a, const integer lda, const doublereal* v, const doublereal* w)
{
    /* Initialized data */

    static const doublereal one = 1.;

    /* System generated locals */
    integer a_dim1, a_offset;


    /* Local variables */
    integer i__, j;
    doublereal cos__, sin__;

/* ***begin prologue  dymnl2 */

/* subroutine dymnl2 */

/* given an m by n matrix a, this subroutine computes a*q where */
/* q is the product of 2*(n - 1) transformations */

/* gv(n-1)*...*gv(1)*gw(1)*...*gw(n-1) */

/* and gv(i), gw(i) are givens rotations in the (i,n) plane which */
/* eliminate elements in the i-th and n-th planes, respectively. */
/* q itself is not given, rather the information to recover the */
/* gv, gw rotations is supplied. */

/* the subroutine statement is */

/* subroutine dymnl2(m,n,a,lda,v,w) */

/* where */

/* m is a positive integer input variable set to the number */
/* of rows of a. */

/* n is a positive integer input variable set to the number */
/* of columns of a. */

/* a is an m by n array. on input a must contain the matrix */
/* to be postmultiplied by the orthogonal matrix q */
/* described above. on output a*q has replaced a. */

/* lda is a positive integer input variable not less than m */
/* which specifies the leading dimension of the array a. */

/* v is an input array of length n. v(i) must contain the */
/* information necessary to recover the givens rotation gv(i) */
/* described above. */

/* w is an input array of length n. w(i) must contain the */
/* information necessary to recover the givens rotation gw(i) */
/* described above. */

/* subroutines called */

/* fortran-supplied ... dabs,dsqrt */

/* argonne national laboratory. minpack project. march 1980. */
/* burton s. garbow, kenneth e. hillstrom, jorge j. more */
/* ***end prologue  dymnl2 */
/*     .. executable statements .. */
    /* Parameter adjustments */
    --w;
    --v;
    a_dim1 = lda;
    a_offset = a_dim1 + 1;
    a -= a_offset;

    /* Function Body */

/* apply the first set of givens rotations to a. */

/* ***first executable statement  dymnl2 */

    for (j = n-1; j >= 1; --j) {
		if (fabs(v[j])>one) {
			cos__ = one / v[j];
			/* Computing 2nd power */
			sin__ = sqrt(one - cos__ * cos__);
		} else {
			sin__ = v[j];
			/* Computing 2nd power */
			cos__ = sqrt(one - sin__ * sin__);
		}
		for (i__ = 1; i__ <= m; ++i__) {
			const double aij=a[i__ + j * a_dim1];
			const double ain=a[i__ + n * a_dim1];
			const double temp = cos__ * aij - sin__ * ain;
			a[i__ + n * a_dim1] = sin__ * aij + cos__ * ain;
			a[i__ + j * a_dim1] = temp;
		}
    }

/* apply the second set of givens rotations to a. */

    for (j = 1; j <= n-1; ++j) {
		if (fabs(w[j])>one) {
			cos__ = one / w[j];
			/* Computing 2nd power */
			sin__ = sqrt(one - cos__ * cos__);
		} else {
			sin__ = w[j];
			/* Computing 2nd power */
			cos__ = sqrt(one - sin__ * sin__);
		}
		for (i__ = 1; i__ <= m; ++i__) {
			const double aij=a[i__ + j * a_dim1];
			const double ain=a[i__ + n * a_dim1];
			const double temp = cos__ *aij  + sin__ * ain;
			a[i__ + n * a_dim1] = -sin__ * aij + cos__ * ain;
			a[i__ + j * a_dim1] = temp;
		}
    }
    return ;

/* last card of subroutine dymnl2. */

} /* dymnl2_ */


DYMOLA_STATIC void dymnl3_Fast(const integer m, const integer n, doublereal*s, const integer ls, 
				 const doublereal*u, doublereal*v, doublereal*w, logical*sing,
				 const integer*ipivots)
{
    /* Initialized data */

    static const doublereal one = 1.;
    static const doublereal p5 = .5;
    static const doublereal p25 = .25;
    static const doublereal zero = 0.;

    /* System generated locals */
    doublereal d__1, d__2;

    /* Local variables */
    integer i__, j, l, jj;
    doublereal tan__;
    doublereal cos__, sin__, tau, temp, cotan;

/* ***begin prologue  dymnl3 */

/* subroutine dymnl3 */

/* given an m by n lower trapezoidal matrix s, an m-vector u, */
/* and an n-vector v, the problem is to determine an */
/* orthogonal matrix q such that */

/* (s + u*v^t )*q */

/* is again lower trapezoidal. */

/* this subroutine determines q as the product of 2*(n - 1) */
/* transformations */

/* gv(n-1)*...*gv(1)*gw(1)*...*gw(n-1) */

/* where gv(i), gw(i) are givens rotations in the (i,n) plane */
/* which eliminate elements in the i-th and n-th planes, */
/* respectively. q itself is not accumulated, rather the */
/* information to recover the gv, gw rotations is returned. */

/* the subroutine statement is */

/* subroutine dymnl3(m,n,s,ls,u,v,w,sing) */

/* where */

/* m is a positive integer input variable set to the number */
/* of rows of s. */

/* n is a positive integer input variable set to the number */
/* of columns of s. n must not exceed m. */

/* s is an array of length ls. on input s must contain the lower */
/* trapezoidal matrix s stored by columns. on output s contains */
/* the lower trapezoidal matrix produced as described above. */

/* ls is a positive integer input variable not less than */
/* (n*(2*m-n+1))/2. */

/* u is an input array of length m which must contain the */
/* vector u. */

/* v is an array of length n. on input v must contain the vector */
/* v. on output v(i) contains the information necessary to */
/* recover the givens rotation gv(i) described above. */

/* w is an output array of length m. w(i) contains information */
/* necessary to recover the givens rotation gw(i) described */
/* above. */

/* sing is a logical output variable. sing is set true if any */
/* of the diagonal elements of the output s are zero. otherwise */
/* sing is set false. */

/* subprograms called */

/* fortran-supplied ... dabs,dsqrt */

/* argonne national laboratory. minpack project. march 1980. */
/* burton s. garbow, kenneth e. hillstrom, jorge j. more, */
/* john l. nazareth */
/* ***end prologue  dymnl3 */


/*     .. executable statements .. */
    /* Parameter adjustments */
    --w;
    --u;
    --v;
    --s;

    /* Function Body */

/* ***first executable statement  dymnl3 */

/* initialize the diagonal element pointer. */

    jj = n * (n+1)/2; /* *n * ((*m << 1) - *n + 1) / 2 - (*m - *n); */

/* move the nontrivial part of the last column of s into w. */

    l = jj;
    for (i__ = n; i__ <= m; ++i__) {
		w[i__] = s[l];
		++l;
    }

/* rotate the vector v into a multiple of the n-th unit vector */
/* in such a way that a spike is introduced into w. */

    for (j=n-1; j>=1; --j) {
		jj -= m - j + 1;
		w[j] = zero;
		if (v[j] != zero) {
			
			/*   determine a givens rotation which eliminates the */
			/*   j-th element of v. */
			
			if (((d__1 = v[n], Dymola_abs(d__1)) >= (d__2 = v[j], Dymola_abs(d__2)))) {
				tan__ = v[j] / v[n];
				/* Computing 2nd power */
				d__1 = tan__;
				cos__ = p5 / sqrt(p25 + p25 * (d__1 * d__1));
				sin__ = cos__ * tan__;
				tau = sin__;
			} else {
				cotan = v[n] / v[j];
				/* Computing 2nd power */
				d__1 = cotan;
				sin__ = p5 / sqrt(p25 + p25 * (d__1 * d__1));
				cos__ = sin__ * cotan;
				tau = one;
				if (Dymola_abs(cos__) * DBL_MAX > one) {
					tau = one / cos__;
				}
			}
			
			/*   apply the transformation to v and store the information */
			/*   necessary to recover the givens rotation. */
			
			v[n] = sin__ * v[j] + cos__ * v[n];
			v[j] = tau;
			
			/*   apply the transformation to s and extend the spike in w. */
			
			l = jj;
			for (i__ = j; i__ <= m; ++i__) {
				temp = cos__ * s[l] - sin__ * w[i__];
				w[i__] = sin__ * s[l] + cos__ * w[i__];
				s[l] = temp;
				++l;
			}
		}
    }

/* add the spike from the rank 1 update to w. */

    for (i__ = 1; i__ <= m; ++i__) {
		w[i__] += v[n] * (ipivots ? u[ipivots[i__-1]] : u[i__]);
    }
	
	/* eliminate the spike. */
	
    *sing = FALSE_;
    for (j = 1; j <= n-1; ++j) {
		if (w[j] != zero) {
			
			/*   determine a givens rotation which eliminates the */
			/*   j-th element of the spike. */
			
			if ((d__1 = s[jj], Dymola_abs(d__1)) >= (d__2 = w[j], Dymola_abs(d__2))) {
				tan__ = w[j] / s[jj];
				/* Computing 2nd power */
				d__1 = tan__;
				cos__ = p5 / sqrt(p25 + p25 * (d__1 * d__1));
				sin__ = cos__ * tan__;
				tau = sin__;
			} else {
				cotan = s[jj] / w[j];
				/* Computing 2nd power */
				d__1 = cotan;
				sin__ = p5 / sqrt(p25 + p25 * (d__1 * d__1));
				cos__ = sin__ * cotan;
				tau = one;
				if (Dymola_abs(cos__) * DBL_MAX > one) {
					tau = one / cos__;
				}
			}
			/*   apply the transformation to s and reduce the spike in w. */
			
			l = jj;
			for (i__ = j; i__ <= m; ++i__) {
				temp = cos__ * s[l] + sin__ * w[i__];
				w[i__] = -sin__ * s[l] + cos__ * w[i__];
				s[l] = temp;
				++l;
			}
			
			/*   store the information necessary to recover the */
			/*   givens rotation. */
			
			w[j] = tau;
			
		}
		/*   test for zero diagonal elements in the output s. */
		
		if (s[jj] == zero) {
			*sing = TRUE_;
		}
		jj += m - j + 1;
    }

/* move w back into the last column of the output s. */

    l = jj;
    for (i__ = n; i__ <= m; ++i__) {
		s[l] = w[i__];
		++l;
    }
    if (s[jj] == zero) {
		*sing = TRUE_;
    }
    return ;

/* last card of subroutine dymnl3. */

} /* dymnl3_ */


DYMOLA_STATIC void dymnl4_Fast(const integer n, const doublereal* r__, const integer lr, const doublereal*diag, 
				 const doublereal*qtb, const doublereal delta, doublereal*x, doublereal*wa1, doublereal*wa2,
				 const integer*ipivots,
				 int inJacobian)
{
    /* Initialized data */

    static const doublereal one = 1.;
    static const doublereal zero = 0.;

    /* System generated locals */
    doublereal d__1, d__2, d__3, d__4;


    /* Local variables */
    integer i__, j, k, l, jj, jp1;
    doublereal sum, temp;
    doublereal alpha, bnorm, gnorm, qnorm, sgnorm;
	int divideBy=0;

/* ***begin prologue  dymnl4 */

/* ********* */

/* subroutine dymnl4 */

/* given an m by n matrix a, an n by n nonsingular diagonal */
/* matrix d, an m-vector b, and a positive number delta, the */
/* problem is to determine the convex combination x of the */
/* gauss-newton and scaled gradient directions that minimizes */
/* (a*x - b) in the least squares sense, subject to the */
/* restriction that the euclidean norm of d*x be at most delta. */

/* this subroutine completes the solution of the problem */
/* if it is provided with the necessary information from the */
/* qr factorization of a. that is, if a = q*r, where q has */
/* orthogonal columns and r is an upper triangular matrix, */
/* then dymnl4 expects the full upper triangle of r and */
/* the first n components of (q transpose)*b. */

/* the subroutine statement is */

/* subroutine dymnl4(n,r,lr,diag,qtb,delta,x,wa1,wa2) */

/* where */

/* n is a positive integer input variable set to the order of r. */

/* r is an input array of length lr which must contain the upper */
/* triangular matrix r stored by rows. */

/* lr is a positive integer input variable not less than */
/* (n*(n+1))/2. */

/* diag is an input array of length n which must contain the */
/* diagonal elements of the matrix d. */

/* qtb is an input array of length n which must contain the first */
/* n elements of the vector (q transpose)*b. */

/* delta is a positive input variable which specifies an upper */
/* bound on the euclidean norm of d*x. */

/* x is an output array of length n which contains the desired */
/* convex combination of the gauss-newton direction and the */
/* scaled gradient direction. */

/* wa1 and wa2 are work arrays of length n. */

/* ipivots is an optional pivoting matrix as returned by dymnl7_fast */
/* Additional comments on pivoting*/
/* A=QRP' */
/* min |Ax-b|, |d'*x|<=delta */
/* min |QRP'x-b|, |d'*x|<=delta */
/* y=P'*x x=P*y */
/* min |QRy-b|, |d'*P*y|<=delta */
/* min |Ry-Q'b|, |(P'*d)'*y|<=delta */
/* We compute y in x-vector and then go to returnSection */

/* subprograms called */

/* fortran-supplied ... dabs,dmax1,dmin1,dsqrt */

/* argonne national laboratory. minpack project. march 1980. */
/* burton s. garbow, kenneth e. hillstrom, jorge j. more */
/* ***end prologue  dymnl4 */


/*     .. executable statements .. */
    /* Parameter adjustments */
    --wa2;
    --wa1;
    --x;
    --qtb;
    --diag;
    --r__;

    /* Function Body */

/* ***first executable statement  dymnl4 */

/* first, calculate the gauss-newton direction. */

    jj = n * (n + 1) / 2 + 1;
    for (k = 1; k <= n; ++k) {
		j = n - k + 1;
		jp1 = j + 1;
		jj -= k;
		l = jj + 1;
		sum = zero;

		for (i__ = jp1; i__ <= n; ++i__) {
			sum += r__[l] * x[i__];
			++l;
		}

		temp = r__[jj];
		if (temp == zero) {
			
			l = j;
			for (i__ = 1; i__ <= j; ++i__) {
				/* Computing MAX */
				d__2 = temp, d__3 = (d__1 = r__[l], Dymola_abs(d__1));
				temp = Dymola_max(d__2,d__3);
				l = l + n - i__;
				/* L30: */
			}
			temp = DBL_EPSILON * temp;
			if (temp == zero) {
				temp = DBL_EPSILON;
			}
		}
		if (divideBy>0) {
			/* Ensure consistent down-scaling */
			double t2;
			int i;
			t2=qtb[j];
			for(i=0;i<divideBy;++i) t2*=1e-50;
			x[j]=(t2-sum)/temp;
		} else
			x[j] = (qtb[j] - sum) / temp;
		if (x[j]>1e200 || x[j]<-1e200) {
			++divideBy;
			for(i__=j;i__<=n;++i__) x[j]*=1e-50; /* Scale it down to avoid overflow*/
		}
    }

/* test whether the gauss-newton direction is acceptable. */

    for (j = 1; j <= n; ++j) {
		wa1[j] = zero;
		wa2[j] = (ipivots ? diag[ipivots[j-1]] : diag[j]) * x[j];
		/* L60: */
    }
    qnorm = dnrm2_Fast1(n, &wa2[1]);
    if (qnorm <= delta || inJacobian) {
		goto returnSection;
    }
/* note: early return if acceptable */

/* the gauss-newton direction is not acceptable. */
/* next, calculate the scaled gradient direction. */

    l = 1;
    for (j = 1; j <= n; ++j) {
		temp = qtb[j];
		for (i__ = j; i__ <= n; ++i__) {
			wa1[i__] += r__[l] * temp;
			++l;
		}
		wa1[j] /= (ipivots ? diag[ipivots[j-1]] : diag[j]);
    }

/* calculate the norm of the scaled gradient and test for */
/* the special case in which the scaled gradient is zero. */

    gnorm = dnrm2_Fast1(n, &wa1[1]);
    sgnorm = zero;
    alpha = delta / qnorm;
    if (gnorm == zero) {
	goto L120;
    }

/* calculate the point along the scaled gradient */
/* at which the quadratic is minimized. */

    for (j = 1; j <= n; ++j) {
	wa1[j] = wa1[j] / gnorm / (ipivots ? diag[ipivots[j-1]] : diag[j]);
/* L90: */
    }
    l = 1;
    for (j = 1; j <= n; ++j) {
	sum = zero;
	for (i__ = j; i__ <= n; ++i__) {
	    sum += r__[l] * wa1[i__];
	    ++l;
/* L100: */
	}
	wa2[j] = sum;
/* L110: */
    }
    temp = dnrm2_Fast1(n, &wa2[1]);
    sgnorm = gnorm / temp / temp;

/* test whether the scaled gradient direction is acceptable. */

    alpha = zero;
    if (sgnorm >= delta) {
	goto L120;
    }

/* the scaled gradient direction is not acceptable. */
/* finally, calculate the point along the dogleg */
/* at which the quadratic is minimized. */

    bnorm = dnrm2_Fast1(n, &qtb[1]);
    temp = bnorm / gnorm * (bnorm / qnorm) * (sgnorm / delta);
/* Computing 2nd power */
    d__1 = sgnorm / delta;
/* Computing 2nd power */
    d__2 = temp - delta / qnorm;
/* Computing 2nd power */
    d__3 = delta / qnorm;
/* Computing 2nd power */
    d__4 = sgnorm / delta;
    temp = temp - delta / qnorm * (d__1 * d__1) + sqrt(d__2 * d__2 + (one - 
	    d__3 * d__3) * (one - d__4 * d__4));
/* Computing 2nd power */
    d__1 = sgnorm / delta;
    alpha = delta / qnorm * (one - d__1 * d__1) / temp;
L120:

/* form appropriate convex combination of the gauss-newton */
/* direction and the scaled gradient direction. */

    temp = (one - alpha) * Dymola_min(sgnorm,delta);
    for (j = 1; j <= n; ++j) {
		x[j] = temp * wa1[j] + alpha * x[j];
    }
returnSection:
	/* Pivot result if necessary */

	if (ipivots) {
		/* First copy result to work-area */
		for(j=1;j<=n;++j) wa1[j]=x[j];
		/* Then compute P*x as indicated in dymnl7_fast */
		for(j=1;j<=n;++j) x[ipivots[j-1]]=wa1[j];
	}
    return ;

/* last card of subroutine dymnl4. */

} /* dymnl4_ */


DYMOLA_STATIC void dymnl5_Fast(integer*irev, const integer n, const integer n2, doublereal *x, doublereal *fvec, doublereal*fvec2,
	doublereal *fjac, 
			 const integer ldfjac, const integer ml, const integer mu, const doublereal *nominalx, 
	doublereal *wa1, doublereal *wa2, doublereal* dsave, integer* isave,logical useCentral,
	logical printDetails,const char*const*varnames,int check)
{
    /* Initialized data */

    static const doublereal zero = 0.;

    /* System generated locals */
    integer fjac_dim1, fjac_offset;
    doublereal d__1;

    /* Local variables */
    doublereal h__;
    integer i__, j, k;
    doublereal eps, temp;
    integer msum;
	int failedEvaluation=0;


/* ----------------------------------------------------------------------- */
/*     this subroutine computes a forward-difference approximation */
/*     to the n2 by n jacobian matrix associated with a specified */
/*     problem of n2 functions in n variables. if the jacobian has */
/*     a banded form, then function evaluations are saved by only */
/*     approximating the nonzero terms. */

/*       irev is a integer input and output variable for driving reverse */
/*         communication */

/*       n is a positive integer input variable set to the number */
/*         of functions and variables. */

/*       x is an input array of length n. */

/*       fvec is an input array of length n2 which must contain the */
/*         functions evaluated at x. */

	/*  fvec2 is an optional input array of length n */

/*       fjac is an output n2 by n array which contains the */
/*         approximation to the jacobian matrix evaluated at x. */

/*       ldfjac is a positive integer input variable not less than n2 */
/*         which specifies the leading dimension of the array fjac. */

/*       ml is a nonnegative integer input variable which specifies */
/*         the number of subdiagonals within the band of the */
/*         jacobian matrix. if the jacobian is not banded, set */
/*         ml to at least n - 1. */

/*       nominal is an input variable used in determining a suitable */
/*         step length for the forward-difference approximation. */

/*       mu is a nonnegative integer input variable which specifies */
/*         the number of superdiagonals within the band of the */
/*         jacobian matrix. if the jacobian is not banded, set */
/*         mu to at least n - 1. */

/*       wa1,wa2 and wa3 are work arrays of length n. if ml + mu + 1 is a */
/*         least n, then the jacobian is considered dense, and wa2 is */
/*         not referenced. if fvec2 is given then wa1 must be n+n2*/

/*       dsave,isave are work arrays to save the internal state of the */
/*         subroutine for the next call. */

/* subprograms called */
/* ------------------ */
/* fortran-supplied  dmax1,dabs,dsqrt */

/* author            Guenter M. Gramlich, D. Joos */
/* date              23.05.91, Oberpfaffenhofen */
/* version           1.0       23.09.93 */
/* ----------------------------------------------------------------------- */


/*     .. executable statements .. */
    /* Parameter adjustments */
    --wa2;
    --wa1;
    --fvec;
    --x;
    fjac_dim1 = ldfjac;
    fjac_offset = fjac_dim1 + 1;
    fjac -= fjac_offset;
    --dsave;
    --isave;

    /* Function Body */

/* ***first executable statement  dymnl5 */

    msum = ml + mu + 1;

	if (*irev == 2) {
		failedEvaluation=1;
		*irev=1;
	}

    if (*irev == 1) {
		/*       ... get last internal state */
		temp = dsave[1];
		h__ = dsave[2];
		eps = dsave[3];
		j = isave[1];
		k = isave[2];
		/*       ... jump to appropriate place */
		if (msum < n) {
			goto L110;
		}
		goto L30;
    } else {
		/*       ... initialize internal state */
		temp = 0.;
		h__ = 0.;
		eps = sqrt(DBL_EPSILON);
		if (useCentral) eps = 1e-6;
		j = 0;
		k = 0;
    }
	
    if (msum < n) {
		goto L70;
    }

/* computation of dense approximate jacobian. */

    j = 1;
    for (i__ = 1; i__ <= n2; ++i__) {
	wa1[i__] = fvec[i__];
/* L10: */
    }
	if (fvec2) for (i__ = 1; i__ <= n; ++i__) wa1[i__ + n2] = fvec2[i__ - 1];
L20:
	temp = x[j];
	if (nominalx!=0)
		h__ = eps * Dymola_max(nominalx[j-1],Dymola_abs(temp));
	else
		h__ = eps * Dymola_max(1, Dymola_abs(temp));
	if (h__ == zero) {
		h__ = eps;
	}
	if (k!=0)
		x[j] = temp - h__;
	else
		x[j] = temp + h__;
    *irev = 1;
    goto L999;
L30:
    x[j] = temp;
	if (k==0) {
		if (failedEvaluation) {
			/* Try other direction */
			k=2;
			goto L20;
		}
		if (printDetails && check && !useCentral) {
			double rSum;
			rSum=0;
			for (i__ = 1; i__ <= n2; ++i__) rSum+=Dymola_abs(fjac[i__ + j * fjac_dim1]);
			for (i__ = 1; i__ <= n2; ++i__) {
				double analyticD, numericD;
				analyticD=fjac[i__ + j * fjac_dim1];
				numericD=(fvec[i__] - wa1[i__]) / h__;
			if (Dymola_abs(analyticD-numericD)>1e-3*rSum) {
				char str[600];
				/* First is j = which variable, second is i which equation */
				sprintfC(str,"Jacobian element(%d %.400s,%d)= is %g [analytic] or %g [sum=%g]",j,
					(varnames && varnames[j-1])?varnames[j-1]:"",i__,analyticD,numericD,rSum);
				DymosimMessage(str);
			}
			}
		}
		for (i__ = 1; i__ <= n2; ++i__) {
			fjac[i__ + j * fjac_dim1] = (fvec[i__] - wa1[i__]) / h__;
		}
		if (useCentral) {
			k=1;
			goto L20;
		}
	} else {
		if (failedEvaluation) {
			if (k==1) {
				/* Ok in other direction, fall-thru */
			} else {
				/* Total failure */
				for (i__ = 1; i__ <= n2; ++i__) fvec[i__] = wa1[i__];
				*irev = 2;
				goto L999;
			}
		} else if (k==2) {
			for (i__ = 1; i__ <= n2; ++i__) {
				fjac[i__ + j * fjac_dim1] = -(fvec[i__] - wa1[i__]) / h__;
			}
		} else {
			double rSum;
			rSum=0;
			for (i__ = 1; i__ <= n2; ++i__) rSum+=Dymola_abs(fjac[i__ + j * fjac_dim1]);
			for (i__ = 1; i__ <= n2; ++i__) {
				double d;
				double fwd_d;
				d= - (fvec[i__] - wa1[i__]) / h__;
				fwd_d = fjac[i__ + j * fjac_dim1];
				if (printDetails && Dymola_abs(d-fwd_d)>1e-3*(rSum)) {
					char str[600];
					/* First is j = which variable, second is i which equation */
					sprintfC(str,"Jacobian element(%d %.400s,%d)= is %g or %g [sum=%g]",j,
						(varnames && varnames[j-1])?varnames[j-1]:"",i__,fwd_d,d,rSum);
					DymosimMessage(str);
				}	
				fjac[i__ + j * fjac_dim1] =fwd_d*0.5+0.5*d; /* Use central difference */
			}
		}
		k=0;
	}
	if (j == n) {
		goto L50;
	}
    ++j;
    goto L20;
L50:
    for (i__ = 1; i__ <= n2; ++i__) {
	fvec[i__] = wa1[i__];
/* L60: */
    }
	if (fvec2) for (i__ = 1; i__ <= n; ++i__) fvec2[i__ - 1]=wa1[i__ + n2];
    goto L160;

L70:

/* computation of banded approximate jacobian. assumes n==n2 and fvec2==0 */

    k = 1;
    for (j = 1; j <= n; ++j) {
	wa1[j] = fvec[j];
/* L80: */
    }

L90:
    for (j = k; msum < 0 ? j >= n : j <= n; j += msum) {
	wa2[j] = x[j];
	h__ = eps * (d__1 = wa2[j], Dymola_abs(d__1));
	if (h__ == zero) {
	    h__ = eps;
	}
	x[j] = wa2[j] + h__;
/* L100: */
    }
/* ...return */
    *irev = 1;
    goto L999;

L110:
    for (j = k; msum < 0 ? j >= n : j <= n; j += msum) {
	x[j] = wa2[j];
	h__ = eps * (d__1 = wa2[j], Dymola_abs(d__1));
	if (h__ == zero) {
	    h__ = eps;
	}
	for (i__ = 1; i__ <= n; ++i__) {
	    fjac[i__ + j * fjac_dim1] = zero;
	    if (i__ >= j - mu && i__ <= j + ml) {
		fjac[i__ + j * fjac_dim1] = (fvec[i__] - wa1[i__]) / h__;
	    }
/* L120: */
	}
/* L130: */
    }
    if (k == msum) {
	goto L140;
    }
    ++k;
    goto L90;

L140:
    for (i__ = 1; i__ <= n; ++i__) {
	fvec[i__] = wa1[i__];
/* L150: */
    }
L160:
    *irev = 0;
    goto L999;

/* ... save internal state */
L999:
    dsave[1] = temp;
    dsave[2] = h__;
    dsave[3] = eps;
    isave[1] = j;
    isave[2] = k;
    return;

/* last card of subroutine dymnl5. */

} /* dymnl5_ */


DYMOLA_STATIC void dymnl6_Fast(const integer m, const integer n, doublereal* q, const integer ldq, doublereal*wa)
{
    /* Initialized data */

    static const doublereal one = 1.;
    static const doublereal zero = 0.;

    /* System generated locals */
    integer q_dim1, q_offset;

    /* Local variables */
    integer i__, j, k, l;
    doublereal sum, temp;
    integer minmn;

/* ***begin prologue  dymnl6 */

/* subroutine dymnl6 */

/* this subroutine proceeds from the computed qr factorization of */
/* an m by n matrix a to accumulate the m by m orthogonal matrix */
/* q from its factored form. */

/* the subroutine statement is */

/* subroutine dymnl6(m,n,q,ldq,wa) */

/* where */

/* m is a positive integer input variable set to the number */
/* of rows of a and the order of q. */

/* n is a positive integer input variable set to the number */
/* of columns of a. */

/* q is an m by m array. on input the full lower trapezoid in */
/* the first min(m,n) columns of q contains the factored form. */
/* on output q has been accumulated into a square matrix. */

/* ldq is a positive integer input variable not less than m */
/* which specifies the leading dimension of the array q. */

/* wa is a work array of length m. */

/* subprograms called */

/* fortran-supplied ... min0 */

/* argonne national laboratory. minpack project. march 1980. */
/* burton s. garbow, kenneth e. hillstrom, jorge j. more */
/* ***end prologue  dymnl6 */
/*     .. executable statements .. */
    /* Parameter adjustments */
    --wa;
    q_dim1 = ldq;
    q_offset = q_dim1 + 1;
    q -= q_offset;

    /* Function Body */

/* zero out upper triangle of q in the first min(m,n) columns. */

/* ***first executable statement  dymnl6 */

    minmn = Dymola_min(m,n);
    for (j = 2; j <= minmn; ++j) {
		for (i__ = 1; i__ <= j-1; ++i__) {
			q[i__ + j * q_dim1] = zero;
		}
    }

/* initialize remaining columns to those of the identity matrix. */

    for (j = n+1; j <= m; ++j) {
		for (i__ = 1; i__ <= m; ++i__) {
			q[i__ + j * q_dim1] = zero;
		}
		q[j + j * q_dim1] = one;
    }

/* accumulate q from its factored form. */

    for (l = 1; l <= minmn; ++l) {
		k = minmn - l + 1;
		for (i__ = k; i__ <= m; ++i__) {
			wa[i__] = q[i__ + k * q_dim1];
			q[i__ + k * q_dim1] = zero;
		}
		q[k + k * q_dim1] = one;
		if (wa[k] != zero) {
			double wak_inverse;
			wak_inverse=1/wa[k];
			for (j = k; j <= m; ++j) {
				sum = zero;
				for (i__ = k; i__ <= m; ++i__) {
					sum += q[i__ + j * q_dim1] * wa[i__];
				}
				temp = sum *wak_inverse;
				for (i__ = k; i__ <= m; ++i__) {
					q[i__ + j * q_dim1] -= temp * wa[i__];
				}
			}
		}
    }
    return;

/* last card of subroutine dymnl6. */

} /* dymnl6_ */


DYMOLA_STATIC void dymnl7_Fast(const integer m, const integer n, doublereal* a, const integer lda, 
				 const logical pivot, 
			 integer*ipvt, const integer lipvt, doublereal*sigma, doublereal*acnorm, 
	doublereal*wa,const char*const*varnames, doublereal*x,int printEvent) 
{
    /* Initialized data */

    static const doublereal one = 1.;
    static const doublereal p05 = .05;
    static const doublereal zero = 0.;
	static const doublereal smallPivot =1e-9;

    /* System generated locals */
    integer a_dim1, a_offset;
    doublereal d__1, d__2, d__3;


    /* Local variables */
    integer i__, j, k, jp1;
    doublereal sum;
    integer kmax;
    doublereal temp;
    integer minmn;
    doublereal ajnorm;
	integer wasSmall=0;
	integer firstTime=1;


/* this subroutine uses householder transformations with column */
/* pivoting (optional) to compute a qr factorization of the */
/* m by n matrix a. that is, dymnl7 determines an orthogonal */
/* matrix q, a permutation matrix p, and an upper trapezoidal */
/* matrix r with diagonal elements of nonincreasing magnitude, */
/* such that a*p = q*r. the householder transformation for */
/* column k, k = 1,2,...,min(m,n), is of the form */

/* t */
/* i - (1/u(k))*u*u */

/* where u has zeros in the first k-1 positions. the form of */
/* this transformation and the method of pivoting first */
/* appeared in the corresponding linpack subroutine. */

/* the subroutine statement is */

/* subroutine dymnl7(m,n,a,lda,pivot,ipvt,lipvt,sigma,acnorm,wa) */

/* where */

/* m is a positive integer input variable set to the number */
/* of rows of a. */

/* n is a positive integer input variable set to the number */
/* of columns of a. */

/* a is an m by n array. on input a contains the matrix for */
/* which the qr factorization is to be computed. on output */
/* the strict upper trapezoidal part of a contains the strict */
/* upper trapezoidal part of r, and the lower trapezoidal */
/* part of a contains a factored form of q (the non-trivial */
/* elements of the u vectors described above). */

/* lda is a positive integer input variable not less than m */
/* which specifies the leading dimension of the array a. */

/* pivot is a logical input variable. if pivot is set .true., */
/* then column pivoting is enforced. if pivot is set .false., */
/* then no column pivoting is done. */

/* ipvt is an integer output array of length lipvt. ipvt */
/* defines the permutation matrix p such that a*p = q*r. */
/* column j of p is column ipvt(j) of the identity matrix. */
/* if pivot is .false., ipvt is not referenced. */

/* For a permutation matrix we have: transpose(P)*P=I [GvL] */
/* For this representation it is easy to compute: */

/* transpose(P)*x_i =x[ipvt[i]] or x[ipvt[i-1]] if C-array for ipvt. */
/* x'*P*y=(P'*x)'*y where P'*x is easy to compute */

/* To compute y=P*x we initialize the output and then: */
/* y[ipvt[i]]=x[i] */

/* Note: We use a C-array in other routines to make it easier to handle optional pivoting. */

/* lipvt is a positive integer input variable. if pivot is */
/* .false., then lipvt may be as small as 1. if pivot is */
/* .true., then lipvt must be at least n. */

/* sigma is an output array of length n which contains the */
/* diagonal elements of r. */

/* acnorm is an output array of length n which contains the */
/* norms of the corresponding columns of the input matrix a. */
/* if this information is not needed, then acnorm can coincide */
/* with sigma. */

/* wa is a work array of length n. if pivot is .false., then wa */
/* can coincide with sigma. */

/* subprograms called */

/* fortran-supplied ... dmax1,dsqrt,min0 */

/* minpack. version of december 1978. */
/* burton s. garbow, kenneth e. hillstrom, jorge j. more */
/* ***end prologue  dymnl7 */


/*     .. executable statements .. */
    /* Parameter adjustments */
    --wa;
    --acnorm;
    --sigma;
    a_dim1 = lda;
    a_offset = a_dim1 + 1;
    a -= a_offset;
    --ipvt;

    /* Function Body */

/* ***first executable statement  dymnl7 */

/* compute the initial column norms and initialize several arrays. */

    for (j = 1; j <= n; ++j) {
	acnorm[j] = dnrm2_Fast1(m, &a[j * a_dim1 + 1]);
	sigma[j] = acnorm[j];
	wa[j] = sigma[j];
	if (pivot) {
	    ipvt[j] = j;
	}
	wasSmall=wasSmall || (acnorm[j]<smallPivot);
/* L10: */
    }


/* reduce a to r with householder transformations. */

    minmn = Dymola_min(m,n);
    for (j = 1; j <= minmn; ++j) {
		if (pivot) {
			
			/*   bring the column of largest norm into the pivot position. */
			
			kmax = j;
			for (k = j; k <= n; ++k) {
				/* Commented code: Only pivot if necessary */
				if (sigma[k] > sigma[kmax] /*&& (kmax!=j || sigma[kmax]==0)*/) {
					kmax = k;
				}
				
			}
			if (sigma[kmax]<smallPivot) {
				/* Too small */
				
				if (!!(printEvent&(1<<8))) {
					if (firstTime) {
					  /* This message will appear as heading to the other ones */
					  DymosimMessage("The non-linear system is difficult to solve, this could either be\n"
						"due to a dependency between equations, or due to bad start-values.");
					  firstTime=0;
					}

					if (!wasSmall) {
					 /* Simple analysis of cause. If wasSmall is true at least one column was small before QR */
					 /* Since wasSmall is false none of the columns were small before start of QR and thus */
					 /* this special message, indicating that one has to look for dependency between variables. */
					  DymosimMessage("Note: None of the columns are small on their own - the problem only occurred after eliminating other dependencies between variables.");
					 wasSmall=1;
					}
					{
					  char str[2000];
					  sprintfC(str, "Variable %d(%.400s)=%g has small pivot %g and is hard to solve%s", ipvt[kmax],
						  varnames?varnames[ipvt[kmax]-1]:"?", x[ipvt[kmax]-1], sigma[kmax], (j<minmn)?",":".");
					  DymosimMessage(str);
					 }
				}
			}
			if (kmax != j) {
				/* Swap kmax and j */
				
				for (i__ = 1; i__ <= m; ++i__) {
					temp = a[i__ + j * a_dim1];
					a[i__ + j * a_dim1] = a[i__ + kmax * a_dim1];
					a[i__ + kmax * a_dim1] = temp;
				}
				sigma[kmax] = sigma[j];
				wa[kmax] = wa[j];
				k = ipvt[j];
				ipvt[j] = ipvt[kmax];
				ipvt[kmax] = k;
			}
		}
		
		/*   compute the householder transformation to reduce the */
		/*   j-th column of a to a multiple of the j-th unit vector. */
		
		ajnorm = dnrm2_Fast1(m-j+1, &a[j + j * a_dim1]);
		if (ajnorm != zero) {
			if (a[j + j * a_dim1] < zero) {
				ajnorm = -ajnorm;
			}
			for (i__ = j; i__ <= m; ++i__) {
				a[i__ + j * a_dim1] /= ajnorm;
				/* L50: */
			}
			a[j + j * a_dim1] += one;
			
			/*   apply the transformation to the remaining columns */
			/*   and update the norms. */
			
			jp1 = j + 1;
			for (k = jp1; k <= n; ++k) {
				sum = zero;
				for (i__ = j; i__ <= m; ++i__) {
					sum += a[i__ + j * a_dim1] * a[i__ + k * a_dim1];
				}
				temp = sum / a[j + j * a_dim1];
				for (i__ = j; i__ <= m; ++i__) {
					a[i__ + k * a_dim1] -= temp * a[i__ + j * a_dim1];
				}
				if (!(!pivot || sigma[k] == zero)) {
					
					temp = a[j + k * a_dim1] / sigma[k];
					/* Computing MAX */
					/* Computing 2nd power */
					d__3 = temp;
					d__1 = zero, d__2 = one - d__3 * d__3;
					sigma[k] *= sqrt((Dymola_max(d__1,d__2)));
					/* Computing 2nd power */
					d__1 = sigma[k] / wa[k];
					if (p05 * (d__1 * d__1) <= DBL_EPSILON) {
						
						sigma[k] = dnrm2_Fast1(m - j, &a[jp1 + k * a_dim1]);
						wa[k] = sigma[k];
					}
				}
				;
			}
		}
		sigma[j] = -ajnorm;
		/* L110: */
    }
    return ;

/* last card of subroutine dymnl7. */

} /* dymnl7_ */

DYMOLA_STATIC void dymnlinf1_(const integer*sysnr, const integer*n, const doublereal*sol, const doublereal*res, 
				const integer*nfunc, const integer*njac, const integer*nmax,const char*const*varnames)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Local variables */
    integer i__;
    doublereal norm;


/* Print messages after successful termination of DymNL */

/* SysNr: IN, number of nonlinear equation system */
/* N    : IN, argument N of DymNL */
/* Sol  : IN, argument X of DymNL (solution vector) */
/* Res  : IN, argument FVEC of DymNL (residue) */
/* nFunc: IN, accumulated number of calculations of residue */
/* nJac : IN, accumulated number of calculations of symbolic */
/*        Jacobian */
/* nmax : IN, dimension of nFunc/nJac */

/* ..................................................................... */



/* ..................................................................... */

    /* Parameter adjustments */
    --res;
    --sol;
    --njac;
    --nfunc;

    /* Function Body */
    norm = 0.;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	norm += (d__1 = res[i__], Dymola_abs(d__1));
/* L10: */
    }
    dymosimmessagedouble_("  Solution: Infinity-" "norm of residue = ", &norm, 
	    39);
    if (*sysnr <= *nmax) {
	if (nfunc[*sysnr] > 0) {
	    if (njac[*sysnr] <= 0) {
		DymosimMessageInt_("            Acc. number of residue calculations:", &nfunc[*sysnr], 48);
	    } else {
		DymosimMessageInt_("            Acc. number of residue     calc.:", &nfunc[*sysnr], 51);
	    }
	}

	if (njac[*sysnr] > 0) {
	    DymosimMessageInt_("            Acc. number of symbolic Jacobian calc.:", &njac[*sysnr], 51);
	}
    }

    dymnlinf2_(*n, &sol[1],varnames,0);

	dymosimmessage_("Residual:", 9);

	dymnlinf2_(*n, &res[1], 0, 0);


    return ;
} /* dymnlinf1_ */




DYMOLA_STATIC void dymnlinf2_(integer n, const doublereal*sol,const char*const*varnames,unsigned indent)
{
    /* Local variables */
    integer i__;


/* Print solution vector of DymNL */

/* N    : IN, argument N of DymNL */
/* Sol  : IN, argument X of DymNL (solution vector) */

/* ..................................................................... */



/* ..................................................................... */

    /* Parameter adjustments */
    --sol;
	if (indent > 100) indent = 100;

	if (varnames==0) {
		dymosimmessagedoubles_("", &sol[1], &n, 0);
	} else {
		for(i__=1;i__<=n;i__++) {
			char str[200];
			int i;
			if (indent) sprintfC(str, "%*s", indent, "");
			for(i=0;varnames[i__-1][i]!='\0';i++) {
				str[i+indent]=varnames[i__-1][i];
				if (i+indent>=140) {
					/* truncate string */
					strcpy(str+i+indent,"...");i+=3;
					break;
				}
			}
			strcpy(str+i+indent," = ");i+=3;
			dymosimmessagedouble_(str,sol+i__,i+indent);
		}
	}
    return ;
} /* dymnlinf2_ */

DYMOLA_STATIC void DymosimMessageSeverity(int severity, const char*message);
DYMOLA_STATIC void dymnlerr_(const doublereal*time, const integer*sysnr, const integer*info, const integer*n, 
			   const integer*iopt, const doublereal*tol, const doublereal*sol, const doublereal*res, 
	const integer*nfunc, const integer*njac, const integer*nmax,const char*const*varnames, const double*wa1,const char*tag,int idemand,int printevent,int*const advicePrinted)

{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Local variables */
    integer i__, nfcn;
    doublereal norm;
	char str[600];


/* Print error message, if nonlinear system of equations could */
/* not be solved */

/* Time : IN, actual time instant */
/* SysNr: IN, number of system of equations */
/* Info : IN, argument INFO of DymNL */
/* N    : IN, argument N of DymNL */
/* iOpt : IN, argument iOpt of DymNL */
/* Tol  : IN, argument TOL of DymNL */
/* Sol  : IN, argument X of DymNL (solution vector) */
/* Res  : IN, argument FVEC of DymNL (residue) */
/* nFunc: IN, accumulated number of calculations of residue */
/* nJac : IN, accumulated number of calculations of symbolic */
/*        Jacobian */
/* nmax : IN, dimension of nFunc/nJac */

/* ..................................................................... */



/* ..................................................................... */


    /* Parameter adjustments */
    --res;
    --sol;
    --njac;
    --nfunc;

    /* Function Body */
	DymosimMessageSeverity(1, "\nERROR: Failed to solve nonlinear system using Newton solver.");
	if (idemand == 0)
		sprintfC(str, "  During initialization at time: %.16G", *time);
	else
		sprintfC(str, "  Time: %.16G", *time);
	DymosimMessageSeverity(1, str);
	if (tag) {
		sprintfC(str, "  %.400s", tag);
		DymosimMessageSeverity(1, str);
	}
	DymosimMessageSeverity(1, "");

	if (advicePrinted && *advicePrinted)
		DymosimMessageSeverity(1, "  For debugging help refer to the first error message of this type.");
	else {
		DymosimMessageSeverity(1, "  Common causes:");
		if (idemand == 0) {
			DymosimMessageSeverity(1, "   * The system of equations has no solution - the residual will be above zero.\n     - This may be caused by initial conditions not being fully specified, check the translation log.\n     - In some cases the event-logic can cause this.");
			DymosimMessageSeverity(1, "   * Starting values are too far from the solution, see homotopy in the manual.\n     - In rare cases this could occur at events.");
		} else {
			DymosimMessageSeverity(1, "   * The system of equations has no solution - the residual will be above zero.\n     - In some cases the event-logic can cause this.");
			DymosimMessageSeverity(1, "   * Starting values are too far from the solution.\n     - In rare cases this could occur at events.");
		}
		DymosimMessageSeverity(1, "   * The equations are too discontinuous for the nonlinear solver - the residual will have knees.\n     - Likely caused by over-using noEvent.");
		if (idemand == 0)
			DymosimMessageSeverity(1, "  Especially consider the first two items above when the nonlinear solver fails during initialization.");
		DymosimMessageSeverity(1, "");

		dymosimmessageSev_(1, "  To get more information consider the options:", 100);
		dymosimmessageSev_(1, "   * Simulation/Setup/Translation/Generate listing of translated Modelica code in dsmodel.mof", 150);
		dymosimmessageSev_(1, "   * Simulation/Setup/Translation/List non-linear iteration variables", 150);
		if (idemand == 0)
			DymosimMessageSeverity(1, "   * Simulation/Setup/Debug/Store variables after failed initialization\n     - If a failure to solve a nonlinear equation caused failed initialization.");
		DymosimMessageSeverity(1, "   * The options under the group Simulation/Setup/Debug/Nonlinear solver diagnostics");

		if (advicePrinted) *advicePrinted = 1;
	}
	DymosimMessageSeverity(1, "");

	if ((printevent&(1 << 6)) || (printevent&(1 << 7)) || (printevent&(1 << 8)) || (printevent&(1 << 17))) {
		if (*info == 0)
			DymosimMessageSeverity(1, "  The nonlinear solver stopped due to:");
		else if (*info >= 2 && *info <= 4)
			DymosimMessageSeverity(1, "  The nonlinear solver stopped since:");

		if (*info == 0) {
			dymosimmessageSev_(1, "   * Improper input parameters (wrong initialization)",
				53);

		}
		else if (*info == 2) {
			if (*iopt == 2) {
				nfcn = (*n + 1) * 200;
			}
			else {
				nfcn = (*n + 1) * 100;
			}
			dymosimmessageSev_(1, "   * Number of calls to nonlinear solver DymNL has reached or exceeded", 70);
			DymosimMessageIntSev_(1, "     the maximum allowed number of function calls=", &nfcn, 52);

		}
		else if (*info == 3) {
			sprintfC(str, "   * The tolerance of %G is too small. No further improvement", tol);
			DymosimMessageSeverity(1, str);
			dymosimmessageSev_(1, "     in the approximate solution is possible.", 45);

		}
		else if (*info == 4) {
			dymosimmessageSev_(1, "   * Iteration is not making good progress.", 43);

		}
		else {
			sprintfC(str, "  Argument INFO = %d of solver DymNL is wrong.", info);
			DymosimMessageSeverity(1, str);
		}

		if (*sysnr <= *nmax) {
			if (nfunc[*sysnr] > 0) {
				if (njac[*sysnr] <= 0) {
					DymosimMessageIntSev_(1, "  Accumulated number of residual calculations:", &nfunc[*sysnr], 46);
				}
				else {
					DymosimMessageIntSev_(1, "  Accumulated number of residual calculations:", &nfunc[*sysnr], 50);
				}
			}

			if (njac[*sysnr] > 0) {
				DymosimMessageIntSev_(1, "  Accumulated number of symbolic Jacobian calculations:", &njac[*sysnr], 55);
			}
		}

		DymosimMessageSeverity(1, "");
	}

	norm = 0.;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	norm += (d__1 = res[i__], Dymola_abs(d__1));
/* L10: */
    }
	if (wa1) {
		int i;
		double dmi = 1.0;
		double dma = 1.0;
#if 1
		/* Estimates based on diagonal elements of the R factor. R is stored in wa1. The previous implementation 
		   used the work array wa1 from dymnl1_Fast which sometimes contains the diagonal of R. However, it is usually
		   overwritten with other work data. -- Erik Henningsson, 2018-01-04 */
		int index = 0;
		for (i = 0; i < *n; ++i) {
			double wabs;
			wabs = fabs(wa1[index]);
			index += i + 2;
			if (i == 0 || wabs>dma) dma = wabs;
			if (i == 0 || wabs<dmi) dmi = wabs;
		}
		/* Estimate based on the smallest and largest diagonal element of the R matrix. */
		if (dmi == 0)
			sprintfC(str, "  The Jacobian is estimated to be singular.");
		else
			sprintfC(str, "  Jacobian inverse norm estimate: %g\n  Condition number estimate: %g", 1 / dmi, dma / dmi);
#else
		for(i=1;i<=*n;i++) {
			double wabs;
			wabs=fabs(wa1[i-1]);
			if (i==1 || wabs>dma) dma=wabs;
			if (i==1 || wabs<dmi) dmi=wabs;
		}
		sprintfC(str,"  Jacobian has inverse norm %g and condition number %g.",dmi,dma/dmi);
#endif
		DymosimMessageSeverity(1, str);
		if (norm >= DBL_MAX)
			dymosimmessageSev_(1, "  Failed to evaluate any residual. Try to give better start-values.", 70);
		else {
			sprintfC(str, "  1-norm of the residual = %G", norm);
			DymosimMessageSeverity(1, str);
		}

		if (norm>1e6) {
			DymosimMessageSeverity(1, "  The residual is large, using better start values can be a solution.");
		} else {
			if ((*n==1 && dmi<1e-2) || dma>1e6*dmi) {
				DymosimMessageSeverity(1, "  The estimates indicate that the Jacobian is close to singular, suggesting that there is no solution.");
				if (norm < 1e-3) {
					DymosimMessageSeverity(1, "   - Especially since the norm of the last residual vector is small.");
					if (idemand != 0)
						DymosimMessageSeverity(1, "   - Check if any variable has reached its physical limit.");
				}
			}
			else if (norm<1e-3) DymosimMessageSeverity(1, "  The residual is small, but it is not clear that it is close to a singular point.\n   - It could be that there are discontinuities (knees).");
		}
	}

#if 0
    DymosimMessageIntSev_(1, "  Nonlinear system of equations number = ", sysnr, 
	    42);
#endif

	DymosimMessageSeverity(1, "");

    dymosimmessageSev_(1, "  Last value of the solution:", 34);
    dymnlinf2_(*n, &sol[1], varnames, 4);

	if (norm<DBL_MAX) {
		dymosimmessageSev_(1, "  Last value of the residual:", 34);
		dymosimmessagedoublesSevIndent_(0, "", &res[1], n, 0, 4);
	}

	dymosimmessageSev_(1, " ", 1);

    return;
} /* dymnlerr_ */

/* Subroutine */ DYMOLA_STATIC int dymnon_(qinfrev, qiopt, qnnl, qsol, qres, qjac, qtol, 
	qinfo, qd, qi, printevent, qnlnr, time, qnlfunc, qnljac, qnlmax, 
	ierr___)
integer *qinfrev, *qiopt, *qnnl;
doublereal *qsol, *qres, *qjac, *qtol;
integer *qinfo;
doublereal *qd;
integer *qi, *printevent, *qnlnr;
doublereal *time;
integer *qnlfunc, *qnljac, *qnlmax, *ierr___;
{
    static integer idum[20];







    /* Parameter adjustments */
    --qsol;
    --qres;
    qjac -= 11;
    --qd;
    --qnlfunc;
    --qnljac;

    /* Function Body */
    if (*qinfrev == -1) {
	if (*printevent&(1<<6)) {
	    dymosimmessage_(" ", 1);
	    DymosimMessageInt_("Solving nonlinear system of equations number = ", qnlnr, 47);
	    dymosimmessagedouble_("        iteratively at Time = ", time, 30)
		    ;
	}
    }
    if ((*printevent&(1<<7)) && *qinfrev != 3) {
	dymnlinf2_(*qnnl, &qsol[1], 0, 0);
    }
    if (*qinfrev > 0) {
		++qnlfunc[*qnlnr];
    
		if (*qinfrev == 2) 
			++qnljac[*qnlnr];
	}
    dymnl_(qinfrev, qiopt, qnnl, &qsol[1], &qres[1], &qjac[11], qtol, qtol, qinfo, &
	    qd[1], qi, idum, &c_b362);

    if (*qinfrev <= 0) {
	if (*qinfo != 1) {
		if ((*printevent&(1 << 6)) || !(*printevent&(1 << 10))) {
			dymnlerr_(time, qnlnr, qinfo, qnnl, qiopt, qtol, &qsol[1], &qres[
				1], &qnlfunc[1], &qnljac[1], qnlmax, 0, &qd[20 + (*qnnl) * 7], 0, -1, 0, 0);
		}
	    *ierr___ = 1;
	} else if ((*printevent&(1<<6)) && *qinfo == 1) {
	    dymnlinf1_(qnlnr, qnnl, &qsol[1], &qres[1], &qnlfunc[1], &
		    qnljac[1], qnlmax, 0);
	}
    }
    return 0;
} /* dymnon_ */


/* Subroutine */ DYMOLA_STATIC int dymnon4_(qinfrev, qiopt, qnnl, qsol, qres, qjac, qtol, qtoldesired, 
	qinfo, qd, qi, idum, printevent, qnlnr, time, qnlfunc, qnljac, qnlmax, varnames,
	ierr___)
integer *qinfrev, *qiopt, *qnnl;
doublereal *qsol, *qres, *qjac, *qtol, *qtoldesired;
integer *qinfo;
doublereal *qd;
integer *qi, *printevent, *qnlnr;
doublereal *time;
integer *qnlfunc, *qnljac, *qnlmax, *ierr___;
integer *idum; /* integer array of length 20 */
const char*const*varnames;
{







    /* Parameter adjustments */
    --qnlfunc;
    --qnljac;

    /* Function Body */
    if (*qinfrev == -1) {
	if ((*printevent&(1<<6))) {
	    dymosimmessage_(" ", 1);
	    DymosimMessageInt_("Solving nonlinear system of equations number = ", qnlnr, 47);
	    dymosimmessagedouble_("        iteratively at Time = ", time, 30)
		    ;
	}
    }
    if ((*printevent&(1<<7)) && *qinfrev != 3) {
	dymnlinf2_(*qnnl, qsol, varnames, 0);
    }
    if (*qinfrev > 0) {
		++qnlfunc[*qnlnr];
    
		if (*qinfrev == 2) 
			++qnljac[*qnlnr];
	}
    dymnl_(qinfrev, qiopt, qnnl, qsol, qres, qjac, qtol, qtoldesired, qinfo, 
	    qd, qi, idum, &c_b362);

    if (*qinfrev <= 0) {
	if (*qinfo != 1) {
		if ((*printevent&(1 << 6)) || !(*printevent&(1 << 10))) {
			dymnlerr_(time, qnlnr, qinfo, qnnl, qiopt, qtol, qsol, qres, &qnlfunc[1], &qnljac[1], qnlmax, varnames, &qd[20 + (*qnnl) * 7], 0, -1, 0, 0);
		}
	    *ierr___ = 1;
	} else if ((*printevent&(1<<6)) && *qinfo == 1) {
	    dymnlinf1_(qnlnr, qnnl, qsol, qres, &qnlfunc[1], &
		    qnljac[1], qnlmax, varnames);
	}
    }
    return 0;
} /* dymnon4_ */

#ifdef DYMOSIM
LIBDS_API void DynDsResCollectNonlinearEquationTags(int nlmax, int nr, const char * const tag);
#else
static void DynDsResCollectNonlinearEquationTags(int nlmax, int nr, const char * const tag) { ; }
#endif

LIBDS_API void dymnon8_(int*qinfrev, int qiopt, int qnnl, double*qsol,double* qres,double* qjac,double*qjac2,double*qres2,int lqd2,
					 double qtol, double qtoldesired,
	int*qinfo, double*qd, int lqd, int*idum, int printevent, int inJacobian, int qnlnr, double time, 
	int*qnlfunc, int*qnljac, int qnlmax, const char*const*varnames,const double*nom,int*ierr___,
	const char*tag,int idemand,int*const advicePrinted,int preciseTol) {
#ifdef DEBUG_NL
	LocalTime=0;
#endif /* DEBUG_NL */
	if (*qinfrev < 0) {
		if ((printevent&(1<<6))) {
			dymosimmessage_(" ", 1);
			DymosimMessageInt_("Solving nonlinear system of equations number = ", &qnlnr, 47);
			if (tag) DymosimMessage(tag);
			dymosimmessagedouble_("        iteratively at Time = ", &time, 30)
				;
		}
    }
	if (*qinfrev<100) {
		int failed = 0, i;
		for (i = 0; i < qnnl; ++i) if (!(qres[i] > -DBL_MAX) || !(qres[i] < DBL_MAX)) failed = 1;
		if (failed) {
			if (*qinfrev > 0) {
				if (!(printevent& (1 << 10))) DymosimMessage("Residual was NaN or Inf.\n");
				if (!(printevent& (1 << 10))) DymosimMessage("Non-linear solver will attempt to handle this problem.\n");
				*qinfrev += 100;
			} else {
				if (!(printevent& (1 << 10))) DymosimMessage("First evaluation failed for non-linear solver.\n"); \
				*qinfrev = -1;
			}
		}
	}
    if ((printevent&(1<<7)) && *qinfrev != 3 && *qinfrev!=5) {
		dymnlinf2_(qnnl, qsol, varnames, 0);
		if (*qinfrev!=-1) {
			dymosimmessage_("Residual:",9);
			dymnlinf2_(qnnl, qres, 0, 0);
		}
		dymosimmessage_(" ",1);
    }
    if (*qinfrev > 0) {
		++qnlfunc[qnlnr-1];
    
		if (*qinfrev == 2) 
			++qnljac[qnlnr-1];
		if (*qinfrev == 3)
			--qnljac[qnlnr - 1];
	} else if (*qinfrev >=-40 && *qinfrev<=-10) {
		++qnlfunc[qnlnr-1];
		if (*qinfrev <= -11 && *qinfrev>-20)
			++qnljac[qnlnr-1];
	}
    dymnl_WithNominal2(qinfrev, qiopt, qnnl, qsol, qres, qjac, qjac2, qres2, lqd2, qtol, qtoldesired, qinfo,
		qd, lqd, idum, nom, varnames,idum+20, printevent, inJacobian, preciseTol);
	
    if (*qinfrev <= 0) {
		if (printevent&(1 << 17))
			DynDsResCollectNonlinearEquationTags(qnlmax, qnlnr, tag);
		if (*qinfo != 1) {
			if ((printevent&(1<<6)) || !(printevent&(1<<10))) 
			dymnlerr_(&time, &qnlnr, qinfo, &qnnl, &qiopt, &qtol, qsol, qres, qnlfunc, 
				qnljac, &qnlmax, varnames, &qd[20+qnnl*7],tag,idemand,printevent,advicePrinted);
			*ierr___ = 1;
		} else if ((printevent&(1<<6)) && *qinfo == 1) {
			dymnlinf1_(&qnlnr, &qnnl, qsol, qres, qnlfunc,qnljac, &qnlmax, varnames);
		}
    }
}
LIBDS_API void dymnon7_(int*qinfrev, int qiopt, int qnnl, double*qsol, double* qres, double* qjac,
	double qtol, double qtoldesired,
	int*qinfo, double*qd, int lqd, int*idum, int printevent, int inJacobian, int qnlnr, double time,
	int*qnlfunc, int*qnljac, int qnlmax, const char*const*varnames, const double*nom, int*ierr___,
	const char*tag, int idemand, int*const advicePrinted, int preciseTol) {
	dymnon8_(qinfrev, qiopt, qnnl, qsol, qres, qjac, 0, 0, 0, qtol, qtoldesired, qinfo, qd, lqd, idum, printevent, inJacobian, qnlnr, time, qnlfunc, qnljac, qnlmax, varnames, nom, ierr___, tag, idemand, advicePrinted, preciseTol);
}
LIBDS_API void dymnon6_(int*qinfrev, int qiopt, int qnnl, double*qsol,double* qres,double* qjac,
					 double qtol, double qtoldesired,
	int*qinfo, double*qd, int lqd, int*idum, int printevent, int inJacobian, int qnlnr, double time, 
	int*qnlfunc, int*qnljac, int qnlmax, const char*const*varnames,const double*nom,int*ierr___) {
		dymnon7_(qinfrev,qiopt,qnnl,qsol,qres,qjac,qtol,qtoldesired,qinfo,qd,lqd,idum,printevent,inJacobian,
			qnlnr,time,qnlfunc,qnljac,qnlmax,varnames,nom,ierr___,0,0,0,0);
}
LIBDS_API void dymnon5_(int*qinfrev, int qiopt, int qnnl, double*qsol,double* qres,double* qjac,
					 double qtol, double qtoldesired,
	int*qinfo, double*qd, int lqd, int*idum, int printevent, int qnlnr, double time, 
	int*qnlfunc, int*qnljac, int qnlmax, const char*const*varnames,const double*nom,int*ierr___) {
		dymnon6_(qinfrev,qiopt,qnnl,qsol,qres,qjac,qtol,qtoldesired,qinfo,qd,lqd,idum,printevent,0,
			qnlnr,time,qnlfunc,qnljac,qnlmax,varnames,nom,ierr___);
	}



#ifdef DYMOSIM
	LIBDS_API void DynLogEvents(int action, doublereal time, int event_type, const char* expression, int iresult, double result);
#else /*DYMOSIM*/
#undef DynLogEvents
#define DynLogEvents(action, time, event_type, expression, iresult, result)
#endif /*DYMOSIM*/


DYMOLA_STATIC int dymnon3_(integer*qinfrev, integer*qiopt, integer*qnnl, double*qsol, double*qres, double*qjac, double*qtol,
			 double*qtoldesired, integer*qinfo, double*qd, integer*lqd, integer*idum, integer*printevent, 
			 integer*qnlnr, double*time, integer*qnlfunc, integer*qnljac, integer*qnlmax,integer*ierr___)
{
	return dymnon4_(qinfrev,qiopt,qnnl,qsol,qres,qjac,qtol,qtoldesired,qinfo,qd,lqd,idum,printevent,
		qnlnr,time,qnlfunc,qnljac,qnlmax,0,ierr___);
}
DYMOLA_STATIC int dymnon2_(integer*qinfrev, integer*qiopt, integer*qnnl, double*qsol,double* qres,double* qjac,double* qtol, 
					integer*qinfo, double*qd, integer*lqd, integer*idum, integer*printevent, integer*qnlnr, 
					double*time, 
					integer*qnlfunc, integer*qnljac, integer*qnlmax, integer*ierr___)
{
	return dymnon3_(qinfrev, qiopt, qnnl, qsol, qres, qjac, qtol, qtol, 
	qinfo, qd, lqd, idum, printevent, qnlnr, time, qnlfunc, qnljac, qnlmax, 
	ierr___); /* Backwards compatibility.*/
}
/* Subroutine */ DYMOLA_STATIC int handleevent_(relation, m, cp, cn, c__, init, printevent, 
	eps, t, anyevent, relation_len)
const char *relation;
integer*m;
doublereal *cp, *cn, *c__;
logical *init;
integer *printevent;
doublereal *eps, *t;
logical *anyevent;
ftnlen relation_len;
{
    /* System generated locals */
    const char* a__1[3];
    integer i__1[3];
    doublereal d__1;

    /* Builtin functions */

    /* Local variables */
    integer mold;
    doublereal delta, epsequ;
    char textline[200];


/* EVENTMAN.FOR */

/* Implements decision table for events. */

/* CopyRight: 		(C) Dynasim AB, 1993-2001 */
/* Author:  		Hilding Elmqvist */
/* Date:    		November 23, 1997 */
/* Version: 		1.9 */
/* Revisions: */
/*   May 14, 1993	Disabling three-valued logic. */
/*   May 23, 1993	Introduced BooleanChanged. */
/*   May 31, 1993        Removed debug printouts. */
/*   July 28, 1993       Changed meaning of PrintEvent */
/*   September 30, 1993  Introduced call to disstr */
/*   November 9, 1993    Introduced hysteresis. */
/*   November 12, 1993   Rewritten - simplified */
/*   March 20, 1994      EpsEqu introduced for equality test (Otter) */
/*   October 24, 1996    Simplified code for output */
/*   November 23, 1997   Fortran code adapted to C code. */
/*                       EPSLON replaced by epsmch (more efficient). */
/*                      Real number (0.9) replaced by double number (0.9D0)*/
/*                       (Otter). */

/* PrintEvent: */
/*   >=5: Log < > == */

/* ---------------------------------------------------------- */
/* 		C < -Delta	-Delta <= C 	C > Delta */
/* 				and C <= Delta */

/* 		M = -1		M = 0		M = 1 */

/* ---------------------------------------------------------- */


    delta = *eps / 1e5;
    *cp = *eps;
    *cn = -(*eps);
    epsequ = DBL_EPSILON * 10.;
    if ((d__1 = *c__ - *cp, Dymola_abs(d__1)) <= epsequ) {
	*cp = *eps * .9;
    } else if ((d__1 = *c__ - *cn, Dymola_abs(d__1)) <= epsequ) {
	*cn = *eps * -.9;
    }
    if (*init) {
	*m = -2;
    }
    mold = *m;
    if (*c__ >= -delta && *c__ <= delta && *m != 0) {
	*m = 0;
	if ((*printevent&(1<<1))) {
/* Writing concatenation */
	    i__1[0] = 11, a__1[0] = "Expression ";
	    i__1[1] = relation_len, a__1[1] = relation;
	    i__1[2] = 8, a__1[2] = " became ";
	    s_cat(textline, a__1, i__1, &c__3, 200);
	    dymosimmessagedouble2_(textline, c__, " ( == 0).", 200, 9);
		DynLogEvents(-1, 0, 4, relation, 3, 0);
	}
    } else if (*c__ > delta && *m != 1) {
	*m = 1;
	if ((*printevent&(1<<1))) {
/* Writing concatenation */
	    i__1[0] = 11, a__1[0] = "Expression ";
	    i__1[1] = relation_len, a__1[1] = relation;
	    i__1[2] = 8, a__1[2] = " became ";
	    s_cat(textline, a__1, i__1, &c__3, 200);
	    dymosimmessagedouble2_(textline, c__, " ( > 0).", 200, 8);
		DynLogEvents(-1, 0, 4, relation, 4, 0);
	}
    } else if (*c__ < -delta && *m != -1) {
	*m = -1;
	if ((*printevent&(1<<1))) {
/* Writing concatenation */
	    i__1[0] = 11, a__1[0] = "Expression ";
	    i__1[1] = relation_len, a__1[1] = relation;
	    i__1[2] = 8, a__1[2] = " became ";
	    s_cat(textline, a__1, i__1, &c__3, 200);
	    dymosimmessagedouble2_(textline, c__, " ( < 0).", 200, 8);
		DynLogEvents(-1, 0, 4, relation, 5, 0);
	}
    }
    if (*m != mold && ! (*init)) {
	*anyevent = TRUE_;
    }
    return 0;
} /* handleevent_ */

DYMOLA_STATIC void handleevent2(const char*rele,const char*sube,logical*ql,double*qp,double*qn,double eps,double qrel,logical init,int printevent,
			 logical*anyevent,logical ltz,logical invres,logical eventiter)
{
	/* New event logic for Modelica, 1999-08-25, Hans Olsson, Dynasim */
	/* In Modelica we can separate x>0,x>=0,x<0,x<=0 and we thus only need */
	/* one crossing-function and two states (e.g. x>0 or not x>0) */
	/* Furthermore the epsilon is only used if necesary, i.e. if we start close to zero. */
	/* qp is the epsilon we use and qn is the maximum allow epsilon (gives the sign). */
	double useqrel;
	logical res;
	useqrel = (eventiter) ? qrel - *qp : qrel;
	res=ltz ? (useqrel<0) : (useqrel>0);
	*qn = (res != ltz) ? - eps : eps;
	if (invres) res = !res;
	if (*ql != res || init) {
		if (!init) *anyevent=1;
		*qp=(Dymola_abs(qrel) < 100*eps || eventiter) ? *qn : *qn*1e-6;
		if ((printevent&(1<<1))) {
			char str[1000];
			sprintfC(str,"Expression %.400s became %s ( %.400s = %g )",rele,res?"true":"false",sube,qrel);
			DymosimMessage(str);
			DynLogEvents(-1, 0, 4, rele, res, 0);
		}
	} else {
		if (!eventiter && Dymola_abs(qrel)<eps) *qp = *qn;
	}
	*ql=res;
}

LIBDS_API void handleevent3(const char*relation,integer*m,doublereal*cp,doublereal*cn,doublereal c__,logical init,
						 integer printevent, doublereal eps, doublereal t,logical*anyevent,
						 logical eventiter,doublereal largeeps,logical convergenceproblem)
/* Subroutine */ 
{
    /* System generated locals */
    const char* a__1[3];
    integer i__1[3];
    /*doublereal d__1;*/

    /* Builtin functions */

    /* Local variables */
    integer mold;
    doublereal delta, epsequ;
    char textline[200];


/* EVENTMAN.FOR */

/* Implements decision table for events. */

/* CopyRight: 		(C) Dynasim AB, 1993-2001 */
/* Author:  		Hilding Elmqvist */
/* Date:    		December 3, 1999 */
/* Version: 		1.10 */
/* Revisions: */
/*   May 14, 1993	Disabling three-valued logic. */
/*   May 23, 1993	Introduced BooleanChanged. */
/*   May 31, 1993        Removed debug printouts. */
/*   July 28, 1993       Changed meaning of PrintEvent */
/*   September 30, 1993  Introduced call to disstr */
/*   November 9, 1993    Introduced hysteresis. */
/*   November 12, 1993   Rewritten - simplified */
/*   March 20, 1994      EpsEqu introduced for equality test (Otter) */
/*   October 24, 1996    Simplified code for output */
/*   November 23, 1997   Fortran code adapted to C code. */
/*                       EPSLON replaced by epsmch (more efficient). */
/*                      Real number (0.9) replaced by double number (0.9D0)*/
/*                       (Otter). */
/*   December 3, 1999    Introduced eventiter (Hans Olsson) rewrote and renamed it*/

/* PrintEvent: */
/*   >=5: Log < > == */

/* ---------------------------------------------------------- */
/* 		C < -Delta	-Delta <= C 	C > Delta */
/* 				and C <= Delta */

/* 		M = -1		M = 0		M = 1 */

/* ---------------------------------------------------------- */


    delta = eps / 1e5;
    if (init && !eventiter) {
		*m = -2;
    }
    mold = *m;
	/* new code: use one-sided crossing functions during event iterations */
	/* This introduces a necessary hysteresis */
	       if (mold == -1 && fabs(c__)<largeeps && eventiter && fabs(*cp)>eps && c__ <      *cp) {
		*cp = *cn =    fabs(*cp);
	} else if (mold ==  1 && fabs(c__)<largeeps && eventiter && fabs(*cp)>eps && c__ >      *cn) {
		*cp = *cn = -  fabs(*cp);
	/* dangerous code: try to increase epsilon during event iterations */
	/* Necessary for some hydraulics problem */
	} else if (eventiter && mold == -1 && c__ < largeeps && c__ > *cp && convergenceproblem) {
		double neweps;
		neweps=Dymola_min(Dymola_max(eps,largeeps),10*fabs(*cp));
		*cp = *cn =  neweps;
		if ((printevent&(1<<1))) {
			a__1[0]="Warning: Event epsilon of ";i__1[0]=strlen(a__1[0]);
			a__1[1]=relation; i__1[1]=strlen(relation);
			a__1[2]=" increased to "; i__1[2]=strlen(a__1[2]);
			s_cat(textline, a__1, i__1, &c__3, 200);
			dymosimmessagedouble_(textline,&neweps,200);
		}
		if (c__ > *cp) {
			*m =  1;
			*cp = *cn = - neweps;
		}
	} else if (eventiter && mold ==  1 && c__ >-largeeps && c__ < *cn && convergenceproblem) {
		double neweps;
		neweps=Dymola_min(Dymola_max(eps,largeeps),10*fabs(*cp));
		*cp = *cn = -neweps;
		if ((printevent&(1<<1))) {
			a__1[0]="Warning: Event epsilon of ";i__1[0]=strlen(a__1[0]);
			a__1[1]=relation; i__1[1]=strlen(relation);
			a__1[2]=" increased to "; i__1[2]=strlen(a__1[2]);
			s_cat(textline, a__1, i__1, &c__3, 200);
			dymosimmessagedouble_(textline,&neweps,200);
		}
		if (c__ < *cn) {
			*m =  -1;
			*cp = *cn =   neweps;
		}
	} else {
		if (eventiter && fabs(*cp)> eps) {
			/* keep previous increase*/
			*cp = fabs(*cp);
			*cn = -(*cp);
		} else {
			/* old code */
			*cp = eps;
			*cn = -(eps);
			epsequ = DBL_EPSILON * 10.;
			if (fabs(c__ - *cp) <= epsequ) {
			*cp = eps * .9;
			} else if (fabs(c__ - *cn) <= epsequ) {
			*cn = eps * -.9;
			}
		}
		if (c__ <= delta && c__ >= - delta)
			*m = 0;
		else if (c__ > delta)
			*m = 1;
		else if (c__ < - delta) 
			*m = -1;
	}
	if ((printevent&(1<<1)) && *m != mold && (!init||(printevent&(1<<2)))) {
		/* Common routines for writing result*/
	    i__1[0] = 11, a__1[0] = "Expression ";
	    i__1[1] = strlen(relation), a__1[1] =relation ;
	    i__1[2] = 8, a__1[2] = " became ";
	    s_cat(textline, a__1, i__1, &c__3, 200);
    if (*m==0) {
/* Writing concatenation */
	    dymosimmessagedouble2_(textline, &c__, " ( == 0).", 200, 9);
		DynLogEvents(-1, 0, 4, relation, 3, 0);
    } else if (*m == 1) {
/* Writing concatenation */
	    dymosimmessagedouble2_(textline, &c__, " ( > 0).", 200, 8);
		DynLogEvents(-1, 0, 4, relation, 4, 0);
    } else if (*m == -1) {
/* Writing concatenation */
	    dymosimmessagedouble2_(textline, &c__, " ( < 0).", 200, 8);
		DynLogEvents(-1, 0, 4, relation, 5, 0);
    }
	}
    if (*m != mold && ! init) {
	*anyevent = TRUE_;
    }
} /* handleevent_ */

#ifdef DYMOSIM
extern void DynCollectCrossingExpressions(int index, const char * const rele, const char * const sube);
#else
static void DynCollectCrossingExpressions(int index, const char * const rele, const char * const sube) { ; }
#endif

LIBDS_API logical handleevent5S(
	const char*rele,
	const char*sube,
	logical*ql,
	double*qp,
	double*qn,
	double eps,
	double qrel,
	double*qz,
	logical init,
	logical event,
	logical idemand4,
	int printevent,
	logical*anyevent,
	logical ltz,
	logical invres,
	logical*eventiter,
	double largeeps,
	logical convergenceproblem, double t, int firstIter, int index) {
	double useqrel;
	logical res;
	logical neg;
	int oldB = 0;
#ifdef GODESS
	useqrel = qrel;
	res = ltz ? (useqrel<0) : (useqrel>0);
	neg = res != ltz;
	if (event || init)
		*qp = *qn = neg ? -eps : eps;
	if (invres)
		res = !res;
	*ql = res;
	qz[0] = qz[1] = 0.1;
	return *ql;
#else /* GODESS */
	/* if *ql & 2 events are enabled. Only care about event iteration in that case. */
	useqrel = (*eventiter && (event || init) && (*ql & 2)) ? qrel - *qp : qrel;
	res = ltz ? (useqrel<0) : (useqrel>0);
	neg = res != ltz;
#ifdef DYMOSIM
	if (printevent & (1 << 1)) DynCollectCrossingExpressions(index, rele, sube);
	if (init) {
		extern int Check5(char*key);
		if (!Check5("")) {
			DymosimError("");
			return 0;
		}
	}
#endif /* DYMOSIM */
	if (firstIter && event && !*eventiter && !init) *ql = (*ql & 15) | (((*ql & 3) | 4) << 4);
	if (firstIter && event && !init) oldB = *ql & (16 | 32 | 64);
	if (event || init)
		*qn = neg ? -eps : eps;
	if (invres)
		res = !res;
	if ((idemand4) && (!(*ql&(2 | 4)))) {
		if ((*ql & 1) == res) {
			if (fabs(qrel)>0.1) {
				/* Did not have events enabled and far from turning point */
				*ql = 2 | res;
				*qp = *qn = neg ? -eps : eps; /* Remove any previous increase */
			}
		} else {
			*ql |= 4;
			/* Do not turn it on before the next event*/
			/* The problem is events that come and go */
			/*  */

			/*    Sketches explaining the problem.							    */
			/*    At some point in time we get a value far from the crossing.   */
			/*  Since smooth crossing may appear and reappear it could			*/
			/*    be any of the following:										*/
			/* 																    */
			/*  1															    */
			/*               *													*/
			/*             /													*/
			/*          /														*/
			/* ------------------												*/
			/*       /															*/
			/* 																	*/
			/* 2																*/
			/*                   *												*/
			/*                 /												*/
			/*               /													*/
			/* 																	*/
			/* -------------------												*/
			/* 																	*/
			/* 																	*/
			/* 																	*/
			/* 3																*/
			/* 																	*/
			/* 																	*/
			/*                 *												*/
			/* 			     /													*/
			/* 	 		    /													*/
			/* -------------/													*/
			/* --------------------------										*/
			/* 																	*/
			/* 4																*/
			/*                            *										*/
			/*                           /										*/
			/* /--\          /-\        /										*/
			/* ----\-------/----\------/										*/
			/*       \----/      \-----											*/
			/* 																	*/
			/* 																	*/
			/* 																	*/
			/* From the first evaluation at the end of a step					*/
			/* we cannot tell cases 1 and 2 apart.								*/
			/* If we enable rootfinding in the wrong state						*/
			/* it will look as though we have already passed the root           */
			/* which will confuse the logic.									*/
			/* 																	*/
			/* 																	*/
			/* The bit '1<<2=4' indicate that we potentially have				*/
			/* this problem. A future solution for cases 3 &4 would be          */
			/* to turn off this bit after every accepted step (accepted         */
			/* means that event handling is complete)							*/

		}
	}
	if ((event && ((*ql & 2) || fabs(qrel)>0.1) && res != (*ql & 1)) || init) {
		if (!init) {
			*anyevent = 1;
		}
		if (*eventiter) {
			if (Dymola_abs(qrel)<largeeps && convergenceproblem) {
				double neweps;
				neweps = Dymola_min(Dymola_max(eps, largeeps), Dymola_max(eps, 10 * fabs(*qp)));
				if (neweps>eps && (printevent&(1 << 1))) {
					char str[1000];
					sprintfC(str, "Warning: Event epsilon of %.400s increased to %g.\n", rele, neweps);
					DymosimMessage(str);
				}
				*qp = neg ? -neweps : neweps;
			} else {
				double d;
				d = fabs(*qp);
				if (d<eps) d = eps;
				/* keep old increase (if any) */
				*qp = neg ? -d : d;
			}
		} else {
			*qp = (Dymola_abs(qrel) < 100 * eps) ? *qn : *qn*1e-6;
		}
		if ((printevent&(1 << 1)) && (!init || (printevent&(1 << 2)) && !(*eventiter && (*ql & 1) == res))) {
			char str[1000];
			sprintfC(str, "Expression %.400s became %s ( %.400s = %g )", rele, res ? "true" : "false", sube, qrel);
			DymosimMessage(str);
			DynLogEvents(-1, 0, 4, rele, res, 0);
		}
		if (*eventiter)
			*ql = res | (*ql & 2); /* Keep events if iteration */
		else {
			*ql = res;
		}
		if (fabs(qrel)>0.1) *ql |= 2; /* Enable events if far from it */
	} else {
		if (oldB & 64) {
			/* Special logic - to handle iteratively solving a non-linear system of equations during an event iteration*/
			/* The problem is that the extra iteration can cause the change of result and result becoming large to happen */
			/* in subsequent iterations, breaking the logic above */
			if (((oldB&(32)) || fabs(qrel) > 0.1) && res != ((oldB & 16) >> 4)) {
				if ((printevent&(1 << 1)) && (!init || (printevent&(1 << 2)) && !(*eventiter && (*ql & 1) == res))) {
					char str[1000];
					sprintfC(str, "Expression %.400s became %s ( %.400s = %g )", rele, res ? "true" : "false", sube, qrel);
					DymosimMessage(str);
					DynLogEvents(-1, 0, 4, rele, res, 0);
				}
				*anyevent = 1;
				oldB = 0;
			}
		}
		if ((!*eventiter) && event) {
			if (fabs(qrel) <= 0.1) {
				*ql &= 1; /* Disable events */
			}
			/* if (eventiter): Keep increase of qp. */
			if (Dymola_abs(qrel)<eps)
				*qp = *qn; /* Reasonable value close to zero-crossing */
			else if (Dymola_abs(qrel)>largeeps && Dymola_abs(qrel) > 100 * eps)
				*qp = *qn * 1e-6; /* Decrease it if far from zero-crossing */
								  /* otherwise: keep old increase */
		}
		if (!(*ql & 2)) {
			/* Not event generating => noEvent */
			if (event)
				*ql = res; /* noEvent logic */
			else
				*ql = res | (*ql & 4); /* noEvent but keep disabling */
		}
		*ql |= oldB;
	}
	*eventiter = 1;

	qz[0] = 0.1;
	if (*ql & 2) {
		/* Enable event */
		if ((*ql & 1) != (ltz == invres)) {
			qz[0] = -qrel + fabs(*qp);
		} else {
			qz[0] = qrel + fabs(*qp);
		}
	}
	qz[1] = qz[0];
	return (*ql & 1);
#endif /* GODESS */
}
LIBDS_API logical handleevent4S(
	const char*rele,
	const char*sube,
	logical*ql,
	double*qp,
	double*qn,
	double eps,
	double qrel,
	double*qz,
	logical init,
	logical event,
	logical idemand4,
	int printevent,
	logical*anyevent,
	logical ltz,
	logical invres,
	logical*eventiter,
	double largeeps,
	logical convergenceproblem, double t) {
	return handleevent5S(rele, sube, ql, qp, qn, eps, qrel, qz, init, event, idemand4, printevent, anyevent, ltz, invres, eventiter, largeeps, convergenceproblem, t, 0, -1);
}
LIBDS_API void handleevent5(const char*rele,const char*sube,logical*ql,double*qp,double*qn,double eps,double qrel,logical init,int printevent,
			 logical*anyevent,logical*anyevent2,logical ltz,logical invres,logical eventiter,doublereal largeeps,logical convergenceproblem,int index)
{
	/* New event logic for Modelica, 1999-08-25, Hans Olsson, Dynasim */
	/* In Modelica we can separate x>0,x>=0,x<0,x<=0 and we thus only need */
	/* one crossing-function and two states (e.g. x>0 or not x>0) */
	/* Furthermore the epsilon is only used if necesary, i.e. if we start close to zero. */
	/* qp is the epsilon we use and qn is the maximum allow normal epsilon (gives the sign). */
	/* 1999-12-03 Allowed even further increase of qp during event iterations, but give warning in these cases. */
	double useqrel;
	logical res;
	logical neg;
	if (printevent & (1 << 1)) DynCollectCrossingExpressions(index, rele, sube);
	useqrel = eventiter ? qrel - *qp : qrel;
	res=ltz ? (useqrel<0) : (useqrel>0);
	neg=res != ltz;
	*qn = neg ? - eps : eps;
#ifdef DYMOSIM
	if (init) {
			extern int Check5(char*key);
			if (!Check5("")) {
				DymosimError("");
				return ;
			}
		}
#endif /* DYMOSIM */
	if (invres) 
		res = !res;
	if (*ql != res || init) {
		if (!init) {
			*anyevent=1;
			if (anyevent2) *anyevent2=1;
		}
		if (eventiter) {
			if (Dymola_abs(qrel)<largeeps && convergenceproblem) {
				double neweps;
				neweps=Dymola_min(Dymola_max(eps,largeeps),Dymola_max(eps,10*fabs(*qp)));
				if (neweps>eps && (printevent&(1<<1))) {
					char str[1000];
					sprintfC(str,"Warning: Event epsilon of %.400s increased to %g.\n",rele,neweps);
					DymosimMessage(str);
				}
				*qp = neg ? -neweps : neweps;
			} else {
				double d;
				d=fabs(*qp);
				if (d<eps) d=eps;
				/* keep old increase (if any) */
				*qp = neg ? -d : d;
			}
		} else {
			*qp=(Dymola_abs(qrel) < 100*eps) ? *qn : *qn*1e-6;
		}
		if ((printevent&(1<<1)) && (!init || (printevent&(1<<2)) && !(eventiter && *ql==res))) {
			char str[1000];
			sprintfC(str,"Expression %.400s became %s ( %.400s = %g )",rele,res?"true":"false",sube,qrel);
			DymosimMessage(str);
			DynLogEvents(-1, 0, 4, rele, res, 0);
		}
	} else if (!eventiter) {
		if (Dymola_abs(qrel)<eps) 
			*qp = *qn; /* Reasonable value close to zero-crossing */
		else if (Dymola_abs(qrel)>largeeps && Dymola_abs(qrel) > 100*eps) 
			*qp = *qn * 1e-6; /* Decrease it if far from zero-crossing */
		/* otherwise: keep old increase */
	} /* if (eventiter): Keep increase of qp. */
	*ql=res;
}
LIBDS_API void handleevent4(const char*rele,const char*sube,logical*ql,double*qp,double*qn,double eps,double qrel,logical init,int printevent,
			 logical*anyevent,logical ltz,logical invres,logical eventiter,doublereal largeeps,logical convergenceproblem,int index)
{
	handleevent5(rele, sube, ql, qp, qn, eps, qrel, init, printevent, anyevent, 0, ltz, invres, eventiter,largeeps, convergenceproblem, index);
}


LIBDS_API void roundEvent5(const char*expr,double (*func)(double),double qrel,double*val,double*fuzz,double eps,
						logical posi,logical negi,logical reli,
						logical init,logical printevent,logical *anyevent,logical *anyevent2,logical eventiter,double leps,logical slow, int index)
{
	/* For now: ignore eventiter. */
	double res;	
	if (printevent & (1 << 1)) DynCollectCrossingExpressions(index, expr, "");
	res= (*func)(qrel);
	*fuzz=eps;
	if (res!=*val) {
		if (!init) {
			*anyevent = 1;
			if (anyevent2) *anyevent2=1;
		}
		if ((printevent&(1<<1)) && (!init || (printevent&(1<<2)))) {
			char str[1000];
			sprintfC(str,"Expression %.400s became %g ( unrounded = %.12g )",
				expr,res,qrel);
			DymosimMessage(str);
			DynLogEvents(-1, 0, 4, expr, 2, res);
		}
	}
	*val = res;
}
LIBDS_API void roundEvent4(const char*expr,double (*func)(double),double qrel,double*val,double*fuzz,double eps,
						logical posi,logical negi,logical reli,
						logical init,logical printevent,logical *anyevent,logical eventiter,double leps,logical slow, int index)
{
	roundEvent5(expr,func,qrel,val,fuzz,eps,posi,negi,reli,init,printevent,anyevent,0,eventiter,leps,slow,index);
}

/* Subroutine */ LIBDS_API int booleanchanged_(varname, var, newvar, printevent, 
	anyevent, varname_len)
const char *varname;
logical *var, *newvar;
integer *printevent;
logical *anyevent;
ftnlen varname_len;
{
    /* System generated locals */
    const char* a__1[4];
    integer i__1[4];

    /* Builtin functions */

    /* Local variables */
    char newval[6], textline[200];


/* Logs changes to boolean state variables. */


    if (*var != *newvar) {
	*anyevent = TRUE_;
	if (*printevent&(1<<1)) {
	    if (*newvar) {
		s_copy(newval, "true.", 6, 5);
		DynLogEvents(-1, 0, 4, varname, 1, 1);
	    } else {
		s_copy(newval, "false.", 6, 6);
		DynLogEvents(-1, 0, 4, varname, 0, 0);
	    }
/* Writing concatenation */
	    i__1[0] = 9, a__1[0] = "Variable ";
	    i__1[1] = varname_len, a__1[1] = varname;
	    i__1[2] = 12, a__1[2] = " changed to ";
	    i__1[3] = 6, a__1[3] = newval;
	    s_cat(textline, a__1, i__1, &c__4, 200);
	    dymosimmessage_(textline, 200);
	}
    }
    return 0;
} /* booleanchanged_ */


#ifndef GODESS
/* Subroutine */ DYMOLA_STATIC int dgeequ_(integer *m, integer *n, doublereal *a, integer *
	lda, doublereal *r__, doublereal *c__, doublereal *rowcnd, doublereal 
	*colcnd, doublereal *amax, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;
    doublereal d__1, d__2, d__3;

    /* Local variables */
    integer i__, j;
    doublereal rcmin, rcmax;
    doublereal bignum, smlnum;

/*  -- LAPACK computational routine (version 3.4.0) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     November 2011 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. External Subroutines .. */
/*     .. */
/*     .. Intrinsic Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Test the input parameters. */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --r__;
    --c__;

    /* Function Body */
    *info = 0;
    if (*m < 0) {
	*info = -1;
    } else if (*n < 0) {
	*info = -2;
    } else if (*lda < Dymola_max(1,*m)) {
	*info = -4;
    }
    if (*info != 0) {
	i__1 = -(*info);
	xerbla_("DGEEQU", &i__1);
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0) {
	*rowcnd = 1.;
	*colcnd = 1.;
	*amax = 0.;
	return 0;
    }

/*     Get machine constants. */

    smlnum = dlamch_("S");
    bignum = 1. / smlnum;

/*     Compute row scale factors. */

    i__1 = *m;
    for (i__ = 1; i__ <= i__1; ++i__) {
	r__[i__] = 0.;
/* L10: */
    }

/*     Find the maximum element in each row. */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
	i__2 = *m;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* Computing MAX */
	    d__2 = r__[i__], d__3 = (d__1 = a[i__ + j * a_dim1], Dymola_abs(d__1));
	    r__[i__] = Dymola_max(d__2,d__3);
/* L20: */
	}
/* L30: */
    }

/*     Find the maximum and minimum scale factors. */

    rcmin = bignum;
    rcmax = 0.;
    i__1 = *m;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* Computing MAX */
	d__1 = rcmax, d__2 = r__[i__];
	rcmax = Dymola_max(d__1,d__2);
/* Computing MIN */
	d__1 = rcmin, d__2 = r__[i__];
	rcmin = Dymola_min(d__1,d__2);
/* L40: */
    }
    *amax = rcmax;

    if (rcmin == 0.) {

/*        Find the first zero scale factor and return an error code. */

	i__1 = *m;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    if (r__[i__] == 0.) {
		*info = i__;
		return 0;
	    }
/* L50: */
	}
    } else {

/*        Invert the scale factors. */

	i__1 = *m;
	for (i__ = 1; i__ <= i__1; ++i__) {
/* Computing MIN */
/* Computing MAX */
	    d__2 = r__[i__];
	    d__1 = Dymola_max(d__2,smlnum);
	    r__[i__] = 1. / Dymola_min(d__1,bignum);
/* L60: */
	}

/*        Compute ROWCND = min(R(I)) / max(R(I)) */

	*rowcnd = Dymola_max(rcmin,smlnum) / Dymola_min(rcmax,bignum);
    }

/*     Compute column scale factors */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
	c__[j] = 0.;
/* L70: */
    }

/*     Find the maximum element in each column, */
/*     assuming the row scaling computed above. */

    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
	i__2 = *m;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* Computing MAX */
	    d__2 = c__[j], d__3 = (d__1 = a[i__ + j * a_dim1], Dymola_abs(d__1)) * 
		    r__[i__];
	    c__[j] = Dymola_max(d__2,d__3);
/* L80: */
	}
/* L90: */
    }

/*     Find the maximum and minimum scale factors. */

    rcmin = bignum;
    rcmax = 0.;
    i__1 = *n;
    for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
	d__1 = rcmin, d__2 = c__[j];
	rcmin = Dymola_min(d__1,d__2);
/* Computing MAX */
	d__1 = rcmax, d__2 = c__[j];
	rcmax = Dymola_max(d__1,d__2);
/* L100: */
    }

    if (rcmin == 0.) {

/*        Find the first zero scale factor and return an error code. */

	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    if (c__[j] == 0.) {
		*info = *m + j;
		return 0;
	    }
/* L110: */
	}
    } else {

/*        Invert the scale factors. */

	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
/* Computing MAX */
	    d__2 = c__[j];
	    d__1 = Dymola_max(d__2,smlnum);
	    c__[j] = 1. / Dymola_min(d__1,bignum);
/* L120: */
	}

/*        Compute COLCND = min(C(J)) / max(C(J)) */

	*colcnd = Dymola_max(rcmin,smlnum) / Dymola_min(rcmax,bignum);
    }

    return 0;

/*     End of DGEEQU */

} /* dgeequ_ */

/* Subroutine */ DYMOLA_STATIC int dlaqge_(integer *m, integer *n, doublereal *a, integer *lda, doublereal *r__, doublereal *c__, doublereal *rowcnd, doublereal *colcnd, doublereal *amax, char *equed)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    integer i__, j;
    doublereal cj, large, small;

/*  -- LAPACK auxiliary routine (version 3.4.2) -- */
/*  -- LAPACK is a software package provided by Univ. of Tennessee,    -- */
/*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..-- */
/*     September 2012 */

/*     .. Scalar Arguments .. */
/*     .. */
/*     .. Array Arguments .. */
/*     .. */

/*  ===================================================================== */

/*     .. Parameters .. */
/*     .. */
/*     .. Local Scalars .. */
/*     .. */
/*     .. External Functions .. */
/*     .. */
/*     .. Executable Statements .. */

/*     Quick return if possible */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --r__;
    --c__;

    /* Function Body */
    if (*m <= 0 || *n <= 0) {
	*(unsigned char *)equed = 'N';
	return 0;
    }

/*     Initialize LARGE and SMALL. */

    small = dlamch_("Safe minimum") / dlamch_("Precision");
    large = 1. / small;

    if (*rowcnd >= .1 && *amax >= small && *amax <= large) {

/*        No row scaling */

	if (*colcnd >= .1) {

/*           No column scaling */

	    *(unsigned char *)equed = 'N';
	} else {

/*           Column scaling */

	    i__1 = *n;
	    for (j = 1; j <= i__1; ++j) {
		cj = c__[j];
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    a[i__ + j * a_dim1] = cj * a[i__ + j * a_dim1];
/* L10: */
		}
/* L20: */
	    }
	    *(unsigned char *)equed = 'C';
	}
    } else if (*colcnd >= .1) {

/*        Row scaling, no column scaling */

	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *m;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		a[i__ + j * a_dim1] = r__[i__] * a[i__ + j * a_dim1];
/* L30: */
	    }
/* L40: */
	}
	*(unsigned char *)equed = 'R';
    } else {

/*        Row and column scaling */

	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    cj = c__[j];
	    i__2 = *m;
	    for (i__ = 1; i__ <= i__2; ++i__) {
		a[i__ + j * a_dim1] = cj * r__[i__] * a[i__ + j * a_dim1];
/* L50: */
	    }
/* L60: */
	}
	*(unsigned char *)equed = 'B';
    }

    return 0;

/*     End of DLAQGE */

} /* dlaqge_ */

#endif

#ifndef DYMOSIM
#undef DynLogEvents
#define DynLogEvents(action, time, event_type, expression, iresult, result) 0
#endif

#endif
     #define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model Modelica.Electrical.Analog.Examples.CauerLowPassAnalog
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Tue Nov  5 10:05:18 2019

   */
#ifndef DYN_MULTINSTANCE
#define DYN_MULTINSTANCE 1
#endif

#include <matrixop.h>
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    5
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    51
#define NP_    14
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 2110224657
#define NHash2_ -1774208929
#define NHash3_ 226498513
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    31
#define SizePre_ 0
#define SizeEq_ 7
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 88
#define NGlobalHelpI_ 20
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="Modelica.Electrical.Analog.Examples.CauerLowPassAnalog";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/meagh/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
DYMOLA_STATIC const char*GUIDString="{a36f8d12-fcaf-4a63-a80c-7d2dd468862f}";
DYMOLA_STATIC const double cvodeTolerance=1E-05;
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[21]={4 , 1 , 1 , 2 , 2 , 4 , 1 , 3 , 1 , 5 , 4 , 1
   , 1 , 2 , 2 , 4 , 1 , 3 , 1 , 5 , 0};
DYMOLA_STATIC int QJacobianGC_[41]={
1 , 1 , 1 , 1 , 0 , 4 , 4 , 4 , 2 , 2 , 3 , 3 , 3 , 0 , 3 , 5 , 5 , 5 , 0 , 0 , 1
   , 1 , 1 , 1 , 0 , 4 , 4 , 4 , 2 , 2 , 3 , 3 , 3 , 0 , 3 , 5 , 5 , 5 , 0 , 0
   , 0};
DYMOLA_STATIC double QJacobianCD_[6]={0  , 44 , 50 , 54 , 70 , 64};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,36) = false;
DYNX(W_,43) = false;
DYNX(W_,2) = 0;
DYNX(W_,5) = 0.0;
DYNX(W_,14) = 0.0;
DYNX(W_,23) = 0.0;
DYNX(W_,41) = 0.0;
DYNX(W_,47) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,0) = divinvGuarded(2.906997720064*DYNX(DP_,0),"2.906997720064*l1");
DYNX(W_,1) = divinvGuarded(1.392270203025*DYNX(DP_,1),"1.392270203025*l2");
DYNX(W_,7) = DYNX(DP_,2);
DYNX(W_,12) = DYNX(W_,0);
DYNX(W_,16) = DYNX(DP_,3);
DYNX(W_,21) = DYNX(W_,1);
DYNX(W_,25) = DYNX(DP_,4);
DYNX(W_,28) = DYNX(DP_,0);
DYNX(W_,31) = DYNX(DP_,1);
DYNX(W_,37) = DYNX(DP_,6);
DYNX(W_,44) = DYNX(DP_,9);
DYNX(W_,48) = DYNX(DP_,11);
DYNX(W_,49) = DYNX(DP_,12);
DYNX(W_,50) = DYNX(DP_,13);
BoundParameterConstantSection
DYNX(W_,39) = DYNX(DP_,5)*(1+DYNX(DP_,7)*(DYNX(W_,37)-DYNX(DP_,6)));
DYNX(W_,46) = DYNX(DP_,8)*(1+DYNX(DP_,10)*(DYNX(W_,44)-DYNX(DP_,9)));
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,8) = 0;
DYNX(W_,17) = 0;
#endif
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,49) = DYNX(DP_,12);
DYNX(W_,50) = DYNX(DP_,13);
DYNX(W_,48) = DYNX(DP_,11);
DYNX(W_,34) = DYNX(W_,49)+(IF LessTime(DYNX(W_,50), 0) THEN 0 ELSE DYNX(W_,48));
DYNX(W_,32) = DYNX(W_,34)-DYNX(X_,0);
DYNX(W_,37) = DYNX(DP_,6);
AssertModelica(1+DYNX(DP_,7)*(DYNX(W_,37)-DYNX(DP_,6)) >= 1E-15,"1+R1.alpha*(R1.T-R1.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,39) = DYNX(DP_,5)*(1+DYNX(DP_,7)*(DYNX(W_,37)-DYNX(DP_,6)));
 /* Linear system of equations to solve. */
DYNX(W_,33) = 0.0;
SolveScalarLinear( -DYNX(W_,39)," -R1.R_actual",  -DYNX(W_,32)," -R1.v", 
  DYNX(W_,33),"R1.i");
 /* End of Equation Block */ 

DYNX(W_,44) = DYNX(DP_,9);
AssertModelica(1+DYNX(DP_,10)*(DYNX(W_,44)-DYNX(DP_,9)) >= 1E-15,
  "1+R2.alpha*(R2.T-R2.T_ref) >= 1E-15", "Temperature outside scope of model!");
DYNX(W_,46) = DYNX(DP_,8)*(1+DYNX(DP_,10)*(DYNX(W_,44)-DYNX(DP_,9)));
 /* Linear system of equations to solve. */
DYNX(W_,40) = 0.0;
SolveScalarLinear( -DYNX(W_,46)," -R2.R_actual",  -DYNX(X_,2)," -C5.v", 
  DYNX(W_,40),"R2.i");
 /* End of Equation Block */ 

DYNX(W_,0) = divinvGuarded(2.906997720064*DYNX(DP_,0),"2.906997720064*l1");
DYNX(W_,12) = DYNX(W_,0);
DYNX(W_,7) = DYNX(DP_,2);
DYNX(W_,1) = divinvGuarded(1.392270203025*DYNX(DP_,1),"1.392270203025*l2");
DYNX(W_,21) = DYNX(W_,1);
DYNX(W_,25) = DYNX(DP_,4);
DYNX(W_,16) = DYNX(DP_,3);

 /* Linear system of equations to solve. */
/* Tag: extended initialization.linear[1] */
/* Introducing 2 common subexpressions used in 2 expressions */
/* Of the common subexpressions 2 are reals, 0 are integers, and 0
   are booleans. */
/* Automatic tearing of linear system of 10 simultaneous equations
gave a linear system of 3 equations for numerical solution.*/
{
  const char*const varnames_[]={"C5.der(v)", "C1.der(v)", "C3.der(v)"};
  const double nominal_[]={1, 1, 1};
  DidLinearSystemOfEquations(J, b, y, 3, DYNX(DYNhelp,0), 42, DYNX(did_->helpvari_vec,0), 10);
  /* Parameter dependent Jacobian */
  if (NewParametersJac) SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    DYNX(DYNhelp,42) = (-1.0)*DYNX(W_,12);
    DYNX(DYNhelp,43) = (-1.0)*DYNX(W_,21);
    SetMatrixLeading(J, 1, 2, 3, DYNX(W_,7)+DYNX(W_,12));
    SetMatrixLeading(J, 1, 3, 3, DYNX(DYNhelp,42));
    SetMatrixLeading(J, 2, 1, 3, DYNX(DYNhelp,43));
    SetMatrixLeading(J, 2, 2, 3, DYNX(DYNhelp,42));
    SetMatrixLeading(J, 2, 3, 3, DYNX(W_,12)+DYNX(W_,16)+DYNX(W_,21));
    SetMatrixLeading(J, 3, 1, 3, DYNX(W_,21)+DYNX(W_,25));
    SetMatrixLeading(J, 3, 3, 3, DYNX(DYNhelp,43));
  }
  SetVector(b, 1, DYNX(W_,33)-DYNX(X_,3));
  SetVector(b, 2, DYNX(X_,3)-DYNX(X_,4));
  SetVector(b, 3, DYNX(X_,4)-DYNX(W_,40));
  SetVector(y, 1, 0.0);
  SetVector(y, 2, 0.0);
  SetVector(y, 3, 0.0);
  SolveLinearSystemOfEquations(J, b, y, 1);
  DYNX(F_,2) = GetVector(y, 1);
  DYNX(F_,0) = GetVector(y, 2);
  DYNX(F_,1) = GetVector(y, 3);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,4) = DYNX(W_,7)*DYNX(F_,0);
DYNX(W_,9) = DYNX(F_,0)-DYNX(F_,1);
DYNX(W_,10) = DYNX(W_,12)*DYNX(W_,9);
DYNX(W_,13) = DYNX(W_,16)*DYNX(F_,1);
DYNX(W_,18) = DYNX(F_,1)-DYNX(F_,2);
DYNX(W_,19) = DYNX(W_,21)*DYNX(W_,18);
DYNX(W_,22) = DYNX(W_,25)*DYNX(F_,2);
 /* End of Equation Block */ 

DYNX(W_,26) = DYNX(X_,0)-DYNX(X_,1);
DYNX(W_,28) = DYNX(DP_,0);
 /* Linear system of equations to solve. */
DYNX(F_,3) = 0.0;
SolveScalarLinear(DYNX(W_,28),"L1.L", DYNX(W_,26),"L1.v", DYNX(F_,3),"der(L1.i)");
 /* End of Equation Block */ 

DYNX(W_,29) = DYNX(X_,1)-DYNX(X_,2);
DYNX(W_,31) = DYNX(DP_,1);
 /* Linear system of equations to solve. */
DYNX(F_,4) = 0.0;
SolveScalarLinear(DYNX(W_,31),"L2.L", DYNX(W_,29),"L2.v", DYNX(F_,4),"der(L2.i)");
 /* End of Equation Block */ 

InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(W_,34) = DYNX(W_,49)+(IF LessTime(DYNX(W_,50), 0) THEN 0 ELSE DYNX(W_,48));
DYNX(W_,32) = DYNX(W_,34)-DYNX(X_,0);
 /* Linear system of equations to solve. */
DYNX(W_,33) = RememberSimple_(DYNX(W_,33), 0);
SolveScalarLinearParametric( -DYNX(W_,39)," -R1.R_actual",  -DYNX(W_,32),
  " -R1.v", DYNX(W_,33),"R1.i");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
DYNX(W_,40) = RememberSimple_(DYNX(W_,40), 1);
SolveScalarLinearParametric( -DYNX(W_,46)," -R2.R_actual",  -DYNX(X_,2)," -C5.v",
   DYNX(W_,40),"R2.i");
 /* End of Equation Block */ 


 /* Linear system of equations to solve. */
/* Tag: simulation.linear[1] */
/* Introducing 6 common subexpressions used in 2 expressions */
/* Of the common subexpressions 6 are reals, 0 are integers, and 0
   are booleans. */
/* Automatic tearing of linear system of 10 simultaneous equations
gave a linear system of 3 equations for numerical solution.*/
{
  const char*const varnames_[]={"C1.der(v)", "C3.der(v)", "C5.der(v)"};
  const double nominal_[]={1, 1, 1};
  DidLinearSystemOfEquations(J, b, y, 3, DYNX(DYNhelp,44), 42, DYNX(did_->helpvari_vec,10), 10);
  /* Parameter dependent Jacobian */
  if (NewParametersJac) SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    DYNX(DYNhelp,86) = (-1.0)*DYNX(W_,12);
    DYNX(DYNhelp,87) = (-1.0)*DYNX(W_,21);
    SetMatrixLeading(J, 1, 1, 3, DYNX(W_,7)+DYNX(W_,12));
    SetMatrixLeading(J, 1, 2, 3, DYNX(DYNhelp,86));
    SetMatrixLeading(J, 2, 1, 3, DYNX(DYNhelp,86));
    SetMatrixLeading(J, 2, 2, 3, DYNX(W_,12)+DYNX(W_,16)+DYNX(W_,21));
    SetMatrixLeading(J, 2, 3, 3, DYNX(DYNhelp,87));
    SetMatrixLeading(J, 3, 2, 3, DYNX(DYNhelp,87));
    SetMatrixLeading(J, 3, 3, 3, DYNX(W_,21)+DYNX(W_,25));
  }
  SetVector(b, 1, DYNX(W_,33)-DYNX(X_,3));
  SetVector(b, 2, DYNX(X_,3)-DYNX(X_,4));
  SetVector(b, 3, DYNX(X_,4)-DYNX(W_,40));
  SetVector(y, 1, RememberSimple_(DYNX(F_,0), 2));
  SetVector(y, 2, RememberSimple_(DYNX(F_,1), 3));
  SetVector(y, 3, RememberSimple_(DYNX(F_,2), 4));
  SolveLinearSystemOfEquations(J, b, y, 2);
  DYNX(F_,0) = GetVector(y, 1);
  DYNX(F_,1) = GetVector(y, 2);
  DYNX(F_,2) = GetVector(y, 3);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,4) = DYNX(W_,7)*DYNX(F_,0);
DYNX(W_,9) = DYNX(F_,0)-DYNX(F_,1);
DYNX(W_,10) = DYNX(W_,12)*DYNX(W_,9);
DYNX(W_,13) = DYNX(W_,16)*DYNX(F_,1);
DYNX(W_,18) = DYNX(F_,1)-DYNX(F_,2);
DYNX(W_,19) = DYNX(W_,21)*DYNX(W_,18);
DYNX(W_,22) = DYNX(W_,25)*DYNX(F_,2);
 /* End of Equation Block */ 

DYNX(W_,26) = DYNX(X_,0)-DYNX(X_,1);
 /* Linear system of equations to solve. */
DYNX(F_,3) = RememberSimple_(DYNX(F_,3), 5);
SolveScalarLinearParametric(DYNX(W_,28),"L1.L", DYNX(W_,26),"L1.v", DYNX(F_,3),
  "der(L1.i)");
 /* End of Equation Block */ 

DYNX(W_,29) = DYNX(X_,1)-DYNX(X_,2);
 /* Linear system of equations to solve. */
DYNX(F_,4) = RememberSimple_(DYNX(F_,4), 6);
SolveScalarLinearParametric(DYNX(W_,31),"L2.L", DYNX(W_,29),"L2.v", DYNX(F_,4),
  "der(L2.i)");
 /* End of Equation Block */ 

DYNX(W_,6) =  -DYNX(W_,4);
DYNX(W_,11) =  -DYNX(W_,10);
DYNX(W_,15) =  -DYNX(W_,13);
DYNX(W_,20) =  -DYNX(W_,19);
DYNX(W_,24) =  -DYNX(W_,22);
DYNX(W_,35) =  -DYNX(W_,33);
DYNX(W_,42) =  -DYNX(W_,40);

AcceptedSection1

AcceptedSection2
DYNX(W_,17) = DYNX(X_,1)-DYNX(X_,2);
DYNX(W_,8) = DYNX(X_,0)-DYNX(X_,1);
DYNX(W_,3) = DYNX(W_,4)+DYNX(W_,13)+DYNX(W_,22)+DYNX(W_,40)-DYNX(W_,33);
DYNX(W_,38) = DYNX(W_,32)*DYNX(W_,33);
DYNX(W_,45) = DYNX(X_,2)*DYNX(W_,40);
DYNX(W_,27) =  -DYNX(X_,3);
DYNX(W_,30) =  -DYNX(X_,4);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("l1", "filter coefficient I1 [H]", 0, 1.304, 0.0,0.0,0.0,0,560)
DeclareParameter("l2", "filter coefficient I2 [H]", 1, 0.8586, 0.0,0.0,0.0,0,560)
DeclareParameter("c1", "filter coefficient c1 [F]", 2, 1.072, 0.0,1E+100,0.0,0,560)
DeclareVariable("c2", "filter coefficient c2 [F]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("c3", "filter coefficient c3 [F]", 3, 1.682, 0.0,1E+100,0.0,0,560)
DeclareVariable("c4", "filter coefficient c4 [F]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("c5", "filter coefficient c5 [F]", 4, 0.7262, 0.0,1E+100,0.0,0,560)
DeclareVariable("G.p.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("G.p.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareState("C1.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 0, 0, \
0.0,0.0,0.0,0,560)
DeclareDerivative("C1.der(v)", "der(Voltage drop of the two pins (= p.v - n.v)) [V/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("C1.i", "Current flowing from pin p to pin n [A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("C1.p.v", "Potential at the pin [V]", "C1.v", 1, 1, 0, 4)
DeclareAlias2("C1.p.i", "Current flowing into the pin [A]", "C1.i", 1, 5, 4, 132)
DeclareVariable("C1.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("C1.n.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("C1.C", "Capacitance [F]", 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("C2.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("C2.der(v)", "der(Voltage drop of the two pins (= p.v - n.v)) [V/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("C2.i", "Current flowing from pin p to pin n [A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("C2.p.v", "Potential at the pin [V]", "C1.v", 1, 1, 0, 4)
DeclareAlias2("C2.p.i", "Current flowing into the pin [A]", "C2.i", 1, 5, 10, 132)
DeclareAlias2("C2.n.v", "Potential at the pin [V]", "C3.v", 1, 1, 1, 4)
DeclareVariable("C2.n.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("C2.C", "Capacitance [F]", 1, 0.0,1E+100,0.0,0,513)
DeclareState("C3.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 1, 0, \
0.0,0.0,0.0,0,560)
DeclareDerivative("C3.der(v)", "der(Voltage drop of the two pins (= p.v - n.v)) [V/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("C3.i", "Current flowing from pin p to pin n [A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("C3.p.v", "Potential at the pin [V]", "C3.v", 1, 1, 1, 4)
DeclareAlias2("C3.p.i", "Current flowing into the pin [A]", "C3.i", 1, 5, 13, 132)
DeclareVariable("C3.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("C3.n.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("C3.C", "Capacitance [F]", 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("C4.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("C4.der(v)", "der(Voltage drop of the two pins (= p.v - n.v)) [V/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("C4.i", "Current flowing from pin p to pin n [A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("C4.p.v", "Potential at the pin [V]", "C3.v", 1, 1, 1, 4)
DeclareAlias2("C4.p.i", "Current flowing into the pin [A]", "C4.i", 1, 5, 19, 132)
DeclareAlias2("C4.n.v", "Potential at the pin [V]", "C5.v", 1, 1, 2, 4)
DeclareVariable("C4.n.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("C4.C", "Capacitance [F]", 1, 0.0,1E+100,0.0,0,513)
DeclareState("C5.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 2, 0, \
0.0,0.0,0.0,0,560)
DeclareDerivative("C5.der(v)", "der(Voltage drop of the two pins (= p.v - n.v)) [V/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("C5.i", "Current flowing from pin p to pin n [A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("C5.p.v", "Potential at the pin [V]", "C5.v", 1, 1, 2, 4)
DeclareAlias2("C5.p.i", "Current flowing into the pin [A]", "C5.i", 1, 5, 22, 132)
DeclareVariable("C5.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("C5.n.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("C5.C", "Capacitance [F]", 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("L1.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareState("L1.i", "Current flowing from pin p to pin n [A]", 3, 0, 0.0,0.0,\
0.0,0,560)
DeclareDerivative("L1.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("L1.p.v", "Potential at the pin [V]", "C1.v", 1, 1, 0, 4)
DeclareAlias2("L1.p.i", "Current flowing into the pin [A]", "L1.i", 1, 1, 3, 132)
DeclareAlias2("L1.n.v", "Potential at the pin [V]", "C3.v", 1, 1, 1, 4)
DeclareVariable("L1.n.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("L1.L", "Inductance [H]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("L2.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareState("L2.i", "Current flowing from pin p to pin n [A]", 4, 0, 0.0,0.0,\
0.0,0,560)
DeclareDerivative("L2.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("L2.p.v", "Potential at the pin [V]", "C3.v", 1, 1, 1, 4)
DeclareAlias2("L2.p.i", "Current flowing into the pin [A]", "L2.i", 1, 1, 4, 132)
DeclareAlias2("L2.n.v", "Potential at the pin [V]", "C5.v", 1, 1, 2, 4)
DeclareVariable("L2.n.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("L2.L", "Inductance [H]", 1, 0.0,0.0,0.0,0,513)
DeclareParameter("R1.R", "Resistance at temperature T_ref [Ohm]", 5, 1, 0.0,0.0,\
0.0,0,560)
DeclareParameter("R1.T_ref", "Reference temperature [K|degC]", 6, 300.15, 0.0,\
1E+100,300.0,0,560)
DeclareParameter("R1.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 7, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("R1.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("R1.i", "Current flowing from pin p to pin n [A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("R1.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,648)
DeclareAlias2("R1.p.i", "Current flowing into the pin [A]", "R1.i", 1, 5, 33, 132)
DeclareAlias2("R1.n.v", "Potential at the pin [V]", "C1.v", 1, 1, 0, 4)
DeclareVariable("R1.n.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("R1.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("R1.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("R1.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("R1.T_heatPort", "Temperature of heatPort [K|degC]", "R1.T", 1, 5,\
 37, 0)
DeclareVariable("R1.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("R2.R", "Resistance at temperature T_ref [Ohm]", 8, 1, 0.0,0.0,\
0.0,0,560)
DeclareParameter("R2.T_ref", "Reference temperature [K|degC]", 9, 300.15, 0.0,\
1E+100,300.0,0,560)
DeclareParameter("R2.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 10, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("R2.v", "Voltage drop of the two pins (= p.v - n.v) [V]", "C5.v", 1,\
 1, 2, 0)
DeclareVariable("R2.i", "Current flowing from pin p to pin n [A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("R2.p.v", "Potential at the pin [V]", "C5.v", 1, 1, 2, 4)
DeclareAlias2("R2.p.i", "Current flowing into the pin [A]", "R2.i", 1, 5, 40, 132)
DeclareVariable("R2.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("R2.n.i", "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("R2.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("R2.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("R2.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("R2.T_heatPort", "Temperature of heatPort [K|degC]", "R2.T", 1, 5,\
 44, 0)
DeclareVariable("R2.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("V.V", "Height of step [V]", 11, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("V.v", "Voltage drop of the two pins (= p.v - n.v) [V]", "R1.p.v", 1,\
 5, 34, 64)
DeclareAlias2("V.i", "Current flowing from pin p to pin n [A]", "R1.n.i", 1, 5, 35,\
 0)
DeclareAlias2("V.p.v", "Potential at the pin [V]", "R1.p.v", 1, 5, 34, 4)
DeclareAlias2("V.p.i", "Current flowing into the pin [A]", "R1.n.i", 1, 5, 35, 132)
DeclareVariable("V.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("V.n.i", "Current flowing into the pin [A]", "R1.i", 1, 5, 33, 132)
DeclareParameter("V.offset", "Voltage offset [V]", 12, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("V.startTime", "Time offset [s]", 13, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("V.signalSource.height", "Height of step [V]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareAlias2("V.signalSource.y", "Connector of Real output signal [V]", \
"R1.p.v", 1, 5, 34, 0)
DeclareVariable("V.signalSource.offset", "Offset of output signal y [V]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("V.signalSource.startTime", "Output y = offset for time < startTime [s]",\
 0.0, 0.0,0.0,0.0,0,513)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(W_,33), 0.0, 0);
DoRemember_(DYNX(W_,40), 0.0, 1);
DoRemember_(DYNX(F_,0), 0.0, 2);
DoRemember_(DYNX(F_,1), 0.0, 3);
DoRemember_(DYNX(F_,2), 0.0, 4);
DoRemember_(DYNX(F_,3), 0.0, 5);
DoRemember_(DYNX(F_,4), 0.0, 6);
EndEqBlock
EndDataBlock
